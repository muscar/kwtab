MODULE
Curves
NW
IMPORT
Display
Files
Oberon
Graphics
GraphicFrames
TYPE
Curve
POINTER
TO
CurveDesc
CurveDesc
RECORD
Graphics
ObjectDesc
kind
lw
INTEGER
END
kind
up
line
down
line
circle
ellipse
VAR
method
Graphics
Method
PROCEDURE
Dot
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
IF
x
f
X
x
f
X1
y
f
Y
x
f
Y1
THEN
Display
Dot
col
x
y
Display
replace
END
END
Dot
PROCEDURE
mark
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
DEC
x
DEC
y
IF
x
f
X
x
f
X1
y
f
Y
y
f
Y1
THEN
IF
col
Display
black
THEN
Display
ReplConst
Display
black
x
y
Display
replace
ELSE
Display
CopyPattern
col
GraphicFrames
tack
x
y
Display
replace
END
END
END
mark
PROCEDURE
line
f
GraphicFrames
Frame
col
INTEGER
x
y
w
h
d
LONGINT
VAR
x1
y1
u
LONGINT
BEGIN
IF
h
w
THEN
x1
x
w
u
h
w
DIV
IF
d
THEN
INC
y
h
END
WHILE
x
x1
DO
Dot
f
col
x
y
INC
x
IF
u
THEN
INC
u
h
ELSE
INC
u
h
w
INC
y
d
END
END
ELSE
y1
y
h
u
w
h
DIV
IF
d
THEN
INC
x
w
END
WHILE
y
y1
DO
Dot
f
col
x
y
INC
y
IF
u
THEN
INC
u
w
ELSE
INC
u
w
h
INC
x
d
END
END
END
END
line
PROCEDURE
circle
f
GraphicFrames
Frame
col
INTEGER
x0
y0
r
LONGINT
VAR
x
y
u
LONGINT
BEGIN
u
r
x
r
y
WHILE
y
x
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
x
y0
y
IF
u
THEN
INC
u
y
ELSE
INC
u
y
x
DEC
x
END
INC
y
END
END
circle
PROCEDURE
ellipse
f
GraphicFrames
Frame
col
INTEGER
x0
y0
a
b
LONGINT
VAR
x
y
y1
aa
bb
d
g
h
LONGINT
BEGIN
aa
a
a
bb
b
b
h
aa
DIV
b
aa
bb
g
aa
DIV
b
aa
bb
x
y
b
WHILE
g
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
IF
h
THEN
d
x
bb
INC
g
d
ELSE
d
x
bb
y
aa
INC
g
d
aa
DEC
y
END
INC
h
d
INC
x
END
y1
y
h
bb
DIV
a
bb
aa
x
a
y
WHILE
y
y1
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
IF
h
THEN
INC
h
y
aa
ELSE
INC
h
y
aa
x
bb
DEC
x
END
INC
y
END
END
ellipse
PROCEDURE
New
VAR
c
Curve
BEGIN
NEW
c
c
do
method
Graphics
New
c
END
New
PROCEDURE
Copy
src
dst
Graphics
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Curve
kind
src
Curve
kind
dst
Curve
lw
src
Curve
lw
END
Copy
PROCEDURE
Draw
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
col
INTEGER
f
GraphicFrames
Frame
BEGIN
CASE
M
OF
GraphicFrames
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
M
col
Display
black
THEN
col
obj
col
ELSE
col
M
col
END
IF
x
f
X1
f
X
x
w
y
f
Y1
f
Y
y
h
THEN
IF
obj
Curve
kind
THEN
up
line
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
y
END
line
f
col
x
y
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
ELSIF
M
mode
THEN
mark
f
f
col
x
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
line
f
Display
black
x
y
w
h
END
ELSIF
obj
Curve
kind
THEN
down
line
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
y
h
END
line
f
col
x
y
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
h
ELSIF
M
mode
THEN
mark
f
f
col
x
y
h
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
h
line
f
Display
black
x
y
w
h
END
ELSIF
obj
Curve
kind
THEN
circle
w
w
DIV
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
w
y
END
circle
f
col
x
w
y
w
w
ELSIF
M
mode
THEN
mark
f
Display
white
x
w
y
ELSIF
M
mode
THEN
mark
f
f
col
x
w
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
w
y
circle
f
Display
black
x
w
y
w
w
END
ELSIF
obj
Curve
kind
THEN
ellipse
w
w
DIV
h
h
DIV
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
w
y
END
ellipse
f
col
x
w
y
h
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
w
y
ELSIF
M
mode
THEN
mark
f
f
col
x
w
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
w
y
ellipse
f
Display
black
x
w
y
h
w
h
END
END
END
END
END
Draw
PROCEDURE
Selectable
obj
Graphics
Object
x
y
INTEGER
BOOLEAN
VAR
xm
y0
w
h
INTEGER
res
BOOLEAN
BEGIN
IF
obj
Curve
kind
THEN
line
w
obj
w
h
obj
h
IF
obj
Curve
kind
THEN
y0
obj
y
h
h
h
ELSE
y0
obj
y
END
res
obj
x
x
x
obj
x
w
ABS
y
y0
w
x
obj
x
h
w
ELSE
circle
or
ellipse
xm
obj
w
DIV
obj
x
res
xm
x
x
xm
obj
y
y
y
obj
y
END
RETURN
res
END
Selectable
PROCEDURE
Change
obj
Graphics
Object
VAR
M
Graphics
Msg
BEGIN
IF
M
IS
Graphics
ColorMsg
THEN
obj
col
M
Graphics
ColorMsg
col
END
END
Change
PROCEDURE
Read
obj
Graphics
Object
VAR
R
Files
Rider
VAR
C
Graphics
Context
VAR
len
BYTE
BEGIN
Files
ReadByte
R
len
Files
ReadByte
R
len
obj
Curve
kind
len
Files
ReadByte
R
len
obj
Curve
lw
len
END
Read
PROCEDURE
Write
obj
Graphics
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Graphics
Context
BEGIN
Graphics
WriteObj
W
cno
obj
Files
WriteByte
W
Files
WriteByte
W
obj
Curve
kind
Files
WriteByte
W
obj
Curve
lw
END
Write
PROCEDURE
MakeLine
command
VAR
x0
x1
y0
y1
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
x1
G
mark
next
x
y1
G
mark
next
y
NEW
c
c
col
Oberon
CurCol
c
w
ABS
x1
x0
c
h
ABS
y1
y0
c
lw
Graphics
width
IF
x0
x1
THEN
c
x
x0
IF
y0
y1
THEN
c
kind
c
y
y0
ELSE
c
kind
c
y
y1
END
ELSE
c
x
x1
IF
y1
y0
THEN
c
kind
c
y
y1
ELSE
c
kind
c
y
y0
END
END
DEC
c
x
G
x
DEC
c
y
G
y
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
MakeLine
PROCEDURE
MakeCircle
command
VAR
x0
y0
r
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
r
ABS
G
mark
next
x
x0
IF
r
THEN
NEW
c
c
x
x0
r
G
x
c
y
y0
r
G
y
c
w
r
c
h
c
w
c
kind
c
col
Oberon
CurCol
c
lw
Graphics
width
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
END
MakeCircle
PROCEDURE
MakeEllipse
command
VAR
x0
y0
a
b
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
G
mark
next
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
a
ABS
G
mark
next
x
x0
b
ABS
G
mark
next
next
y
y0
IF
a
b
THEN
NEW
c
c
x
x0
a
G
x
c
y
y0
b
G
y
c
w
a
c
h
b
c
kind
c
col
Oberon
CurCol
c
lw
Graphics
width
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
END
MakeEllipse
BEGIN
NEW
method
method
module
Curves
method
allocator
New
method
new
New
method
copy
Copy
method
draw
Draw
method
selectable
Selectable
method
change
Change
method
read
Read
method
write
Write
END
Curves
MODULE
Display
NW
IMPORT
SYSTEM
CONST
black
white
black
background
replace
paint
invert
modes
base
0E7F00H
adr
of
x
pixel
monocolor
display
frame
TYPE
Frame
POINTER
TO
FrameDesc
FrameMsg
RECORD
END
Handler
PROCEDURE
F
Frame
VAR
M
FrameMsg
FrameDesc
RECORD
next
dsc
Frame
X
Y
W
H
INTEGER
handle
Handler
END
VAR
Base
Width
Height
INTEGER
arrow
star
hook
updown
block
cross
grey
INTEGER
a
pattern
is
an
array
of
bytes
the
first
is
its
width
the
second
its
height
the
rest
the
raster
PROCEDURE
Handle
F
Frame
VAR
M
FrameMsg
BEGIN
IF
F
NIL
F
handle
NIL
THEN
F
handle
F
M
END
END
Handle
raster
ops
PROCEDURE
Dot
col
x
y
mode
INTEGER
VAR
a
INTEGER
u
s
SET
BEGIN
a
base
x
DIV
y
s
x
MOD
SYSTEM
GET
a
u
IF
mode
paint
THEN
SYSTEM
PUT
a
u
s
ELSIF
mode
invert
THEN
SYSTEM
PUT
a
u
s
ELSE
mode
replace
IF
col
black
THEN
SYSTEM
PUT
a
u
s
ELSE
SYSTEM
PUT
a
u
s
END
END
END
Dot
PROCEDURE
ReplConst
col
x
y
w
h
mode
INTEGER
VAR
al
ar
a0
a1
INTEGER
left
right
mid
pix
pixl
pixr
SET
BEGIN
al
base
y
ar
x
w
DIV
al
al
x
DIV
al
IF
ar
al
THEN
mid
x
MOD
x
w
MOD
FOR
a1
al
TO
al
h
BY
DO
SYSTEM
GET
a1
pix
IF
mode
invert
THEN
SYSTEM
PUT
a1
pix
mid
ELSIF
mode
replace
col
black
THEN
erase
SYSTEM
PUT
a1
pix
mid
ELSE
mode
paint
OR
mode
replace
col
black
SYSTEM
PUT
a1
pix
mid
END
END
ELSIF
ar
al
THEN
left
x
MOD
right
x
w
MOD
FOR
a0
al
TO
al
h
BY
DO
SYSTEM
GET
a0
pixl
SYSTEM
GET
ar
pixr
IF
mode
invert
THEN
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
PUT
a1
pix
END
SYSTEM
PUT
ar
pixr
right
ELSIF
mode
replace
col
black
THEN
erase
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
PUT
a1
END
SYSTEM
PUT
ar
pixr
right
ELSE
mode
paint
OR
mode
replace
col
black
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
PUT
a1
END
SYSTEM
PUT
ar
pixr
right
END
INC
ar
END
END
END
ReplConst
PROCEDURE
CopyPattern
col
patadr
x
y
mode
INTEGER
only
for
modes
paint
invert
VAR
a
a0
pwd
INTEGER
w
h
pbt
BYTE
pix
SET
BEGIN
SYSTEM
GET
patadr
w
SYSTEM
GET
patadr
h
INC
patadr
a
base
x
DIV
y
FOR
a0
a
TO
a
h
BY
DO
build
pattern
line
w
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
100H
pwd
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
10000H
pwd
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
1000000H
pwd
END
END
END
SYSTEM
GET
a0
pix
IF
mode
invert
THEN
SYSTEM
PUT
a0
SYSTEM
VAL
SET
LSL
pwd
x
MOD
pix
ELSE
SYSTEM
PUT
a0
SYSTEM
VAL
SET
LSL
pwd
x
MOD
pix
END
IF
x
MOD
w
THEN
spill
over
SYSTEM
GET
a0
pix
IF
mode
invert
THEN
SYSTEM
PUT
a0
SYSTEM
VAL
SET
ASR
pwd
x
MOD
pix
ELSE
SYSTEM
PUT
a0
SYSTEM
VAL
SET
ASR
pwd
x
MOD
pix
END
END
END
END
CopyPattern
PROCEDURE
CopyBlock
sx
sy
w
h
dx
dy
mode
INTEGER
only
for
mode
replace
VAR
sa
da
sa0
sa1
d
len
INTEGER
u0
u1
u2
u3
v0
v1
v2
v3
n
INTEGER
end
step
INTEGER
src
dst
spill
SET
m0
m1
m2
m3
SET
BEGIN
u0
sx
DIV
u1
sx
MOD
u2
sx
w
DIV
u3
sx
w
MOD
v0
dx
DIV
v1
dx
MOD
v2
dx
w
DIV
v3
dx
w
MOD
sa
base
u0
sy
da
base
v0
dy
d
da
sa
n
u1
v1
displacement
in
words
and
bits
len
u2
u0
m0
v1
m2
v3
m3
m0
m2
IF
d
THEN
copy
up
scan
down
sa0
sa
h
end
sa
step
ELSE
copy
down
scan
up
sa0
sa
end
sa
h
step
END
WHILE
sa0
end
DO
IF
n
THEN
shift
right
m1
n
IF
v1
w
THEN
SYSTEM
GET
sa0
len
src
src
ROR
src
n
SYSTEM
GET
sa0
len
d
dst
SYSTEM
PUT
sa0
len
d
dst
m2
src
m2
spill
src
m1
FOR
sa1
sa0
len
TO
sa0
BY
DO
SYSTEM
GET
sa1
src
src
ROR
src
n
SYSTEM
PUT
sa1
d
spill
src
m1
spill
src
m1
END
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
SYSTEM
PUT
sa0
d
src
m0
dst
m0
ELSE
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
SYSTEM
PUT
sa0
d
src
m3
dst
m3
END
ELSE
shift
left
m1
n
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
IF
v1
w
THEN
SYSTEM
PUT
sa0
d
dst
m3
src
m3
ELSE
SYSTEM
PUT
sa0
d
dst
m0
src
m0
spill
src
m1
FOR
sa1
sa0
TO
sa0
len
BY
DO
SYSTEM
GET
sa1
src
src
ROR
src
n
SYSTEM
PUT
sa1
d
spill
src
m1
spill
src
m1
END
SYSTEM
GET
sa0
len
src
src
ROR
src
n
SYSTEM
GET
sa0
len
d
dst
SYSTEM
PUT
sa0
len
d
src
m2
dst
m2
END
END
INC
sa0
step
END
END
CopyBlock
PROCEDURE
ReplPattern
col
patadr
x
y
w
h
mode
INTEGER
pattern
width
fixed
pattern
starts
at
patadr
for
mode
invert
only
VAR
al
ar
a0
a1
INTEGER
pta0
pta1
INTEGER
pattern
addresses
ph
BYTE
left
right
mid
pix
pixl
pixr
ptw
SET
BEGIN
al
base
y
SYSTEM
GET
patadr
ph
pta0
patadr
pta1
ph
pta0
ar
x
w
DIV
al
al
x
DIV
al
IF
ar
al
THEN
mid
x
MOD
x
w
MOD
FOR
a1
al
TO
al
h
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
GET
pta0
ptw
SYSTEM
PUT
a1
pix
mid
pix
ptw
mid
INC
pta0
IF
pta0
pta1
THEN
pta0
patadr
END
END
ELSIF
ar
al
THEN
left
x
MOD
right
x
w
MOD
FOR
a0
al
TO
al
h
BY
DO
SYSTEM
GET
a0
pixl
SYSTEM
GET
pta0
ptw
SYSTEM
PUT
a0
pixl
left
pixl
ptw
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
PUT
a1
pix
ptw
END
SYSTEM
GET
ar
pixr
SYSTEM
PUT
ar
pixr
right
pixr
ptw
right
INC
pta0
INC
ar
IF
pta0
pta1
THEN
pta0
patadr
END
END
END
END
ReplPattern
BEGIN
Base
base
Width
Height
arrow
SYSTEM
ADR
0F0F
001C
000E
C101
E300
3F00
1F00
3F00
7F00
FF00
star
SYSTEM
ADR
0F0F
A002
C001
7F7F
C001
A002
hook
SYSTEM
ADR
0C0C
070F
C703
E701
F700
7F00
3F00
1F00
0F00
updown
SYSTEM
ADR
080E
183C
7EFF
FF7E3C18
block
SYSTEM
ADR
FFFF
C3C3
C3C3
FFFF
cross
SYSTEM
ADR
0F0F
grey
SYSTEM
ADR
AAAA
AAAA
END
Display
MODULE
Draw
NW
IMPORT
Files
Fonts
Viewers
Texts
Oberon
TextFrames
MenuViewers
Graphics
GraphicFrames
CONST
Menu
System
Close
System
Copy
System
Grow
Draw
Delete
Draw
Ticks
Draw
Restore
Draw
Store
VAR
W
Texts
Writer
Exported
commands
Open
Delete
SetWidth
ChangeColor
ChangeWidth
ChangeFont
Store
Print
Macro
Ticks
Restore
PROCEDURE
Open
VAR
X
Y
INTEGER
beg
end
t
LONGINT
G
Graphics
Graph
F
GraphicFrames
Frame
V
Viewers
Viewer
S
Texts
Scanner
text
Texts
Text
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
text
beg
end
t
IF
t
THEN
Texts
OpenScanner
S
text
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
THEN
NEW
G
Graphics
Open
G
S
s
NEW
F
GraphicFrames
Open
F
G
Oberon
AllocateUserViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
Menu
F
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Delete
VAR
F
GraphicFrames
Frame
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
F
Oberon
Par
vwr
dsc
next
GraphicFrames
Frame
GraphicFrames
Erase
F
Graphics
Delete
F
graph
END
END
Delete
PROCEDURE
GetArg
VAR
S
Texts
Scanner
VAR
T
Texts
Text
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
END
GetArg
PROCEDURE
SetWidth
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
S
i
S
i
THEN
Graphics
SetWidth
S
i
END
END
SetWidth
PROCEDURE
ChangeColor
VAR
S
Texts
Scanner
CM
Graphics
ColorMsg
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
CM
col
S
i
MOD
GraphicFrames
Change
GraphicFrames
Selected
CM
END
END
ChangeColor
PROCEDURE
ChangeWidth
VAR
S
Texts
Scanner
WM
Graphics
WidMsg
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
WM
w
S
i
GraphicFrames
Change
GraphicFrames
Selected
WM
END
END
ChangeWidth
PROCEDURE
ChangeFont
VAR
S
Texts
Scanner
FM
Graphics
FontMsg
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
FM
fnt
Fonts
This
S
s
IF
FM
fnt
NIL
THEN
GraphicFrames
Change
GraphicFrames
Selected
FM
END
END
END
ChangeFont
PROCEDURE
Redraw
Q
BOOLEAN
VAR
v
Viewers
Viewer
G
GraphicFrames
Frame
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
v
Oberon
Par
vwr
ELSE
v
Oberon
MarkedViewer
END
IF
v
NIL
v
dsc
NIL
v
dsc
next
IS
GraphicFrames
Frame
THEN
G
v
dsc
next
GraphicFrames
Frame
G
ticked
Q
OR
G
ticked
GraphicFrames
Restore
G
END
END
Redraw
PROCEDURE
Ticks
BEGIN
Redraw
FALSE
END
Ticks
PROCEDURE
Restore
BEGIN
Redraw
TRUE
END
Restore
PROCEDURE
Backup
VAR
name
ARRAY
OF
CHAR
VAR
res
i
INTEGER
ch
CHAR
bak
ARRAY
OF
CHAR
BEGIN
i
ch
name
WHILE
ch
0X
DO
bak
i
ch
INC
i
ch
name
i
END
IF
i
THEN
bak
i
bak
i
B
bak
i
a
bak
i
k
bak
i
0X
Files
Rename
name
bak
res
END
END
Backup
PROCEDURE
Store
VAR
S
Texts
Scanner
Menu
TextFrames
Frame
G
GraphicFrames
Frame
v
Viewers
Viewer
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
Menu
Oberon
Par
vwr
dsc
TextFrames
Frame
G
Menu
next
GraphicFrames
Frame
Texts
OpenScanner
S
Menu
text
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
S
s
Texts
WriteString
W
storing
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
GraphicFrames
Store
G
S
s
END
ELSE
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
v
Oberon
MarkedViewer
IF
v
dsc
NIL
v
dsc
next
IS
GraphicFrames
Frame
THEN
G
v
dsc
next
GraphicFrames
Frame
Texts
WriteString
W
S
s
Texts
WriteString
W
storing
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
GraphicFrames
Store
G
S
s
END
END
END
END
Store
PROCEDURE
Macro
VAR
S
Texts
Scanner
T
Texts
Text
time
beg
end
LONGINT
Lname
ARRAY
OF
CHAR
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Lname
S
s
Texts
Scan
S
IF
S
class
Texts
Name
THEN
GraphicFrames
Macro
Lname
S
s
END
END
END
Macro
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
Draw
NW
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
Draw
MODULE
Edit
JG
NW
IMPORT
Files
Fonts
Texts
Display
Viewers
Oberon
MenuViewers
TextFrames
CONST
CR
0DX
maxlen
StandardMenu
System
Close
System
Copy
System
Grow
Edit
Search
Edit
Store
VAR
W
Texts
Writer
time
LONGINT
M
INTEGER
pat
ARRAY
maxlen
OF
CHAR
d
ARRAY
OF
INTEGER
PROCEDURE
Max
i
j
LONGINT
LONGINT
VAR
m
LONGINT
BEGIN
IF
i
j
THEN
m
i
ELSE
m
j
END
RETURN
m
END
Max
PROCEDURE
Open
VAR
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
X
Y
INTEGER
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
OR
S
line
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
THEN
Oberon
AllocateUserViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Store
VAR
V
Viewers
Viewer
Text
TextFrames
Frame
T
Texts
Text
S
Texts
Scanner
f
Files
File
R
Files
Rider
beg
end
time
len
LONGINT
PROCEDURE
Backup
VAR
name
ARRAY
OF
CHAR
VAR
res
i
INTEGER
bak
ARRAY
OF
CHAR
BEGIN
i
WHILE
name
i
0X
DO
bak
i
name
i
INC
i
END
bak
i
bak
i
B
bak
i
a
bak
i
k
bak
i
0X
Files
Rename
name
bak
res
END
Backup
BEGIN
Texts
WriteString
W
Edit
Store
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
V
Oberon
Par
vwr
Texts
OpenScanner
S
V
dsc
TextFrames
Frame
text
ELSE
V
Oberon
MarkedViewer
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
END
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
Texts
WriteString
W
S
s
Texts
WriteInt
W
Text
text
len
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
Texts
Close
Text
text
S
s
END
END
Store
PROCEDURE
CopyLooks
VAR
T
Texts
Text
F
TextFrames
Frame
v
Viewers
Viewer
beg
end
time
LONGINT
fnt
Fonts
Font
col
voff
INTEGER
BEGIN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
v
Oberon
FocusViewer
IF
v
NIL
v
dsc
NIL
v
dsc
next
IS
TextFrames
Frame
THEN
F
v
dsc
next
TextFrames
Frame
Texts
Attributes
F
text
F
carloc
pos
fnt
col
voff
Texts
ChangeLooks
T
beg
end
fnt
col
voff
END
END
END
CopyLooks
PROCEDURE
ChangeFont
VAR
S
Texts
Scanner
T
Texts
Text
beg
end
LONGINT
BEGIN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
ChangeLooks
T
beg
end
Fonts
This
S
s
END
END
END
ChangeFont
PROCEDURE
ChangeColor
VAR
S
Texts
Scanner
T
Texts
Text
col
INTEGER
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
col
S
i
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
ChangeLooks
T
beg
end
NIL
col
END
END
END
ChangeColor
PROCEDURE
ChangeOffset
VAR
S
Texts
Scanner
T
Texts
Text
voff
INTEGER
ch
CHAR
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
voff
S
i
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
ChangeLooks
T
beg
end
NIL
voff
END
END
END
ChangeOffset
PROCEDURE
Search
uses
global
variables
M
pat
d
for
Boyer
Moore
search
VAR
Text
TextFrames
Frame
V
Viewers
Viewer
R
Texts
Reader
T
Texts
Text
pos
beg
end
prevTime
len
LONGINT
n
i
j
INTEGER
buf
ARRAY
OF
CHAR
PROCEDURE
Forward
n
INTEGER
VAR
R
Texts
Reader
VAR
buf
ARRAY
OF
CHAR
VAR
m
INTEGER
j
INTEGER
BEGIN
m
M
n
j
WHILE
j
m
DO
buf
j
buf
n
j
INC
j
END
WHILE
j
M
DO
Texts
Read
R
buf
j
INC
j
END
END
Forward
BEGIN
V
Oberon
Par
vwr
IF
Oberon
Par
frame
V
dsc
THEN
V
Oberon
FocusViewer
END
IF
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
prevTime
time
Oberon
GetSelection
T
beg
end
time
IF
time
prevTime
THEN
Texts
OpenReader
R
T
beg
i
pos
beg
REPEAT
Texts
Read
R
pat
i
INC
i
INC
pos
UNTIL
i
maxlen
OR
pos
end
M
i
j
WHILE
j
DO
d
j
M
INC
j
END
j
WHILE
j
M
DO
d
ORD
pat
j
M
j
INC
j
END
END
IF
Text
hasCar
THEN
pos
Text
carloc
pos
ELSE
pos
END
len
Text
text
len
Texts
OpenReader
R
Text
text
pos
Forward
M
R
buf
pos
pos
M
j
M
REPEAT
DEC
j
UNTIL
j
OR
buf
j
pat
j
WHILE
j
pos
len
DO
n
d
ORD
buf
M
Forward
n
R
buf
INC
pos
n
j
M
REPEAT
DEC
j
UNTIL
j
OR
buf
j
pat
j
END
IF
j
THEN
TextFrames
RemoveSelection
Text
TextFrames
RemoveCaret
Text
Oberon
RemoveMarks
Text
X
Text
Y
Text
W
Text
H
TextFrames
Show
Text
pos
Oberon
PassFocus
V
TextFrames
SetCaret
Text
pos
END
END
END
Search
PROCEDURE
Locate
VAR
Text
TextFrames
Frame
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
beg
end
time
LONGINT
BEGIN
V
Oberon
FocusViewer
IF
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
REPEAT
Texts
Scan
S
UNTIL
S
class
Texts
Int
skip
names
IF
S
class
Texts
Int
THEN
TextFrames
RemoveSelection
Text
TextFrames
RemoveCaret
Text
Oberon
RemoveMarks
Text
X
Text
Y
Text
W
Text
H
TextFrames
Show
Text
Max
S
i
Oberon
PassFocus
V
TextFrames
SetCaret
Text
S
i
END
END
END
END
Locate
PROCEDURE
Recall
VAR
Menu
Main
Display
Frame
buf
Texts
Buffer
V
Viewers
Viewer
pos
LONGINT
M
TextFrames
Frame
BEGIN
V
Oberon
FocusViewer
IF
V
NIL
V
IS
MenuViewers
Viewer
THEN
Menu
V
dsc
Main
V
dsc
next
IF
Main
IS
TextFrames
Frame
THEN
M
Main
TextFrames
Frame
IF
M
hasCar
THEN
TextFrames
Recall
buf
pos
M
carloc
pos
buf
len
Texts
Insert
M
text
M
carloc
pos
buf
TextFrames
SetCaret
M
pos
END
ELSIF
Menu
IS
TextFrames
Frame
THEN
M
Menu
TextFrames
Frame
IF
M
hasCar
THEN
TextFrames
Recall
buf
pos
M
carloc
pos
buf
len
Texts
Insert
M
text
M
carloc
pos
buf
TextFrames
SetCaret
M
pos
END
END
END
END
Recall
BEGIN
Texts
OpenWriter
W
END
Edit
MODULE
FileDir
NW
IMPORT
SYSTEM
Kernel
File
Directory
is
a
B
tree
with
its
root
page
at
DirRootAdr
Each
entry
contains
a
file
name
and
the
disk
address
of
the
file
s
head
sector
CONST
FnLength
SecTabSize
ExTabSize
SectorSize
IndexSize
SectorSize
DIV
HeaderSize
DirRootAdr
DirPgSize
N
DirPgSize
DIV
DirMark
9B1EA38DH
HeaderMark
9BA71D86H
FillerSize
TYPE
DiskAdr
INTEGER
FileName
ARRAY
FnLength
OF
CHAR
SectorTable
ARRAY
SecTabSize
OF
DiskAdr
ExtensionTable
ARRAY
ExTabSize
OF
DiskAdr
EntryHandler
PROCEDURE
name
FileName
sec
DiskAdr
VAR
continue
BOOLEAN
FileHeader
RECORD
first
page
of
each
file
on
disk
mark
INTEGER
name
FileName
aleng
bleng
date
INTEGER
ext
ExtensionTable
sec
SectorTable
fill
ARRAY
SectorSize
HeaderSize
OF
BYTE
END
FileHd
POINTER
TO
FileHeader
IndexSector
ARRAY
IndexSize
OF
DiskAdr
DataSector
ARRAY
SectorSize
OF
BYTE
DirEntry
B
tree
node
RECORD
name
FileName
adr
DiskAdr
sec
no
of
file
header
p
DiskAdr
sec
no
of
descendant
in
directory
END
DirPage
RECORD
mark
INTEGER
m
INTEGER
p0
DiskAdr
sec
no
of
left
descendant
in
directory
fill
ARRAY
FillerSize
OF
BYTE
e
ARRAY
DirPgSize
OF
DirEntry
END
Exported
procedures
Search
Insert
Delete
Enumerate
Init
PROCEDURE
Search
name
FileName
VAR
A
DiskAdr
VAR
i
L
R
INTEGER
dadr
DiskAdr
a
DirPage
BEGIN
dadr
DirRootAdr
A
REPEAT
Kernel
GetSector
dadr
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
a
m
name
a
e
R
name
THEN
A
a
e
R
adr
found
ELSIF
R
THEN
dadr
a
p0
ELSE
dadr
a
e
R
p
END
UNTIL
dadr
OR
A
END
Search
PROCEDURE
insert
name
FileName
dpg0
DiskAdr
VAR
h
BOOLEAN
VAR
v
DirEntry
fad
DiskAdr
h
tree
has
become
higher
and
v
is
ascending
element
VAR
ch
CHAR
i
j
L
R
INTEGER
dpg1
DiskAdr
u
DirEntry
a
DirPage
BEGIN
h
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
a
m
name
a
e
R
name
THEN
a
e
R
adr
fad
Kernel
PutSector
dpg0
a
replace
ELSE
not
on
this
page
IF
R
THEN
dpg1
a
p0
ELSE
dpg1
a
e
R
p
END
IF
dpg1
THEN
not
in
tree
insert
u
adr
fad
u
p
h
TRUE
j
REPEAT
ch
name
j
u
name
j
ch
INC
j
UNTIL
ch
0X
WHILE
j
FnLength
DO
u
name
j
0X
INC
j
END
ELSE
insert
name
dpg1
h
u
fad
END
IF
h
THEN
insert
u
to
the
left
of
e
R
IF
a
m
DirPgSize
THEN
h
FALSE
i
a
m
WHILE
i
R
DO
DEC
i
a
e
i
a
e
i
END
a
e
R
u
INC
a
m
ELSE
split
page
and
assign
the
middle
element
to
v
a
m
N
a
mark
DirMark
IF
R
N
THEN
insert
in
left
half
v
a
e
N
i
N
WHILE
i
R
DO
DEC
i
a
e
i
a
e
i
END
a
e
R
u
Kernel
PutSector
dpg0
a
Kernel
AllocSector
dpg0
dpg0
i
WHILE
i
N
DO
a
e
i
a
e
i
N
INC
i
END
ELSE
insert
in
right
half
Kernel
PutSector
dpg0
a
Kernel
AllocSector
dpg0
dpg0
DEC
R
N
i
IF
R
THEN
v
u
ELSE
v
a
e
N
WHILE
i
R
DO
a
e
i
a
e
N
i
INC
i
END
a
e
i
u
INC
i
END
WHILE
i
N
DO
a
e
i
a
e
N
i
INC
i
END
END
a
p0
v
p
v
p
dpg0
END
Kernel
PutSector
dpg0
a
END
END
END
insert
PROCEDURE
Insert
name
FileName
fad
DiskAdr
VAR
oldroot
DiskAdr
h
BOOLEAN
U
DirEntry
a
DirPage
BEGIN
h
FALSE
insert
name
DirRootAdr
h
U
fad
IF
h
THEN
root
overflow
Kernel
GetSector
DirRootAdr
a
ASSERT
a
mark
DirMark
Kernel
AllocSector
DirRootAdr
oldroot
Kernel
PutSector
oldroot
a
a
mark
DirMark
a
m
a
p0
oldroot
a
e
U
Kernel
PutSector
DirRootAdr
a
END
END
Insert
PROCEDURE
underflow
VAR
c
DirPage
ancestor
page
dpg0
DiskAdr
s
INTEGER
insertion
point
in
c
VAR
h
BOOLEAN
c
undersize
VAR
i
k
INTEGER
dpg1
DiskAdr
a
b
DirPage
a
underflowing
page
b
neighbouring
page
BEGIN
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
h
a
m
N
dpg0
c
e
s
p
IF
s
c
m
THEN
b
page
to
the
right
of
a
dpg1
c
e
s
p
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
k
b
m
N
DIV
k
no
of
items
available
on
page
b
a
e
N
c
e
s
a
e
N
p
b
p0
IF
k
THEN
move
k
items
from
b
to
a
one
to
c
i
WHILE
i
k
DO
a
e
i
N
b
e
i
INC
i
END
c
e
s
b
e
i
b
p0
c
e
s
p
c
e
s
p
dpg1
b
m
b
m
k
i
WHILE
i
b
m
DO
b
e
i
b
e
i
k
INC
i
END
Kernel
PutSector
dpg1
b
a
m
N
k
h
FALSE
ELSE
merge
pages
a
and
b
discard
b
i
WHILE
i
N
DO
a
e
i
N
b
e
i
INC
i
END
i
s
DEC
c
m
WHILE
i
c
m
DO
c
e
i
c
e
i
INC
i
END
a
m
N
h
c
m
N
END
Kernel
PutSector
dpg0
a
ELSE
b
page
to
the
left
of
a
DEC
s
IF
s
THEN
dpg1
c
p0
ELSE
dpg1
c
e
s
p
END
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
k
b
m
N
DIV
k
no
of
items
available
on
page
b
IF
k
THEN
i
N
WHILE
i
DO
DEC
i
a
e
i
k
a
e
i
END
i
k
a
e
i
c
e
s
a
e
i
p
a
p0
move
k
items
from
b
to
a
one
to
c
b
m
b
m
k
WHILE
i
DO
DEC
i
a
e
i
b
e
i
b
m
END
c
e
s
b
e
b
m
a
p0
c
e
s
p
c
e
s
p
dpg0
a
m
N
k
h
FALSE
Kernel
PutSector
dpg0
a
ELSE
merge
pages
a
and
b
discard
a
c
e
s
p
a
p0
b
e
N
c
e
s
i
WHILE
i
N
DO
b
e
i
N
a
e
i
INC
i
END
b
m
N
DEC
c
m
h
c
m
N
END
Kernel
PutSector
dpg1
b
END
END
underflow
PROCEDURE
delete
name
FileName
dpg0
DiskAdr
VAR
h
BOOLEAN
VAR
fad
DiskAdr
search
and
delete
entry
with
key
name
if
a
page
underflow
arises
balance
with
adjacent
page
or
merge
h
page
dpg0
is
undersize
VAR
i
L
R
INTEGER
dpg1
DiskAdr
a
DirPage
PROCEDURE
del
VAR
a
DirPage
R
INTEGER
dpg1
DiskAdr
VAR
h
BOOLEAN
VAR
dpg2
DiskAdr
global
a
R
b
DirPage
BEGIN
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
dpg2
b
e
b
m
p
IF
dpg2
THEN
del
a
R
dpg2
h
IF
h
THEN
underflow
b
dpg2
b
m
h
Kernel
PutSector
dpg1
b
END
ELSE
b
e
b
m
p
a
e
R
p
a
e
R
b
e
b
m
DEC
b
m
h
b
m
N
Kernel
PutSector
dpg1
b
END
END
del
BEGIN
h
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
THEN
dpg1
a
p0
ELSE
dpg1
a
e
R
p
END
IF
R
a
m
name
a
e
R
name
THEN
found
now
delete
fad
a
e
R
adr
IF
dpg1
THEN
a
is
a
leaf
page
DEC
a
m
h
a
m
N
i
R
WHILE
i
a
m
DO
a
e
i
a
e
i
INC
i
END
ELSE
del
a
R
dpg1
h
IF
h
THEN
underflow
a
dpg1
R
h
END
END
Kernel
PutSector
dpg0
a
ELSIF
dpg1
THEN
delete
name
dpg1
h
fad
IF
h
THEN
underflow
a
dpg1
R
h
Kernel
PutSector
dpg0
a
END
ELSE
not
in
tree
fad
END
END
delete
PROCEDURE
Delete
name
FileName
VAR
fad
DiskAdr
VAR
h
BOOLEAN
newroot
DiskAdr
a
DirPage
BEGIN
h
FALSE
delete
name
DirRootAdr
h
fad
IF
h
THEN
root
underflow
Kernel
GetSector
DirRootAdr
a
ASSERT
a
mark
DirMark
IF
a
m
a
p0
THEN
newroot
a
p0
Kernel
GetSector
newroot
a
ASSERT
a
mark
DirMark
Kernel
PutSector
DirRootAdr
a
discard
newroot
END
END
END
Delete
PROCEDURE
enumerate
prefix
ARRAY
OF
CHAR
dpg
DiskAdr
proc
EntryHandler
VAR
continue
BOOLEAN
VAR
i
j
INTEGER
pfx
nmx
CHAR
dpg1
DiskAdr
a
DirPage
BEGIN
Kernel
GetSector
dpg
a
ASSERT
a
mark
DirMark
i
WHILE
i
a
m
continue
DO
j
REPEAT
pfx
prefix
j
nmx
a
e
i
name
j
INC
j
UNTIL
nmx
pfx
OR
pfx
0X
IF
nmx
pfx
THEN
IF
i
THEN
dpg1
a
p0
ELSE
dpg1
a
e
i
p
END
IF
dpg1
THEN
enumerate
prefix
dpg1
proc
continue
END
IF
pfx
0X
THEN
IF
continue
THEN
proc
a
e
i
name
a
e
i
adr
continue
END
ELSE
continue
FALSE
END
END
INC
i
END
IF
continue
i
a
e
i
p
THEN
enumerate
prefix
a
e
i
p
proc
continue
END
END
enumerate
PROCEDURE
Enumerate
prefix
ARRAY
OF
CHAR
proc
EntryHandler
VAR
b
BOOLEAN
BEGIN
b
TRUE
enumerate
prefix
DirRootAdr
proc
b
END
Enumerate
initialization
PROCEDURE
Init
VAR
k
INTEGER
A
ARRAY
OF
DiskAdr
PROCEDURE
MarkSectors
VAR
A
ARRAY
OF
DiskAdr
k
INTEGER
VAR
L
R
i
j
n
INTEGER
x
DiskAdr
hd
FileHeader
B
IndexSector
PROCEDURE
sift
VAR
A
ARRAY
OF
DiskAdr
L
R
INTEGER
VAR
i
j
INTEGER
x
DiskAdr
BEGIN
j
L
x
A
j
REPEAT
i
j
j
j
IF
j
R
A
j
A
j
THEN
INC
j
END
IF
j
R
x
A
j
THEN
A
i
A
j
END
UNTIL
j
R
OR
x
A
j
A
i
x
END
sift
BEGIN
L
k
DIV
R
k
heapsort
WHILE
L
DO
DEC
L
sift
A
L
R
END
WHILE
R
DO
DEC
R
x
A
A
A
R
A
R
x
sift
A
L
R
END
WHILE
L
k
DO
Kernel
GetSector
A
L
hd
ASSERT
hd
mark
HeaderMark
IF
hd
aleng
SecTabSize
THEN
j
hd
aleng
REPEAT
DEC
j
Kernel
MarkSector
hd
sec
j
UNTIL
j
ELSE
j
SecTabSize
REPEAT
DEC
j
Kernel
MarkSector
hd
sec
j
UNTIL
j
n
hd
aleng
SecTabSize
DIV
i
WHILE
i
n
DO
Kernel
MarkSector
hd
ext
i
Kernel
GetSector
hd
ext
i
B
index
sector
IF
i
n
THEN
j
ELSE
j
hd
aleng
SecTabSize
MOD
END
REPEAT
DEC
j
Kernel
MarkSector
B
j
UNTIL
j
INC
i
END
END
INC
L
END
END
MarkSectors
PROCEDURE
TraverseDir
VAR
A
ARRAY
OF
DiskAdr
VAR
k
INTEGER
dpg
DiskAdr
VAR
i
INTEGER
a
DirPage
BEGIN
Kernel
GetSector
dpg
a
ASSERT
a
mark
DirMark
Kernel
MarkSector
dpg
i
WHILE
i
a
m
DO
A
k
a
e
i
adr
INC
k
INC
i
IF
k
THEN
MarkSectors
A
k
k
END
END
IF
a
p0
THEN
TraverseDir
A
k
a
p0
i
WHILE
i
a
m
DO
TraverseDir
A
k
a
e
i
p
INC
i
END
END
END
TraverseDir
BEGIN
k
TraverseDir
A
k
DirRootAdr
MarkSectors
A
k
END
Init
END
FileDir
MODULE
Files
NW
IMPORT
SYSTEM
Kernel
FileDir
A
file
consists
of
a
sequence
of
pages
The
first
page
contains
the
header
Part
of
the
header
is
the
page
table
an
array
of
disk
addresses
to
the
pages
A
file
is
referenced
through
riders
A
rider
indicates
a
current
position
and
refers
to
a
file
CONST
MaxBufs
HS
FileDir
HeaderSize
SS
FileDir
SectorSize
STS
FileDir
SecTabSize
XS
FileDir
IndexSize
TYPE
DiskAdr
INTEGER
File
POINTER
TO
FileDesc
Buffer
POINTER
TO
BufferRecord
Index
POINTER
TO
IndexRecord
Rider
RECORD
eof
BOOLEAN
res
INTEGER
file
File
apos
bpos
INTEGER
buf
Buffer
END
FileDesc
RECORD
next
INTEGER
list
of
files
invisible
to
the
GC
nofbufs
aleng
bleng
INTEGER
modH
registered
BOOLEAN
firstbuf
Buffer
sechint
DiskAdr
name
FileDir
FileName
date
INTEGER
ext
ARRAY
FileDir
ExTabSize
OF
Index
sec
FileDir
SectorTable
END
BufferRecord
RECORD
apos
lim
INTEGER
mod
BOOLEAN
next
Buffer
data
FileDir
DataSector
END
IndexRecord
RECORD
adr
DiskAdr
mod
BOOLEAN
sec
FileDir
IndexSector
END
aleng
SS
bleng
length
including
header
apos
SS
bpos
current
position
bpos
lim
SS
apos
aleng
PgTabSize
apos
aleng
lim
SS
OR
apos
aleng
VAR
root
INTEGER
File
list
of
open
files
PROCEDURE
Check
s
ARRAY
OF
CHAR
VAR
name
FileDir
FileName
VAR
res
INTEGER
VAR
i
INTEGER
ch
CHAR
BEGIN
ch
s
i
IF
ch
A
ch
Z
OR
ch
a
ch
z
THEN
REPEAT
name
i
ch
INC
i
ch
s
i
UNTIL
ch
ch
OR
ch
A
ch
Z
OR
ch
a
ch
z
OR
ch
OR
i
FileDir
FnLength
IF
i
FileDir
FnLength
THEN
res
ELSIF
ch
0X
THEN
res
WHILE
i
FileDir
FnLength
DO
name
i
0X
INC
i
END
ELSE
res
END
ELSIF
ch
0X
THEN
name
0X
res
ELSE
res
END
END
Check
PROCEDURE
Old
name
ARRAY
OF
CHAR
File
VAR
i
k
res
INTEGER
f
File
header
DiskAdr
buf
Buffer
F
FileDir
FileHd
namebuf
FileDir
FileName
inxpg
Index
BEGIN
f
NIL
Check
name
namebuf
res
IF
res
THEN
FileDir
Search
namebuf
header
IF
header
THEN
f
SYSTEM
VAL
File
root
WHILE
f
NIL
f
sec
header
DO
f
SYSTEM
VAL
File
f
next
END
IF
f
NIL
THEN
file
not
yet
present
NEW
buf
buf
apos
buf
next
buf
buf
mod
FALSE
F
SYSTEM
VAL
FileDir
FileHd
SYSTEM
ADR
buf
data
Kernel
GetSector
header
buf
data
ASSERT
F
mark
FileDir
HeaderMark
NEW
f
f
aleng
F
aleng
f
bleng
F
bleng
f
date
F
date
IF
f
aleng
THEN
buf
lim
f
bleng
ELSE
buf
lim
SS
END
f
firstbuf
buf
f
nofbufs
f
name
namebuf
f
registered
TRUE
f
sec
F
sec
k
f
aleng
XS
STS
DIV
XS
i
WHILE
i
k
DO
NEW
inxpg
inxpg
adr
F
ext
i
inxpg
mod
FALSE
Kernel
GetSector
inxpg
adr
inxpg
sec
f
ext
i
inxpg
INC
i
END
WHILE
i
FileDir
ExTabSize
DO
f
ext
i
NIL
INC
i
END
f
sechint
header
f
modH
FALSE
f
next
root
root
SYSTEM
VAL
INTEGER
f
END
END
END
RETURN
f
END
Old
PROCEDURE
New
name
ARRAY
OF
CHAR
File
VAR
i
res
INTEGER
f
File
buf
Buffer
F
FileDir
FileHd
namebuf
FileDir
FileName
BEGIN
f
NIL
Check
name
namebuf
res
IF
res
THEN
NEW
buf
buf
apos
buf
mod
TRUE
buf
lim
HS
buf
next
buf
F
SYSTEM
VAL
FileDir
FileHd
SYSTEM
ADR
buf
data
F
mark
FileDir
HeaderMark
F
aleng
F
bleng
HS
F
name
namebuf
F
date
Kernel
Clock
NEW
f
f
aleng
f
bleng
HS
f
modH
TRUE
f
registered
FALSE
f
date
F
date
f
firstbuf
buf
f
nofbufs
f
name
namebuf
f
sechint
i
REPEAT
f
ext
i
NIL
F
ext
i
INC
i
UNTIL
i
FileDir
ExTabSize
i
REPEAT
f
sec
i
F
sec
i
INC
i
UNTIL
i
STS
END
RETURN
f
END
New
PROCEDURE
UpdateHeader
f
File
VAR
F
FileDir
FileHeader
VAR
k
INTEGER
BEGIN
F
aleng
f
aleng
F
bleng
f
bleng
F
sec
f
sec
k
f
aleng
XS
STS
DIV
XS
WHILE
k
DO
DEC
k
F
ext
k
f
ext
k
adr
END
END
UpdateHeader
PROCEDURE
ReadBuf
f
File
buf
Buffer
pos
INTEGER
VAR
sec
DiskAdr
BEGIN
IF
pos
STS
THEN
sec
f
sec
pos
ELSE
sec
f
ext
pos
STS
DIV
XS
sec
pos
STS
MOD
XS
END
Kernel
GetSector
sec
buf
data
IF
pos
f
aleng
THEN
buf
lim
SS
ELSE
buf
lim
f
bleng
END
buf
apos
pos
buf
mod
FALSE
END
ReadBuf
PROCEDURE
WriteBuf
f
File
buf
Buffer
VAR
i
k
INTEGER
secadr
DiskAdr
inx
Index
BEGIN
IF
buf
apos
STS
THEN
secadr
f
sec
buf
apos
IF
secadr
THEN
Kernel
AllocSector
f
sechint
secadr
f
modH
TRUE
f
sec
buf
apos
secadr
f
sechint
secadr
END
IF
buf
apos
THEN
UpdateHeader
f
SYSTEM
VAL
FileDir
FileHeader
buf
data
f
modH
FALSE
END
ELSE
i
buf
apos
STS
DIV
XS
inx
f
ext
i
IF
inx
NIL
THEN
NEW
inx
inx
adr
inx
sec
f
ext
i
inx
f
modH
TRUE
END
k
buf
apos
STS
MOD
XS
secadr
inx
sec
k
IF
secadr
THEN
Kernel
AllocSector
f
sechint
secadr
f
modH
TRUE
inx
mod
TRUE
inx
sec
k
secadr
f
sechint
secadr
END
END
Kernel
PutSector
secadr
buf
data
buf
mod
FALSE
END
WriteBuf
PROCEDURE
Buf
f
File
pos
INTEGER
Buffer
VAR
buf
Buffer
BEGIN
buf
f
firstbuf
WHILE
buf
apos
pos
buf
next
f
firstbuf
DO
buf
buf
next
END
IF
buf
apos
pos
THEN
buf
NIL
END
RETURN
buf
END
Buf
PROCEDURE
GetBuf
f
File
pos
INTEGER
Buffer
VAR
buf
Buffer
BEGIN
buf
f
firstbuf
WHILE
buf
apos
pos
buf
next
f
firstbuf
DO
buf
buf
next
END
IF
buf
apos
pos
THEN
IF
f
nofbufs
MaxBufs
THEN
allocate
new
buffer
NEW
buf
buf
next
f
firstbuf
next
f
firstbuf
next
buf
INC
f
nofbufs
ELSE
reuse
a
buffer
f
firstbuf
buf
IF
buf
mod
THEN
WriteBuf
f
buf
END
END
IF
pos
f
aleng
THEN
ReadBuf
f
buf
pos
ELSE
buf
apos
pos
buf
lim
buf
mod
FALSE
END
END
RETURN
buf
END
GetBuf
PROCEDURE
Unbuffer
f
File
VAR
i
k
INTEGER
buf
Buffer
inx
Index
head
FileDir
FileHeader
BEGIN
buf
f
firstbuf
REPEAT
IF
buf
mod
THEN
WriteBuf
f
buf
END
buf
buf
next
UNTIL
buf
f
firstbuf
k
f
aleng
XS
STS
DIV
XS
i
WHILE
i
k
DO
inx
f
ext
i
INC
i
IF
inx
mod
THEN
IF
inx
adr
THEN
Kernel
AllocSector
f
sechint
inx
adr
f
sechint
inx
adr
f
modH
TRUE
END
Kernel
PutSector
inx
adr
inx
sec
inx
mod
FALSE
END
END
IF
f
modH
THEN
Kernel
GetSector
f
sec
head
UpdateHeader
f
head
Kernel
PutSector
f
sec
head
f
modH
FALSE
END
END
Unbuffer
PROCEDURE
Register
f
File
BEGIN
IF
f
NIL
f
name
0X
THEN
Unbuffer
f
IF
f
registered
THEN
FileDir
Insert
f
name
f
sec
f
registered
TRUE
f
next
root
root
SYSTEM
VAL
INTEGER
f
END
END
END
Register
PROCEDURE
Close
f
File
BEGIN
IF
f
NIL
THEN
Unbuffer
f
END
END
Close
PROCEDURE
Purge
f
File
VAR
a
i
j
k
INTEGER
ind
FileDir
IndexSector
BEGIN
IF
f
NIL
THEN
a
f
aleng
f
aleng
f
bleng
HS
IF
a
STS
THEN
i
a
ELSE
i
STS
DEC
a
i
j
a
MOD
XS
k
a
DIV
XS
WHILE
k
DO
Kernel
GetSector
f
ext
k
adr
ind
REPEAT
DEC
j
Kernel
FreeSector
ind
j
UNTIL
j
Kernel
FreeSector
f
ext
k
adr
j
XS
DEC
k
END
END
REPEAT
DEC
i
Kernel
FreeSector
f
sec
i
UNTIL
i
END
END
Purge
PROCEDURE
Delete
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
adr
DiskAdr
namebuf
FileDir
FileName
BEGIN
Check
name
namebuf
res
IF
res
THEN
FileDir
Delete
namebuf
adr
IF
adr
THEN
res
END
END
END
Delete
PROCEDURE
Rename
old
new
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
adr
DiskAdr
oldbuf
newbuf
FileDir
FileName
head
FileDir
FileHeader
BEGIN
Check
old
oldbuf
res
IF
res
THEN
Check
new
newbuf
res
IF
res
THEN
FileDir
Delete
oldbuf
adr
IF
adr
THEN
FileDir
Insert
newbuf
adr
Kernel
GetSector
adr
head
head
name
newbuf
Kernel
PutSector
adr
head
ELSE
res
END
END
END
END
Rename
PROCEDURE
Length
f
File
INTEGER
BEGIN
RETURN
f
aleng
SS
f
bleng
HS
END
Length
PROCEDURE
Date
f
File
INTEGER
BEGIN
RETURN
f
date
END
Date
Read
PROCEDURE
Set
VAR
r
Rider
f
File
pos
INTEGER
VAR
a
b
INTEGER
BEGIN
r
eof
FALSE
r
res
IF
f
NIL
THEN
IF
pos
THEN
a
b
HS
ELSIF
pos
f
aleng
SS
f
bleng
HS
THEN
a
pos
HS
DIV
SS
b
pos
HS
MOD
SS
ELSE
a
f
aleng
b
f
bleng
END
r
file
f
r
apos
a
r
bpos
b
r
buf
f
firstbuf
ELSE
r
file
NIL
END
END
Set
PROCEDURE
Pos
VAR
r
Rider
INTEGER
BEGIN
RETURN
r
apos
SS
r
bpos
HS
END
Pos
PROCEDURE
Base
VAR
r
Rider
File
BEGIN
RETURN
r
file
END
Base
PROCEDURE
ReadByte
VAR
r
Rider
VAR
x
BYTE
VAR
buf
Buffer
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
x
r
buf
data
r
bpos
INC
r
bpos
ELSIF
r
apos
r
file
aleng
THEN
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
buf
mod
THEN
WriteBuf
r
file
r
buf
END
ReadBuf
r
file
r
buf
r
apos
ELSE
r
buf
buf
END
x
r
buf
data
r
bpos
ELSE
x
r
eof
TRUE
END
END
ReadByte
PROCEDURE
ReadBytes
VAR
r
Rider
VAR
x
ARRAY
OF
BYTE
n
INTEGER
VAR
i
INTEGER
BEGIN
i
this
implementation
is
to
be
improved
WHILE
i
n
DO
ReadByte
r
x
i
INC
i
END
END
ReadBytes
PROCEDURE
Read
VAR
r
Rider
VAR
ch
CHAR
VAR
buf
Buffer
same
as
ReadByte
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
ch
CHR
r
buf
data
r
bpos
INC
r
bpos
ELSIF
r
apos
r
file
aleng
THEN
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
buf
mod
THEN
WriteBuf
r
file
r
buf
END
ReadBuf
r
file
r
buf
r
apos
ELSE
r
buf
buf
END
ch
CHR
r
buf
data
r
bpos
ELSE
ch
0X
r
eof
TRUE
END
END
Read
PROCEDURE
ReadInt
VAR
R
Rider
VAR
x
INTEGER
VAR
x0
x1
x2
x3
BYTE
BEGIN
ReadByte
R
x0
ReadByte
R
x1
ReadByte
R
x2
ReadByte
R
x3
x
x3
100H
x2
100H
x1
100H
x0
END
ReadInt
PROCEDURE
ReadSet
VAR
R
Rider
VAR
s
SET
VAR
n
INTEGER
BEGIN
ReadInt
R
SYSTEM
VAL
INTEGER
s
END
ReadSet
PROCEDURE
ReadReal
VAR
R
Rider
VAR
x
REAL
VAR
n
INTEGER
BEGIN
ReadInt
R
SYSTEM
VAL
INTEGER
x
END
ReadReal
PROCEDURE
ReadString
VAR
R
Rider
VAR
x
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
i
Read
R
ch
WHILE
ch
0X
DO
IF
i
LEN
x
THEN
x
i
ch
INC
i
END
Read
R
ch
END
x
i
0X
END
ReadString
PROCEDURE
ReadNum
VAR
R
Rider
VAR
x
INTEGER
VAR
n
y
INTEGER
b
BYTE
BEGIN
n
y
ReadByte
R
b
WHILE
b
80H
DO
y
ROR
y
b
80H
DEC
n
ReadByte
R
b
END
IF
n
THEN
x
ROR
y
b
MOD
10H
ELSE
x
ASR
ROR
y
b
n
END
END
ReadNum
Write
PROCEDURE
NewExt
f
File
VAR
i
k
INTEGER
ext
Index
BEGIN
k
f
aleng
STS
DIV
XS
NEW
ext
ext
adr
ext
mod
TRUE
f
ext
k
ext
i
XS
REPEAT
DEC
i
ext
sec
i
UNTIL
i
END
NewExt
PROCEDURE
WriteByte
VAR
r
Rider
x
BYTE
VAR
f
File
buf
Buffer
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
IF
r
bpos
SS
THEN
INC
r
buf
lim
INC
r
file
bleng
r
file
modH
TRUE
ELSE
f
r
file
WriteBuf
f
r
buf
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
apos
f
aleng
THEN
ReadBuf
f
r
buf
r
apos
ELSE
r
buf
apos
r
apos
r
buf
lim
f
aleng
f
aleng
f
bleng
f
modH
TRUE
IF
f
aleng
STS
MOD
XS
THEN
NewExt
f
END
END
ELSE
r
buf
buf
END
r
bpos
END
END
r
buf
data
r
bpos
x
INC
r
bpos
r
buf
mod
TRUE
END
WriteByte
PROCEDURE
WriteBytes
VAR
r
Rider
x
ARRAY
OF
BYTE
n
INTEGER
VAR
i
INTEGER
BEGIN
i
this
implementation
is
to
be
improed
WHILE
i
n
DO
WriteByte
r
x
i
INC
i
END
END
WriteBytes
PROCEDURE
Write
VAR
r
Rider
ch
CHAR
VAR
f
File
buf
Buffer
BEGIN
same
as
WriteByte
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
IF
r
bpos
SS
THEN
INC
r
buf
lim
INC
r
file
bleng
r
file
modH
TRUE
ELSE
f
r
file
WriteBuf
f
r
buf
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
apos
f
aleng
THEN
ReadBuf
f
r
buf
r
apos
ELSE
r
buf
apos
r
apos
r
buf
lim
f
aleng
f
aleng
f
bleng
f
modH
TRUE
IF
f
aleng
STS
MOD
XS
THEN
NewExt
f
END
END
ELSE
r
buf
buf
END
r
bpos
END
END
r
buf
data
r
bpos
ORD
ch
INC
r
bpos
r
buf
mod
TRUE
END
Write
PROCEDURE
WriteInt
VAR
R
Rider
x
INTEGER
BEGIN
WriteByte
R
x
MOD
100H
WriteByte
R
x
DIV
100H
MOD
100H
WriteByte
R
x
DIV
10000H
MOD
100H
WriteByte
R
x
DIV
1000000H
MOD
100H
END
WriteInt
PROCEDURE
WriteSet
VAR
R
Rider
s
SET
BEGIN
WriteInt
R
ORD
s
END
WriteSet
PROCEDURE
WriteReal
VAR
R
Rider
x
REAL
BEGIN
WriteInt
R
ORD
x
END
WriteReal
PROCEDURE
WriteString
VAR
R
Rider
x
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
i
REPEAT
ch
x
i
Write
R
ch
INC
i
UNTIL
ch
0X
END
WriteString
PROCEDURE
WriteNum
VAR
R
Rider
x
INTEGER
BEGIN
WHILE
x
40H
OR
x
40H
DO
WriteByte
R
x
MOD
80H
80H
x
ASR
x
END
WriteByte
R
x
MOD
80H
END
WriteNum
System
use
PROCEDURE
Init
BEGIN
root
Kernel
Init
FileDir
Init
END
Init
PROCEDURE
RestoreList
after
mark
phase
of
garbage
collection
VAR
f
f0
INTEGER
PROCEDURE
mark
f
INTEGER
INTEGER
VAR
m
INTEGER
BEGIN
IF
f
THEN
m
ELSE
SYSTEM
GET
f
m
END
RETURN
m
END
mark
BEGIN
field
next
has
offset
WHILE
mark
root
DO
SYSTEM
GET
root
root
END
f
root
WHILE
f
DO
f0
f
REPEAT
SYSTEM
GET
f0
f0
UNTIL
mark
f0
SYSTEM
PUT
f
f0
f
f0
END
END
RestoreList
END
Files
MODULE
Fonts
JG
PDR
NW
IMPORT
SYSTEM
Files
CONST
FontFileId
0DBH
TYPE
Font
POINTER
TO
FontDesc
FontDesc
RECORD
name
ARRAY
OF
CHAR
height
minX
maxX
minY
maxY
INTEGER
next
Font
T
ARRAY
OF
INTEGER
raster
ARRAY
OF
BYTE
END
LargeFontDesc
RECORD
FontDesc
ext
ARRAY
OF
BYTE
END
LargeFont
POINTER
TO
LargeFontDesc
raster
sizes
Syntax8
Syntax10
Syntax12
Syntax14
Syntax14b
Syntax16
Syntax20
Syntac24
Syntax24b
VAR
Default
root
Font
PROCEDURE
GetPat
fnt
Font
ch
CHAR
VAR
dx
x
y
w
h
patadr
INTEGER
VAR
pa
INTEGER
dxb
xb
yb
wb
hb
BYTE
BEGIN
pa
fnt
T
ORD
ch
MOD
80H
patadr
pa
SYSTEM
GET
pa
dxb
SYSTEM
GET
pa
xb
SYSTEM
GET
pa
yb
SYSTEM
GET
pa
wb
SYSTEM
GET
pa
hb
dx
dxb
x
xb
y
yb
w
wb
h
hb
IF
yb
THEN
y
yb
ELSE
y
yb
END
END
GetPat
PROCEDURE
This
name
ARRAY
OF
CHAR
Font
TYPE
RunRec
RECORD
beg
end
BYTE
END
BoxRec
RECORD
dx
x
y
w
h
BYTE
END
VAR
F
Font
LF
LargeFont
f
Files
File
R
Files
Rider
NofRuns
NofBoxes
BYTE
NofBytes
INTEGER
height
minX
maxX
minY
maxY
BYTE
i
j
k
m
n
INTEGER
a
a0
INTEGER
b
beg
end
BYTE
run
ARRAY
OF
RunRec
box
ARRAY
OF
BoxRec
PROCEDURE
RdInt16
VAR
R
Files
Rider
VAR
b0
BYTE
VAR
b1
BYTE
BEGIN
Files
ReadByte
R
b0
Files
ReadByte
R
b1
END
RdInt16
BEGIN
F
root
WHILE
F
NIL
name
F
name
DO
F
F
next
END
IF
F
NIL
THEN
f
Files
Old
name
IF
f
NIL
THEN
Files
Set
R
f
Files
ReadByte
R
b
IF
b
FontFileId
THEN
Files
ReadByte
R
b
abstraction
Files
ReadByte
R
b
family
Files
ReadByte
R
b
variant
NEW
F
F
name
name
RdInt16
R
height
RdInt16
R
minX
RdInt16
R
maxX
RdInt16
R
minY
RdInt16
R
maxY
RdInt16
R
NofRuns
NofBoxes
k
WHILE
k
NofRuns
DO
RdInt16
R
beg
run
k
beg
beg
RdInt16
R
end
run
k
end
end
NofBoxes
NofBoxes
end
beg
INC
k
END
NofBytes
j
WHILE
j
NofBoxes
DO
RdInt16
R
box
j
dx
RdInt16
R
box
j
x
RdInt16
R
box
j
y
RdInt16
R
box
j
w
RdInt16
R
box
j
h
NofBytes
NofBytes
box
j
w
DIV
box
j
h
INC
j
END
IF
NofBytes
THEN
NEW
F
ELSE
NEW
LF
F
LF
END
F
name
name
F
height
height
F
minX
minX
F
maxX
maxX
F
maxY
maxY
IF
minY
80H
THEN
F
minY
minY
100H
ELSE
F
minY
minY
END
a0
SYSTEM
ADR
F
raster
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
null
pattern
for
characters
not
in
a
run
INC
a0
a
a0
j
k
m
WHILE
k
NofRuns
DO
WHILE
m
run
k
beg
m
DO
F
T
m
a0
INC
m
END
WHILE
m
run
k
end
m
DO
F
T
m
a
SYSTEM
PUT
a
box
j
dx
SYSTEM
PUT
a
box
j
x
SYSTEM
PUT
a
box
j
y
SYSTEM
PUT
a
box
j
w
SYSTEM
PUT
a
box
j
h
INC
a
n
box
j
w
DIV
box
j
h
WHILE
n
DO
DEC
n
Files
ReadByte
R
b
SYSTEM
PUT
a
b
INC
a
END
INC
j
INC
m
END
INC
k
END
WHILE
m
DO
F
T
m
a0
INC
m
END
F
next
root
root
F
ELSE
bad
file
id
F
Default
END
ELSE
font
file
not
available
F
Default
END
END
RETURN
F
END
This
PROCEDURE
Free
remove
all
but
first
two
from
font
list
VAR
f
Font
BEGIN
f
root
next
IF
f
NIL
THEN
f
f
next
END
f
next
NIL
END
Free
BEGIN
root
NIL
Default
This
Oberon10
Scn
Fnt
END
Fonts
MODULE
GraphicFrames
NW
IMPORT
SYSTEM
Display
Viewers
Input
Fonts
Texts
Graphics
Oberon
MenuViewers
CONST
update
message
ids
drawobj
drawobjs
drawobjd
drawnorm
drawsel
drawdel
markW
TYPE
Frame
POINTER
TO
FrameDesc
Location
POINTER
TO
LocDesc
LocDesc
RECORD
x
y
INTEGER
next
Location
END
FrameDesc
RECORD
Display
FrameDesc
graph
Graphics
Graph
Xg
Yg
INTEGER
pos
rel
to
graph
origin
X1
Y1
INTEGER
right
and
upper
margins
x
y
col
INTEGER
x
X
Xg
y
Y
Yg
marked
ticked
BOOLEAN
mark
LocDesc
END
DrawMsg
RECORD
Graphics
Msg
f
Frame
x
y
col
mode
INTEGER
END
UpdateMsg
RECORD
Display
FrameMsg
id
INTEGER
graph
Graphics
Graph
obj
Graphics
Object
END
ChangedMsg
RECORD
Display
FrameMsg
f
Frame
graph
Graphics
Graph
mode
INTEGER
END
SelQuery
RECORD
Display
FrameMsg
f
Frame
time
LONGINT
END
FocusQuery
RECORD
Display
FrameMsg
f
Frame
END
PosQuery
RECORD
Display
FrameMsg
f
Frame
x
y
INTEGER
END
DispMsg
RECORD
Display
FrameMsg
x1
y1
w
INTEGER
pat
INTEGER
graph
Graphics
Graph
END
VAR
Crosshair
Oberon
Marker
tack
dotted
dotted1
INTEGER
patterns
newcap
Graphics
Caption
TBuf
Texts
Buffer
DW
DH
CL
INTEGER
W
Texts
Writer
Exported
procedures
Restore
Focus
Selected
This
Draw
DrawNorm
Erase
DrawObj
EraseObj
Change
Defocus
Deselect
Macro
Open
PROCEDURE
SetChangeMark
F
Frame
col
INTEGER
set
mark
in
corner
of
frame
BEGIN
IF
F
H
THEN
IF
col
THEN
Display
ReplConst
Display
black
F
X
F
W
F
Y
F
H
Display
replace
ELSE
Display
CopyPattern
Display
white
Display
block
F
X
F
W
F
Y
F
H
Display
paint
END
END
END
SetChangeMark
PROCEDURE
Restore
F
Frame
VAR
x
x0
y
INTEGER
M
DrawMsg
BEGIN
F
X1
F
X
F
W
F
Y1
F
Y
F
H
F
x
F
X
F
Xg
DIV
F
y
F
Y
F
Yg
DIV
F
marked
FALSE
F
mark
next
NIL
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Display
ReplConst
F
col
F
X
F
Y
F
W
F
H
IF
F
ticked
THEN
x0
F
X
DIV
y
F
Y
DIV
WHILE
y
F
Y1
DO
x
x0
WHILE
x
F
X1
DO
Display
Dot
Display
white
x
y
Display
replace
INC
x
END
INC
y
END
END
M
f
F
M
x
F
x
M
y
F
y
M
col
M
mode
Graphics
Draw
F
graph
M
IF
F
graph
changed
THEN
SetChangeMark
F
END
END
Restore
PROCEDURE
FlipCross
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
cross
X
Y
Display
invert
END
FlipCross
PROCEDURE
Focus
Frame
VAR
FQ
FocusQuery
BEGIN
FQ
f
NIL
Viewers
Broadcast
FQ
RETURN
FQ
f
END
Focus
PROCEDURE
Selected
Frame
VAR
SQ
SelQuery
BEGIN
SQ
f
NIL
SQ
time
Viewers
Broadcast
SQ
RETURN
SQ
f
END
Selected
PROCEDURE
This
x
y
INTEGER
Frame
VAR
PQ
PosQuery
BEGIN
PQ
f
NIL
PQ
x
x
PQ
y
y
Viewers
Broadcast
PQ
RETURN
PQ
f
END
This
PROCEDURE
Mark
F
Frame
mode
INTEGER
VAR
CM
ChangedMsg
BEGIN
CM
f
F
CM
graph
F
graph
CM
mode
mode
Viewers
Broadcast
CM
END
Mark
PROCEDURE
Draw
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawsel
UM
graph
F
graph
Viewers
Broadcast
UM
END
Draw
PROCEDURE
DrawNorm
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawnorm
UM
graph
F
graph
Viewers
Broadcast
UM
END
DrawNorm
PROCEDURE
Erase
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawdel
UM
graph
F
graph
Viewers
Broadcast
UM
Mark
F
END
Erase
PROCEDURE
DrawObj
F
Frame
obj
Graphics
Object
VAR
UM
UpdateMsg
BEGIN
UM
id
drawobj
UM
graph
F
graph
UM
obj
obj
Viewers
Broadcast
UM
END
DrawObj
PROCEDURE
EraseObj
F
Frame
obj
Graphics
Object
VAR
UM
UpdateMsg
BEGIN
UM
id
drawobjd
UM
graph
F
graph
UM
obj
obj
Viewers
Broadcast
UM
END
EraseObj
PROCEDURE
Change
F
Frame
VAR
msg
Graphics
Msg
BEGIN
IF
F
NIL
THEN
Erase
F
Graphics
Change
F
graph
msg
Draw
F
END
END
Change
PROCEDURE
FlipMark
x
y
INTEGER
BEGIN
Display
ReplConst
Display
white
x
y
Display
ReplConst
Display
white
x
y
END
FlipMark
PROCEDURE
Defocus
F
Frame
VAR
m
Location
BEGIN
newcap
NIL
IF
F
marked
THEN
FlipMark
F
mark
x
F
mark
y
m
F
mark
next
WHILE
m
NIL
DO
FlipMark
m
x
m
y
m
m
next
END
F
marked
FALSE
F
mark
next
NIL
END
END
Defocus
PROCEDURE
Deselect
F
Frame
VAR
UM
UpdateMsg
BEGIN
IF
F
NIL
THEN
UM
id
drawnorm
UM
graph
F
graph
Viewers
Broadcast
UM
Graphics
Deselect
F
graph
END
END
Deselect
PROCEDURE
Macro
Lname
Mname
ARRAY
OF
CHAR
VAR
x
y
INTEGER
F
Frame
mac
Graphics
Macro
mh
Graphics
MacHead
L
Graphics
Library
BEGIN
F
Focus
IF
F
NIL
THEN
x
F
mark
x
F
x
y
F
mark
y
F
y
Graphics
GetLib
Lname
FALSE
L
IF
L
NIL
THEN
mh
Graphics
ThisMac
L
Mname
IF
mh
NIL
THEN
Deselect
F
Defocus
F
NEW
mac
mac
x
x
mac
y
y
mac
w
mh
w
mac
h
mh
h
mac
mac
mh
mac
do
Graphics
MacMethod
mac
col
Oberon
CurCol
Graphics
Add
F
graph
mac
DrawObj
F
mac
Mark
F
END
ELSE
Texts
WriteString
W
Lname
Texts
WriteString
W
not
available
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
END
Macro
PROCEDURE
CaptionCopy
F
Frame
x1
y1
INTEGER
T
Texts
Text
beg
end
LONGINT
Graphics
Caption
VAR
ch
CHAR
dx
w
x2
y2
w1
h1
INTEGER
cap
Graphics
Caption
pat
INTEGER
R
Texts
Reader
BEGIN
Texts
Write
W
0DX
NEW
cap
cap
len
end
beg
cap
pos
Graphics
T
len
cap
do
Graphics
CapMethod
Texts
OpenReader
R
T
beg
Texts
Read
R
ch
W
fnt
R
fnt
W
col
R
col
w
cap
x
x1
F
x
cap
y
y1
F
y
R
fnt
minY
WHILE
beg
end
DO
Fonts
GetPat
R
fnt
ch
dx
x2
y2
w1
h1
pat
INC
w
dx
INC
beg
Texts
Write
W
ch
Texts
Read
R
ch
END
cap
w
w
cap
h
W
fnt
height
cap
col
W
col
Texts
Append
Graphics
T
W
buf
Graphics
Add
F
graph
cap
Mark
F
RETURN
cap
END
CaptionCopy
PROCEDURE
NewLine
F
Frame
G
Graphics
Graph
x
y
w
h
INTEGER
VAR
line
Graphics
Line
BEGIN
NEW
line
line
col
Oberon
CurCol
line
x
x
F
x
line
y
y
F
y
line
w
w
line
h
h
line
do
Graphics
LineMethod
Graphics
Add
G
line
Mark
F
END
NewLine
PROCEDURE
Edit
F
Frame
x0
y0
INTEGER
k0
SET
VAR
obj
Graphics
Object
x1
y1
w
h
t
INTEGER
beg
end
time
LONGINT
k1
k2
SET
mark
newmark
Location
T
Texts
Text
Fd
Frame
G
Graphics
Graph
BEGIN
k1
k0
G
F
graph
REPEAT
Input
Mouse
k2
x1
y1
k1
k1
k2
DEC
x1
x1
F
x
MOD
DEC
y1
y1
F
y
MOD
Oberon
DrawMouse
Crosshair
x1
y1
UNTIL
k2
Oberon
FadeMouse
IF
k0
THEN
left
key
w
ABS
x1
x0
h
ABS
y1
y0
IF
k1
THEN
IF
w
h
THEN
set
mark
IF
x1
markW
F
X
x1
markW
F
X1
y1
markW
F
Y
y1
markW
F
Y1
THEN
Defocus
F
Oberon
PassFocus
Viewers
This
F
X
F
Y
F
mark
x
x1
F
mark
y
y1
F
marked
TRUE
FlipMark
x1
y1
END
ELSE
draw
line
Deselect
F
IF
w
h
THEN
IF
y1
y0
THEN
y0
y1
END
NewLine
F
G
x0
y0
Graphics
width
h
ELSE
IF
x1
x0
THEN
x0
x1
END
NewLine
F
G
x0
y0
w
Graphics
width
END
Draw
F
END
ELSIF
k1
THEN
copy
text
selection
to
mark
Deselect
F
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
DrawObj
F
CaptionCopy
F
x1
y1
T
beg
end
Mark
F
END
ELSIF
k1
THEN
IF
F
marked
THEN
set
secondary
mark
NEW
newmark
newmark
x
x1
newmark
y
y1
newmark
next
NIL
FlipMark
x1
y1
mark
F
mark
next
IF
mark
NIL
THEN
F
mark
next
newmark
ELSE
WHILE
mark
next
NIL
DO
mark
mark
next
END
mark
next
newmark
END
END
END
ELSIF
k0
THEN
middle
key
IF
k1
THEN
move
IF
x0
x1
OR
y0
y1
THEN
Fd
This
x1
y1
Erase
F
IF
Fd
F
THEN
Graphics
Move
G
x1
x0
y1
y0
ELSIF
Fd
NIL
Fd
graph
G
THEN
Graphics
Move
G
x1
Fd
x
x0
F
x
DIV
y1
Fd
y
y0
F
y
DIV
END
Draw
F
Mark
F
END
ELSIF
k1
THEN
copy
Fd
This
x1
y1
IF
Fd
NIL
THEN
DrawNorm
F
IF
Fd
F
THEN
Graphics
Copy
G
G
x1
x0
y1
y0
ELSE
Deselect
Fd
Graphics
Copy
G
Fd
graph
x1
Fd
x
x0
F
x
DIV
y1
Fd
y
y0
F
y
DIV
END
Draw
Fd
Mark
F
END
ELSIF
k1
THEN
shift
graph
INC
F
Xg
x1
x0
INC
F
Yg
y1
y0
Restore
F
END
ELSIF
k0
THEN
right
key
select
newcap
NIL
IF
k1
THEN
Deselect
F
END
IF
ABS
x0
x1
ABS
y0
y1
THEN
obj
Graphics
ThisObj
G
x1
F
x
y1
F
y
IF
obj
NIL
THEN
Graphics
SelectObj
G
obj
DrawObj
F
obj
END
ELSE
IF
x1
x0
THEN
t
x0
x0
x1
x1
t
END
IF
y1
y0
THEN
t
y0
y0
y1
y1
t
END
Graphics
SelectArea
G
x0
F
x
y0
F
y
x1
F
x
y1
F
y
Draw
F
END
END
END
Edit
PROCEDURE
NewCaption
F
Frame
col
INTEGER
font
Fonts
Font
BEGIN
Texts
Write
W
0DX
NEW
newcap
newcap
x
F
mark
x
F
x
newcap
y
F
mark
y
F
y
font
minY
newcap
w
newcap
h
font
height
newcap
col
col
newcap
pos
Graphics
T
len
newcap
len
newcap
do
Graphics
CapMethod
Graphics
Add
F
graph
newcap
W
fnt
font
Mark
F
END
NewCaption
PROCEDURE
InsertChar
F
Frame
ch
CHAR
VAR
w1
h1
INTEGER
DM
DispMsg
BEGIN
DM
graph
F
graph
Fonts
GetPat
W
fnt
ch
DM
w
DM
x1
DM
y1
w1
h1
DM
pat
DEC
DM
y1
W
fnt
minY
IF
newcap
x
newcap
w
DM
w
F
x
F
X1
THEN
Viewers
Broadcast
DM
INC
newcap
w
DM
w
INC
newcap
len
Texts
Write
W
ch
END
Texts
Append
Graphics
T
W
buf
END
InsertChar
PROCEDURE
DeleteChar
F
Frame
VAR
w1
h1
INTEGER
ch
CHAR
pos
LONGINT
DM
DispMsg
R
Texts
Reader
BEGIN
DM
graph
F
graph
IF
newcap
len
THEN
pos
Graphics
T
len
Texts
OpenReader
R
Graphics
T
pos
backspace
Texts
Read
R
ch
IF
ch
THEN
Fonts
GetPat
R
fnt
ch
DM
w
DM
x1
DM
y1
w1
h1
DM
pat
DEC
newcap
w
DM
w
DEC
newcap
len
DEC
DM
y1
R
fnt
minY
Viewers
Broadcast
DM
Texts
Delete
Graphics
T
pos
pos
TBuf
END
END
END
DeleteChar
PROCEDURE
GetSelection
F
Frame
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
VAR
obj
Graphics
Object
BEGIN
obj
F
graph
sel
IF
obj
NIL
F
graph
time
time
THEN
CASE
obj
OF
Graphics
Caption
beg
obj
pos
end
obj
pos
obj
len
text
Graphics
T
time
F
graph
time
END
END
END
GetSelection
PROCEDURE
Handle
G
Display
Frame
VAR
M
Display
FrameMsg
VAR
x
y
h
INTEGER
DM
DispMsg
dM
DrawMsg
G1
Frame
BEGIN
CASE
G
OF
Frame
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
x
M
X
M
X
G
x
MOD
y
M
Y
M
Y
G
y
MOD
IF
M
keys
THEN
Edit
G
x
y
M
keys
ELSE
Oberon
DrawMouse
Crosshair
x
y
END
ELSIF
M
id
Oberon
consume
THEN
IF
M
ch
7FX
THEN
DEL
Erase
G
Graphics
Delete
G
graph
Mark
G
ELSIF
M
ch
20X
M
ch
7FX
THEN
IF
newcap
NIL
THEN
InsertChar
G
M
ch
Mark
G
ELSIF
G
marked
THEN
Defocus
G
Deselect
G
NewCaption
G
M
col
M
fnt
InsertChar
G
M
ch
END
ELSIF
M
ch
8X
newcap
NIL
THEN
DeleteChar
G
Mark
G
END
END
UpdateMsg
IF
M
graph
G
graph
THEN
dM
f
G
dM
x
G
x
dM
y
G
y
dM
col
IF
M
id
drawobj
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawobjs
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawobjd
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawsel
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
ELSIF
M
id
drawnorm
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
ELSIF
M
id
drawdel
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
END
END
ChangedMsg
IF
M
graph
G
graph
THEN
SetChangeMark
G
M
mode
END
SelQuery
IF
G
graph
sel
NIL
M
time
G
graph
time
THEN
M
f
G
Frame
M
time
G
graph
time
END
FocusQuery
IF
G
marked
THEN
M
f
G
END
PosQuery
IF
G
X
M
x
M
x
G
X1
G
Y
M
y
M
y
G
Y1
THEN
M
f
G
END
DispMsg
DM
M
x
G
x
newcap
x
newcap
w
y
G
y
newcap
y
IF
DM
graph
G
graph
x
G
X
x
DM
w
G
X1
y
G
Y
y
G
Y1
THEN
Display
CopyPattern
Oberon
CurCol
DM
pat
x
DM
x1
y
DM
y1
Display
ReplConst
Display
white
x
y
DM
w
newcap
h
END
Oberon
ControlMsg
IF
M
id
Oberon
neutralize
THEN
Oberon
RemoveMarks
G
X
G
Y
G
W
G
H
Defocus
G
DrawNorm
G
Graphics
Deselect
G
graph
ELSIF
M
id
Oberon
defocus
THEN
Defocus
G
END
Oberon
SelectionMsg
GetSelection
G
M
text
M
beg
M
end
M
time
Oberon
CopyMsg
Oberon
RemoveMarks
G
X
G
Y
G
W
G
H
Defocus
G
NEW
G1
G1
G
M
F
G1
MenuViewers
ModifyMsg
G
Y
M
Y
G
H
M
H
Restore
G
END
END
END
Handle
PROCEDURE
Store
F
Frame
name
ARRAY
OF
CHAR
BEGIN
Mark
F
Graphics
WriteFile
F
graph
name
END
Store
Draw
Methods
PROCEDURE
ReplConst
F
Frame
col
x
y
w
h
mode
INTEGER
BEGIN
IF
x
F
X
THEN
DEC
w
F
X
x
x
F
X
END
IF
x
w
F
X1
THEN
w
F
X1
x
END
IF
y
F
Y
THEN
DEC
h
F
Y
y
y
F
Y
END
IF
y
h
F
Y1
THEN
h
F
Y1
y
END
Display
ReplConst
col
x
y
w
h
mode
END
ReplConst
PROCEDURE
ReplPattern
F
Frame
col
patadr
x
y
w
h
mode
INTEGER
BEGIN
IF
x
F
X
THEN
DEC
w
F
X
x
x
F
X
END
IF
x
w
F
X1
THEN
w
F
X1
x
END
IF
y
F
Y
THEN
DEC
h
F
Y
y
y
F
Y
END
IF
y
h
F
Y1
THEN
h
F
Y1
y
END
Display
ReplPattern
col
patadr
x
y
w
h
mode
END
ReplPattern
PROCEDURE
DrawLine
obj
Graphics
Object
VAR
M
Graphics
Msg
M
mode
draw
according
to
state
normal
selected
selected
normal
erase
VAR
x
y
w
h
col
INTEGER
f
Frame
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
x
w
f
X
x
f
X1
y
h
f
Y
y
f
Y1
THEN
col
obj
col
IF
M
mode
obj
selected
OR
M
mode
THEN
ReplPattern
f
col
Display
grey
x
y
w
h
Display
replace
ELSIF
M
mode
IN
THEN
ReplConst
f
col
x
y
w
h
Display
replace
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
erase
END
END
END
END
DrawLine
PROCEDURE
DrawCaption
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
dx
x0
x1
y0
y1
w
h
w1
h1
col
INTEGER
f
Frame
ch
CHAR
pat
INTEGER
fnt
Fonts
Font
R
Texts
Reader
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
f
X
x
x
f
X1
f
Y
y
y
h
f
Y1
THEN
IF
x
w
f
X1
THEN
w
f
X1
x
END
Texts
OpenReader
R
Graphics
T
obj
Graphics
Caption
pos
Texts
Read
R
ch
IF
M
mode
THEN
IF
ch
THEN
fnt
R
fnt
x0
x
y0
y
fnt
minY
col
obj
col
REPEAT
Fonts
GetPat
fnt
ch
dx
x1
y1
w1
h1
pat
IF
x0
x1
w1
f
X1
THEN
Display
CopyPattern
col
pat
x0
x1
y0
y1
Display
paint
INC
x0
dx
Texts
Read
R
ch
ELSE
ch
0X
END
UNTIL
ch
IF
obj
selected
THEN
ReplConst
f
Display
white
x
y
w
h
Display
invert
END
END
ELSIF
M
mode
IN
THEN
ReplConst
f
Display
white
x
y
w
h
Display
invert
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
END
END
END
END
DrawCaption
PROCEDURE
DrawMacro
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
INTEGER
f
Frame
M1
DrawMsg
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
x
w
f
X
x
f
X1
y
h
f
Y
y
f
Y1
THEN
M1
x
x
M1
y
y
IF
M
mode
THEN
M1
f
f
M1
col
obj
col
M1
mode
Graphics
DrawMac
obj
Graphics
Macro
mac
M1
IF
obj
selected
THEN
ReplPattern
f
Display
white
dotted
x
y
w
h
Display
invert
END
ELSIF
M
mode
IN
THEN
ReplPattern
f
Display
white
dotted
x
y
w
h
Display
invert
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
END
END
END
END
DrawMacro
PROCEDURE
Open
G
Frame
graph
Graphics
Graph
BEGIN
G
graph
graph
G
Xg
G
Yg
G
x
G
X
G
y
G
Y
G
col
Display
black
G
marked
FALSE
G
mark
next
NIL
G
ticked
TRUE
G
handle
Handle
END
Open
BEGIN
DW
Display
Width
DH
Display
Height
CL
Texts
OpenWriter
W
tack
SYSTEM
ADR
dotted
SYSTEM
ADR
dotted1
SYSTEM
ADR
Crosshair
Fade
FlipCross
Crosshair
Draw
FlipCross
Graphics
InstallDrawMethods
DrawLine
DrawCaption
DrawMacro
END
GraphicFrames
MODULE
Graphics
NW
IMPORT
SYSTEM
Files
Modules
Fonts
Printer
Texts
Oberon
CONST
NameLen
GraphFileId
0FAX
LibFileId
0FBX
TYPE
Graph
POINTER
TO
GraphDesc
Object
POINTER
TO
ObjectDesc
Method
POINTER
TO
MethodDesc
Line
POINTER
TO
LineDesc
Caption
POINTER
TO
CaptionDesc
Macro
POINTER
TO
MacroDesc
ObjectDesc
RECORD
x
y
w
h
INTEGER
col
BYTE
selected
marked
BOOLEAN
do
Method
next
Object
END
Msg
RECORD
END
WidMsg
RECORD
Msg
w
INTEGER
END
ColorMsg
RECORD
Msg
col
INTEGER
END
FontMsg
RECORD
Msg
fnt
Fonts
Font
END
Name
ARRAY
NameLen
OF
CHAR
GraphDesc
RECORD
time
LONGINT
sel
first
Object
changed
BOOLEAN
END
MacHead
POINTER
TO
MacHeadDesc
MacExt
POINTER
TO
MacExtDesc
Library
POINTER
TO
LibraryDesc
MacHeadDesc
RECORD
name
Name
w
h
INTEGER
ext
MacExt
lib
Library
first
Object
next
MacHead
END
LibraryDesc
RECORD
name
Name
first
MacHead
next
Library
END
MacExtDesc
RECORD
END
Context
RECORD
nofonts
noflibs
nofclasses
INTEGER
font
ARRAY
OF
Fonts
Font
lib
ARRAY
OF
Library
class
ARRAY
OF
Modules
Command
END
MethodDesc
RECORD
module
allocator
Name
new
Modules
Command
copy
PROCEDURE
from
to
Object
draw
change
PROCEDURE
obj
Object
VAR
msg
Msg
selectable
PROCEDURE
obj
Object
x
y
INTEGER
BOOLEAN
read
PROCEDURE
obj
Object
VAR
R
Files
Rider
VAR
C
Context
write
PROCEDURE
obj
Object
cno
INTEGER
VAR
R
Files
Rider
VAR
C
Context
print
PROCEDURE
obj
Object
x
y
INTEGER
END
LineDesc
RECORD
ObjectDesc
unused
INTEGER
END
CaptionDesc
RECORD
ObjectDesc
pos
len
INTEGER
END
MacroDesc
RECORD
ObjectDesc
mac
MacHead
END
VAR
width
res
INTEGER
new
Object
T
Texts
Text
captions
LineMethod
CapMethod
MacMethod
Method
GetLib0
PROCEDURE
name
ARRAY
OF
CHAR
replace
BOOLEAN
VAR
Lib
Library
FirstLib
Library
W
TW
XW
Texts
Writer
PROCEDURE
New
obj
Object
BEGIN
new
obj
END
New
PROCEDURE
Add
G
Graph
obj
Object
BEGIN
obj
marked
FALSE
obj
selected
TRUE
obj
next
G
first
G
first
obj
G
sel
obj
G
time
Oberon
Time
G
changed
TRUE
END
Add
PROCEDURE
ThisObj
G
Graph
x
y
INTEGER
Object
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
obj
do
selectable
obj
x
y
DO
obj
obj
next
END
RETURN
obj
END
ThisObj
PROCEDURE
SelectObj
G
Graph
obj
Object
BEGIN
IF
obj
NIL
THEN
obj
selected
TRUE
G
sel
obj
G
time
Oberon
Time
END
END
SelectObj
PROCEDURE
SelectArea
G
Graph
x0
y0
x1
y1
INTEGER
VAR
obj
Object
t
INTEGER
BEGIN
obj
G
first
IF
x1
x0
THEN
t
x0
x0
x1
x1
t
END
IF
y1
y0
THEN
t
y0
y0
y1
y1
t
END
WHILE
obj
NIL
DO
IF
x0
obj
x
obj
x
obj
w
x1
y0
obj
y
obj
y
obj
h
y1
THEN
obj
selected
TRUE
G
sel
obj
END
obj
obj
next
END
IF
G
sel
NIL
THEN
G
time
Oberon
Time
END
END
SelectArea
PROCEDURE
Draw
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
obj
do
draw
obj
M
obj
obj
next
END
END
Draw
PROCEDURE
List
G
Graph
VAR
obj
Object
tag
INTEGER
BEGIN
obj
G
first
WHILE
obj
NIL
DO
Texts
Write
XW
9X
Texts
WriteHex
XW
ORD
obj
Texts
Write
XW
9X
Texts
WriteInt
XW
obj
x
Texts
WriteInt
XW
obj
y
Texts
WriteInt
XW
obj
w
Texts
WriteInt
XW
obj
h
Texts
Write
XW
SYSTEM
GET
ORD
obj
tag
Texts
WriteHex
XW
tag
SYSTEM
GET
ORD
obj
tag
Texts
WriteHex
XW
tag
Texts
WriteLn
XW
obj
obj
next
END
Texts
Append
Oberon
Log
XW
buf
END
List
procedures
operating
on
selection
PROCEDURE
Deselect
G
Graph
VAR
obj
Object
BEGIN
obj
G
first
G
sel
NIL
G
time
WHILE
obj
NIL
DO
obj
selected
FALSE
obj
obj
next
END
END
Deselect
PROCEDURE
DrawSel
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
draw
obj
M
END
obj
obj
next
END
END
DrawSel
PROCEDURE
Change
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
G
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
change
obj
M
END
obj
obj
next
END
END
Change
PROCEDURE
Move
G
Graph
dx
dy
INTEGER
VAR
obj
ob0
Object
x0
x1
y0
y1
INTEGER
BEGIN
obj
G
first
G
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
obj
IS
Caption
THEN
x0
obj
x
x1
obj
w
x0
y0
obj
y
y1
obj
h
y0
IF
dx
THEN
vertical
move
ob0
G
first
WHILE
ob0
NIL
DO
IF
ob0
selected
ob0
IS
Line
x0
ob0
x
ob0
x
x1
ob0
w
ob0
h
THEN
IF
y0
ob0
y
ob0
y
y1
THEN
INC
ob0
y
dy
DEC
ob0
h
dy
ob0
marked
TRUE
ELSIF
y0
ob0
y
ob0
h
ob0
y
ob0
h
y1
THEN
INC
ob0
h
dy
ob0
marked
TRUE
END
END
ob0
ob0
next
END
ELSIF
dy
THEN
horizontal
move
ob0
G
first
WHILE
ob0
NIL
DO
IF
ob0
selected
ob0
IS
Line
y0
ob0
y
ob0
y
y1
ob0
h
ob0
w
THEN
IF
x0
ob0
x
ob0
x
x1
THEN
INC
ob0
x
dx
DEC
ob0
w
dx
ob0
marked
TRUE
ELSIF
x0
ob0
x
ob0
w
ob0
x
ob0
w
x1
THEN
INC
ob0
w
dx
ob0
marked
TRUE
END
END
ob0
ob0
next
END
END
END
obj
obj
next
END
obj
G
first
now
move
WHILE
obj
NIL
DO
IF
obj
selected
THEN
INC
obj
x
dx
INC
obj
y
dy
END
obj
marked
FALSE
obj
obj
next
END
END
Move
PROCEDURE
Copy
Gs
Gd
Graph
dx
dy
INTEGER
VAR
obj
Object
BEGIN
obj
Gs
first
Gd
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
new
obj
do
copy
obj
new
INC
new
x
dx
INC
new
y
dy
obj
selected
FALSE
Add
Gd
new
END
obj
obj
next
END
new
NIL
END
Copy
PROCEDURE
Delete
G
Graph
VAR
obj
pred
Object
BEGIN
G
sel
NIL
G
changed
TRUE
obj
G
first
WHILE
obj
NIL
obj
selected
DO
obj
obj
next
END
G
first
obj
IF
obj
NIL
THEN
pred
obj
obj
obj
next
WHILE
obj
NIL
DO
IF
obj
selected
THEN
pred
next
obj
next
ELSE
pred
obj
END
obj
obj
next
END
END
END
Delete
Storing
PROCEDURE
WMsg
s0
s1
ARRAY
OF
CHAR
BEGIN
Texts
WriteString
W
s0
Texts
WriteString
W
s1
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
WMsg
PROCEDURE
InitContext
VAR
C
Context
BEGIN
C
nofonts
C
noflibs
C
nofclasses
C
class
LineMethod
new
C
class
CapMethod
new
C
class
MacMethod
new
END
InitContext
PROCEDURE
FontNo
VAR
W
Files
Rider
VAR
C
Context
fnt
Fonts
Font
INTEGER
VAR
fno
INTEGER
BEGIN
fno
WHILE
fno
C
nofonts
C
font
fno
fnt
DO
INC
fno
END
IF
fno
C
nofonts
THEN
Files
WriteByte
W
Files
WriteByte
W
Files
WriteByte
W
fno
Files
WriteString
W
fnt
name
C
font
fno
fnt
INC
C
nofonts
END
RETURN
fno
END
FontNo
PROCEDURE
StoreElems
VAR
W
Files
Rider
VAR
C
Context
obj
Object
VAR
cno
INTEGER
BEGIN
WHILE
obj
NIL
DO
cno
WHILE
cno
C
nofclasses
obj
do
new
C
class
cno
DO
INC
cno
END
IF
cno
C
nofclasses
THEN
Files
WriteByte
W
Files
WriteByte
W
Files
WriteByte
W
cno
Files
WriteString
W
obj
do
module
Files
WriteString
W
obj
do
allocator
C
class
cno
obj
do
new
INC
C
nofclasses
END
obj
do
write
obj
cno
W
C
obj
obj
next
END
Files
WriteByte
W
END
StoreElems
PROCEDURE
Store
G
Graph
VAR
W
Files
Rider
VAR
C
Context
BEGIN
InitContext
C
StoreElems
W
C
G
first
G
changed
FALSE
END
Store
PROCEDURE
WriteObj
VAR
W
Files
Rider
cno
INTEGER
obj
Object
BEGIN
Files
WriteByte
W
cno
Files
WriteInt
W
obj
y
10000H
obj
x
Files
WriteInt
W
obj
h
10000H
obj
w
Files
WriteByte
W
obj
col
END
WriteObj
PROCEDURE
WriteFile
G
Graph
name
ARRAY
OF
CHAR
VAR
F
Files
File
W
Files
Rider
C
Context
BEGIN
F
Files
New
name
Files
Set
W
F
Files
Write
W
GraphFileId
InitContext
C
StoreElems
W
C
G
first
Files
Register
F
END
WriteFile
PROCEDURE
Print
G
Graph
x0
y0
INTEGER
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
obj
do
print
obj
x0
y0
obj
obj
next
END
END
Print
Loading
PROCEDURE
GetClass
module
allocator
ARRAY
OF
CHAR
VAR
com
Modules
Command
VAR
mod
Modules
Module
BEGIN
Modules
Load
module
mod
IF
mod
NIL
THEN
com
Modules
ThisCommand
mod
allocator
IF
com
NIL
THEN
WMsg
allocator
unknown
END
ELSE
WMsg
module
not
available
com
NIL
END
END
GetClass
PROCEDURE
Font
VAR
R
Files
Rider
VAR
C
Context
Fonts
Font
VAR
fno
BYTE
BEGIN
Files
ReadByte
R
fno
RETURN
C
font
fno
END
Font
PROCEDURE
ReadObj
VAR
R
Files
Rider
obj
Object
VAR
xy
wh
INTEGER
dmy
BYTE
BEGIN
Files
ReadInt
R
xy
obj
y
xy
DIV
10000H
obj
x
xy
10000H
DIV
10000H
Files
ReadInt
R
wh
obj
h
wh
DIV
10000H
obj
w
wh
10000H
DIV
10000H
Files
ReadByte
R
obj
col
END
ReadObj
PROCEDURE
LoadElems
VAR
R
Files
Rider
VAR
C
Context
VAR
fobj
Object
VAR
cno
m
n
len
BYTE
pos
INTEGER
obj
Object
fnt
Fonts
Font
name
name1
ARRAY
OF
CHAR
BEGIN
obj
NIL
Files
ReadByte
R
cno
WHILE
R
eof
cno
DO
IF
cno
THEN
Files
ReadByte
R
m
Files
ReadByte
R
n
Files
ReadString
R
name
IF
m
THEN
fnt
Fonts
This
name
C
font
n
fnt
ELSIF
m
THEN
GetLib0
name
FALSE
C
lib
n
ELSIF
m
THEN
Files
ReadString
R
name1
GetClass
name
name1
C
class
n
END
ELSIF
C
class
cno
NIL
THEN
C
class
cno
ReadObj
R
new
new
selected
FALSE
new
marked
FALSE
new
next
obj
obj
new
new
do
read
new
R
C
ELSE
ReadObj
R
new
Files
ReadByte
R
len
pos
Files
Pos
R
Files
Set
R
Files
Base
R
pos
len
END
Files
ReadByte
R
cno
END
new
NIL
fobj
obj
END
LoadElems
PROCEDURE
Load
G
Graph
VAR
R
Files
Rider
VAR
C
Context
BEGIN
G
sel
NIL
InitContext
C
LoadElems
R
C
G
first
END
Load
PROCEDURE
Open
G
Graph
name
ARRAY
OF
CHAR
VAR
tag
CHAR
F
Files
File
R
Files
Rider
C
Context
BEGIN
G
first
NIL
G
sel
NIL
G
time
G
changed
FALSE
F
Files
Old
name
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
tag
IF
tag
GraphFileId
THEN
InitContext
C
LoadElems
R
C
G
first
res
ELSE
res
END
ELSE
res
END
END
Open
PROCEDURE
SetWidth
w
INTEGER
BEGIN
width
w
END
SetWidth
Macros
Libraries
PROCEDURE
GetLib
name
ARRAY
OF
CHAR
replace
BOOLEAN
VAR
Lib
Library
VAR
i
wh
INTEGER
ch
CHAR
L
Library
mh
MacHead
obj
Object
F
Files
File
R
Files
Rider
C
Context
Lname
Fname
ARRAY
OF
CHAR
BEGIN
L
FirstLib
i
WHILE
L
NIL
L
name
name
DO
L
L
next
END
IF
L
NIL
THEN
load
library
from
file
i
WHILE
name
i
0X
DO
Fname
i
name
i
INC
i
END
Fname
i
Fname
i
L
Fname
i
i
Fname
i
b
Fname
i
0X
F
Files
Old
Fname
IF
F
NIL
THEN
WMsg
loading
Fname
Files
Set
R
F
Files
Read
R
ch
IF
ch
LibFileId
THEN
IF
L
NIL
THEN
NEW
L
L
name
name
L
next
FirstLib
FirstLib
L
END
L
first
NIL
InitContext
C
LoadElems
R
C
obj
WHILE
obj
NIL
DO
NEW
mh
mh
first
obj
Files
ReadInt
R
wh
mh
h
wh
DIV
10000H
MOD
10000H
mh
w
wh
MOD
10000H
Files
ReadString
R
mh
name
mh
lib
L
mh
next
L
first
L
first
mh
LoadElems
R
C
obj
END
ELSE
L
NIL
END
ELSE
L
NIL
END
END
Lib
L
END
GetLib
PROCEDURE
NewLib
Lname
ARRAY
OF
CHAR
Library
VAR
L
Library
BEGIN
NEW
L
L
name
Lname
L
first
NIL
L
next
FirstLib
FirstLib
L
RETURN
L
END
NewLib
PROCEDURE
StoreLib
L
Library
Fname
ARRAY
OF
CHAR
VAR
i
INTEGER
mh
MacHead
F
Files
File
W
Files
Rider
C
Context
Gname
ARRAY
OF
CHAR
BEGIN
L
FirstLib
WHILE
L
NIL
L
name
Fname
DO
L
L
next
END
IF
L
NIL
THEN
i
WHILE
Fname
i
0X
DO
Gname
i
Fname
i
INC
i
END
Gname
i
Gname
i
L
Gname
i
i
Gname
i
b
Gname
i
0X
F
Files
New
Gname
Files
Set
W
F
Files
Write
W
LibFileId
InitContext
C
mh
L
first
WHILE
mh
NIL
DO
StoreElems
W
C
mh
first
Files
WriteInt
W
mh
h
10000H
mh
w
Files
WriteString
W
mh
name
mh
mh
next
END
Files
WriteByte
W
Files
Register
F
ELSE
Texts
WriteString
TW
Fname
Texts
WriteString
TW
not
found
Texts
WriteLn
TW
Texts
Append
Oberon
Log
TW
buf
END
END
StoreLib
PROCEDURE
RemoveLibraries
BEGIN
FirstLib
NIL
END
RemoveLibraries
PROCEDURE
ThisMac
L
Library
Mname
ARRAY
OF
CHAR
MacHead
VAR
mh
MacHead
BEGIN
mh
L
first
WHILE
mh
NIL
mh
name
Mname
DO
mh
mh
next
END
RETURN
mh
END
ThisMac
PROCEDURE
DrawMac
mh
MacHead
VAR
M
Msg
VAR
elem
Object
BEGIN
elem
mh
first
WHILE
elem
NIL
DO
elem
do
draw
elem
M
elem
elem
next
END
END
DrawMac
Procedures
for
designing
macros
PROCEDURE
OpenMac
mh
MacHead
G
Graph
x
y
INTEGER
VAR
obj
Object
BEGIN
obj
mh
first
WHILE
obj
NIL
DO
obj
do
new
obj
do
copy
obj
new
INC
new
x
x
INC
new
y
y
new
selected
TRUE
Add
G
new
obj
obj
next
END
new
NIL
END
OpenMac
PROCEDURE
MakeMac
G
Graph
VAR
head
MacHead
VAR
x0
y0
x1
y1
INTEGER
obj
last
Object
mh
MacHead
BEGIN
obj
G
first
last
NIL
x0
x1
y0
y1
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
new
obj
do
copy
obj
new
new
next
last
new
selected
FALSE
last
new
IF
obj
x
x0
THEN
x0
obj
x
END
IF
obj
x
obj
w
x1
THEN
x1
obj
x
obj
w
END
IF
obj
y
y0
THEN
y0
obj
y
END
IF
obj
y
obj
h
y1
THEN
y1
obj
y
obj
h
END
END
obj
obj
next
END
obj
last
WHILE
obj
NIL
DO
obj
x
obj
x
x0
obj
y
obj
y
y0
obj
obj
next
END
NEW
mh
mh
w
x1
x0
mh
h
y1
y0
mh
first
last
mh
ext
NIL
new
NIL
head
mh
END
MakeMac
PROCEDURE
InsertMac
mh
MacHead
L
Library
VAR
new
BOOLEAN
VAR
mh1
MacHead
BEGIN
mh
lib
L
mh1
L
first
WHILE
mh1
NIL
mh1
name
mh
name
DO
mh1
mh1
next
END
IF
mh1
NIL
THEN
new
TRUE
mh
next
L
first
L
first
mh
ELSE
new
FALSE
mh1
w
mh
w
mh1
h
mh
h
mh1
first
mh
first
END
END
InsertMac
Line
Methods
PROCEDURE
NewLine
VAR
line
Line
BEGIN
NEW
line
new
line
line
do
LineMethod
END
NewLine
PROCEDURE
CopyLine
src
dst
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
END
CopyLine
PROCEDURE
ChangeLine
obj
Object
VAR
M
Msg
BEGIN
CASE
M
OF
WidMsg
IF
obj
w
obj
h
THEN
IF
obj
w
THEN
obj
w
M
w
END
ELSIF
obj
h
THEN
obj
h
M
w
END
ColorMsg
obj
col
M
col
END
END
ChangeLine
PROCEDURE
LineSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
w
obj
y
y
y
obj
y
obj
h
END
LineSelectable
PROCEDURE
ReadLine
obj
Object
VAR
R
Files
Rider
VAR
C
Context
BEGIN
END
ReadLine
PROCEDURE
WriteLine
obj
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Context
BEGIN
WriteObj
W
cno
obj
END
WriteLine
PROCEDURE
PrintLine
obj
Object
x
y
INTEGER
VAR
w
h
INTEGER
BEGIN
w
obj
w
h
obj
h
IF
w
h
THEN
h
h
ELSE
w
w
END
Printer
ReplConst
obj
x
x
obj
y
y
w
h
END
PrintLine
Caption
Methods
PROCEDURE
NewCaption
VAR
cap
Caption
BEGIN
NEW
cap
new
cap
cap
do
CapMethod
END
NewCaption
PROCEDURE
CopyCaption
src
dst
Object
VAR
ch
CHAR
R
Texts
Reader
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Caption
pos
T
len
dst
Caption
len
src
Caption
len
Texts
Write
TW
0DX
Texts
OpenReader
R
T
src
Caption
pos
Texts
Read
R
ch
TW
fnt
R
fnt
WHILE
ch
0DX
DO
Texts
Write
TW
ch
Texts
Read
R
ch
END
Texts
Append
T
TW
buf
END
CopyCaption
PROCEDURE
ChangeCaption
obj
Object
VAR
M
Msg
VAR
dx
x1
dy
y1
w
w1
h1
len
INTEGER
pos
LONGINT
ch
CHAR
patadr
INTEGER
fnt
Fonts
Font
R
Texts
Reader
BEGIN
CASE
M
OF
FontMsg
fnt
M
FontMsg
fnt
w
len
pos
obj
Caption
pos
Texts
OpenReader
R
T
pos
Texts
Read
R
ch
dy
R
fnt
minY
WHILE
ch
0DX
DO
Fonts
GetPat
fnt
ch
dx
x1
y1
w1
h1
patadr
INC
w
dx
INC
len
Texts
Read
R
ch
END
INC
obj
y
fnt
minY
dy
obj
w
w
obj
h
fnt
height
Texts
ChangeLooks
T
pos
pos
len
fnt
ColorMsg
obj
col
M
ColorMsg
col
END
END
ChangeCaption
PROCEDURE
CaptionSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
w
obj
y
y
y
obj
y
obj
h
END
CaptionSelectable
PROCEDURE
ReadCaption
obj
Object
VAR
R
Files
Rider
VAR
C
Context
VAR
ch
CHAR
fno
BYTE
len
INTEGER
BEGIN
obj
Caption
pos
T
len
Texts
Write
TW
0DX
Files
ReadByte
R
fno
TW
fnt
C
font
fno
len
Files
Read
R
ch
WHILE
ch
0DX
DO
Texts
Write
TW
ch
INC
len
Files
Read
R
ch
END
obj
Caption
len
len
Texts
Append
T
TW
buf
END
ReadCaption
PROCEDURE
WriteCaption
obj
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Context
VAR
ch
CHAR
fno
BYTE
TR
Texts
Reader
BEGIN
IF
obj
Caption
len
THEN
Texts
OpenReader
TR
T
obj
Caption
pos
Texts
Read
TR
ch
fno
FontNo
W
C
TR
fnt
WriteObj
W
cno
obj
Files
WriteByte
W
fno
WHILE
ch
0DX
DO
Files
Write
W
ch
Texts
Read
TR
ch
END
Files
Write
W
0X
END
END
WriteCaption
PROCEDURE
PrintCaption
obj
Object
x
y
INTEGER
VAR
fnt
Fonts
Font
i
INTEGER
ch
CHAR
R
Texts
Reader
s
ARRAY
OF
CHAR
BEGIN
IF
obj
Caption
len
THEN
Texts
OpenReader
R
T
obj
Caption
pos
Texts
Read
R
ch
fnt
R
fnt
DEC
y
fnt
minY
i
WHILE
ch
DO
s
i
ch
INC
i
Texts
Read
R
ch
END
s
i
0X
IF
i
THEN
Printer
String
obj
x
x
obj
y
y
s
fnt
name
END
END
END
PrintCaption
Macro
Methods
PROCEDURE
NewMacro
VAR
mac
Macro
BEGIN
NEW
mac
new
mac
mac
do
MacMethod
END
NewMacro
PROCEDURE
CopyMacro
src
dst
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Macro
mac
src
Macro
mac
END
CopyMacro
PROCEDURE
ChangeMacro
obj
Object
VAR
M
Msg
BEGIN
CASE
M
OF
ColorMsg
obj
col
M
col
END
END
ChangeMacro
PROCEDURE
MacroSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
y
y
y
obj
y
END
MacroSelectable
PROCEDURE
ReadMacro
obj
Object
VAR
R
Files
Rider
VAR
C
Context
VAR
lno
BYTE
name
ARRAY
OF
CHAR
BEGIN
Files
ReadByte
R
lno
Files
ReadString
R
name
obj
Macro
mac
ThisMac
C
lib
lno
name
END
ReadMacro
PROCEDURE
WriteMacro
obj
Object
cno
INTEGER
VAR
W1
Files
Rider
VAR
C
Context
VAR
lno
INTEGER
BEGIN
lno
WHILE
lno
C
noflibs
obj
Macro
mac
lib
C
lib
lno
DO
INC
lno
END
IF
lno
C
noflibs
THEN
Files
WriteByte
W1
Files
WriteByte
W1
Files
WriteByte
W1
lno
Files
WriteString
W1
obj
Macro
mac
lib
name
C
lib
lno
obj
Macro
mac
lib
INC
C
noflibs
END
WriteObj
W1
cno
obj
Files
WriteByte
W1
lno
Files
WriteString
W1
obj
Macro
mac
name
END
WriteMacro
PROCEDURE
PrintMacro
obj
Object
x
y
INTEGER
VAR
elem
Object
mh
MacHead
BEGIN
mh
obj
Macro
mac
IF
mh
NIL
THEN
elem
mh
first
WHILE
elem
NIL
DO
elem
do
print
elem
obj
x
x
obj
y
y
elem
elem
next
END
END
END
PrintMacro
PROCEDURE
Notify
T
Texts
Text
op
INTEGER
beg
end
LONGINT
BEGIN
END
Notify
PROCEDURE
InstallDrawMethods
drawLine
drawCaption
drawMacro
PROCEDURE
obj
Object
VAR
msg
Msg
BEGIN
LineMethod
draw
drawLine
CapMethod
draw
drawCaption
MacMethod
draw
drawMacro
END
InstallDrawMethods
BEGIN
Texts
OpenWriter
W
Texts
OpenWriter
TW
Texts
OpenWriter
XW
width
GetLib0
GetLib
NEW
T
Texts
Open
T
T
notify
Notify
NEW
LineMethod
LineMethod
new
NewLine
LineMethod
copy
CopyLine
LineMethod
selectable
LineSelectable
LineMethod
change
ChangeLine
LineMethod
read
ReadLine
LineMethod
write
WriteLine
LineMethod
print
PrintLine
NEW
CapMethod
CapMethod
new
NewCaption
CapMethod
copy
CopyCaption
CapMethod
selectable
CaptionSelectable
CapMethod
change
ChangeCaption
CapMethod
read
ReadCaption
CapMethod
write
WriteCaption
CapMethod
print
PrintCaption
NEW
MacMethod
MacMethod
new
NewMacro
MacMethod
copy
CopyMacro
MacMethod
selectable
MacroSelectable
MacMethod
change
ChangeMacro
MacMethod
read
ReadMacro
MacMethod
write
WriteMacro
MacMethod
print
PrintMacro
END
Graphics
MODULE
GraphTool
NW
IMPORT
Files
Texts
Oberon
CONST
Context
Line
Caption
Macro
Rectangles
VAR
W
Texts
Writer
PROCEDURE
DecGraph
VAR
ch
CHAR
class
col
fno
cat
inx
libno
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0F8X
THEN
Files
ReadByte
R
class
WHILE
R
eof
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Files
Read
R
ch
Texts
WriteInt
W
col
Texts
Write
W
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Macro
THEN
Files
ReadByte
R
libno
Files
ReadString
R
name
Texts
WriteInt
W
libno
Texts
Write
W
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
file
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecGraph
PROCEDURE
DecGraph1
VAR
ch
CHAR
class
col
fno
len
lw
vers
cat
inx
libno
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0FAX
THEN
Files
ReadByte
R
class
WHILE
R
eof
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Texts
WriteInt
W
col
Texts
Write
W
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Macro
THEN
Files
ReadByte
R
libno
Files
ReadString
R
name
Texts
WriteInt
W
libno
Texts
Write
W
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
len
Texts
WriteInt
W
len
Files
ReadByte
R
lw
Texts
WriteInt
W
lw
Files
ReadByte
R
vers
Texts
WriteInt
W
vers
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
file
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecGraph1
PROCEDURE
DecLibrary1
VAR
ch
CHAR
class
col
fno
cat
inx
libno
len
lnw
vers
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
library1
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0FBX
THEN
Files
ReadByte
R
class
WHILE
class
R
eof
DO
WHILE
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Texts
WriteInt
W
col
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Texts
Write
W
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Texts
Write
W
Files
ReadByte
R
len
Texts
WriteInt
W
len
Files
ReadByte
R
lnw
Texts
WriteInt
W
lnw
Files
ReadByte
R
vers
Texts
WriteInt
W
vers
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
end
macro
Texts
WriteString
W
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
MOD
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
library
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecLibrary1
PROCEDURE
ConvertFontname
VAR
x
ARRAY
OF
CHAR
BEGIN
Syntax
Oberon
IF
x
S
x
y
x
n
x
t
x
a
x
x
THEN
x
O
x
b
x
e
x
r
x
o
x
n
END
END
ConvertFontname
PROCEDURE
ConvertLibrary
VAR
ch
CHAR
class
col
fno
cat
inx
libno
len
lnw
vers
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
G
Files
File
R
Q
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
convert
library
Texts
WriteString
W
S
s
F
Files
Old
S
s
IF
F
NIL
THEN
Texts
Scan
S
G
Files
New
S
s
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Files
Set
R
F
Files
Set
Q
G
Files
Read
R
ch
IF
ch
0FDX
THEN
Files
Write
Q
0FBX
Files
ReadByte
R
class
WHILE
class
R
eof
DO
WHILE
class
DO
Files
WriteByte
Q
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
WriteByte
Q
cat
Files
WriteByte
Q
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
font
ConvertFontname
name
END
Files
WriteString
Q
name
IF
cat
THEN
class
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
Files
WriteString
Q
name
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
ELSE
Files
ReadInt
R
xy
Files
WriteInt
Q
xy
Files
ReadInt
R
wh
Files
WriteInt
Q
wh
Files
ReadByte
R
col
Files
Read
R
ch
Files
WriteByte
Q
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Files
WriteByte
Q
fno
Files
ReadString
R
name
Files
WriteString
Q
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
len
Files
WriteByte
Q
len
Files
ReadByte
R
len
Files
ReadByte
R
lnw
Files
WriteByte
Q
lnw
Files
ReadByte
R
vers
Files
WriteByte
Q
vers
ELSE
Texts
WriteString
W
alien
class
Texts
WriteInt
W
class
END
END
Files
ReadByte
R
class
END
Files
WriteByte
Q
end
macro
Files
ReadInt
R
wh
Files
WriteInt
Q
wh
Files
ReadString
R
name
Files
WriteString
Q
name
Texts
WriteString
W
name
Texts
WriteInt
W
wh
MOD
10000H
Texts
WriteInt
W
wh
DIV
10000H
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
library
END
Files
Register
G
Texts
WriteString
W
done
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
ConvertLibrary
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
GraphTool
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
GraphTool
MODULE
Input
NW
Ceres
PDR
NW
Ceres
IMPORT
SYSTEM
CONST
msAdr
kbdAdr
VAR
kbdCode
BYTE
last
keyboard
code
read
Recd
Up
Shift
Ctrl
Ext
BOOLEAN
KTabAdr
INTEGER
keyboard
code
translation
table
MW
MH
MX
MY
INTEGER
mouse
limits
and
coords
MK
SET
mouse
keys
FIFO
implemented
in
hardware
because
every
read
must
be
handled
including
tracking
the
state
of
the
Shift
and
Ctrl
keys
PROCEDURE
Peek
BEGIN
IF
SYSTEM
BIT
msAdr
THEN
SYSTEM
GET
kbdAdr
kbdCode
IF
kbdCode
0F0H
THEN
Up
TRUE
ELSIF
kbdCode
0E0H
THEN
Ext
TRUE
ELSE
IF
kbdCode
12H
OR
kbdCode
59H
THEN
shift
Shift
Up
ELSIF
kbdCode
14H
THEN
ctrl
Ctrl
Up
ELSIF
Up
THEN
Recd
TRUE
real
key
going
down
END
Up
FALSE
Ext
FALSE
END
END
END
Peek
PROCEDURE
Available
INTEGER
BEGIN
Peek
RETURN
ORD
Recd
END
Available
PROCEDURE
Read
VAR
ch
CHAR
BEGIN
WHILE
Recd
DO
Peek
END
IF
Shift
OR
Ctrl
THEN
INC
kbdCode
80H
END
ctrl
implies
shift
ch
kbdTab
kbdCode
SYSTEM
GET
KTabAdr
kbdCode
ch
IF
Ctrl
THEN
ch
CHR
ORD
ch
MOD
20H
END
Recd
FALSE
END
Read
PROCEDURE
Mouse
VAR
keys
SET
VAR
x
y
INTEGER
VAR
w
INTEGER
BEGIN
SYSTEM
GET
msAdr
w
keys
SYSTEM
VAL
SET
w
DIV
1000000H
MOD
x
w
MOD
400H
y
w
DIV
1000H
MOD
400H
IF
y
MH
THEN
y
MH
END
END
Mouse
PROCEDURE
SetMouseLimits
w
h
INTEGER
BEGIN
MW
w
MH
h
END
SetMouseLimits
PROCEDURE
Init
BEGIN
Up
FALSE
Shift
FALSE
Ctrl
FALSE
Recd
FALSE
KTabAdr
SYSTEM
ADR
1A
7A
6E
6D
6A
2C
6B
6F
2E
2F
6C
3B
2D
5B
3D
0D
5D
5C
7F
1B
7E
5A
4E
5E
4D
4A
2A
3C
4B
4F
3E
3F
4C
3A
5F
7B
2B
0D
7D
7C
7F
1B
END
Init
BEGIN
Init
END
Input
MODULE
Kernel
NW
PR
IMPORT
SYSTEM
CONST
SectorLength
timer
spiData
spiCtrl
CARD0
SPIFAST
FSoffset
80000H
256MB
in
byte
blocks
mapsize
10000H
1K
sectors
64MB
TYPE
Sector
ARRAY
SectorLength
OF
BYTE
VAR
allocated
NofSectors
INTEGER
heapOrg
heapLim
INTEGER
stackOrg
stackSize
MemLim
INTEGER
clock
INTEGER
list0
list1
list2
list3
INTEGER
lists
of
free
blocks
of
size
n
bytes
data
INTEGER
SPI
data
in
sectorMap
ARRAY
mapsize
DIV
OF
SET
New
heap
allocation
PROCEDURE
GetBlock
VAR
p
LONGINT
len
LONGINT
len
is
multiple
of
VAR
q0
q1
q2
size
LONGINT
done
BOOLEAN
BEGIN
q0
q1
list0
done
FALSE
WHILE
done
q1
DO
SYSTEM
GET
q1
size
SYSTEM
GET
q1
q2
IF
size
len
THEN
no
fit
q0
q1
q1
q2
ELSIF
size
len
THEN
extract
p
done
TRUE
p
q1
IF
q0
THEN
SYSTEM
PUT
q0
q2
ELSE
list0
q2
END
ELSE
reduce
size
done
TRUE
p
q1
q1
q1
len
SYSTEM
PUT
q1
size
len
SYSTEM
PUT
q1
SYSTEM
PUT
q1
q2
IF
q0
THEN
SYSTEM
PUT
q0
q1
ELSE
list0
q1
END
END
END
IF
done
THEN
p
END
END
GetBlock
PROCEDURE
GetBlock128
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list1
THEN
p
list1
SYSTEM
GET
list1
list1
ELSE
GetBlock
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list1
list1
q
p
q
END
END
GetBlock128
PROCEDURE
GetBlock64
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list2
THEN
p
list2
SYSTEM
GET
list2
list2
ELSE
GetBlock128
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list2
list2
q
p
q
END
END
GetBlock64
PROCEDURE
GetBlock32
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list3
THEN
p
list3
SYSTEM
GET
list3
list3
ELSE
GetBlock64
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list3
list3
q
p
q
END
END
GetBlock32
PROCEDURE
New
VAR
ptr
LONGINT
tag
LONGINT
called
by
NEW
via
MT
ptr
and
tag
are
pointers
VAR
p
size
lim
LONGINT
BEGIN
SYSTEM
GET
tag
size
IF
size
THEN
GetBlock32
p
ELSIF
size
THEN
GetBlock64
p
ELSIF
size
THEN
GetBlock128
p
ELSE
GetBlock
p
size
DIV
END
IF
p
THEN
ptr
ELSE
ptr
p
SYSTEM
PUT
p
tag
lim
p
size
INC
p
INC
allocated
size
WHILE
p
lim
DO
SYSTEM
PUT
p
INC
p
END
END
END
New
Garbage
collector
PROCEDURE
Mark
pref
LONGINT
VAR
pvadr
offadr
offset
tag
p
q
r
LONGINT
BEGIN
SYSTEM
GET
pref
pvadr
pointers
heapOrg
considered
NIL
WHILE
pvadr
DO
SYSTEM
GET
pvadr
p
SYSTEM
GET
p
offadr
IF
p
heapOrg
offadr
THEN
q
p
mark
elements
in
data
structure
with
root
p
REPEAT
SYSTEM
GET
p
offadr
IF
offadr
THEN
SYSTEM
GET
p
tag
offadr
tag
ELSE
INC
offadr
END
SYSTEM
PUT
p
offadr
SYSTEM
GET
offadr
offset
IF
offset
THEN
down
SYSTEM
GET
p
offset
r
SYSTEM
GET
r
offadr
IF
r
heapOrg
offadr
THEN
SYSTEM
PUT
p
offset
q
q
p
p
r
END
ELSE
up
SYSTEM
GET
q
offadr
SYSTEM
GET
offadr
offset
IF
p
q
THEN
SYSTEM
GET
q
offset
r
SYSTEM
PUT
q
offset
p
p
q
q
r
END
END
UNTIL
p
q
offset
END
INC
pref
SYSTEM
GET
pref
pvadr
END
END
Mark
PROCEDURE
Scan
VAR
p
q
mark
tag
size
LONGINT
BEGIN
p
heapOrg
REPEAT
SYSTEM
GET
p
mark
q
p
WHILE
mark
DO
SYSTEM
GET
p
tag
SYSTEM
GET
tag
size
INC
p
size
SYSTEM
GET
p
mark
END
size
p
q
DEC
allocated
size
size
of
free
block
IF
size
THEN
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list3
list3
q
INC
q
DEC
size
END
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list2
list2
q
INC
q
DEC
size
END
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list1
list1
q
INC
q
DEC
size
END
IF
size
THEN
SYSTEM
PUT
q
size
SYSTEM
PUT
q
SYSTEM
PUT
q
list0
list0
q
INC
q
size
END
END
IF
mark
THEN
SYSTEM
GET
p
tag
SYSTEM
GET
tag
size
SYSTEM
PUT
p
INC
p
size
ELSE
free
SYSTEM
GET
p
size
INC
p
size
END
UNTIL
p
heapLim
END
Scan
Disk
storage
management
PROCEDURE
SPIIdle
n
INTEGER
send
n
FFs
slowly
with
no
card
selected
BEGIN
SYSTEM
PUT
spiCtrl
WHILE
n
DO
DEC
n
SYSTEM
PUT
spiData
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
END
END
SPIIdle
PROCEDURE
SPI
n
INTEGER
send
rcv
byte
slowly
with
card
selected
BEGIN
SYSTEM
PUT
spiCtrl
CARD0
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
END
SPI
PROCEDURE
SPICmd
n
arg
INTEGER
VAR
i
crc
INTEGER
BEGIN
send
cmd
REPEAT
SPIIdle
UNTIL
data
flush
while
unselected
REPEAT
SPI
UNTIL
data
flush
while
selected
IF
n
THEN
crc
ELSIF
n
THEN
crc
ELSE
crc
END
SPI
n
MOD
send
command
FOR
i
TO
BY
DO
SPI
ROR
arg
i
END
send
arg
SPI
crc
i
REPEAT
SPI
DEC
i
UNTIL
data
80H
OR
i
END
SPICmd
PROCEDURE
SDShift
VAR
n
INTEGER
VAR
data
INTEGER
BEGIN
SPICmd
CMD58
get
card
capacity
bit
SYSTEM
GET
spiData
data
SPI
IF
data
OR
SYSTEM
BIT
spiData
THEN
n
n
END
non
SDHC
card
SPI
SPI
SPIIdle
flush
response
END
SDShift
PROCEDURE
ReadSD
src
dst
INTEGER
VAR
i
INTEGER
BEGIN
SDShift
src
SPICmd
src
ASSERT
data
CMD17
read
one
block
i
wait
for
start
data
marker
REPEAT
SPI
INC
i
UNTIL
data
SYSTEM
PUT
spiCtrl
SPIFAST
CARD0
FOR
i
TO
BY
DO
SYSTEM
PUT
spiData
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
SYSTEM
PUT
dst
data
INC
dst
END
SPI
SPI
SPIIdle
may
be
a
checksum
deselect
card
END
ReadSD
PROCEDURE
WriteSD
dst
src
INTEGER
VAR
i
n
INTEGER
x
BYTE
BEGIN
SDShift
dst
SPICmd
dst
ASSERT
data
CMD24
write
one
block
SPI
write
start
data
marker
SYSTEM
PUT
spiCtrl
SPIFAST
CARD0
FOR
i
TO
BY
DO
SYSTEM
GET
src
n
INC
src
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
END
SPI
SPI
dummy
checksum
i
REPEAT
SPI
INC
i
UNTIL
data
MOD
OR
i
ASSERT
data
MOD
SPIIdle
deselect
card
END
WriteSD
PROCEDURE
InitSecMap
VAR
i
INTEGER
BEGIN
NofSectors
sectorMap
sectorMap
FOR
i
TO
mapsize
DIV
DO
sectorMap
i
END
END
InitSecMap
PROCEDURE
MarkSector
sec
INTEGER
BEGIN
sec
sec
DIV
ASSERT
SYSTEM
H
INCL
sectorMap
sec
DIV
sec
MOD
INC
NofSectors
END
MarkSector
PROCEDURE
FreeSector
sec
INTEGER
BEGIN
sec
sec
DIV
ASSERT
SYSTEM
H
EXCL
sectorMap
sec
DIV
sec
MOD
DEC
NofSectors
END
FreeSector
PROCEDURE
AllocSector
hint
INTEGER
VAR
sec
INTEGER
VAR
s
INTEGER
BEGIN
find
free
sector
starting
after
hint
hint
hint
DIV
ASSERT
SYSTEM
H
s
hint
REPEAT
INC
s
IF
s
mapsize
THEN
s
END
UNTIL
s
MOD
IN
sectorMap
s
DIV
INCL
sectorMap
s
DIV
s
MOD
INC
NofSectors
sec
s
END
AllocSector
PROCEDURE
GetSector
src
INTEGER
VAR
dst
Sector
BEGIN
src
src
DIV
ASSERT
SYSTEM
H
src
src
FSoffset
ReadSD
src
SYSTEM
ADR
dst
ReadSD
src
SYSTEM
ADR
dst
END
GetSector
PROCEDURE
PutSector
dst
INTEGER
VAR
src
Sector
BEGIN
dst
dst
DIV
ASSERT
SYSTEM
H
dst
dst
FSoffset
WriteSD
dst
SYSTEM
ADR
src
WriteSD
dst
SYSTEM
ADR
src
END
PutSector
Miscellaneous
procedures
PROCEDURE
Time
INTEGER
VAR
t
INTEGER
BEGIN
SYSTEM
GET
timer
t
RETURN
t
END
Time
PROCEDURE
Clock
INTEGER
BEGIN
RETURN
clock
END
Clock
PROCEDURE
SetClock
dt
INTEGER
BEGIN
clock
dt
END
SetClock
PROCEDURE
Install
Padr
at
INTEGER
BEGIN
SYSTEM
PUT
at
0E7000000H
Padr
at
DIV
END
Install
PROCEDURE
Trap
VAR
a
INTEGER
b
INTEGER
VAR
u
v
w
INTEGER
BEGIN
u
SYSTEM
REG
SYSTEM
GET
u
v
w
v
DIV
10H
MOD
10H
trap
number
IF
w
THEN
New
a
b
ELSE
stop
LED
w
REPEAT
UNTIL
FALSE
END
END
Trap
PROCEDURE
Init
BEGIN
Install
SYSTEM
ADR
Trap
20H
install
temporary
trap
SYSTEM
GET
MemLim
SYSTEM
GET
heapOrg
stackOrg
heapOrg
stackSize
8000H
heapLim
MemLim
list1
list2
list3
list0
heapOrg
SYSTEM
PUT
list0
heapLim
heapOrg
SYSTEM
PUT
list0
SYSTEM
PUT
list0
allocated
clock
InitSecMap
END
Init
END
Kernel
MODULE
MenuViewers
JG
NW
IMPORT
Input
Display
Viewers
Oberon
CONST
extend
reduce
FrameColor
Display
white
TYPE
Viewer
POINTER
TO
ViewerDesc
ViewerDesc
RECORD
Viewers
ViewerDesc
menuH
INTEGER
END
ModifyMsg
RECORD
Display
FrameMsg
id
INTEGER
dY
Y
H
INTEGER
END
PROCEDURE
Copy
V
Viewer
VAR
V1
Viewer
VAR
Menu
Main
Display
Frame
M
Oberon
CopyMsg
BEGIN
Menu
V
dsc
Main
V
dsc
next
NEW
V1
V1
V
V1
state
M
F
NIL
Menu
handle
Menu
M
V1
dsc
M
F
M
F
NIL
Main
handle
Main
M
V1
dsc
next
M
F
END
Copy
PROCEDURE
Draw
V
Viewers
Viewer
BEGIN
Display
ReplConst
FrameColor
V
X
V
Y
V
H
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
V
Y
V
H
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
W
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
H
V
W
Display
replace
END
Draw
PROCEDURE
Extend
V
Viewer
newY
INTEGER
VAR
dH
INTEGER
BEGIN
dH
V
Y
newY
IF
dH
THEN
Display
ReplConst
Display
black
V
X
newY
V
W
dH
Display
replace
Display
ReplConst
FrameColor
V
X
newY
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
newY
dH
Display
replace
Display
ReplConst
FrameColor
V
X
newY
V
W
Display
replace
END
END
Extend
PROCEDURE
Reduce
V
Viewer
newY
INTEGER
BEGIN
Display
ReplConst
FrameColor
V
X
newY
V
W
Display
replace
END
Reduce
PROCEDURE
Grow
V
Viewer
oldH
INTEGER
VAR
dH
INTEGER
BEGIN
dH
V
H
oldH
IF
dH
THEN
Display
ReplConst
FrameColor
V
X
V
Y
oldH
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
V
Y
oldH
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
H
V
W
Display
replace
END
END
Grow
PROCEDURE
Shrink
V
Viewer
newH
INTEGER
BEGIN
Display
ReplConst
FrameColor
V
X
V
Y
newH
V
W
Display
replace
END
Shrink
PROCEDURE
Adjust
F
Display
Frame
id
dY
Y
H
INTEGER
VAR
M
ModifyMsg
BEGIN
M
id
id
M
dY
dY
M
Y
Y
M
H
H
F
handle
F
M
F
Y
Y
F
H
H
END
Adjust
PROCEDURE
Restore
V
Viewer
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
Draw
V
Menu
X
V
X
Menu
Y
V
Y
V
H
Menu
W
V
W
Menu
H
Main
X
V
X
Main
Y
V
Y
V
H
V
menuH
Main
W
V
W
Main
H
IF
V
H
V
menuH
THEN
Adjust
Menu
extend
V
Y
V
H
V
menuH
V
menuH
Adjust
Main
extend
V
Y
V
H
V
menuH
ELSE
Adjust
Menu
extend
V
Y
V
H
END
END
Restore
PROCEDURE
Modify
V
Viewer
Y
H
INTEGER
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
IF
Y
V
Y
THEN
extend
Oberon
RemoveMarks
V
X
Y
V
W
V
Y
Y
Extend
V
Y
IF
H
V
menuH
THEN
Adjust
Menu
extend
Y
H
V
menuH
V
menuH
Adjust
Main
extend
Y
H
V
menuH
ELSE
Adjust
Menu
extend
Y
H
END
ELSIF
Y
V
Y
THEN
reduce
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
IF
H
V
menuH
THEN
Adjust
Main
reduce
Y
H
V
menuH
Adjust
Menu
reduce
Y
H
V
menuH
V
menuH
ELSE
Adjust
Main
reduce
Y
H
V
menuH
Adjust
Menu
reduce
Y
H
END
Reduce
V
Y
END
END
Modify
PROCEDURE
Change
V
Viewer
X
Y
INTEGER
Keys
SET
VAR
Menu
Main
Display
Frame
V1
Viewers
Viewer
keysum
SET
Y0
dY
H
INTEGER
BEGIN
Keys
Menu
V
dsc
Main
V
dsc
next
Oberon
DrawMouseArrow
X
Y
Display
ReplConst
Display
white
V
X
V
Y
V
H
V
dsc
H
V
W
V
dsc
H
Display
invert
Y0
Y
keysum
Keys
Input
Mouse
Keys
X
Y
WHILE
Keys
DO
keysum
keysum
Keys
Oberon
DrawMouseArrow
X
Y
Input
Mouse
Keys
X
Y
END
Display
ReplConst
Display
white
V
X
V
Y
V
H
V
dsc
H
V
W
V
dsc
H
Display
invert
IF
IN
keysum
THEN
IF
IN
keysum
THEN
V1
Viewers
This
X
Y
IF
V1
IS
Viewer
Y
V1
Y
V1
H
V1
Viewer
menuH
THEN
Y
V1
Y
V1
H
END
IF
Y
V1
Y
V
menuH
THEN
Y
V1
Y
V
menuH
END
Viewers
Close
V
Viewers
Open
V
X
Y
Restore
V
ELSE
IF
Y
Y0
THEN
extend
dY
Y
Y0
V1
Viewers
Next
V
IF
V1
state
THEN
CASE
V1
OF
Viewer
IF
V1
H
V1
menuH
THEN
dY
ELSIF
V1
H
V1
menuH
dY
THEN
dY
V1
H
V1
menuH
END
Viewers
Viewer
IF
V1
H
dY
THEN
dY
V1
H
END
END
ELSIF
V1
H
dY
THEN
dY
V1
H
END
Viewers
Change
V
V
Y
V
H
dY
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
Grow
V
V
H
dY
IF
V
H
V
menuH
THEN
Adjust
Menu
extend
dY
V
Y
V
H
V
menuH
V
menuH
Adjust
Main
extend
dY
V
Y
V
H
V
menuH
ELSE
V
H
Adjust
Menu
extend
dY
V
Y
V
H
Adjust
Main
extend
dY
V
Y
V
H
V
menuH
END
ELSIF
Y
Y0
THEN
reduce
dY
Y0
Y
IF
V
H
V
menuH
THEN
IF
V
H
V
menuH
dY
THEN
dY
V
H
V
menuH
END
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
H
V
H
dY
Adjust
Main
reduce
dY
V
Y
H
V
menuH
Adjust
Menu
reduce
dY
V
Y
H
V
menuH
V
menuH
Shrink
V
H
Viewers
Change
V
V
Y
H
END
END
END
END
END
Change
PROCEDURE
Suspend
V
Viewer
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
Adjust
Main
reduce
V
Y
V
H
V
menuH
Adjust
Menu
reduce
V
Y
V
H
END
Suspend
PROCEDURE
Handle
V
Display
Frame
VAR
M
Display
FrameMsg
VAR
X
Y
INTEGER
Menu
Main
Display
Frame
V1
Viewer
BEGIN
Menu
V
dsc
Main
V
dsc
next
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
X
M
X
Y
M
Y
IF
Y
V
Y
THEN
Oberon
DrawMouseArrow
X
Y
ELSIF
Y
V
Y
V
H
V
Viewer
menuH
THEN
Main
handle
Main
M
ELSIF
Y
V
Y
V
H
V
Viewer
menuH
THEN
Menu
handle
Menu
M
ELSIF
Y
V
Y
V
H
THEN
IF
IN
M
keys
THEN
Change
V
Viewer
X
Y
M
keys
ELSE
Menu
handle
Menu
M
END
ELSE
Oberon
DrawMouseArrow
X
Y
END
ELSE
Menu
handle
Menu
M
Main
handle
Main
M
END
Oberon
ControlMsg
IF
M
id
Oberon
mark
THEN
X
M
X
Y
M
Y
Oberon
DrawMouseArrow
X
Y
Oberon
DrawPointer
X
Y
ELSE
Menu
handle
Menu
M
Main
handle
Main
M
END
Oberon
CopyMsg
Copy
V
Viewer
V1
M
F
V1
Viewers
ViewerMsg
IF
M
id
Viewers
restore
THEN
Restore
V
Viewer
ELSIF
M
id
Viewers
modify
THEN
Modify
V
Viewer
M
Y
M
H
ELSIF
M
id
Viewers
suspend
THEN
Suspend
V
Viewer
END
Display
FrameMsg
Menu
handle
Menu
M
Main
handle
Main
M
END
END
Handle
PROCEDURE
New
Menu
Main
Display
Frame
menuH
X
Y
INTEGER
Viewer
VAR
V
Viewer
BEGIN
NEW
V
V
handle
Handle
V
dsc
Menu
V
dsc
next
Main
V
menuH
menuH
Viewers
Open
V
X
Y
Restore
V
RETURN
V
END
New
END
MenuViewers
MODULE
Modules
Link
and
load
on
RISC
NW
IMPORT
SYSTEM
Files
CONST
versionkey
1X
MT
DescSize
TYPE
Module
POINTER
TO
ModDesc
Command
PROCEDURE
ModuleName
ARRAY
OF
CHAR
ModDesc
RECORD
name
ModuleName
next
Module
key
num
size
refcnt
INTEGER
data
code
imp
cmd
ent
ptr
unused
INTEGER
addresses
END
VAR
root
M
Module
MTOrg
AllocPtr
res
INTEGER
importing
imported
ModuleName
limit
INTEGER
PROCEDURE
ThisFile
name
ARRAY
OF
CHAR
Files
File
VAR
i
INTEGER
filename
ModuleName
BEGIN
i
WHILE
name
i
0X
DO
filename
i
name
i
INC
i
END
filename
i
filename
i
r
filename
i
s
filename
i
c
filename
i
0X
RETURN
Files
Old
filename
END
ThisFile
PROCEDURE
error
n
INTEGER
name
ARRAY
OF
CHAR
BEGIN
res
n
importing
name
END
error
PROCEDURE
Check
s
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
ch
s
res
i
IF
ch
A
ch
Z
OR
ch
a
ch
z
THEN
REPEAT
ch
s
i
INC
i
UNTIL
ch
ch
OR
ch
A
ch
Z
OR
ch
a
ch
z
OR
ch
OR
i
IF
i
ch
0X
THEN
res
END
END
END
Check
PROCEDURE
Load
name
ARRAY
OF
CHAR
VAR
newmod
Module
search
module
in
list
if
not
found
load
module
res
already
present
or
loaded
res
file
not
available
res
key
conflict
res
bad
file
version
res
corrupted
file
res
no
space
VAR
mod
impmod
Module
i
n
key
impkey
mno
nofimps
size
INTEGER
p
u
v
w
INTEGER
addresses
ch
CHAR
body
Command
fixorgP
fixorgD
fixorgT
INTEGER
disp
adr
inst
pno
vno
dest
offset
INTEGER
name1
impname
ModuleName
F
Files
File
R
Files
Rider
import
ARRAY
OF
Module
BEGIN
mod
root
res
nofimps
WHILE
mod
NIL
name
mod
name
DO
mod
mod
next
END
IF
mod
NIL
THEN
load
Check
name
IF
res
THEN
F
ThisFile
name
ELSE
F
NIL
END
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadString
R
name1
Files
ReadInt
R
key
Files
Read
R
ch
Files
ReadInt
R
size
importing
name1
IF
ch
versionkey
THEN
Files
ReadString
R
impname
imports
WHILE
impname
0X
res
DO
Files
ReadInt
R
impkey
Load
impname
impmod
import
nofimps
impmod
importing
name1
IF
res
THEN
IF
impmod
key
impkey
THEN
INC
impmod
refcnt
INC
nofimps
ELSE
error
name1
imported
impname
END
END
Files
ReadString
R
impname
END
ELSE
error
name1
END
ELSE
error
name
END
IF
res
THEN
search
for
a
hole
in
the
list
allocate
and
link
INC
size
DescSize
mod
root
WHILE
mod
NIL
mod
name
0X
mod
size
size
DO
mod
mod
next
END
IF
mod
NIL
THEN
no
large
enough
hole
was
found
IF
AllocPtr
size
limit
THEN
allocate
p
AllocPtr
mod
SYSTEM
VAL
Module
p
AllocPtr
p
size
100H
DIV
20H
20H
mod
size
AllocPtr
p
mod
num
root
num
mod
next
root
root
mod
ELSE
error
name1
END
ELSE
fill
hole
p
SYSTEM
VAL
INTEGER
mod
END
END
IF
res
THEN
read
file
INC
p
DescSize
allocate
descriptor
mod
name
name
mod
key
key
mod
refcnt
mod
data
p
data
SYSTEM
PUT
mod
num
MTOrg
p
module
table
entry
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
type
descriptors
Files
ReadInt
R
n
WHILE
n
DO
SYSTEM
PUT
p
INC
p
DEC
n
END
variable
space
Files
ReadInt
R
n
WHILE
n
DO
Files
Read
R
ch
SYSTEM
PUT
p
ch
INC
p
DEC
n
END
strings
mod
code
p
program
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
program
code
mod
imp
p
copy
imports
i
WHILE
i
nofimps
DO
SYSTEM
PUT
p
import
i
INC
p
INC
i
END
mod
cmd
p
commands
Files
Read
R
ch
WHILE
ch
0X
DO
REPEAT
SYSTEM
PUT
p
ch
INC
p
Files
Read
R
ch
UNTIL
ch
0X
REPEAT
SYSTEM
PUT
p
0X
INC
p
UNTIL
p
MOD
Files
ReadInt
R
n
SYSTEM
PUT
p
n
INC
p
Files
Read
R
ch
END
REPEAT
SYSTEM
PUT
p
0X
INC
p
UNTIL
p
MOD
mod
ent
p
entries
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
mod
ptr
p
pointer
references
Files
ReadInt
R
w
WHILE
w
DO
SYSTEM
PUT
p
mod
data
w
INC
p
Files
ReadInt
R
w
END
SYSTEM
PUT
p
INC
p
Files
ReadInt
R
fixorgP
Files
ReadInt
R
fixorgD
Files
ReadInt
R
fixorgT
Files
ReadInt
R
w
body
SYSTEM
VAL
Command
mod
code
w
Files
Read
R
ch
IF
ch
O
THEN
corrupted
file
mod
NIL
error
name
END
END
IF
res
THEN
fixup
of
BL
adr
mod
code
fixorgP
WHILE
adr
mod
code
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
100000H
MOD
10H
pno
inst
DIV
1000H
MOD
100H
disp
inst
MOD
1000H
SYSTEM
GET
mod
imp
mno
impmod
SYSTEM
GET
impmod
ent
pno
dest
dest
dest
impmod
code
offset
dest
adr
DIV
SYSTEM
PUT
adr
offset
MOD
1000000H
0F7000000H
adr
adr
disp
END
fixup
of
LDR
STR
ADD
adr
mod
code
fixorgD
WHILE
adr
mod
code
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
100000H
MOD
10H
disp
inst
MOD
1000H
IF
mno
THEN
global
SYSTEM
PUT
adr
inst
DIV
1000000H
10H
MT
100000H
mod
num
ELSE
import
SYSTEM
GET
mod
imp
mno
impmod
v
impmod
num
SYSTEM
PUT
adr
inst
DIV
1000000H
10H
MT
100000H
v
SYSTEM
GET
adr
inst
vno
inst
MOD
100H
SYSTEM
GET
impmod
ent
vno
offset
IF
ODD
inst
DIV
100H
THEN
offset
offset
impmod
code
impmod
data
END
SYSTEM
PUT
adr
inst
DIV
10000H
10000H
offset
END
adr
adr
disp
END
fixup
of
type
descriptors
adr
mod
data
fixorgT
WHILE
adr
mod
data
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
1000000H
MOD
10H
vno
inst
DIV
1000H
MOD
1000H
disp
inst
MOD
1000H
IF
mno
THEN
global
inst
mod
data
vno
ELSE
import
SYSTEM
GET
mod
imp
mno
impmod
SYSTEM
GET
impmod
ent
vno
offset
inst
impmod
data
offset
END
SYSTEM
PUT
adr
inst
adr
adr
disp
END
body
initialize
module
ELSIF
res
THEN
importing
name
WHILE
nofimps
DO
DEC
nofimps
DEC
import
nofimps
refcnt
END
END
END
newmod
mod
END
Load
PROCEDURE
ThisCommand
mod
Module
name
ARRAY
OF
CHAR
Command
VAR
k
adr
w
INTEGER
ch
CHAR
s
ARRAY
OF
CHAR
BEGIN
res
w
IF
mod
NIL
THEN
adr
mod
cmd
SYSTEM
GET
adr
ch
WHILE
ch
0X
res
DO
k
read
command
name
REPEAT
s
k
ch
INC
k
INC
adr
SYSTEM
GET
adr
ch
UNTIL
ch
0X
s
k
0X
REPEAT
INC
adr
UNTIL
adr
MOD
SYSTEM
GET
adr
k
INC
adr
IF
s
name
THEN
res
w
mod
code
k
ELSE
SYSTEM
GET
adr
ch
END
END
END
RETURN
SYSTEM
VAL
Command
w
END
ThisCommand
PROCEDURE
Free
name
ARRAY
OF
CHAR
VAR
mod
imp
Module
p
q
INTEGER
BEGIN
mod
root
res
WHILE
mod
NIL
mod
name
name
DO
mod
mod
next
END
IF
mod
NIL
THEN
IF
mod
refcnt
THEN
mod
name
0X
p
mod
imp
q
mod
cmd
WHILE
p
q
DO
SYSTEM
GET
p
imp
DEC
imp
refcnt
INC
p
END
ELSE
res
END
END
END
Free
PROCEDURE
Init
BEGIN
Files
Init
MTOrg
SYSTEM
REG
MT
SYSTEM
GET
AllocPtr
SYSTEM
GET
root
SYSTEM
GET
limit
DEC
limit
8000H
END
Init
BEGIN
Init
Load
Oberon
M
LED
res
REPEAT
UNTIL
FALSE
only
if
load
fails
END
Modules
MODULE
Net
NW
PR
IMPORT
SYSTEM
SCC
Files
Viewers
Texts
TextFrames
MenuViewers
Oberon
CONST
PakSize
T0
T1
timeouts
T0
T1
timeouts
ACK
10H
NAK
25H
NPR
26H
acknowledgements
NRQ
34H
NRS
35H
name
request
response
SND
41H
REC
42H
MSG
44H
TRQ
46H
TIM
47H
time
requests
VAR
W
Texts
Writer
Server
Oberon
Task
head0
head1
SCC
Header
partner
ARRAY
OF
CHAR
dmy
ARRAY
OF
BYTE
protected
BOOLEAN
write
protection
PROCEDURE
SetPartner
name
ARRAY
OF
CHAR
BEGIN
head0
dadr
head1
sadr
partner
name
END
SetPartner
PROCEDURE
Send
t
BYTE
L
INTEGER
data
ARRAY
OF
BYTE
BEGIN
head0
typ
t
head0
len
L
SCC
SendPacket
head0
data
END
Send
PROCEDURE
ReceiveHead
timeout
LONGINT
VAR
time
LONGINT
BEGIN
time
Oberon
Time
timeout
REPEAT
SCC
ReceiveHead
head1
IF
head1
valid
head1
sadr
head0
dadr
THEN
SCC
Skip
head1
len
head1
valid
FALSE
END
IF
head1
valid
Oberon
Time
time
THEN
head1
typ
0FFH
END
UNTIL
head1
valid
OR
head1
typ
0FFH
END
ReceiveHead
PROCEDURE
FindPartner
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
time
LONGINT
k
INTEGER
Id
ARRAY
OF
CHAR
IdB
ARRAY
OF
BYTE
BEGIN
SCC
Skip
SCC
Available
res
k
WHILE
k
name
k
0X
DO
Id
k
name
k
IdB
k
ORD
Id
k
INC
k
END
Id
k
0X
IdB
k
also
terminate
IdB
IF
Id
partner
THEN
head0
dadr
0FFH
Send
NRQ
k
IdB
time
Oberon
Time
T1
REPEAT
SCC
ReceiveHead
head1
IF
head1
valid
THEN
IF
head1
typ
NRS
THEN
SetPartner
Id
ELSE
SCC
Skip
head1
len
head1
valid
FALSE
END
ELSIF
Oberon
Time
time
THEN
res
partner
0X
END
UNTIL
head1
valid
OR
res
END
END
FindPartner
PROCEDURE
AppendS
s
ARRAY
OF
CHAR
VAR
d
ARRAY
OF
BYTE
VAR
k
INTEGER
VAR
i
INTEGER
ch
CHAR
BEGIN
i
REPEAT
ch
s
i
d
k
ORD
ch
INC
i
INC
k
UNTIL
ch
0X
END
AppendS
PROCEDURE
AppendW
s
LONGINT
VAR
d
ARRAY
OF
BYTE
n
INTEGER
VAR
k
INTEGER
VAR
i
INTEGER
BEGIN
i
REPEAT
d
k
s
MOD
100H
s
s
DIV
100H
INC
i
INC
k
UNTIL
i
n
END
AppendW
PROCEDURE
PickS
VAR
s
ARRAY
OF
CHAR
VAR
i
INTEGER
x
BYTE
BEGIN
i
REPEAT
SCC
Receive
x
s
i
CHR
x
INC
i
UNTIL
x
END
PickS
PROCEDURE
PickQ
VAR
w
LONGINT
VAR
x0
x1
x2
x3
BYTE
BEGIN
SCC
Receive
x0
SCC
Receive
x1
SCC
Receive
x2
SCC
Receive
x3
w
x0
100H
x1
100H
x2
100H
x3
END
PickQ
PROCEDURE
SendData
F
Files
File
VAR
k
seqno
INTEGER
x
BYTE
len
LONGINT
R
Files
Rider
buf
ARRAY
PakSize
OF
BYTE
BEGIN
Files
Set
R
F
len
seqno
REPEAT
k
REPEAT
Files
ReadByte
R
x
IF
R
eof
THEN
buf
k
x
INC
k
END
UNTIL
R
eof
OR
k
PakSize
REPEAT
Send
seqno
k
buf
ReceiveHead
T1
UNTIL
head1
typ
seqno
ACK
seqno
seqno
MOD
len
len
k
IF
head1
typ
seqno
ACK
THEN
Texts
WriteString
W
failed
k
END
UNTIL
k
PakSize
Texts
WriteInt
W
len
END
SendData
PROCEDURE
ReceiveData
F
Files
File
VAR
done
BOOLEAN
VAR
k
retry
seqno
INTEGER
x
BYTE
len
LONGINT
R
Files
Rider
BEGIN
Files
Set
R
F
seqno
len
retry
k
PakSize
REPEAT
IF
head1
typ
seqno
THEN
seqno
seqno
MOD
len
len
head1
len
retry
Send
seqno
ACK
dmy
k
WHILE
k
head1
len
DO
SCC
Receive
x
Files
WriteByte
R
x
INC
k
END
IF
k
PakSize
THEN
done
TRUE
END
ELSE
DEC
retry
IF
retry
THEN
Texts
WriteString
W
failed
done
FALSE
k
END
Send
seqno
ACK
dmy
END
ReceiveHead
T0
UNTIL
k
PakSize
Texts
WriteInt
W
len
END
ReceiveData
PROCEDURE
reply
msg
INTEGER
BEGIN
IF
msg
THEN
Texts
WriteString
W
no
link
ELSIF
msg
THEN
Texts
WriteString
W
no
permission
ELSIF
msg
THEN
Texts
WriteString
W
not
done
ELSIF
msg
THEN
Texts
WriteString
W
not
found
ELSIF
msg
THEN
Texts
WriteString
W
no
response
ELSIF
msg
THEN
Texts
WriteString
W
time
set
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
reply
PROCEDURE
Serve
VAR
i
INTEGER
done
BOOLEAN
x
BYTE
F
Files
File
pw
clock
newclock
LONGINT
Id
ARRAY
OF
CHAR
IdB
ARRAY
OF
BYTE
FileName
ARRAY
OF
CHAR
BEGIN
SCC
ReceiveHead
head1
IF
head1
valid
THEN
IF
head1
typ
SND
THEN
PickS
Id
PickQ
pw
PickS
FileName
Texts
WriteString
W
Id
Texts
Write
W
Texts
WriteString
W
FileName
F
Files
Old
FileName
IF
F
NIL
THEN
Texts
WriteString
W
sending
SetPartner
Id
Texts
Append
Oberon
Log
W
buf
SendData
F
ELSE
Send
NAK
dmy
Texts
Write
W
END
reply
ELSIF
head1
typ
REC
THEN
PickS
Id
PickQ
pw
PickS
FileName
IF
protected
THEN
Texts
WriteString
W
Id
Texts
Write
W
Texts
WriteString
W
FileName
F
Files
New
FileName
IF
F
NIL
THEN
Texts
WriteString
W
receiving
SetPartner
Id
Texts
Append
Oberon
Log
W
buf
Send
ACK
dmy
ReceiveHead
T0
ReceiveData
F
done
IF
done
THEN
Files
Register
F
END
ELSE
Send
NAK
dmy
Texts
Write
W
END
reply
ELSE
Send
NPR
dmy
END
ELSIF
head1
typ
MSG
THEN
i
WHILE
i
head1
len
DO
SCC
Receive
x
Texts
Write
W
CHR
x
INC
i
END
Send
ACK
dmy
reply
ELSIF
head1
typ
TRQ
THEN
i
AppendW
Oberon
Clock
IdB
i
Send
TIM
IdB
ELSIF
head1
typ
TIM
THEN
PickQ
newclock
PickS
Id
PickQ
pw
clock
Oberon
Clock
IF
protected
Id
0X
ABS
pw
clock
THEN
Oberon
SetClock
newclock
Texts
WriteString
W
Id
Texts
WriteString
W
changed
System
Date
Texts
WriteClock
W
newclock
reply
END
ELSIF
head1
typ
NRQ
THEN
i
REPEAT
SCC
Receive
x
Id
i
CHR
x
INC
i
IF
i
THEN
Id
0X
x
END
UNTIL
x
WHILE
i
head1
len
DO
SCC
Receive
x
INC
i
END
IF
Id
Oberon
User
THEN
SetPartner
Id
Send
NRS
dmy
END
ELSE
SCC
Skip
head1
len
END
END
END
Serve
PROCEDURE
GetPar1
VAR
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
END
GetPar1
PROCEDURE
GetPar
VAR
S
Texts
Scanner
VAR
end
LONGINT
VAR
T
Texts
Text
beg
tm
LONGINT
BEGIN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
tm
IF
tm
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
ELSE
end
Oberon
Par
text
len
END
END
GetPar
PROCEDURE
SendFiles
VAR
k
INTEGER
end
LONGINT
S
Texts
Scanner
F
Files
File
buf
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
k
IF
k
THEN
GetPar
S
end
WHILE
Texts
Pos
S
end
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
k
AppendS
Oberon
User
buf
k
AppendW
Oberon
Password
buf
k
AppendS
S
s
buf
k
IF
S
nextCh
THEN
prefix
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
THEN
buf
k
ORD
AppendS
S
s
buf
k
Texts
Write
W
Texts
WriteString
W
S
s
END
END
F
Files
Old
S
s
IF
F
NIL
THEN
Send
REC
k
buf
ReceiveHead
T0
IF
head1
typ
ACK
THEN
Texts
WriteString
W
sending
Texts
Append
Oberon
Log
W
buf
SendData
F
reply
ELSIF
head1
typ
NPR
THEN
reply
end
ELSIF
head1
typ
NAK
THEN
reply
end
ELSE
reply
end
END
ELSE
reply
END
Texts
Scan
S
END
ELSE
reply
END
END
END
SendFiles
PROCEDURE
ReceiveFiles
VAR
k
INTEGER
done
BOOLEAN
end
LONGINT
S
Texts
Scanner
F
Files
File
buf
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
k
IF
k
THEN
GetPar
S
end
WHILE
Texts
Pos
S
end
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
k
AppendS
Oberon
User
buf
k
AppendW
Oberon
Password
buf
k
AppendS
S
s
buf
k
IF
S
nextCh
THEN
prefix
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
THEN
buf
k
ORD
AppendS
S
s
buf
k
Texts
Write
W
Texts
WriteString
W
S
s
END
END
Send
SND
k
buf
Texts
WriteString
W
receiving
Texts
Append
Oberon
Log
W
buf
ReceiveHead
T1
IF
head1
typ
THEN
F
Files
New
S
s
IF
F
NIL
THEN
ReceiveData
F
done
IF
done
THEN
Files
Register
F
reply
ELSE
end
END
ELSE
reply
Send
NAK
dmy
END
ELSIF
head1
typ
NAK
THEN
reply
ELSIF
head1
typ
NPR
THEN
reply
end
ELSE
reply
end
END
Texts
Scan
S
END
ELSE
reply
END
END
END
ReceiveFiles
PROCEDURE
SendMsg
VAR
i
INTEGER
ch
CHAR
S
Texts
Scanner
msg
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
i
IF
i
THEN
Texts
Read
S
ch
WHILE
ch
i
DO
msg
i
ORD
ch
INC
i
Texts
Read
S
ch
END
Send
MSG
i
msg
ReceiveHead
T0
IF
head1
typ
ACK
THEN
reply
END
ELSE
reply
END
END
END
SendMsg
PROCEDURE
GetTime
VAR
dt
res
INTEGER
S
Texts
Scanner
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
res
IF
res
THEN
Send
TRQ
dmy
ReceiveHead
T1
IF
head1
typ
TIM
THEN
PickQ
dt
Oberon
SetClock
dt
reply
END
ELSE
reply
END
END
END
GetTime
PROCEDURE
StartServer
BEGIN
protected
TRUE
partner
0X
SCC
Start
TRUE
Oberon
Remove
Server
Oberon
Install
Server
Texts
WriteString
W
Server
started
as
Texts
WriteString
W
Oberon
User
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
StartServer
PROCEDURE
Unprotect
BEGIN
protected
FALSE
END
Unprotect
PROCEDURE
WProtect
BEGIN
protected
TRUE
END
WProtect
PROCEDURE
Reset
BEGIN
SCC
Start
TRUE
END
Reset
PROCEDURE
StopServer
BEGIN
Oberon
Remove
Server
Texts
WriteString
W
Server
stopped
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
StopServer
PROCEDURE
SCCStatus
BEGIN
Texts
WriteString
W
SCC
Available
Texts
WriteInt
W
SCC
Available
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
SCCStatus
BEGIN
Texts
OpenWriter
W
Server
Oberon
NewTask
Serve
END
Net
MODULE
Oberon
JG
NW
IMPORT
SYSTEM
Kernel
Files
Modules
Input
Display
Viewers
Fonts
Texts
CONST
message
ids
consume
track
defocus
neutralize
mark
off
idle
active
task
states
BasicCycle
ESC
1BX
SETSTAR
1AX
TYPE
Painter
PROCEDURE
x
y
INTEGER
Marker
RECORD
Fade
Draw
Painter
END
Cursor
RECORD
marker
Marker
on
BOOLEAN
X
Y
INTEGER
END
InputMsg
RECORD
Display
FrameMsg
id
INTEGER
keys
SET
X
Y
INTEGER
ch
CHAR
fnt
Fonts
Font
col
voff
INTEGER
END
SelectionMsg
RECORD
Display
FrameMsg
time
LONGINT
text
Texts
Text
beg
end
LONGINT
END
ControlMsg
RECORD
Display
FrameMsg
id
X
Y
INTEGER
END
CopyMsg
RECORD
Display
FrameMsg
F
Display
Frame
END
Task
POINTER
TO
TaskDesc
Handler
PROCEDURE
TaskDesc
RECORD
state
nextTime
period
INTEGER
next
Task
handle
Handler
END
VAR
User
ARRAY
OF
CHAR
Password
LONGINT
Arrow
Star
Marker
Mouse
Pointer
Cursor
FocusViewer
Viewers
Viewer
Log
Texts
Text
Par
RECORD
vwr
Viewers
Viewer
frame
Display
Frame
text
Texts
Text
pos
LONGINT
END
CurFnt
Fonts
Font
CurCol
CurOff
INTEGER
NofTasks
INTEGER
CurTask
Task
DW
DH
CL
INTEGER
ActCnt
INTEGER
action
count
for
GC
Mod
Modules
Module
user
identification
PROCEDURE
Code
VAR
s
ARRAY
OF
CHAR
LONGINT
VAR
i
INTEGER
a
b
c
LONGINT
BEGIN
a
b
i
WHILE
s
i
0X
DO
c
b
b
a
a
c
MOD
ORD
s
i
INC
i
END
IF
b
THEN
b
b
END
RETURN
b
a
END
Code
PROCEDURE
SetUser
VAR
user
password
ARRAY
OF
CHAR
BEGIN
User
user
Password
Code
password
END
SetUser
PROCEDURE
Clock
LONGINT
BEGIN
RETURN
Kernel
Clock
END
Clock
PROCEDURE
SetClock
d
LONGINT
BEGIN
Kernel
SetClock
d
END
SetClock
PROCEDURE
Time
LONGINT
BEGIN
RETURN
Kernel
Time
END
Time
cursor
handling
PROCEDURE
FlipArrow
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
arrow
X
Y
Display
invert
END
FlipArrow
PROCEDURE
FlipStar
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
star
X
Y
Display
invert
END
FlipStar
PROCEDURE
OpenCursor
VAR
c
Cursor
BEGIN
c
on
FALSE
c
X
c
Y
END
OpenCursor
PROCEDURE
FadeCursor
VAR
c
Cursor
BEGIN
IF
c
on
THEN
c
marker
Fade
c
X
c
Y
c
on
FALSE
END
END
FadeCursor
PROCEDURE
DrawCursor
VAR
c
Cursor
m
Marker
x
y
INTEGER
BEGIN
IF
c
on
x
c
X
OR
y
c
Y
OR
m
Draw
c
marker
Draw
THEN
c
marker
Fade
c
X
c
Y
c
on
FALSE
END
IF
c
on
THEN
m
Draw
x
y
c
marker
m
c
X
x
c
Y
y
c
on
TRUE
END
END
DrawCursor
PROCEDURE
DrawMouse
m
Marker
x
y
INTEGER
BEGIN
DrawCursor
Mouse
m
x
y
END
DrawMouse
PROCEDURE
DrawMouseArrow
x
y
INTEGER
BEGIN
DrawCursor
Mouse
Arrow
x
y
END
DrawMouseArrow
PROCEDURE
FadeMouse
BEGIN
FadeCursor
Mouse
END
FadeMouse
PROCEDURE
DrawPointer
x
y
INTEGER
BEGIN
DrawCursor
Pointer
Star
x
y
END
DrawPointer
display
management
PROCEDURE
RemoveMarks
X
Y
W
H
INTEGER
BEGIN
IF
Mouse
X
X
Mouse
X
X
W
Mouse
Y
Y
Mouse
Y
Y
H
THEN
FadeCursor
Mouse
END
IF
Pointer
X
X
Pointer
X
X
W
Pointer
Y
Y
Pointer
Y
Y
H
THEN
FadeCursor
Pointer
END
END
RemoveMarks
PROCEDURE
HandleFiller
V
Display
Frame
VAR
M
Display
FrameMsg
BEGIN
CASE
M
OF
InputMsg
IF
M
id
track
THEN
DrawCursor
Mouse
Arrow
M
X
M
Y
END
ControlMsg
IF
M
id
mark
THEN
DrawCursor
Pointer
Star
M
X
M
Y
END
Viewers
ViewerMsg
IF
M
id
Viewers
restore
V
W
V
H
THEN
RemoveMarks
V
X
V
Y
V
W
V
H
Display
ReplConst
Display
black
V
X
V
Y
V
W
V
H
Display
replace
ELSIF
M
id
Viewers
modify
M
Y
V
Y
THEN
RemoveMarks
V
X
M
Y
V
W
V
Y
M
Y
Display
ReplConst
Display
black
V
X
M
Y
V
W
V
Y
M
Y
Display
replace
END
END
END
HandleFiller
PROCEDURE
OpenDisplay
UW
SW
H
INTEGER
VAR
Filler
Viewers
Viewer
BEGIN
Input
SetMouseLimits
Viewers
curW
UW
SW
H
Display
ReplConst
Display
black
Viewers
curW
UW
SW
H
Display
replace
NEW
Filler
Filler
handle
HandleFiller
Viewers
InitTrack
UW
H
Filler
init
user
track
NEW
Filler
Filler
handle
HandleFiller
Viewers
InitTrack
SW
H
Filler
init
system
track
END
OpenDisplay
PROCEDURE
DisplayWidth
X
INTEGER
INTEGER
BEGIN
RETURN
DW
END
DisplayWidth
PROCEDURE
DisplayHeight
X
INTEGER
INTEGER
BEGIN
RETURN
DH
END
DisplayHeight
PROCEDURE
OpenTrack
X
W
INTEGER
VAR
Filler
Viewers
Viewer
BEGIN
NEW
Filler
Filler
handle
HandleFiller
Viewers
OpenTrack
X
W
Filler
END
OpenTrack
PROCEDURE
UserTrack
X
INTEGER
INTEGER
BEGIN
RETURN
X
DIV
DW
DW
END
UserTrack
PROCEDURE
SystemTrack
X
INTEGER
INTEGER
BEGIN
RETURN
X
DIV
DW
DW
DW
DIV
END
SystemTrack
PROCEDURE
UY
X
INTEGER
INTEGER
VAR
h
INTEGER
fil
bot
alt
max
Display
Frame
BEGIN
Viewers
Locate
X
fil
bot
alt
max
IF
fil
H
DH
DIV
THEN
h
DH
ELSE
h
max
Y
max
H
DIV
END
RETURN
h
END
UY
PROCEDURE
AllocateUserViewer
DX
INTEGER
VAR
X
Y
INTEGER
BEGIN
IF
Pointer
on
THEN
X
Pointer
X
Y
Pointer
Y
ELSE
X
DX
DIV
DW
DW
Y
UY
X
END
END
AllocateUserViewer
PROCEDURE
SY
X
INTEGER
INTEGER
VAR
H0
H1
H2
H3
y
INTEGER
fil
bot
alt
max
Display
Frame
BEGIN
H3
DH
DH
DIV
H2
H3
H3
DIV
H1
DH
DIV
H0
DH
DIV
Viewers
Locate
X
DH
fil
bot
alt
max
IF
fil
H
DH
DIV
THEN
y
DH
ELSIF
max
H
DH
H0
THEN
y
max
Y
H3
ELSIF
max
H
H3
H0
THEN
y
max
Y
H2
ELSIF
max
H
H2
H0
THEN
y
max
Y
H1
ELSIF
max
bot
THEN
y
max
Y
max
H
DIV
ELSIF
bot
H
H1
THEN
y
bot
H
DIV
ELSE
y
alt
Y
alt
H
DIV
END
RETURN
y
END
SY
PROCEDURE
AllocateSystemViewer
DX
INTEGER
VAR
X
Y
INTEGER
BEGIN
IF
Pointer
on
THEN
X
Pointer
X
Y
Pointer
Y
ELSE
X
DX
DIV
DW
DW
DW
DIV
Y
SY
X
END
END
AllocateSystemViewer
PROCEDURE
MarkedViewer
Viewers
Viewer
BEGIN
RETURN
Viewers
This
Pointer
X
Pointer
Y
END
MarkedViewer
PROCEDURE
PassFocus
V
Viewers
Viewer
VAR
M
ControlMsg
BEGIN
M
id
defocus
FocusViewer
handle
FocusViewer
M
FocusViewer
V
END
PassFocus
PROCEDURE
OpenLog
T
Texts
Text
BEGIN
Log
T
END
OpenLog
command
interpretation
PROCEDURE
SetPar
F
Display
Frame
T
Texts
Text
pos
LONGINT
BEGIN
Par
vwr
Viewers
This
F
X
F
Y
Par
frame
F
Par
text
T
Par
pos
pos
END
SetPar
PROCEDURE
Call
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
mod
Modules
Module
P
Modules
Command
i
j
INTEGER
ch
CHAR
Mname
Cname
ARRAY
OF
CHAR
BEGIN
i
ch
name
WHILE
ch
ch
0X
DO
Mname
i
ch
INC
i
ch
name
i
END
IF
ch
THEN
Mname
i
0X
INC
i
Modules
Load
Mname
mod
res
Modules
res
IF
Modules
res
THEN
j
ch
name
i
INC
i
WHILE
ch
0X
DO
Cname
j
ch
INC
j
ch
name
i
INC
i
END
Cname
j
0X
P
Modules
ThisCommand
mod
Cname
res
Modules
res
IF
Modules
res
THEN
P
END
END
ELSE
res
END
END
Call
PROCEDURE
GetSelection
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
VAR
M
SelectionMsg
BEGIN
M
time
Viewers
Broadcast
M
time
M
time
IF
time
THEN
text
M
text
beg
M
beg
end
M
end
END
END
GetSelection
PROCEDURE
GC
VAR
mod
Modules
Module
BEGIN
IF
ActCnt
OR
Kernel
allocated
Kernel
heapLim
Kernel
heapOrg
10000H
THEN
mod
Modules
root
LED
21H
WHILE
mod
NIL
DO
IF
mod
name
0X
THEN
Kernel
Mark
mod
ptr
END
mod
mod
next
END
LED
23H
Files
RestoreList
LED
27H
Kernel
Scan
LED
20H
ActCnt
BasicCycle
END
END
GC
PROCEDURE
NewTask
h
Handler
period
INTEGER
Task
VAR
t
Task
BEGIN
NEW
t
t
state
off
t
next
t
t
handle
h
t
period
period
RETURN
t
END
NewTask
PROCEDURE
Install
T
Task
BEGIN
IF
T
state
off
THEN
T
next
CurTask
next
CurTask
next
T
T
state
idle
T
nextTime
INC
NofTasks
END
END
Install
PROCEDURE
Remove
T
Task
VAR
t
Task
BEGIN
IF
T
state
off
THEN
t
T
WHILE
t
next
T
DO
t
t
next
END
t
next
T
next
T
state
off
T
next
NIL
CurTask
t
DEC
NofTasks
END
END
Remove
PROCEDURE
Collect
count
INTEGER
BEGIN
ActCnt
count
END
Collect
PROCEDURE
SetFont
fnt
Fonts
Font
BEGIN
CurFnt
fnt
END
SetFont
PROCEDURE
SetColor
col
INTEGER
BEGIN
CurCol
col
END
SetColor
PROCEDURE
SetOffset
voff
INTEGER
BEGIN
CurOff
voff
END
SetOffset
PROCEDURE
Loop
VAR
V
Viewers
Viewer
M
InputMsg
N
ControlMsg
prevX
prevY
X
Y
t
INTEGER
keys
SET
ch
CHAR
BEGIN
REPEAT
Input
Mouse
keys
X
Y
IF
Input
Available
THEN
Input
Read
ch
IF
ch
ESC
THEN
N
id
neutralize
Viewers
Broadcast
N
FadeCursor
Pointer
LED
ELSIF
ch
SETSTAR
THEN
N
id
mark
N
X
X
N
Y
Y
V
Viewers
This
X
Y
V
handle
V
N
ELSE
M
id
consume
M
ch
ch
M
fnt
CurFnt
M
col
CurCol
M
voff
CurOff
FocusViewer
handle
FocusViewer
M
DEC
ActCnt
END
ELSIF
keys
THEN
M
id
track
M
X
X
M
Y
Y
M
keys
keys
REPEAT
V
Viewers
This
M
X
M
Y
V
handle
V
M
Input
Mouse
M
keys
M
X
M
Y
UNTIL
M
keys
DEC
ActCnt
ELSE
IF
X
prevX
OR
Y
prevY
OR
Mouse
on
THEN
M
id
track
M
X
X
IF
Y
Display
Height
THEN
Y
Display
Height
END
M
Y
Y
M
keys
keys
V
Viewers
This
X
Y
V
handle
V
M
prevX
X
prevY
Y
END
CurTask
CurTask
next
t
Kernel
Time
IF
t
CurTask
nextTime
THEN
CurTask
nextTime
t
CurTask
period
CurTask
state
active
CurTask
handle
CurTask
state
idle
END
END
UNTIL
FALSE
END
Loop
PROCEDURE
Reset
BEGIN
IF
CurTask
state
active
THEN
Remove
CurTask
END
SYSTEM
LDREG
Kernel
stackOrg
reset
stack
pointer
Loop
END
Reset
BEGIN
User
0X
Arrow
Fade
FlipArrow
Arrow
Draw
FlipArrow
Star
Fade
FlipStar
Star
Draw
FlipStar
OpenCursor
Mouse
OpenCursor
Pointer
DW
Display
Width
DH
Display
Height
CL
DW
OpenDisplay
DW
DIV
DW
DIV
DH
FocusViewer
Viewers
This
CurFnt
Fonts
Default
CurCol
Display
white
CurOff
ActCnt
CurTask
NewTask
GC
Install
CurTask
Modules
Load
System
Mod
Mod
NIL
Loop
END
Oberon
MODULE
ORB
NW
in
Oberon
IMPORT
Files
ORS
Definition
of
data
types
Object
and
Type
which
together
form
the
data
structure
called
symbol
table
Contains
procedures
for
creation
of
Objects
and
for
search
NewObj
this
thisimport
thisfield
and
OpenScope
CloseScope
Handling
of
import
and
export
i
e
reading
and
writing
of
symbol
files
is
done
by
procedures
Import
and
Export
This
module
contains
the
list
of
standard
identifiers
with
which
the
symbol
table
universe
and
that
of
the
pseudo
module
SYSTEM
are
initialized
CONST
versionkey
maxTypTab
class
values
Head
Const
Var
Par
Fld
Typ
SProc
SFunc
Mod
form
values
Byte
Bool
Char
Int
Real
Set
Pointer
NilTyp
NoTyp
Proc
String
Array
Record
TYPE
Object
POINTER
TO
ObjDesc
Module
POINTER
TO
ModDesc
Type
POINTER
TO
TypeDesc
ObjDesc
RECORD
class
exno
BYTE
expo
rdo
BOOLEAN
exported
read
only
lev
INTEGER
next
dsc
Object
type
Type
name
ORS
Ident
val
LONGINT
END
ModDesc
RECORD
ObjDesc
orgname
ORS
Ident
END
TypeDesc
RECORD
form
ref
mno
INTEGER
ref
is
only
used
for
import
export
nofpar
INTEGER
for
procedures
extension
level
for
records
len
LONGINT
for
arrays
len
open
array
for
records
adr
of
descriptor
dsc
typobj
Object
base
Type
for
arrays
records
pointers
size
LONGINT
in
bytes
always
multiple
of
except
for
Byte
Bool
and
Char
END
Object
classes
and
the
meaning
of
val
class
val
Var
address
Par
address
Const
value
Fld
offset
Typ
type
descriptor
TD
address
SProc
inline
code
number
SFunc
inline
code
number
Mod
key
Type
forms
and
the
meaning
of
dsc
and
base
form
dsc
base
Pointer
type
of
dereferenced
object
Proc
params
result
type
Array
type
of
elements
Record
fields
extension
VAR
topScope
universe
system
Object
byteType
boolType
charType
Type
intType
realType
setType
nilType
noType
strType
Type
nofmod
Ref
INTEGER
typtab
ARRAY
maxTypTab
OF
Type
PROCEDURE
NewObj
VAR
obj
Object
id
ORS
Ident
class
INTEGER
insert
new
Object
with
name
id
VAR
new
x
Object
BEGIN
x
topScope
WHILE
x
next
NIL
x
next
name
id
DO
x
x
next
END
IF
x
next
NIL
THEN
NEW
new
new
name
id
new
class
class
new
next
NIL
new
rdo
FALSE
new
dsc
NIL
x
next
new
obj
new
ELSE
obj
x
next
ORS
Mark
mult
def
END
END
NewObj
PROCEDURE
thisObj
Object
VAR
s
x
Object
BEGIN
s
topScope
REPEAT
x
s
next
WHILE
x
NIL
x
name
ORS
id
DO
x
x
next
END
s
s
dsc
UNTIL
x
NIL
OR
s
NIL
RETURN
x
END
thisObj
PROCEDURE
thisimport
mod
Object
Object
VAR
obj
Object
BEGIN
IF
mod
rdo
THEN
IF
mod
name
0X
THEN
obj
mod
dsc
WHILE
obj
NIL
obj
name
ORS
id
DO
obj
obj
next
END
ELSE
obj
NIL
END
ELSE
obj
NIL
END
RETURN
obj
END
thisimport
PROCEDURE
thisfield
rec
Type
Object
VAR
fld
Object
BEGIN
fld
rec
dsc
WHILE
fld
NIL
fld
name
ORS
id
DO
fld
fld
next
END
RETURN
fld
END
thisfield
PROCEDURE
OpenScope
VAR
s
Object
BEGIN
NEW
s
s
class
Head
s
dsc
topScope
s
next
NIL
topScope
s
END
OpenScope
PROCEDURE
CloseScope
BEGIN
topScope
topScope
dsc
END
CloseScope
Import
PROCEDURE
MakeFileName
VAR
FName
ORS
Ident
name
ext
ARRAY
OF
CHAR
VAR
i
j
INTEGER
BEGIN
i
j
assume
name
suffix
less
than
characters
WHILE
i
ORS
IdLen
name
i
0X
DO
FName
i
name
i
INC
i
END
REPEAT
FName
i
ext
j
INC
i
INC
j
UNTIL
ext
j
0X
FName
i
0X
END
MakeFileName
PROCEDURE
ThisModule
name
orgname
ORS
Ident
non
BOOLEAN
key
LONGINT
Object
VAR
mod
Module
obj
obj1
Object
BEGIN
obj1
topScope
obj
obj1
next
search
for
module
WHILE
obj
NIL
obj
name
name
DO
obj1
obj
obj
obj1
next
END
IF
obj
NIL
THEN
insert
new
module
NEW
mod
mod
class
Mod
mod
rdo
FALSE
mod
name
name
mod
orgname
orgname
mod
val
key
mod
lev
nofmod
INC
nofmod
mod
type
noType
mod
dsc
NIL
mod
next
NIL
obj1
next
mod
obj
mod
ELSE
module
already
present
IF
non
THEN
ORS
Mark
invalid
import
order
END
END
RETURN
obj
END
ThisModule
PROCEDURE
Read
VAR
R
Files
Rider
VAR
x
INTEGER
VAR
b
BYTE
BEGIN
Files
ReadByte
R
b
IF
b
80H
THEN
x
b
ELSE
x
b
100H
END
END
Read
PROCEDURE
InType
VAR
R
Files
Rider
thismod
Object
VAR
T
Type
VAR
key
LONGINT
ref
class
form
np
readonly
INTEGER
fld
par
obj
mod
Object
t
Type
name
modname
ORS
Ident
BEGIN
Read
R
ref
IF
ref
THEN
T
typtab
ref
already
read
ELSE
NEW
t
T
t
typtab
ref
t
t
mno
thismod
lev
Read
R
form
t
form
form
IF
form
Pointer
THEN
InType
R
thismod
t
base
t
size
ELSIF
form
Array
THEN
InType
R
thismod
t
base
Files
ReadNum
R
t
len
Files
ReadNum
R
t
size
ELSIF
form
Record
THEN
InType
R
thismod
t
base
IF
t
base
form
NoTyp
THEN
t
base
NIL
obj
NIL
ELSE
obj
t
base
dsc
END
Files
ReadNum
R
t
len
TD
adr
exno
Files
ReadNum
R
t
nofpar
ext
level
Files
ReadNum
R
t
size
Read
R
class
WHILE
class
DO
fields
NEW
fld
fld
class
class
Files
ReadString
R
fld
name
IF
fld
name
0X
THEN
fld
expo
TRUE
InType
R
thismod
fld
type
ELSE
fld
expo
FALSE
fld
type
nilType
END
Files
ReadNum
R
fld
val
fld
next
obj
obj
fld
Read
R
class
END
t
dsc
obj
ELSIF
form
Proc
THEN
InType
R
thismod
t
base
obj
NIL
np
Read
R
class
WHILE
class
DO
parameters
NEW
par
par
class
class
Read
R
readonly
par
rdo
readonly
InType
R
thismod
par
type
par
next
obj
obj
par
INC
np
Read
R
class
END
t
dsc
obj
t
nofpar
np
t
size
END
Files
ReadString
R
modname
IF
modname
0X
THEN
re
import
Files
ReadInt
R
key
Files
ReadString
R
name
mod
ThisModule
modname
modname
FALSE
key
obj
mod
dsc
search
type
WHILE
obj
NIL
obj
name
name
DO
obj
obj
next
END
IF
obj
NIL
THEN
T
obj
type
type
object
found
in
object
list
of
mod
ELSE
insert
new
type
object
in
object
list
of
mod
NEW
obj
obj
name
name
obj
class
Typ
obj
next
mod
dsc
mod
dsc
obj
obj
type
t
t
mno
mod
lev
t
typobj
obj
T
t
END
typtab
ref
T
END
END
END
InType
PROCEDURE
Import
VAR
modid
modid1
ORS
Ident
VAR
key
LONGINT
class
k
INTEGER
obj
Object
t
Type
thismod
Object
modname
fname
ORS
Ident
F
Files
File
R
Files
Rider
BEGIN
IF
modid1
SYSTEM
THEN
thismod
ThisModule
modid
modid1
TRUE
key
DEC
nofmod
thismod
lev
thismod
dsc
system
thismod
rdo
TRUE
ELSE
MakeFileName
fname
modid1
smb
F
Files
Old
fname
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadInt
R
key
Files
ReadInt
R
key
Files
ReadString
R
modname
thismod
ThisModule
modid
modid1
TRUE
key
thismod
rdo
TRUE
Read
R
class
version
key
IF
class
versionkey
THEN
ORS
Mark
wrong
version
END
Read
R
class
WHILE
class
DO
NEW
obj
obj
class
class
Files
ReadString
R
obj
name
InType
R
thismod
obj
type
obj
lev
thismod
lev
IF
class
Typ
THEN
t
obj
type
t
typobj
obj
Read
R
k
fixup
bases
of
previously
declared
pointer
types
WHILE
k
DO
typtab
k
base
t
Read
R
k
END
ELSE
IF
class
Const
THEN
IF
obj
type
form
Real
THEN
Files
ReadInt
R
obj
val
ELSE
Files
ReadNum
R
obj
val
END
ELSIF
class
Var
THEN
Files
ReadNum
R
obj
val
obj
rdo
TRUE
END
END
obj
next
thismod
dsc
thismod
dsc
obj
Read
R
class
END
ELSE
ORS
Mark
import
not
available
END
END
END
Import
Export
PROCEDURE
Write
VAR
R
Files
Rider
x
INTEGER
BEGIN
Files
WriteByte
R
x
END
Write
PROCEDURE
OutType
VAR
R
Files
Rider
t
Type
VAR
obj
mod
fld
Object
PROCEDURE
OutPar
VAR
R
Files
Rider
par
Object
n
INTEGER
VAR
cl
INTEGER
BEGIN
IF
n
THEN
OutPar
R
par
next
n
cl
par
class
Write
R
cl
IF
par
rdo
THEN
Write
R
ELSE
Write
R
END
OutType
R
par
type
END
END
OutPar
PROCEDURE
FindHiddenPointers
VAR
R
Files
Rider
typ
Type
offset
LONGINT
VAR
fld
Object
i
n
LONGINT
BEGIN
IF
typ
form
Pointer
OR
typ
form
NilTyp
THEN
Write
R
Fld
Write
R
Files
WriteNum
R
offset
ELSIF
typ
form
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindHiddenPointers
R
fld
type
fld
val
offset
fld
fld
next
END
ELSIF
typ
form
Array
THEN
i
n
typ
len
WHILE
i
n
DO
FindHiddenPointers
R
typ
base
typ
base
size
i
offset
INC
i
END
END
END
FindHiddenPointers
BEGIN
IF
t
ref
THEN
type
was
already
output
Write
R
t
ref
ELSE
obj
t
typobj
IF
obj
NIL
THEN
Write
R
Ref
t
ref
Ref
INC
Ref
ELSE
anonymous
Write
R
END
Write
R
t
form
IF
t
form
Pointer
THEN
OutType
R
t
base
ELSIF
t
form
Array
THEN
OutType
R
t
base
Files
WriteNum
R
t
len
Files
WriteNum
R
t
size
ELSIF
t
form
Record
THEN
IF
t
base
NIL
THEN
OutType
R
t
base
ELSE
OutType
R
noType
END
IF
obj
NIL
THEN
Files
WriteNum
R
obj
exno
ELSE
Write
R
END
Files
WriteNum
R
t
nofpar
Files
WriteNum
R
t
size
fld
t
dsc
WHILE
fld
NIL
DO
fields
IF
fld
expo
THEN
Write
R
Fld
Files
WriteString
R
fld
name
OutType
R
fld
type
Files
WriteNum
R
fld
val
offset
ELSE
FindHiddenPointers
R
fld
type
fld
val
END
fld
fld
next
END
Write
R
ELSIF
t
form
Proc
THEN
OutType
R
t
base
OutPar
R
t
dsc
t
nofpar
Write
R
END
IF
t
mno
obj
NIL
THEN
re
export
output
name
mod
topScope
next
WHILE
mod
NIL
mod
lev
t
mno
DO
mod
mod
next
END
IF
mod
NIL
THEN
Files
WriteString
R
mod
Module
orgname
Files
WriteInt
R
mod
val
Files
WriteString
R
obj
name
ELSE
ORS
Mark
re
export
not
found
Write
R
END
ELSE
Write
R
END
END
END
OutType
PROCEDURE
Export
VAR
modid
ORS
Ident
VAR
newSF
BOOLEAN
VAR
key
LONGINT
VAR
x
sum
oldkey
LONGINT
obj
obj0
Object
filename
ORS
Ident
F
F1
Files
File
R
R1
Files
Rider
BEGIN
Ref
Record
MakeFileName
filename
modid
smb
F
Files
New
filename
Files
Set
R
F
Files
WriteInt
R
placeholder
Files
WriteInt
R
placeholder
for
key
to
be
inserted
at
the
end
Files
WriteString
R
modid
Write
R
versionkey
obj
topScope
next
WHILE
obj
NIL
DO
IF
obj
expo
THEN
Write
R
obj
class
Files
WriteString
R
obj
name
OutType
R
obj
type
IF
obj
class
Typ
THEN
IF
obj
type
form
Record
THEN
obj0
topScope
next
check
whether
this
is
base
of
previously
declared
pointer
types
WHILE
obj0
obj
DO
IF
obj0
type
form
Pointer
obj0
type
base
obj
type
obj0
type
ref
THEN
Write
R
obj0
type
ref
END
obj0
obj0
next
END
END
Write
R
ELSIF
obj
class
Const
THEN
IF
obj
type
form
Proc
THEN
Files
WriteNum
R
obj
exno
ELSIF
obj
type
form
Real
THEN
Files
WriteInt
R
obj
val
ELSE
Files
WriteNum
R
obj
val
END
ELSIF
obj
class
Var
THEN
Files
WriteNum
R
obj
exno
END
END
obj
obj
next
END
REPEAT
Write
R
UNTIL
Files
Length
F
MOD
FOR
Ref
Record
TO
maxTypTab
DO
typtab
Ref
NIL
END
Files
Set
R
F
sum
Files
ReadInt
R
x
compute
key
checksum
WHILE
R
eof
DO
sum
sum
x
Files
ReadInt
R
x
END
F1
Files
Old
filename
sum
is
new
key
IF
F1
NIL
THEN
Files
Set
R1
F1
Files
ReadInt
R1
oldkey
ELSE
oldkey
sum
END
IF
sum
oldkey
THEN
IF
newSF
OR
F1
NIL
THEN
key
sum
newSF
TRUE
Files
Set
R
F
Files
WriteInt
R
sum
Files
Register
F
insert
checksum
ELSE
ORS
Mark
new
symbol
file
inhibited
END
ELSE
newSF
FALSE
key
sum
END
END
Export
PROCEDURE
Init
BEGIN
topScope
universe
nofmod
END
Init
PROCEDURE
type
ref
form
INTEGER
size
LONGINT
Type
VAR
tp
Type
BEGIN
NEW
tp
tp
form
form
tp
size
size
tp
ref
ref
tp
base
NIL
typtab
ref
tp
RETURN
tp
END
type
PROCEDURE
enter
name
ARRAY
OF
CHAR
cl
INTEGER
type
Type
n
LONGINT
VAR
obj
Object
BEGIN
NEW
obj
obj
name
name
obj
class
cl
obj
type
type
obj
val
n
obj
dsc
NIL
IF
cl
Typ
THEN
type
typobj
obj
END
obj
next
system
system
obj
END
enter
BEGIN
byteType
type
Byte
Int
boolType
type
Bool
Bool
charType
type
Char
Char
intType
type
Int
Int
realType
type
Real
Real
setType
type
Set
Set
nilType
type
NilTyp
NilTyp
noType
type
NoTyp
NoTyp
strType
type
String
String
initialize
universe
with
data
types
and
in
line
procedures
LONGINT
is
synonym
to
INTEGER
LONGREAL
to
REAL
LED
ADC
SBC
LDPSR
LDREG
REG
COND
are
not
in
language
definition
system
NIL
n
procno
nofpar
enter
UML
SFunc
intType
functions
enter
SBC
SFunc
intType
enter
ADC
SFunc
intType
enter
ROR
SFunc
intType
enter
ASR
SFunc
intType
enter
LSL
SFunc
intType
enter
LEN
SFunc
intType
enter
CHR
SFunc
charType
enter
ORD
SFunc
intType
enter
FLT
SFunc
realType
enter
FLOOR
SFunc
intType
enter
ODD
SFunc
boolType
enter
ABS
SFunc
intType
enter
LED
SProc
noType
procedures
enter
UNPK
SProc
noType
enter
PACK
SProc
noType
enter
NEW
SProc
noType
enter
ASSERT
SProc
noType
enter
EXCL
SProc
noType
enter
INCL
SProc
noType
enter
DEC
SProc
noType
enter
INC
SProc
noType
enter
SET
Typ
setType
types
enter
BOOLEAN
Typ
boolType
enter
BYTE
Typ
byteType
enter
CHAR
Typ
charType
enter
LONGREAL
Typ
realType
enter
REAL
Typ
realType
enter
LONGINT
Typ
intType
enter
INTEGER
Typ
intType
topScope
NIL
OpenScope
topScope
next
system
universe
topScope
system
NIL
initialize
unsafe
pseudo
module
SYSTEM
enter
H
SFunc
intType
functions
enter
COND
SFunc
boolType
enter
SIZE
SFunc
intType
enter
ADR
SFunc
intType
enter
VAL
SFunc
intType
enter
REG
SFunc
intType
enter
BIT
SFunc
boolType
enter
LDREG
SProc
noType
procedures
enter
LDPSR
SProc
noType
enter
COPY
SProc
noType
enter
PUT
SProc
noType
enter
GET
SProc
noType
END
ORB
MODULE
ORG
N
Wirth
Oberon
compiler
code
generator
for
RISC
IMPORT
SYSTEM
Files
ORS
ORB
Code
generator
for
Oberon
compiler
for
RISC
processor
Procedural
interface
to
Parser
OSAP
result
in
array
code
Procedure
Close
writes
code
files
CONST
WordSize
StkOrg0
VarOrg0
for
RISC
only
MT
SP
LNK
dedicated
registers
maxCode
maxStrx
maxTD
C24
1000000H
Reg
RegI
Cond
internal
item
modes
frequently
used
opcodes
U
2000H
V
1000H
Mov
Lsl
Asr
Ror
And
Ann
Ior
Xor
Add
Sub
Cmp
Mul
Div
Fad
Fsb
Fml
Fdv
Ldr
Str
BR
BLR
BC
BL
MI
PL
EQ
NE
LT
GE
LE
GT
TYPE
Item
RECORD
mode
INTEGER
type
ORB
Type
a
b
r
LONGINT
rdo
BOOLEAN
read
only
END
Item
forms
and
meaning
of
fields
mode
r
a
b
Const
value
proc
adr
immediate
value
Var
base
off
direct
adr
Par
off0
off1
indirect
adr
Reg
regno
RegI
regno
off
Cond
cond
Fchain
Tchain
VAR
pc
varsize
LONGINT
program
counter
data
index
tdx
strx
LONGINT
entry
LONGINT
main
entry
point
RH
LONGINT
available
registers
R
R
H
frame
LONGINT
frame
offset
changed
in
SaveRegs
and
RestoreRegs
fixorgP
fixorgD
fixorgT
LONGINT
origins
of
lists
of
locations
to
be
fixed
up
by
loader
check
BOOLEAN
emit
run
time
checks
version
INTEGER
RISC
RISC
relmap
ARRAY
OF
INTEGER
condition
codes
for
relations
code
ARRAY
maxCode
OF
LONGINT
data
ARRAY
maxTD
OF
LONGINT
type
descriptors
str
ARRAY
maxStrx
OF
CHAR
instruction
assemblers
according
to
formats
PROCEDURE
Put0
op
a
b
c
LONGINT
BEGIN
emit
format
instruction
code
pc
a
10H
b
10H
op
10000H
c
INC
pc
END
Put0
PROCEDURE
Put1
op
a
b
im
LONGINT
BEGIN
emit
format
instruction
10000H
im
10000H
IF
im
THEN
INC
op
V
END
code
pc
a
40H
10H
b
10H
op
10000H
im
MOD
10000H
INC
pc
END
Put1
PROCEDURE
Put1a
op
a
b
im
LONGINT
BEGIN
same
as
Put1
but
with
range
test
10000H
im
10000H
IF
im
10000H
im
0FFFFH
THEN
Put1
op
a
b
im
ELSE
Put1
Mov
U
RH
im
DIV
10000H
IF
im
MOD
10000H
THEN
Put1
Ior
RH
RH
im
MOD
10000H
END
Put0
op
a
b
RH
END
END
Put1a
PROCEDURE
Put2
op
a
b
off
LONGINT
BEGIN
emit
load
store
instruction
code
pc
op
10H
a
10H
b
100000H
off
MOD
100000H
INC
pc
END
Put2
PROCEDURE
Put3
op
cond
off
LONGINT
BEGIN
emit
branch
instruction
code
pc
op
10H
cond
1000000H
off
MOD
1000000H
INC
pc
END
Put3
PROCEDURE
incR
BEGIN
IF
RH
MT
THEN
INC
RH
ELSE
ORS
Mark
register
stack
overflow
END
END
incR
PROCEDURE
CheckRegs
BEGIN
IF
RH
THEN
ORS
Mark
Reg
Stack
RH
END
IF
pc
maxCode
THEN
ORS
Mark
program
too
long
END
IF
frame
THEN
ORS
Mark
frame
error
frame
END
END
CheckRegs
PROCEDURE
SetCC
VAR
x
Item
n
LONGINT
BEGIN
x
mode
Cond
x
a
x
b
x
r
n
END
SetCC
PROCEDURE
Trap
cond
num
LONGINT
BEGIN
Put3
BLR
cond
ORS
Pos
100H
num
10H
MT
END
Trap
handling
of
forward
reference
fixups
of
branch
addresses
and
constant
tables
PROCEDURE
negated
cond
LONGINT
LONGINT
BEGIN
IF
cond
THEN
cond
cond
ELSE
cond
cond
END
RETURN
cond
END
negated
PROCEDURE
fix
at
with
LONGINT
BEGIN
code
at
code
at
DIV
C24
C24
with
MOD
C24
END
fix
PROCEDURE
FixOne
at
LONGINT
BEGIN
fix
at
pc
at
END
FixOne
PROCEDURE
FixLink
L
LONGINT
VAR
L1
LONGINT
BEGIN
WHILE
L
DO
L1
code
L
MOD
40000H
fix
L
pc
L
L
L1
END
END
FixLink
PROCEDURE
FixLinkWith
L0
dst
LONGINT
VAR
L1
LONGINT
BEGIN
WHILE
L0
DO
L1
code
L0
MOD
C24
code
L0
code
L0
DIV
C24
C24
dst
L0
MOD
C24
L0
L1
END
END
FixLinkWith
PROCEDURE
merged
L0
L1
LONGINT
LONGINT
VAR
L2
L3
LONGINT
BEGIN
IF
L0
THEN
L3
L0
REPEAT
L2
L3
L3
code
L2
MOD
40000H
UNTIL
L3
code
L2
code
L2
L1
L1
L0
END
RETURN
L1
END
merged
loading
of
operands
and
addresses
into
registers
PROCEDURE
GetSB
base
LONGINT
BEGIN
IF
version
THEN
Put1
Mov
RH
VarOrg0
ELSE
Put2
Ldr
RH
base
pc
fixorgD
fixorgD
pc
END
END
GetSB
PROCEDURE
NilCheck
BEGIN
IF
check
THEN
Trap
EQ
END
END
NilCheck
PROCEDURE
load
VAR
x
Item
VAR
op
LONGINT
BEGIN
IF
x
type
size
THEN
op
Ldr
ELSE
op
Ldr
END
IF
x
mode
Reg
THEN
IF
x
mode
ORB
Const
THEN
IF
x
type
form
ORB
Proc
THEN
IF
x
r
THEN
ORS
Mark
not
allowed
ELSIF
x
r
THEN
Put3
BL
Put1a
Sub
RH
LNK
pc
x
a
ELSE
GetSB
x
r
Put1
Add
RH
RH
x
a
100H
mark
as
progbase
relative
END
ELSIF
x
a
0FFFFH
x
a
10000H
THEN
Put1
Mov
RH
x
a
ELSE
Put1
Mov
U
RH
x
a
DIV
10000H
MOD
10000H
IF
x
a
MOD
10000H
THEN
Put1
Ior
RH
RH
x
a
MOD
10000H
END
END
x
r
RH
incR
ELSIF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
op
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put2
op
RH
RH
x
a
END
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
op
RH
RH
x
b
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
Put2
op
x
r
x
r
x
a
ELSIF
x
mode
Cond
THEN
Put3
BC
negated
x
r
FixLink
x
b
Put1
Mov
RH
Put3
BC
FixLink
x
a
Put1
Mov
RH
x
r
RH
incR
END
x
mode
Reg
END
END
load
PROCEDURE
loadAdr
VAR
x
Item
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put1a
Add
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put1a
Add
RH
RH
x
a
END
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
IF
x
b
THEN
Put1a
Add
RH
RH
x
b
END
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
IF
x
a
THEN
Put1a
Add
x
r
x
r
x
a
END
ELSE
ORS
Mark
address
error
END
x
mode
Reg
END
loadAdr
PROCEDURE
loadCond
VAR
x
Item
BEGIN
IF
x
type
form
ORB
Bool
THEN
IF
x
mode
ORB
Const
THEN
x
r
x
a
ELSE
load
x
IF
code
pc
DIV
40000000H
THEN
Put1
Cmp
x
r
x
r
END
x
r
NE
DEC
RH
END
x
mode
Cond
x
a
x
b
ELSE
ORS
Mark
not
Boolean
END
END
loadCond
PROCEDURE
loadTypTagAdr
T
ORB
Type
VAR
x
Item
BEGIN
x
mode
ORB
Var
x
a
T
len
x
r
T
mno
loadAdr
x
END
loadTypTagAdr
PROCEDURE
loadStringAdr
VAR
x
Item
BEGIN
GetSB
Put1a
Add
RH
RH
varsize
x
a
x
mode
Reg
x
r
RH
incR
END
loadStringAdr
Items
Conversion
from
constants
or
from
Objects
on
the
Heap
to
Items
on
the
Stack
PROCEDURE
MakeConstItem
VAR
x
Item
typ
ORB
Type
val
LONGINT
BEGIN
x
mode
ORB
Const
x
type
typ
x
a
val
END
MakeConstItem
PROCEDURE
MakeRealItem
VAR
x
Item
val
REAL
BEGIN
x
mode
ORB
Const
x
type
ORB
realType
x
a
SYSTEM
VAL
LONGINT
val
END
MakeRealItem
PROCEDURE
MakeStringItem
VAR
x
Item
len
LONGINT
copies
string
from
ORS
buffer
to
ORG
string
array
VAR
i
LONGINT
BEGIN
x
mode
ORB
Const
x
type
ORB
strType
x
a
strx
x
b
len
i
IF
strx
len
maxStrx
THEN
WHILE
len
DO
str
strx
ORS
str
i
INC
strx
INC
i
DEC
len
END
WHILE
strx
MOD
DO
str
strx
0X
INC
strx
END
ELSE
ORS
Mark
too
many
strings
END
END
MakeStringItem
PROCEDURE
MakeItem
VAR
x
Item
y
ORB
Object
curlev
LONGINT
BEGIN
x
mode
y
class
x
type
y
type
x
a
y
val
x
rdo
y
rdo
IF
y
class
ORB
Par
THEN
x
b
ELSIF
y
class
ORB
Const
y
type
form
ORB
String
THEN
x
b
y
lev
len
ELSE
x
r
y
lev
END
IF
y
lev
y
lev
curlev
y
class
ORB
Const
THEN
ORS
Mark
not
accessible
END
END
MakeItem
Code
generation
for
Selectors
Variables
Constants
PROCEDURE
Field
VAR
x
Item
y
ORB
Object
x
x
y
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
x
a
x
a
y
val
ELSE
loadAdr
x
x
mode
RegI
x
a
y
val
END
ELSIF
x
mode
RegI
THEN
x
a
x
a
y
val
ELSIF
x
mode
ORB
Par
THEN
x
b
x
b
y
val
END
END
Field
PROCEDURE
Index
VAR
x
y
Item
x
x
y
VAR
s
lim
LONGINT
BEGIN
s
x
type
base
size
lim
x
type
len
IF
y
mode
ORB
Const
lim
THEN
IF
y
a
OR
y
a
lim
THEN
ORS
Mark
bad
index
END
IF
x
mode
IN
ORB
Var
RegI
THEN
x
a
y
a
s
x
a
ELSIF
x
mode
ORB
Par
THEN
x
b
y
a
s
x
b
END
ELSE
load
y
IF
check
THEN
check
array
bounds
IF
lim
THEN
Put1a
Cmp
RH
y
r
lim
ELSE
open
array
IF
x
mode
IN
ORB
Var
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put0
Cmp
RH
y
r
RH
ELSE
ORS
Mark
error
in
Index
END
END
Trap
BCC
END
IF
s
THEN
Put1
Lsl
y
r
y
r
ELSIF
s
THEN
Put1a
Mul
y
r
y
r
s
END
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
Put0
Add
y
r
SP
y
r
INC
x
a
frame
ELSE
GetSB
x
r
IF
x
r
THEN
Put0
Add
y
r
RH
y
r
ELSE
Put1a
Add
RH
RH
x
a
Put0
Add
y
r
RH
y
r
x
a
END
END
x
r
y
r
x
mode
RegI
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put0
Add
y
r
RH
y
r
x
mode
RegI
x
r
y
r
x
a
x
b
ELSIF
x
mode
RegI
THEN
Put0
Add
x
r
x
r
y
r
DEC
RH
END
END
END
Index
PROCEDURE
DeRef
VAR
x
Item
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
Ldr
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put2
Ldr
RH
RH
x
a
END
NilCheck
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
Ldr
RH
RH
x
b
NilCheck
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
Put2
Ldr
x
r
x
r
x
a
NilCheck
ELSIF
x
mode
Reg
THEN
ORS
Mark
bad
mode
in
DeRef
END
x
mode
RegI
x
a
x
b
END
DeRef
PROCEDURE
Q
T
ORB
Type
VAR
dcw
LONGINT
BEGIN
one
entry
of
type
descriptor
extension
table
IF
T
base
NIL
THEN
Q
T
base
dcw
data
dcw
T
mno
1000H
T
len
1000H
dcw
fixorgT
fixorgT
dcw
INC
dcw
END
END
Q
PROCEDURE
FindPtrFlds
typ
ORB
Type
off
LONGINT
VAR
dcw
LONGINT
VAR
fld
ORB
Object
i
s
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
data
dcw
off
INC
dcw
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindPtrFlds
fld
type
fld
val
off
dcw
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
s
typ
base
size
FOR
i
TO
typ
len
DO
FindPtrFlds
typ
base
i
s
off
dcw
END
END
END
FindPtrFlds
PROCEDURE
BuildTD
T
ORB
Type
VAR
dc
LONGINT
VAR
dcw
k
s
LONGINT
dcw
word
address
BEGIN
dcw
dc
DIV
s
T
size
convert
size
for
heap
allocation
IF
s
THEN
s
ELSIF
s
THEN
s
ELSIF
s
THEN
s
ELSE
s
s
DIV
END
T
len
dc
data
dcw
s
INC
dcw
len
used
as
address
k
T
nofpar
extension
level
IF
k
THEN
ORS
Mark
ext
level
too
large
ELSE
Q
T
dcw
WHILE
k
DO
data
dcw
INC
dcw
INC
k
END
END
FindPtrFlds
T
dcw
data
dcw
INC
dcw
tdx
dcw
dc
dcw
IF
tdx
maxTD
THEN
ORS
Mark
too
many
record
types
tdx
END
END
BuildTD
PROCEDURE
TypeTest
VAR
x
Item
T
ORB
Type
varpar
isguard
BOOLEAN
VAR
pc0
LONGINT
BEGIN
fetch
tag
into
RH
IF
varpar
THEN
Put2
Ldr
RH
SP
x
a
frame
ELSE
load
x
pc0
pc
Put3
BC
EQ
NIL
belongs
to
every
pointer
type
Put2
Ldr
RH
x
r
END
Put2
Ldr
RH
RH
T
nofpar
incR
loadTypTagAdr
T
tag
of
T
Put0
Cmp
RH
RH
RH
DEC
RH
IF
varpar
THEN
fix
pc0
pc
pc0
END
IF
isguard
THEN
IF
check
THEN
Trap
NE
END
ELSE
SetCC
x
EQ
IF
varpar
THEN
DEC
RH
END
END
END
TypeTest
Code
generation
for
Boolean
operators
PROCEDURE
Not
VAR
x
Item
x
x
VAR
t
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
x
r
negated
x
r
t
x
a
x
a
x
b
x
b
t
END
Not
PROCEDURE
And1
VAR
x
Item
x
x
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
x
a
x
a
pc
FixLink
x
b
x
b
END
And1
PROCEDURE
And2
VAR
x
y
Item
BEGIN
IF
y
mode
Cond
THEN
loadCond
y
END
x
a
merged
y
a
x
a
x
b
y
b
x
r
y
r
END
And2
PROCEDURE
Or1
VAR
x
Item
x
x
OR
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
x
r
x
b
x
b
pc
FixLink
x
a
x
a
END
Or1
PROCEDURE
Or2
VAR
x
y
Item
BEGIN
IF
y
mode
Cond
THEN
loadCond
y
END
x
a
y
a
x
b
merged
y
b
x
b
x
r
y
r
END
Or2
Code
generation
for
arithmetic
operators
PROCEDURE
Neg
VAR
x
Item
x
x
BEGIN
IF
x
type
form
ORB
Int
THEN
IF
x
mode
ORB
Const
THEN
x
a
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Sub
x
r
RH
x
r
END
ELSIF
x
type
form
ORB
Real
THEN
IF
x
mode
ORB
Const
THEN
x
a
x
a
7FFFFFFFH
ELSE
load
x
Put1
Mov
RH
Put0
Fsb
x
r
RH
x
r
END
ELSE
form
Set
IF
x
mode
ORB
Const
THEN
x
a
x
a
ELSE
load
x
Put1
Xor
x
r
x
r
END
END
END
Neg
PROCEDURE
AddOp
op
LONGINT
VAR
x
y
Item
x
x
y
BEGIN
IF
op
ORS
plus
THEN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
y
a
THEN
Put1a
Add
x
r
x
r
y
a
END
ELSE
load
x
load
y
Put0
Add
RH
x
r
y
r
DEC
RH
x
r
RH
END
ELSE
op
ORS
minus
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
y
a
THEN
Put1a
Sub
x
r
x
r
y
a
END
ELSE
load
x
load
y
Put0
Sub
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
END
AddOp
PROCEDURE
log2
m
LONGINT
VAR
e
LONGINT
LONGINT
BEGIN
e
WHILE
ODD
m
DO
m
m
DIV
INC
e
END
RETURN
m
END
log2
PROCEDURE
MulOp
VAR
x
y
Item
x
x
y
VAR
e
LONGINT
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
Put1
Lsl
x
r
x
r
e
ELSIF
y
mode
ORB
Const
THEN
load
x
Put1a
Mul
x
r
x
r
y
a
ELSIF
x
mode
ORB
Const
x
a
log2
x
a
e
THEN
load
y
Put1
Lsl
y
r
y
r
e
x
mode
Reg
x
r
y
r
ELSIF
x
mode
ORB
Const
THEN
load
y
Put1a
Mul
y
r
y
r
x
a
x
mode
Reg
x
r
y
r
ELSE
load
x
load
y
Put0
Mul
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
MulOp
PROCEDURE
DivOp
op
LONGINT
VAR
x
y
Item
x
x
op
y
VAR
e
LONGINT
BEGIN
IF
op
ORS
div
THEN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
y
a
THEN
x
a
x
a
DIV
y
a
ELSE
ORS
Mark
bad
divisor
END
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
Put1
Asr
x
r
x
r
e
ELSIF
y
mode
ORB
Const
THEN
IF
y
a
THEN
load
x
Put1a
Div
x
r
x
r
y
a
ELSE
ORS
Mark
bad
divisor
END
ELSE
load
y
IF
check
THEN
Trap
LE
END
load
x
Put0
Div
RH
x
r
y
r
DEC
RH
x
r
RH
END
ELSE
op
ORS
mod
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
y
a
THEN
x
a
x
a
MOD
y
a
ELSE
ORS
Mark
bad
modulus
END
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
IF
e
THEN
Put1
And
x
r
x
r
y
a
ELSE
Put1
Lsl
x
r
x
r
e
Put1
Ror
x
r
x
r
e
END
ELSIF
y
mode
ORB
Const
THEN
IF
y
a
THEN
load
x
Put1a
Div
x
r
x
r
y
a
Put0
Mov
U
x
r
ELSE
ORS
Mark
bad
modulus
END
ELSE
load
y
IF
check
THEN
Trap
LE
END
load
x
Put0
Div
RH
x
r
y
r
Put0
Mov
U
RH
DEC
RH
x
r
RH
END
END
END
DivOp
Code
generation
for
REAL
operators
PROCEDURE
RealOp
op
INTEGER
VAR
x
y
Item
x
x
op
y
BEGIN
load
x
load
y
IF
op
ORS
plus
THEN
Put0
Fad
RH
x
r
y
r
ELSIF
op
ORS
minus
THEN
Put0
Fsb
RH
x
r
y
r
ELSIF
op
ORS
times
THEN
Put0
Fml
RH
x
r
y
r
ELSIF
op
ORS
rdiv
THEN
Put0
Fdv
RH
x
r
y
r
END
DEC
RH
x
r
RH
END
RealOp
Code
generation
for
set
operators
PROCEDURE
Singleton
VAR
x
Item
x
x
BEGIN
IF
x
mode
ORB
Const
THEN
x
a
LSL
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Lsl
x
r
RH
x
r
END
END
Singleton
PROCEDURE
Set
VAR
x
y
Item
x
x
y
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
x
a
y
a
THEN
x
a
LSL
y
a
LSL
x
a
ELSE
x
a
END
ELSE
IF
x
mode
ORB
Const
x
a
THEN
x
a
LSL
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Lsl
x
r
RH
x
r
END
IF
y
mode
ORB
Const
y
a
THEN
Put1
Mov
RH
LSL
y
a
y
mode
Reg
y
r
RH
incR
ELSE
load
y
Put1
Mov
RH
Put0
Lsl
y
r
RH
y
r
END
IF
x
mode
ORB
Const
THEN
IF
x
a
THEN
Put1
Xor
y
r
y
r
Put1a
And
RH
y
r
x
a
END
x
mode
Reg
x
r
RH
ELSE
DEC
RH
Put0
Ann
RH
x
r
y
r
END
END
END
Set
PROCEDURE
In
VAR
x
y
Item
x
x
IN
y
BEGIN
load
y
IF
x
mode
ORB
Const
THEN
Put1
Ror
y
r
y
r
x
a
MOD
20H
DEC
RH
ELSE
load
x
Put1
Add
x
r
x
r
Put0
Ror
y
r
y
r
x
r
DEC
RH
END
SetCC
x
MI
END
In
PROCEDURE
SetOp
op
LONGINT
VAR
x
y
Item
x
x
op
y
VAR
xset
yset
SET
x
type
form
Set
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
xset
SYSTEM
VAL
SET
x
a
yset
SYSTEM
VAL
SET
y
a
IF
op
ORS
plus
THEN
xset
xset
yset
ELSIF
op
ORS
minus
THEN
xset
xset
yset
ELSIF
op
ORS
times
THEN
xset
xset
yset
ELSIF
op
ORS
rdiv
THEN
xset
xset
yset
END
x
a
SYSTEM
VAL
LONGINT
xset
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
op
ORS
plus
THEN
Put1a
Ior
x
r
x
r
y
a
ELSIF
op
ORS
minus
THEN
Put1a
Ann
x
r
x
r
y
a
ELSIF
op
ORS
times
THEN
Put1a
And
x
r
x
r
y
a
ELSIF
op
ORS
rdiv
THEN
Put1a
Xor
x
r
x
r
y
a
END
ELSE
load
x
load
y
IF
op
ORS
plus
THEN
Put0
Ior
RH
x
r
y
r
ELSIF
op
ORS
minus
THEN
Put0
Ann
RH
x
r
y
r
ELSIF
op
ORS
times
THEN
Put0
And
RH
x
r
y
r
ELSIF
op
ORS
rdiv
THEN
Put0
Xor
RH
x
r
y
r
END
DEC
RH
x
r
RH
END
END
SetOp
Code
generation
for
relations
PROCEDURE
IntRelation
op
INTEGER
VAR
x
y
Item
x
x
y
BEGIN
IF
y
mode
ORB
Const
y
type
form
ORB
Proc
THEN
load
x
IF
y
a
OR
op
IN
ORS
eql
ORS
neq
OR
code
pc
DIV
40000000H
THEN
Put1a
Cmp
x
r
x
r
y
a
END
DEC
RH
ELSE
IF
x
mode
Cond
OR
y
mode
Cond
THEN
ORS
Mark
not
implemented
END
load
x
load
y
Put0
Cmp
x
r
x
r
y
r
DEC
RH
END
SetCC
x
relmap
op
ORS
eql
END
IntRelation
PROCEDURE
RealRelation
op
INTEGER
VAR
x
y
Item
x
x
y
BEGIN
load
x
IF
y
mode
ORB
Const
y
a
THEN
DEC
RH
ELSE
load
y
Put0
Fsb
x
r
x
r
y
r
DEC
RH
END
SetCC
x
relmap
op
ORS
eql
END
RealRelation
PROCEDURE
StringRelation
op
INTEGER
VAR
x
y
Item
x
x
y
x
y
are
char
arrays
or
strings
BEGIN
IF
x
type
form
ORB
String
THEN
loadStringAdr
x
ELSE
loadAdr
x
END
IF
y
type
form
ORB
String
THEN
loadStringAdr
y
ELSE
loadAdr
y
END
Put2
Ldr
RH
x
r
Put1
Add
x
r
x
r
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put0
Cmp
RH
RH
RH
Put3
BC
NE
Put1
Cmp
RH
RH
Put3
BC
NE
DEC
RH
SetCC
x
relmap
op
ORS
eql
END
StringRelation
Code
generation
of
Assignments
PROCEDURE
StrToChar
VAR
x
Item
BEGIN
x
type
ORB
charType
DEC
strx
x
a
ORD
str
x
a
END
StrToChar
PROCEDURE
Store
VAR
x
y
Item
x
y
VAR
op
LONGINT
BEGIN
load
y
IF
x
type
size
THEN
op
Str
ELSE
op
Str
END
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
op
y
r
SP
x
a
frame
ELSE
GetSB
x
r
Put2
op
y
r
RH
x
a
END
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
op
y
r
RH
x
b
ELSIF
x
mode
RegI
THEN
Put2
op
y
r
x
r
x
a
DEC
RH
ELSE
ORS
Mark
bad
mode
in
Store
END
DEC
RH
END
Store
PROCEDURE
StoreStruct
VAR
x
y
Item
x
y
frame
VAR
s
pc0
LONGINT
BEGIN
IF
y
type
size
THEN
loadAdr
x
loadAdr
y
IF
x
type
form
ORB
Array
x
type
len
THEN
IF
y
type
len
THEN
IF
x
type
size
y
type
size
THEN
Put1a
Mov
RH
y
type
size
DIV
ELSE
ORS
Mark
different
length
size
not
implemented
END
ELSE
y
open
array
Put2
Ldr
RH
SP
y
a
s
y
type
base
size
element
size
pc0
pc
Put3
BC
EQ
IF
s
THEN
Put1
Add
RH
RH
Put1
Asr
RH
RH
ELSIF
s
THEN
Put1a
Mul
RH
RH
s
DIV
END
IF
check
THEN
Put1a
Mov
RH
x
type
size
DIV
Put0
Cmp
RH
RH
RH
Trap
GT
END
fix
pc0
pc
pc0
END
ELSIF
x
type
form
ORB
Record
THEN
Put1a
Mov
RH
x
type
size
DIV
ELSE
ORS
Mark
inadmissible
assignment
END
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put2
Str
RH
x
r
Put1
Add
x
r
x
r
Put1
Sub
RH
RH
Put3
BC
NE
END
RH
END
StoreStruct
PROCEDURE
CopyString
VAR
x
y
Item
x
y
VAR
len
LONGINT
BEGIN
loadAdr
x
len
x
type
len
IF
len
THEN
IF
len
y
b
THEN
ORS
Mark
string
too
long
END
ELSIF
check
THEN
Put2
Ldr
RH
SP
x
a
open
array
len
frame
Put1
Cmp
RH
RH
y
b
Trap
LT
END
loadStringAdr
y
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put2
Str
RH
x
r
Put1
Add
x
r
x
r
Put1
Asr
RH
RH
Put3
BC
NE
RH
END
CopyString
Code
generation
for
parameters
PROCEDURE
OpenArrayParam
VAR
x
Item
BEGIN
loadAdr
x
IF
x
type
len
THEN
Put1a
Mov
RH
x
type
len
ELSE
Put2
Ldr
RH
SP
x
a
frame
END
incR
END
OpenArrayParam
PROCEDURE
VarParam
VAR
x
Item
ftype
ORB
Type
VAR
xmd
INTEGER
BEGIN
xmd
x
mode
loadAdr
x
IF
ftype
form
ORB
Array
ftype
len
THEN
open
array
IF
x
type
len
THEN
Put1a
Mov
RH
x
type
len
ELSE
Put2
Ldr
RH
SP
x
a
frame
END
incR
ELSIF
ftype
form
ORB
Record
THEN
IF
xmd
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
incR
ELSE
loadTypTagAdr
x
type
END
END
END
VarParam
PROCEDURE
ValueParam
VAR
x
Item
BEGIN
load
x
END
ValueParam
PROCEDURE
StringParam
VAR
x
Item
BEGIN
loadStringAdr
x
Put1
Mov
RH
x
b
incR
len
END
StringParam
For
Statements
PROCEDURE
For0
VAR
x
y
Item
BEGIN
load
y
END
For0
PROCEDURE
For1
VAR
x
y
z
w
Item
VAR
L
LONGINT
BEGIN
IF
z
mode
ORB
Const
THEN
Put1a
Cmp
RH
y
r
z
a
ELSE
load
z
Put0
Cmp
RH
y
r
z
r
DEC
RH
END
L
pc
IF
w
a
THEN
Put3
BC
GT
ELSIF
w
a
THEN
Put3
BC
LT
ELSE
ORS
Mark
zero
increment
Put3
BC
MI
END
Store
x
y
END
For1
PROCEDURE
For2
VAR
x
y
w
Item
BEGIN
load
x
DEC
RH
Put1a
Add
x
r
x
r
w
a
END
For2
Branches
procedure
calls
procedure
prolog
and
epilog
PROCEDURE
Here
LONGINT
BEGIN
RETURN
pc
END
Here
PROCEDURE
FJump
VAR
L
LONGINT
BEGIN
Put3
BC
L
L
pc
END
FJump
PROCEDURE
CFJump
VAR
x
Item
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
x
a
FixLink
x
b
x
a
pc
END
CFJump
PROCEDURE
BJump
L
LONGINT
BEGIN
Put3
BC
L
pc
END
BJump
PROCEDURE
CBJump
VAR
x
Item
L
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
L
pc
FixLink
x
b
FixLinkWith
x
a
L
END
CBJump
PROCEDURE
Fixup
VAR
x
Item
BEGIN
FixLink
x
a
END
Fixup
PROCEDURE
SaveRegs
r
LONGINT
R
r
VAR
r0
LONGINT
BEGIN
r
r0
Put1
Sub
SP
SP
r
INC
frame
r
REPEAT
Put2
Str
r0
SP
r
r0
INC
r0
UNTIL
r0
r
END
SaveRegs
PROCEDURE
RestoreRegs
r
LONGINT
R
r
VAR
r0
LONGINT
BEGIN
r
r0
r
REPEAT
DEC
r0
Put2
Ldr
r0
SP
r
r0
UNTIL
r0
Put1
Add
SP
SP
r
DEC
frame
r
END
RestoreRegs
PROCEDURE
PrepCall
VAR
x
Item
VAR
r
LONGINT
BEGIN
x
type
form
ORB
Proc
IF
x
mode
ORB
Par
THEN
load
x
END
r
RH
IF
RH
THEN
SaveRegs
RH
RH
END
END
PrepCall
PROCEDURE
Call
VAR
x
Item
r
LONGINT
BEGIN
x
type
form
ORB
Proc
IF
x
mode
ORB
Const
THEN
IF
x
r
THEN
Put3
BL
x
a
DIV
pc
ELSE
imported
IF
pc
fixorgP
1000H
THEN
Put3
BL
x
r
100H
x
a
1000H
pc
fixorgP
fixorgP
pc
ELSE
ORS
Mark
fixup
impossible
END
END
ELSE
IF
x
mode
ORB
Par
THEN
load
x
DEC
RH
ELSE
Put2
Ldr
RH
SP
Put1
Add
SP
SP
DEC
r
DEC
frame
END
IF
check
THEN
Trap
EQ
END
Put3
BLR
RH
END
IF
x
type
base
form
ORB
NoTyp
THEN
procedure
RH
ELSE
function
IF
r
THEN
Put0
Mov
r
RestoreRegs
r
END
x
mode
Reg
x
r
r
RH
r
END
END
Call
PROCEDURE
Enter
parblksize
locblksize
LONGINT
int
BOOLEAN
VAR
a
r
LONGINT
BEGIN
frame
IF
int
THEN
procedure
prolog
IF
locblksize
10000H
THEN
ORS
Mark
too
many
locals
END
a
r
Put1
Sub
SP
SP
locblksize
Put2
Str
LNK
SP
WHILE
a
parblksize
DO
Put2
Str
r
SP
a
INC
r
INC
a
END
ELSE
interrupt
procedure
Put1
Sub
SP
SP
locblksize
Put2
Str
SP
Put2
Str
SP
Put2
Str
SP
R0
R1
R2
saved
on
stack
END
END
Enter
PROCEDURE
Return
form
INTEGER
VAR
x
Item
size
LONGINT
int
BOOLEAN
BEGIN
IF
form
ORB
NoTyp
THEN
load
x
END
IF
int
THEN
procedure
epilog
Put2
Ldr
LNK
SP
Put1
Add
SP
SP
size
Put3
BR
LNK
ELSE
interrupt
return
restore
R2
R1
R0
Put2
Ldr
SP
Put2
Ldr
SP
Put2
Ldr
SP
Put1
Add
SP
SP
size
Put3
BR
10H
RTI
END
RH
END
Return
In
line
code
procedures
PROCEDURE
Increment
upordown
LONGINT
VAR
x
y
Item
VAR
op
zr
v
LONGINT
BEGIN
frame
IF
upordown
THEN
op
Add
ELSE
op
Sub
END
IF
x
type
ORB
byteType
THEN
v
ELSE
v
END
IF
y
type
form
ORB
NoTyp
THEN
y
mode
ORB
Const
y
a
END
IF
x
mode
ORB
Var
x
r
THEN
zr
RH
Put2
Ldr
v
zr
SP
x
a
incR
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
y
a
ELSE
load
y
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
v
zr
SP
x
a
DEC
RH
ELSE
loadAdr
x
zr
RH
Put2
Ldr
v
RH
x
r
incR
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
y
a
ELSE
load
y
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
v
zr
x
r
DEC
RH
END
END
Increment
PROCEDURE
Include
inorex
LONGINT
VAR
x
y
Item
VAR
op
zr
LONGINT
BEGIN
loadAdr
x
zr
RH
Put2
Ldr
RH
x
r
incR
IF
inorex
THEN
op
Ior
ELSE
op
Ann
END
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
LSL
y
a
ELSE
load
y
Put1
Mov
RH
Put0
Lsl
y
r
RH
y
r
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
zr
x
r
DEC
RH
END
Include
PROCEDURE
Assert
VAR
x
Item
VAR
cond
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
IF
x
a
THEN
cond
negated
x
r
ELSE
Put3
BC
x
r
x
b
FixLink
x
a
x
b
pc
cond
END
Trap
cond
FixLink
x
b
END
Assert
PROCEDURE
New
VAR
x
Item
BEGIN
loadAdr
x
loadTypTagAdr
x
type
base
Trap
RH
END
New
PROCEDURE
Pack
VAR
x
y
Item
VAR
z
Item
BEGIN
z
x
load
x
load
y
Put1
Lsl
y
r
y
r
Put0
Add
x
r
x
r
y
r
DEC
RH
Store
z
x
END
Pack
PROCEDURE
Unpk
VAR
x
y
Item
VAR
z
e0
Item
BEGIN
z
x
load
x
e0
mode
Reg
e0
r
RH
e0
type
ORB
intType
Put1
Asr
RH
x
r
Put1
Sub
RH
RH
Store
y
e0
incR
Put1
Lsl
RH
RH
Put0
Sub
x
r
x
r
RH
Store
z
x
END
Unpk
PROCEDURE
Led
VAR
x
Item
BEGIN
load
x
Put1
Mov
RH
Put2
Str
x
r
RH
DEC
RH
END
Led
PROCEDURE
Get
VAR
x
y
Item
BEGIN
load
x
x
type
y
type
x
mode
RegI
x
a
Store
y
x
END
Get
PROCEDURE
Put
VAR
x
y
Item
BEGIN
load
x
x
type
y
type
x
mode
RegI
x
a
Store
x
y
END
Put
PROCEDURE
Copy
VAR
x
y
z
Item
BEGIN
load
x
load
y
IF
z
mode
ORB
Const
THEN
IF
z
a
THEN
load
z
ELSE
ORS
Mark
bad
count
END
ELSE
load
z
IF
check
THEN
Trap
LT
END
Put3
BC
EQ
END
Put2
Ldr
RH
x
r
Put1
Add
x
r
x
r
Put2
Str
RH
y
r
Put1
Add
y
r
y
r
Put1
Sub
z
r
z
r
Put3
BC
NE
DEC
RH
END
Copy
PROCEDURE
LDPSR
VAR
x
Item
BEGIN
x
mode
Const
Put3
x
a
20H
END
LDPSR
PROCEDURE
LDREG
VAR
x
y
Item
BEGIN
IF
y
mode
ORB
Const
THEN
Put1a
Mov
x
a
y
a
ELSE
load
y
Put0
Mov
x
a
y
r
DEC
RH
END
END
LDREG
In
line
code
functions
PROCEDURE
Abs
VAR
x
Item
BEGIN
IF
x
mode
ORB
Const
THEN
x
a
ABS
x
a
ELSE
load
x
IF
x
type
form
ORB
Real
THEN
Put1
Lsl
x
r
x
r
Put1
Ror
x
r
x
r
ELSE
Put1
Cmp
x
r
x
r
Put3
BC
GE
Put1
Mov
RH
Put0
Sub
x
r
RH
x
r
END
END
END
Abs
PROCEDURE
Odd
VAR
x
Item
BEGIN
load
x
Put1
And
x
r
x
r
SetCC
x
NE
DEC
RH
END
Odd
PROCEDURE
Floor
VAR
x
Item
BEGIN
load
x
Put1
Mov
U
RH
4B00H
Put0
Fad
V
x
r
x
r
RH
END
Floor
PROCEDURE
Float
VAR
x
Item
BEGIN
load
x
Put1
Mov
U
RH
4B00H
Put0
Fad
U
x
r
x
r
RH
END
Float
PROCEDURE
Ord
VAR
x
Item
BEGIN
IF
x
mode
IN
ORB
Var
ORB
Par
RegI
Cond
THEN
load
x
END
END
Ord
PROCEDURE
Len
VAR
x
Item
BEGIN
IF
x
type
len
THEN
IF
x
mode
RegI
THEN
DEC
RH
END
x
mode
ORB
Const
x
a
x
type
len
ELSE
open
array
Put2
Ldr
RH
SP
x
a
frame
x
mode
Reg
x
r
RH
incR
END
END
Len
PROCEDURE
Shift
fct
LONGINT
VAR
x
y
Item
VAR
op
LONGINT
BEGIN
load
x
IF
fct
THEN
op
Lsl
ELSIF
fct
THEN
op
Asr
ELSE
op
Ror
END
IF
y
mode
ORB
Const
THEN
Put1
op
x
r
x
r
y
a
MOD
20H
ELSE
load
y
Put0
op
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
Shift
PROCEDURE
ADC
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Add
2000H
x
r
x
r
y
r
DEC
RH
END
ADC
PROCEDURE
SBC
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Sub
2000H
x
r
x
r
y
r
DEC
RH
END
SBC
PROCEDURE
UML
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Mul
2000H
x
r
x
r
y
r
DEC
RH
END
UML
PROCEDURE
Bit
VAR
x
y
Item
BEGIN
load
x
Put2
Ldr
x
r
x
r
IF
y
mode
ORB
Const
THEN
Put1
Ror
x
r
x
r
y
a
DEC
RH
ELSE
load
y
Put1
Add
y
r
y
r
Put0
Ror
x
r
x
r
y
r
DEC
RH
END
SetCC
x
MI
END
Bit
PROCEDURE
Register
VAR
x
Item
BEGIN
x
mode
Const
Put0
Mov
RH
x
a
MOD
10H
x
mode
Reg
x
r
RH
incR
END
Register
PROCEDURE
H
VAR
x
Item
BEGIN
x
mode
Const
Put0
Mov
U
x
a
MOD
V
RH
x
mode
Reg
x
r
RH
incR
END
H
PROCEDURE
Adr
VAR
x
Item
BEGIN
IF
x
mode
IN
ORB
Var
ORB
Par
RegI
THEN
loadAdr
x
ELSIF
x
mode
ORB
Const
x
type
form
ORB
Proc
THEN
load
x
ELSIF
x
mode
ORB
Const
x
type
form
ORB
String
THEN
loadStringAdr
x
ELSE
ORS
Mark
not
addressable
END
END
Adr
PROCEDURE
Condition
VAR
x
Item
BEGIN
x
mode
Const
SetCC
x
x
a
END
Condition
PROCEDURE
Open
v
INTEGER
BEGIN
pc
tdx
strx
RH
fixorgP
fixorgD
fixorgT
check
v
version
v
IF
v
THEN
pc
REPEAT
code
pc
INC
pc
UNTIL
pc
END
END
Open
PROCEDURE
SetDataSize
dc
LONGINT
BEGIN
varsize
dc
END
SetDataSize
PROCEDURE
Header
BEGIN
entry
pc
IF
version
THEN
code
0E7000000H
pc
Put1a
Mov
SP
StkOrg0
RISC
ELSE
Put1
Sub
SP
SP
Put2
Str
LNK
SP
END
END
Header
PROCEDURE
NofPtrs
typ
ORB
Type
LONGINT
VAR
fld
ORB
Object
n
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
n
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
n
WHILE
fld
NIL
DO
n
NofPtrs
fld
type
n
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
n
NofPtrs
typ
base
typ
len
ELSE
n
END
RETURN
n
END
NofPtrs
PROCEDURE
FindPtrs
VAR
R
Files
Rider
typ
ORB
Type
adr
LONGINT
VAR
fld
ORB
Object
i
s
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
Files
WriteInt
R
adr
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindPtrs
R
fld
type
fld
val
adr
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
s
typ
base
size
FOR
i
TO
typ
len
DO
FindPtrs
R
typ
base
i
s
adr
END
END
END
FindPtrs
PROCEDURE
Close
VAR
modid
ORS
Ident
key
nofent
LONGINT
VAR
obj
ORB
Object
i
comsize
nofimps
nofptrs
size
LONGINT
name
ORS
Ident
F
Files
File
R
Files
Rider
BEGIN
exit
code
IF
version
THEN
Put1
Mov
Put3
BR
RISC
ELSE
Put2
Ldr
LNK
SP
Put1
Add
SP
SP
Put3
BR
LNK
END
obj
ORB
topScope
next
nofimps
comsize
nofptrs
WHILE
obj
NIL
DO
IF
obj
class
ORB
Mod
obj
dsc
ORB
system
THEN
INC
nofimps
count
imports
ELSIF
obj
exno
obj
class
ORB
Const
obj
type
form
ORB
Proc
obj
type
nofpar
obj
type
base
ORB
noType
THEN
i
count
commands
WHILE
obj
name
i
0X
DO
INC
i
END
i
i
DIV
INC
comsize
i
ELSIF
obj
class
ORB
Var
THEN
INC
nofptrs
NofPtrs
obj
type
count
pointers
END
obj
obj
next
END
size
varsize
strx
comsize
pc
nofimps
nofent
nofptrs
varsize
includes
type
descriptors
ORB
MakeFileName
name
modid
rsc
write
code
file
F
Files
New
name
Files
Set
R
F
Files
WriteString
R
modid
Files
WriteInt
R
key
Files
Write
R
CHR
version
Files
WriteInt
R
size
obj
ORB
topScope
next
WHILE
obj
NIL
obj
class
ORB
Mod
DO
imports
IF
obj
dsc
ORB
system
THEN
Files
WriteString
R
obj
ORB
Module
orgname
Files
WriteInt
R
obj
val
END
obj
obj
next
END
Files
Write
R
0X
Files
WriteInt
R
tdx
i
WHILE
i
tdx
DO
Files
WriteInt
R
data
i
INC
i
END
type
descriptors
Files
WriteInt
R
varsize
tdx
data
Files
WriteInt
R
strx
FOR
i
TO
strx
DO
Files
Write
R
str
i
END
strings
Files
WriteInt
R
pc
code
len
FOR
i
TO
pc
DO
Files
WriteInt
R
code
i
END
program
obj
ORB
topScope
next
WHILE
obj
NIL
DO
commands
IF
obj
exno
obj
class
ORB
Const
obj
type
form
ORB
Proc
obj
type
nofpar
obj
type
base
ORB
noType
THEN
Files
WriteString
R
obj
name
Files
WriteInt
R
obj
val
END
obj
obj
next
END
Files
Write
R
0X
Files
WriteInt
R
nofent
Files
WriteInt
R
entry
obj
ORB
topScope
next
WHILE
obj
NIL
DO
entries
IF
obj
exno
THEN
IF
obj
class
ORB
Const
obj
type
form
ORB
Proc
OR
obj
class
ORB
Var
THEN
Files
WriteInt
R
obj
val
ELSIF
obj
class
ORB
Typ
THEN
IF
obj
type
form
ORB
Record
THEN
Files
WriteInt
R
obj
type
len
MOD
10000H
ELSIF
obj
type
form
ORB
Pointer
obj
type
base
typobj
NIL
OR
obj
type
base
typobj
exno
THEN
Files
WriteInt
R
obj
type
base
len
MOD
10000H
END
END
END
obj
obj
next
END
obj
ORB
topScope
next
WHILE
obj
NIL
DO
pointer
variables
IF
obj
class
ORB
Var
THEN
FindPtrs
R
obj
type
obj
val
END
obj
obj
next
END
Files
WriteInt
R
Files
WriteInt
R
fixorgP
Files
WriteInt
R
fixorgD
Files
WriteInt
R
fixorgT
Files
WriteInt
R
entry
Files
Write
R
O
Files
Register
F
END
Close
BEGIN
relmap
relmap
relmap
relmap
relmap
relmap
END
ORG
MODULE
ORP
N
Wirth
Oberon
compiler
for
RISC
in
Oberon
IMPORT
Texts
Oberon
ORS
ORB
ORG
Author
Niklaus
Wirth
Parser
of
Oberon
RISC
compiler
Uses
Scanner
ORS
to
obtain
symbols
tokens
ORB
for
definition
of
data
structures
and
for
handling
import
and
export
and
ORG
to
produce
binary
code
ORP
performs
type
checking
and
data
allocation
Parser
is
target
independent
except
for
part
of
the
handling
of
allocations
TYPE
PtrBase
POINTER
TO
PtrBaseDesc
PtrBaseDesc
RECORD
list
of
names
of
pointer
base
types
name
ORS
Ident
type
ORB
Type
next
PtrBase
END
VAR
sym
INTEGER
last
symbol
read
dc
LONGINT
data
counter
level
exno
version
INTEGER
newSF
BOOLEAN
option
flag
expression
PROCEDURE
VAR
x
ORG
Item
to
avoid
forward
reference
Type
PROCEDURE
VAR
type
ORB
Type
FormalType
PROCEDURE
VAR
typ
ORB
Type
dim
INTEGER
modid
ORS
Ident
pbsList
PtrBase
list
of
names
of
pointer
base
types
dummy
ORB
Object
W
Texts
Writer
PROCEDURE
Check
s
INTEGER
msg
ARRAY
OF
CHAR
BEGIN
IF
sym
s
THEN
ORS
Get
sym
ELSE
ORS
Mark
msg
END
END
Check
PROCEDURE
qualident
VAR
obj
ORB
Object
BEGIN
obj
ORB
thisObj
ORS
Get
sym
IF
obj
NIL
THEN
ORS
Mark
undef
obj
dummy
END
IF
sym
ORS
period
obj
class
ORB
Mod
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
obj
ORB
thisimport
obj
ORS
Get
sym
IF
obj
NIL
THEN
ORS
Mark
undef
obj
dummy
END
ELSE
ORS
Mark
identifier
expected
obj
dummy
END
END
END
qualident
PROCEDURE
CheckBool
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Bool
THEN
ORS
Mark
not
Boolean
x
type
ORB
boolType
END
END
CheckBool
PROCEDURE
CheckInt
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Int
THEN
ORS
Mark
not
Integer
x
type
ORB
intType
END
END
CheckInt
PROCEDURE
CheckReal
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Real
THEN
ORS
Mark
not
Real
x
type
ORB
realType
END
END
CheckReal
PROCEDURE
CheckSet
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Set
THEN
ORS
Mark
not
Set
x
type
ORB
setType
END
END
CheckSet
PROCEDURE
CheckSetVal
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Int
THEN
ORS
Mark
not
Int
x
type
ORB
setType
ELSIF
x
mode
ORB
Const
THEN
IF
x
a
OR
x
a
THEN
ORS
Mark
invalid
set
END
END
END
CheckSetVal
PROCEDURE
CheckConst
VAR
x
ORG
Item
BEGIN
IF
x
mode
ORB
Const
THEN
ORS
Mark
not
a
constant
x
mode
ORB
Const
END
END
CheckConst
PROCEDURE
CheckReadOnly
VAR
x
ORG
Item
BEGIN
IF
x
rdo
THEN
ORS
Mark
read
only
END
END
CheckReadOnly
PROCEDURE
CheckExport
VAR
expo
BOOLEAN
BEGIN
IF
sym
ORS
times
THEN
expo
TRUE
ORS
Get
sym
IF
level
THEN
ORS
Mark
remove
asterisk
END
ELSE
expo
FALSE
END
END
CheckExport
PROCEDURE
IsExtension
t0
t1
ORB
Type
BOOLEAN
BEGIN
t1
is
an
extension
of
t0
RETURN
t0
t1
OR
t1
NIL
IsExtension
t0
t1
base
END
IsExtension
expressions
PROCEDURE
TypeTest
VAR
x
ORG
Item
T
ORB
Type
guard
BOOLEAN
VAR
xt
ORB
Type
BEGIN
xt
x
type
IF
T
form
xt
form
T
form
ORB
Pointer
OR
T
form
ORB
Record
x
mode
ORB
Par
THEN
WHILE
xt
T
xt
NIL
DO
xt
xt
base
END
IF
xt
T
THEN
xt
x
type
IF
xt
form
ORB
Pointer
THEN
IF
IsExtension
xt
base
T
base
THEN
ORG
TypeTest
x
T
base
FALSE
guard
x
type
T
ELSE
ORS
Mark
not
an
extension
END
ELSIF
xt
form
ORB
Record
x
mode
ORB
Par
THEN
IF
IsExtension
xt
T
THEN
ORG
TypeTest
x
T
TRUE
guard
x
type
T
ELSE
ORS
Mark
not
an
extension
END
ELSE
ORS
Mark
incompatible
types
END
ELSIF
guard
THEN
ORG
MakeConstItem
x
ORB
boolType
END
ELSE
ORS
Mark
type
mismatch
END
IF
guard
THEN
x
type
ORB
boolType
END
END
TypeTest
PROCEDURE
selector
VAR
x
ORG
Item
VAR
y
ORG
Item
obj
ORB
Object
BEGIN
WHILE
sym
ORS
lbrak
OR
sym
ORS
period
OR
sym
ORS
arrow
OR
sym
ORS
lparen
x
type
form
IN
ORB
Record
ORB
Pointer
DO
IF
sym
ORS
lbrak
THEN
REPEAT
ORS
Get
sym
expression
y
IF
x
type
form
ORB
Array
THEN
CheckInt
y
ORG
Index
x
y
x
type
x
type
base
ELSE
ORS
Mark
not
an
array
END
UNTIL
sym
ORS
comma
Check
ORS
rbrak
no
ELSIF
sym
ORS
period
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
IF
x
type
form
ORB
Pointer
THEN
ORG
DeRef
x
x
type
x
type
base
END
IF
x
type
form
ORB
Record
THEN
obj
ORB
thisfield
x
type
ORS
Get
sym
IF
obj
NIL
THEN
ORG
Field
x
obj
x
type
obj
type
ELSE
ORS
Mark
undef
END
ELSE
ORS
Mark
not
a
record
END
ELSE
ORS
Mark
ident
END
ELSIF
sym
ORS
arrow
THEN
ORS
Get
sym
IF
x
type
form
ORB
Pointer
THEN
ORG
DeRef
x
x
type
x
type
base
ELSE
ORS
Mark
not
a
pointer
END
ELSIF
sym
ORS
lparen
x
type
form
IN
ORB
Record
ORB
Pointer
THEN
type
guard
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
TypeTest
x
obj
type
TRUE
ELSE
ORS
Mark
guard
type
expected
END
ELSE
ORS
Mark
not
an
identifier
END
Check
ORS
rparen
missing
END
END
END
selector
PROCEDURE
EqualSignatures
t0
t1
ORB
Type
BOOLEAN
VAR
p0
p1
ORB
Object
com
BOOLEAN
BEGIN
com
TRUE
IF
t0
base
t1
base
t0
nofpar
t1
nofpar
THEN
p0
t0
dsc
p1
t1
dsc
WHILE
p0
NIL
DO
IF
p0
class
p1
class
p0
rdo
p1
rdo
p0
type
p1
type
OR
p0
type
form
ORB
Array
p1
type
form
ORB
Array
p0
type
len
p1
type
len
p0
type
base
p1
type
base
OR
p0
type
form
ORB
Proc
p1
type
form
ORB
Proc
EqualSignatures
p0
type
p1
type
THEN
p0
p0
next
p1
p1
next
ELSE
p0
NIL
com
FALSE
END
END
ELSE
com
FALSE
END
RETURN
com
END
EqualSignatures
PROCEDURE
CompTypes
t0
t1
ORB
Type
varpar
BOOLEAN
BOOLEAN
BEGIN
check
for
assignment
compatibility
RETURN
t0
t1
openarray
assignment
disallowed
in
ORG
OR
t0
form
ORB
Array
t1
form
ORB
Array
t0
base
t1
base
t0
len
t1
len
OR
t0
form
ORB
Record
t1
form
ORB
Record
IsExtension
t0
t1
OR
varpar
t0
form
ORB
Pointer
t1
form
ORB
Pointer
IsExtension
t0
base
t1
base
OR
t0
form
ORB
Proc
t1
form
ORB
Proc
EqualSignatures
t0
t1
OR
t0
form
IN
ORB
Pointer
ORB
Proc
t1
form
ORB
NilTyp
END
CompTypes
PROCEDURE
Parameter
par
ORB
Object
VAR
x
ORG
Item
varpar
BOOLEAN
BEGIN
expression
x
IF
par
NIL
THEN
varpar
par
class
ORB
Par
IF
CompTypes
par
type
x
type
varpar
THEN
IF
varpar
THEN
ORG
ValueParam
x
ELSE
par
class
Par
IF
par
rdo
THEN
CheckReadOnly
x
END
ORG
VarParam
x
par
type
END
ELSIF
x
type
form
ORB
Array
par
type
form
ORB
Array
x
type
base
par
type
base
par
type
len
THEN
IF
par
rdo
THEN
CheckReadOnly
x
END
ORG
OpenArrayParam
x
ELSIF
x
type
form
ORB
String
varpar
par
rdo
par
type
form
ORB
Array
par
type
base
form
ORB
Char
par
type
len
THEN
ORG
StringParam
x
ELSIF
varpar
par
type
form
ORB
Int
x
type
form
ORB
Int
THEN
ORG
ValueParam
x
BYTE
ELSIF
x
type
form
ORB
String
x
b
par
class
ORB
Var
par
type
form
ORB
Char
THEN
ORG
StrToChar
x
ORG
ValueParam
x
ELSIF
par
type
form
ORB
Array
par
type
base
ORB
byteType
par
type
len
par
type
size
x
type
size
THEN
ORG
VarParam
x
par
type
ELSE
ORS
Mark
incompatible
parameters
END
END
END
Parameter
PROCEDURE
ParamList
VAR
x
ORG
Item
VAR
n
INTEGER
par
ORB
Object
BEGIN
par
x
type
dsc
n
IF
sym
ORS
rparen
THEN
Parameter
par
n
WHILE
sym
ORS
comma
DO
Check
sym
comma
IF
par
NIL
THEN
par
par
next
END
INC
n
Parameter
par
END
Check
ORS
rparen
missing
ELSE
ORS
Get
sym
END
IF
n
x
type
nofpar
THEN
ORS
Mark
too
few
params
ELSIF
n
x
type
nofpar
THEN
ORS
Mark
too
many
params
END
END
ParamList
PROCEDURE
StandFunc
VAR
x
ORG
Item
fct
LONGINT
restyp
ORB
Type
VAR
y
ORG
Item
n
npar
LONGINT
BEGIN
Check
ORS
lparen
no
npar
fct
MOD
fct
fct
DIV
expression
x
n
WHILE
sym
ORS
comma
DO
ORS
Get
sym
expression
y
INC
n
END
Check
ORS
rparen
no
IF
n
npar
THEN
IF
fct
THEN
ABS
IF
x
type
form
IN
ORB
Int
ORB
Real
THEN
ORG
Abs
x
restyp
x
type
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
ODD
CheckInt
x
ORG
Odd
x
ELSIF
fct
THEN
FLOOR
CheckReal
x
ORG
Floor
x
ELSIF
fct
THEN
FLT
CheckInt
x
ORG
Float
x
ELSIF
fct
THEN
ORD
IF
x
type
form
ORB
Proc
THEN
ORG
Ord
x
ELSIF
x
type
form
ORB
String
x
b
THEN
ORG
StrToChar
x
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
CHR
CheckInt
x
ORG
Ord
x
ELSIF
fct
THEN
LEN
IF
x
type
form
ORB
Array
THEN
ORG
Len
x
ELSE
ORS
Mark
not
an
array
END
ELSIF
fct
IN
THEN
LSL
ASR
ROR
CheckInt
y
IF
x
type
form
IN
ORB
Int
ORB
Set
THEN
ORG
Shift
fct
x
y
restyp
x
type
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
ADC
ORG
ADC
x
y
ELSIF
fct
THEN
SBC
ORG
SBC
x
y
ELSIF
fct
THEN
UML
ORG
UML
x
y
ELSIF
fct
THEN
BIT
CheckInt
x
CheckInt
y
ORG
Bit
x
y
ELSIF
fct
THEN
REG
CheckConst
x
CheckInt
x
ORG
Register
x
ELSIF
fct
THEN
VAL
IF
x
mode
ORB
Typ
x
type
size
y
type
size
THEN
restyp
x
type
x
y
ELSE
ORS
Mark
casting
not
allowed
END
ELSIF
fct
THEN
ADR
ORG
Adr
x
ELSIF
fct
THEN
SIZE
IF
x
mode
ORB
Typ
THEN
ORG
MakeConstItem
x
ORB
intType
x
type
size
ELSE
ORS
Mark
must
be
a
type
END
ELSIF
fct
THEN
COND
CheckConst
x
CheckInt
x
ORG
Condition
x
ELSIF
fct
THEN
H
CheckConst
x
CheckInt
x
ORG
H
x
END
x
type
restyp
ELSE
ORS
Mark
wrong
nof
params
END
END
StandFunc
PROCEDURE
element
VAR
x
ORG
Item
VAR
y
ORG
Item
BEGIN
expression
x
CheckSetVal
x
IF
sym
ORS
upto
THEN
ORS
Get
sym
expression
y
CheckSetVal
y
ORG
Set
x
y
ELSE
ORG
Singleton
x
END
x
type
ORB
setType
END
element
PROCEDURE
set
VAR
x
ORG
Item
VAR
y
ORG
Item
BEGIN
IF
sym
ORS
if
THEN
IF
sym
ORS
rbrace
THEN
ORS
Mark
missing
END
ORG
MakeConstItem
x
ORB
setType
empty
set
ELSE
element
x
WHILE
sym
ORS
rparen
OR
sym
ORS
rbrace
DO
IF
sym
ORS
comma
THEN
ORS
Get
sym
ELSIF
sym
ORS
rbrace
THEN
ORS
Mark
missing
comma
END
element
y
ORG
SetOp
ORS
plus
x
y
END
END
END
set
PROCEDURE
factor
VAR
x
ORG
Item
VAR
obj
ORB
Object
rx
LONGINT
BEGIN
sync
IF
sym
ORS
char
OR
sym
ORS
ident
THEN
ORS
Mark
expression
expected
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
char
sym
ORS
for
OR
sym
ORS
then
END
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
SFunc
THEN
StandFunc
x
obj
val
obj
type
ELSE
ORG
MakeItem
x
obj
level
selector
x
IF
sym
ORS
lparen
THEN
ORS
Get
sym
IF
x
type
form
ORB
Proc
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ParamList
x
ORG
Call
x
rx
x
type
x
type
base
ELSE
ORS
Mark
not
a
function
ParamList
x
END
END
END
ELSIF
sym
ORS
int
THEN
ORG
MakeConstItem
x
ORB
intType
ORS
ival
ORS
Get
sym
ELSIF
sym
ORS
real
THEN
ORG
MakeRealItem
x
ORS
rval
ORS
Get
sym
ELSIF
sym
ORS
char
THEN
ORG
MakeConstItem
x
ORB
charType
ORS
ival
ORS
Get
sym
ELSIF
sym
ORS
nil
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
nilType
ELSIF
sym
ORS
string
THEN
ORG
MakeStringItem
x
ORS
slen
ORS
Get
sym
ELSIF
sym
ORS
lparen
THEN
ORS
Get
sym
expression
x
Check
ORS
rparen
no
ELSIF
sym
ORS
lbrace
THEN
ORS
Get
sym
set
x
Check
ORS
rbrace
no
ELSIF
sym
ORS
not
THEN
ORS
Get
sym
factor
x
CheckBool
x
ORG
Not
x
ELSIF
sym
ORS
false
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
boolType
ELSIF
sym
ORS
true
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
boolType
ELSE
ORS
Mark
not
a
factor
ORG
MakeConstItem
x
ORB
intType
END
END
factor
PROCEDURE
term
VAR
x
ORG
Item
VAR
y
ORG
Item
op
f
INTEGER
BEGIN
factor
x
f
x
type
form
WHILE
sym
ORS
times
sym
ORS
and
DO
op
sym
ORS
Get
sym
IF
op
ORS
times
THEN
IF
f
ORB
Int
THEN
factor
y
CheckInt
y
ORG
MulOp
x
y
ELSIF
f
ORB
Real
THEN
factor
y
CheckReal
y
ORG
RealOp
op
x
y
ELSIF
f
ORB
Set
THEN
factor
y
CheckSet
y
ORG
SetOp
op
x
y
ELSE
ORS
Mark
bad
type
END
ELSIF
op
ORS
div
OR
op
ORS
mod
THEN
CheckInt
x
factor
y
CheckInt
y
ORG
DivOp
op
x
y
ELSIF
op
ORS
rdiv
THEN
IF
f
ORB
Real
THEN
factor
y
CheckReal
y
ORG
RealOp
op
x
y
ELSIF
f
ORB
Set
THEN
factor
y
CheckSet
y
ORG
SetOp
op
x
y
ELSE
ORS
Mark
bad
type
END
ELSE
op
and
CheckBool
x
ORG
And1
x
factor
y
CheckBool
y
ORG
And2
x
y
END
END
END
term
PROCEDURE
SimpleExpression
VAR
x
ORG
Item
VAR
y
ORG
Item
op
INTEGER
BEGIN
IF
sym
ORS
minus
THEN
ORS
Get
sym
term
x
IF
x
type
form
IN
ORB
Int
ORB
Real
ORB
Set
THEN
ORG
Neg
x
ELSE
CheckInt
x
END
ELSIF
sym
ORS
plus
THEN
ORS
Get
sym
term
x
ELSE
term
x
END
WHILE
sym
ORS
plus
sym
ORS
or
DO
op
sym
ORS
Get
sym
IF
op
ORS
or
THEN
ORG
Or1
x
CheckBool
x
term
y
CheckBool
y
ORG
Or2
x
y
ELSIF
x
type
form
ORB
Int
THEN
term
y
CheckInt
y
ORG
AddOp
op
x
y
ELSIF
x
type
form
ORB
Real
THEN
term
y
CheckReal
y
ORG
RealOp
op
x
y
ELSE
CheckSet
x
term
y
CheckSet
y
ORG
SetOp
op
x
y
END
END
END
SimpleExpression
PROCEDURE
expression0
VAR
x
ORG
Item
VAR
y
ORG
Item
obj
ORB
Object
rel
xf
yf
INTEGER
BEGIN
SimpleExpression
x
IF
sym
ORS
eql
sym
ORS
geq
THEN
rel
sym
ORS
Get
sym
SimpleExpression
y
xf
x
type
form
yf
y
type
form
IF
x
type
y
type
THEN
IF
xf
IN
ORB
Char
ORB
Int
THEN
ORG
IntRelation
rel
x
y
ELSIF
xf
ORB
Real
THEN
ORG
RealRelation
rel
x
y
ELSIF
xf
IN
ORB
Set
ORB
Pointer
ORB
Proc
ORB
NilTyp
ORB
Bool
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Array
x
type
base
form
ORB
Char
OR
xf
ORB
String
THEN
ORG
StringRelation
rel
x
y
ELSE
ORS
Mark
illegal
comparison
END
ELSIF
xf
IN
ORB
Pointer
ORB
Proc
yf
ORB
NilTyp
OR
yf
IN
ORB
Pointer
ORB
Proc
xf
ORB
NilTyp
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Pointer
yf
ORB
Pointer
IsExtension
x
type
base
y
type
base
OR
IsExtension
y
type
base
x
type
base
OR
xf
ORB
Proc
yf
ORB
Proc
EqualSignatures
x
type
y
type
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Array
x
type
base
form
ORB
Char
yf
ORB
String
OR
yf
ORB
Array
y
type
base
form
ORB
Char
OR
yf
ORB
Array
y
type
base
form
ORB
Char
xf
ORB
String
THEN
ORG
StringRelation
rel
x
y
ELSIF
xf
ORB
Char
yf
ORB
String
y
b
THEN
ORG
StrToChar
y
ORG
IntRelation
rel
x
y
ELSIF
yf
ORB
Char
xf
ORB
String
x
b
THEN
ORG
StrToChar
x
ORG
IntRelation
rel
x
y
ELSIF
xf
ORB
Int
yf
ORB
Int
THEN
ORG
IntRelation
rel
x
y
BYTE
ELSE
ORS
Mark
illegal
comparison
END
x
type
ORB
boolType
ELSIF
sym
ORS
in
THEN
ORS
Get
sym
CheckInt
x
SimpleExpression
y
CheckSet
y
ORG
In
x
y
x
type
ORB
boolType
ELSIF
sym
ORS
is
THEN
ORS
Get
sym
qualident
obj
TypeTest
x
obj
type
FALSE
x
type
ORB
boolType
END
END
expression0
statements
PROCEDURE
StandProc
pno
LONGINT
VAR
nap
npar
LONGINT
nof
actual
formal
parameters
x
y
z
ORG
Item
BEGIN
Check
ORS
lparen
no
npar
pno
MOD
pno
pno
DIV
expression
x
nap
IF
sym
ORS
comma
THEN
ORS
Get
sym
expression
y
nap
z
type
ORB
noType
WHILE
sym
ORS
comma
DO
ORS
Get
sym
expression
z
INC
nap
END
ELSE
y
type
ORB
noType
END
Check
ORS
rparen
no
IF
npar
nap
OR
pno
IN
THEN
IF
pno
IN
THEN
INC
DEC
CheckInt
x
CheckReadOnly
x
IF
y
type
ORB
noType
THEN
CheckInt
y
END
ORG
Increment
pno
x
y
ELSIF
pno
IN
THEN
INCL
EXCL
CheckSet
x
CheckReadOnly
x
CheckInt
y
ORG
Include
pno
x
y
ELSIF
pno
THEN
CheckBool
x
ORG
Assert
x
ELSIF
pno
THEN
NEW
CheckReadOnly
x
IF
x
type
form
ORB
Pointer
x
type
base
form
ORB
Record
THEN
ORG
New
x
ELSE
ORS
Mark
not
a
pointer
to
record
END
ELSIF
pno
THEN
CheckReal
x
CheckInt
y
CheckReadOnly
x
ORG
Pack
x
y
ELSIF
pno
THEN
CheckReal
x
CheckInt
y
CheckReadOnly
x
ORG
Unpk
x
y
ELSIF
pno
THEN
IF
x
type
form
ORB
Set
THEN
ORG
Led
x
ELSE
ORS
Mark
bad
type
END
ELSIF
pno
THEN
CheckInt
x
ORG
Get
x
y
ELSIF
pno
THEN
CheckInt
x
ORG
Put
x
y
ELSIF
pno
THEN
CheckInt
x
CheckInt
y
CheckInt
z
ORG
Copy
x
y
z
ELSIF
pno
THEN
CheckConst
x
CheckInt
x
ORG
LDPSR
x
ELSIF
pno
THEN
CheckInt
x
ORG
LDREG
x
y
END
ELSE
ORS
Mark
wrong
nof
parameters
END
END
StandProc
PROCEDURE
StatSequence
VAR
obj
ORB
Object
orgtype
ORB
Type
original
type
of
case
var
x
y
z
w
ORG
Item
L0
L1
rx
LONGINT
PROCEDURE
TypeCase
obj
ORB
Object
VAR
x
ORG
Item
VAR
typobj
ORB
Object
BEGIN
IF
sym
ORS
ident
THEN
qualident
typobj
ORG
MakeItem
x
obj
level
IF
typobj
class
ORB
Typ
THEN
ORS
Mark
not
a
type
END
TypeTest
x
typobj
type
FALSE
obj
type
typobj
type
ORG
CFJump
x
Check
ORS
colon
expected
StatSequence
ELSE
ORG
CFJump
x
ORS
Mark
type
id
expected
END
END
TypeCase
PROCEDURE
SkipCase
BEGIN
WHILE
sym
ORS
colon
DO
ORS
Get
sym
END
ORS
Get
sym
StatSequence
END
SkipCase
BEGIN
StatSequence
REPEAT
sync
obj
NIL
IF
sym
ORS
ident
sym
ORS
for
OR
sym
ORS
semicolon
THEN
ORS
Mark
statement
expected
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
ident
END
IF
sym
ORS
ident
THEN
qualident
obj
ORG
MakeItem
x
obj
level
IF
x
mode
ORB
SProc
THEN
StandProc
obj
val
ELSE
selector
x
IF
sym
ORS
becomes
THEN
assignment
ORS
Get
sym
CheckReadOnly
x
expression
y
IF
CompTypes
x
type
y
type
FALSE
THEN
IF
x
type
form
ORB
Pointer
OR
x
type
form
ORB
Proc
THEN
ORG
Store
x
y
ELSE
ORG
StoreStruct
x
y
END
ELSIF
x
type
form
ORB
Array
y
type
form
ORB
Array
x
type
base
y
type
base
y
type
len
THEN
ORG
StoreStruct
x
y
ELSIF
x
type
form
ORB
Array
x
type
base
form
ORB
Char
y
type
form
ORB
String
THEN
ORG
CopyString
x
y
ELSIF
x
type
form
ORB
Int
y
type
form
ORB
Int
THEN
ORG
Store
x
y
BYTE
ELSIF
x
type
form
ORB
Char
y
type
form
ORB
String
y
b
THEN
ORG
StrToChar
y
ORG
Store
x
y
ELSE
ORS
Mark
illegal
assignment
END
ELSIF
sym
ORS
eql
THEN
ORS
Mark
should
be
ORS
Get
sym
expression
y
ELSIF
sym
ORS
lparen
THEN
procedure
call
ORS
Get
sym
IF
x
type
form
ORB
Proc
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ParamList
x
ORG
Call
x
rx
ELSE
ORS
Mark
not
a
procedure
ParamList
x
END
ELSIF
x
type
form
ORB
Proc
THEN
procedure
call
without
parameters
IF
x
type
nofpar
THEN
ORS
Mark
missing
parameters
END
IF
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ORG
Call
x
rx
ELSE
ORS
Mark
not
a
procedure
END
ELSIF
x
mode
ORB
Typ
THEN
ORS
Mark
illegal
assignment
ELSE
ORS
Mark
not
a
procedure
END
END
ELSIF
sym
ORS
if
THEN
ORS
Get
sym
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
then
no
THEN
StatSequence
L0
WHILE
sym
ORS
elsif
DO
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
then
no
THEN
StatSequence
END
IF
sym
ORS
else
THEN
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
StatSequence
ELSE
ORG
Fixup
x
END
ORG
FixLink
L0
Check
ORS
end
no
END
ELSIF
sym
ORS
while
THEN
ORS
Get
sym
L0
ORG
Here
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
do
no
DO
StatSequence
ORG
BJump
L0
WHILE
sym
ORS
elsif
DO
ORS
Get
sym
ORG
Fixup
x
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
do
no
DO
StatSequence
ORG
BJump
L0
END
ORG
Fixup
x
Check
ORS
end
no
END
ELSIF
sym
ORS
repeat
THEN
ORS
Get
sym
L0
ORG
Here
StatSequence
IF
sym
ORS
until
THEN
ORS
Get
sym
expression
x
CheckBool
x
ORG
CBJump
x
L0
ELSE
ORS
Mark
missing
UNTIL
END
ELSIF
sym
ORS
for
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
ORG
MakeItem
x
obj
level
CheckInt
x
CheckReadOnly
x
IF
sym
ORS
becomes
THEN
ORS
Get
sym
expression
y
CheckInt
y
ORG
For0
x
y
L0
ORG
Here
Check
ORS
to
no
TO
expression
z
CheckInt
z
obj
rdo
TRUE
IF
sym
ORS
by
THEN
ORS
Get
sym
expression
w
CheckConst
w
CheckInt
w
ELSE
ORG
MakeConstItem
w
ORB
intType
END
Check
ORS
do
no
DO
ORG
For1
x
y
z
w
L1
StatSequence
Check
ORS
end
no
END
ORG
For2
x
y
w
ORG
BJump
L0
ORG
FixLink
L1
obj
rdo
FALSE
ELSE
ORS
Mark
expected
END
ELSE
ORS
Mark
identifier
expected
END
ELSIF
sym
ORS
case
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
orgtype
obj
type
IF
orgtype
form
ORB
Pointer
OR
orgtype
form
ORB
Record
obj
class
ORB
Par
THEN
Check
ORS
of
OF
expected
TypeCase
obj
x
L0
WHILE
sym
ORS
bar
DO
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
obj
type
orgtype
TypeCase
obj
x
END
ORG
Fixup
x
ORG
FixLink
L0
obj
type
orgtype
ELSE
ORS
Mark
numeric
case
not
implemented
Check
ORS
of
OF
expected
SkipCase
WHILE
sym
ORS
bar
DO
SkipCase
END
END
ELSE
ORS
Mark
ident
expected
END
Check
ORS
end
no
END
END
ORG
CheckRegs
IF
sym
ORS
semicolon
THEN
ORS
Get
sym
ELSIF
sym
ORS
semicolon
THEN
ORS
Mark
missing
semicolon
END
UNTIL
sym
ORS
semicolon
END
StatSequence
Types
and
declarations
PROCEDURE
IdentList
class
INTEGER
VAR
first
ORB
Object
VAR
obj
ORB
Object
BEGIN
IF
sym
ORS
ident
THEN
ORB
NewObj
first
ORS
id
class
ORS
Get
sym
CheckExport
first
expo
WHILE
sym
ORS
comma
DO
ORS
Get
sym
IF
sym
ORS
ident
THEN
ORB
NewObj
obj
ORS
id
class
ORS
Get
sym
CheckExport
obj
expo
ELSE
ORS
Mark
ident
END
END
IF
sym
ORS
colon
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
ELSE
first
NIL
END
END
IdentList
PROCEDURE
ArrayType
VAR
type
ORB
Type
VAR
x
ORG
Item
typ
ORB
Type
len
LONGINT
BEGIN
NEW
typ
typ
form
ORB
NoTyp
expression
x
IF
x
mode
ORB
Const
x
type
form
ORB
Int
x
a
THEN
len
x
a
ELSE
len
ORS
Mark
not
a
valid
length
END
IF
sym
ORS
of
THEN
ORS
Get
sym
Type
typ
base
IF
typ
base
form
ORB
Array
typ
base
len
THEN
ORS
Mark
dyn
array
not
allowed
END
ELSIF
sym
ORS
comma
THEN
ORS
Get
sym
ArrayType
typ
base
ELSE
ORS
Mark
missing
OF
typ
base
ORB
intType
END
typ
size
len
typ
base
size
DIV
typ
form
ORB
Array
typ
len
len
type
typ
END
ArrayType
PROCEDURE
RecordType
VAR
type
ORB
Type
VAR
obj
obj0
new
bot
base
ORB
Object
typ
tp
ORB
Type
offset
off
n
LONGINT
BEGIN
NEW
typ
typ
form
ORB
NoTyp
typ
base
NIL
typ
mno
level
typ
nofpar
offset
bot
NIL
IF
sym
ORS
lparen
THEN
ORS
Get
sym
record
extension
IF
level
THEN
ORS
Mark
extension
of
local
types
not
implemented
END
IF
sym
ORS
ident
THEN
qualident
base
IF
base
class
ORB
Typ
THEN
IF
base
type
form
ORB
Record
THEN
typ
base
base
type
ELSE
typ
base
ORB
intType
ORS
Mark
invalid
extension
END
typ
nofpar
typ
base
nofpar
nofpar
here
abused
for
extension
level
bot
typ
base
dsc
offset
typ
base
size
ELSE
ORS
Mark
type
expected
END
ELSE
ORS
Mark
ident
expected
END
Check
ORS
rparen
no
END
WHILE
sym
ORS
ident
DO
fields
n
obj
bot
WHILE
sym
ORS
ident
DO
obj0
obj
WHILE
obj0
NIL
obj0
name
ORS
id
DO
obj0
obj0
next
END
IF
obj0
NIL
THEN
ORS
Mark
mult
def
END
NEW
new
ORS
CopyId
new
name
new
class
ORB
Fld
new
next
obj
obj
new
INC
n
ORS
Get
sym
CheckExport
new
expo
IF
sym
ORS
comma
sym
ORS
colon
THEN
ORS
Mark
comma
expected
ELSIF
sym
ORS
comma
THEN
ORS
Get
sym
END
END
Check
ORS
colon
colon
expected
Type
tp
IF
tp
form
ORB
Array
tp
len
THEN
ORS
Mark
dyn
array
not
allowed
END
IF
tp
size
THEN
offset
offset
DIV
END
offset
offset
n
tp
size
off
offset
obj0
obj
WHILE
obj0
bot
DO
obj0
type
tp
obj0
lev
off
off
tp
size
obj0
val
off
obj0
obj0
next
END
bot
obj
IF
sym
ORS
semicolon
THEN
ORS
Get
sym
ELSIF
sym
ORS
end
THEN
ORS
Mark
or
END
END
END
typ
form
ORB
Record
typ
dsc
bot
typ
size
offset
DIV
type
typ
END
RecordType
PROCEDURE
FPSection
VAR
adr
LONGINT
VAR
nofpar
INTEGER
VAR
obj
first
ORB
Object
tp
ORB
Type
parsize
LONGINT
cl
INTEGER
rdo
BOOLEAN
BEGIN
IF
sym
ORS
var
THEN
ORS
Get
sym
cl
ORB
Par
ELSE
cl
ORB
Var
END
IdentList
cl
first
FormalType
tp
rdo
FALSE
IF
cl
ORB
Var
tp
form
ORB
Array
THEN
cl
ORB
Par
rdo
TRUE
END
IF
tp
form
ORB
Array
tp
len
OR
tp
form
ORB
Record
THEN
parsize
ORG
WordSize
open
array
or
record
needs
second
word
for
length
or
type
tag
ELSE
parsize
ORG
WordSize
END
obj
first
WHILE
obj
NIL
DO
INC
nofpar
obj
class
cl
obj
type
tp
obj
rdo
rdo
obj
lev
level
obj
val
adr
adr
adr
parsize
obj
obj
next
END
IF
adr
THEN
ORS
Mark
too
many
parameters
END
END
FPSection
PROCEDURE
ProcedureType
ptype
ORB
Type
VAR
parblksize
LONGINT
VAR
obj
ORB
Object
size
LONGINT
nofpar
INTEGER
BEGIN
ptype
base
ORB
noType
size
parblksize
nofpar
ptype
dsc
NIL
IF
sym
ORS
lparen
THEN
ORS
Get
sym
IF
sym
ORS
rparen
THEN
ORS
Get
sym
ELSE
FPSection
size
nofpar
WHILE
sym
ORS
semicolon
DO
ORS
Get
sym
FPSection
size
nofpar
END
Check
ORS
rparen
no
END
IF
sym
ORS
colon
THEN
function
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
ptype
base
obj
type
IF
obj
class
ORB
Typ
obj
type
form
IN
ORB
Byte
ORB
Pointer
ORB
Proc
THEN
ORS
Mark
illegal
function
type
END
ELSE
ORS
Mark
type
identifier
expected
END
END
END
ptype
nofpar
nofpar
parblksize
size
END
ProcedureType
PROCEDURE
FormalType0
VAR
typ
ORB
Type
dim
INTEGER
VAR
obj
ORB
Object
dmy
LONGINT
BEGIN
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
typ
obj
type
ELSE
ORS
Mark
not
a
type
typ
ORB
intType
END
ELSIF
sym
ORS
array
THEN
ORS
Get
sym
Check
ORS
of
OF
IF
dim
THEN
ORS
Mark
multi
dimensional
open
arrays
not
implemented
END
NEW
typ
typ
form
ORB
Array
typ
len
typ
size
ORG
WordSize
FormalType
typ
base
dim
ELSIF
sym
ORS
procedure
THEN
ORS
Get
sym
ORB
OpenScope
NEW
typ
typ
form
ORB
Proc
typ
size
ORG
WordSize
dmy
ProcedureType
typ
dmy
typ
dsc
ORB
topScope
next
ORB
CloseScope
ELSE
ORS
Mark
identifier
expected
typ
ORB
noType
END
END
FormalType0
PROCEDURE
CheckRecLevel
lev
INTEGER
BEGIN
IF
lev
THEN
ORS
Mark
ptr
base
must
be
global
END
END
CheckRecLevel
PROCEDURE
Type0
VAR
type
ORB
Type
VAR
dmy
LONGINT
obj
ORB
Object
ptbase
PtrBase
BEGIN
type
ORB
intType
sync
IF
sym
ORS
ident
sym
ORS
array
THEN
ORS
Mark
not
a
type
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
ident
OR
sym
ORS
array
END
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
IF
obj
type
NIL
obj
type
form
ORB
NoTyp
THEN
type
obj
type
END
ELSE
ORS
Mark
not
a
type
or
undefined
END
ELSIF
sym
ORS
array
THEN
ORS
Get
sym
ArrayType
type
ELSIF
sym
ORS
record
THEN
ORS
Get
sym
RecordType
type
Check
ORS
end
no
END
ELSIF
sym
ORS
pointer
THEN
ORS
Get
sym
Check
ORS
to
no
TO
NEW
type
type
form
ORB
Pointer
type
size
ORG
WordSize
type
base
ORB
intType
IF
sym
ORS
ident
THEN
obj
ORB
thisObj
IF
obj
NIL
THEN
IF
obj
class
ORB
Typ
obj
type
form
IN
ORB
Record
ORB
NoTyp
THEN
CheckRecLevel
obj
lev
type
base
obj
type
ELSIF
obj
class
ORB
Mod
THEN
ORS
Mark
external
base
type
not
implemented
ELSE
ORS
Mark
no
valid
base
type
END
ELSE
CheckRecLevel
level
enter
into
list
of
forward
references
to
be
fixed
in
Declarations
NEW
ptbase
ORS
CopyId
ptbase
name
ptbase
type
type
ptbase
next
pbsList
pbsList
ptbase
END
ORS
Get
sym
ELSE
Type
type
base
IF
type
base
form
ORB
Record
OR
type
base
typobj
NIL
THEN
ORS
Mark
must
point
to
named
record
END
CheckRecLevel
level
END
ELSIF
sym
ORS
procedure
THEN
ORS
Get
sym
ORB
OpenScope
NEW
type
type
form
ORB
Proc
type
size
ORG
WordSize
dmy
ProcedureType
type
dmy
type
dsc
ORB
topScope
next
ORB
CloseScope
ELSE
ORS
Mark
illegal
type
END
END
Type0
PROCEDURE
Declarations
VAR
varsize
LONGINT
VAR
obj
first
ORB
Object
x
ORG
Item
tp
ORB
Type
ptbase
PtrBase
expo
BOOLEAN
id
ORS
Ident
BEGIN
sync
pbsList
NIL
IF
sym
ORS
const
sym
ORS
end
sym
ORS
return
THEN
ORS
Mark
declaration
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
const
OR
sym
ORS
end
OR
sym
ORS
return
END
IF
sym
ORS
const
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
id
ORS
Get
sym
CheckExport
expo
IF
sym
ORS
eql
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
expression
x
IF
x
type
form
ORB
String
x
b
THEN
ORG
StrToChar
x
END
ORB
NewObj
obj
id
ORB
Const
obj
expo
expo
IF
x
mode
ORB
Const
THEN
obj
val
x
a
obj
lev
x
b
obj
type
x
type
ELSE
ORS
Mark
expression
not
constant
obj
type
ORB
intType
END
Check
ORS
semicolon
missing
END
END
IF
sym
ORS
type
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
id
ORS
Get
sym
CheckExport
expo
IF
sym
ORS
eql
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
Type
tp
ORB
NewObj
obj
id
ORB
Typ
obj
type
tp
obj
expo
expo
obj
lev
level
IF
tp
typobj
NIL
THEN
tp
typobj
obj
END
IF
expo
obj
type
form
ORB
Record
THEN
obj
exno
exno
INC
exno
ELSE
obj
exno
END
IF
tp
form
ORB
Record
THEN
ptbase
pbsList
check
whether
this
is
base
of
a
pointer
type
search
and
fixup
WHILE
ptbase
NIL
DO
IF
obj
name
ptbase
name
THEN
ptbase
type
base
obj
type
END
ptbase
ptbase
next
END
IF
level
THEN
ORG
BuildTD
tp
dc
END
type
descriptor
len
used
as
its
address
END
Check
ORS
semicolon
missing
END
END
IF
sym
ORS
var
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
IdentList
ORB
Var
first
Type
tp
obj
first
WHILE
obj
NIL
DO
obj
type
tp
obj
lev
level
IF
tp
size
THEN
varsize
varsize
DIV
align
END
obj
val
varsize
varsize
varsize
obj
type
size
IF
obj
expo
THEN
obj
exno
exno
INC
exno
END
obj
obj
next
END
Check
ORS
semicolon
missing
END
END
varsize
varsize
DIV
ptbase
pbsList
WHILE
ptbase
NIL
DO
IF
ptbase
type
base
form
ORB
Int
THEN
ORS
Mark
undefined
pointer
base
of
END
ptbase
ptbase
next
END
IF
sym
ORS
const
sym
ORS
var
THEN
ORS
Mark
declaration
in
bad
order
END
END
Declarations
PROCEDURE
ProcedureDecl
VAR
proc
ORB
Object
type
ORB
Type
procid
ORS
Ident
x
ORG
Item
locblksize
parblksize
L
LONGINT
int
BOOLEAN
BEGIN
ProcedureDecl
int
FALSE
ORS
Get
sym
IF
sym
ORS
times
THEN
ORS
Get
sym
int
TRUE
END
IF
sym
ORS
ident
THEN
ORS
CopyId
procid
ORS
Get
sym
ORB
NewObj
proc
ORS
id
ORB
Const
IF
int
THEN
parblksize
ELSE
parblksize
END
NEW
type
type
form
ORB
Proc
type
size
ORG
WordSize
proc
type
type
proc
val
proc
lev
level
CheckExport
proc
expo
IF
proc
expo
THEN
proc
exno
exno
INC
exno
END
ORB
OpenScope
INC
level
type
base
ORB
noType
ProcedureType
type
parblksize
formal
parameter
list
Check
ORS
semicolon
no
locblksize
parblksize
Declarations
locblksize
proc
val
ORG
Here
proc
type
dsc
ORB
topScope
next
IF
sym
ORS
procedure
THEN
L
ORG
FJump
L
REPEAT
ProcedureDecl
Check
ORS
semicolon
no
UNTIL
sym
ORS
procedure
ORG
FixOne
L
proc
val
ORG
Here
proc
type
dsc
ORB
topScope
next
END
ORG
Enter
parblksize
locblksize
int
IF
sym
ORS
begin
THEN
ORS
Get
sym
StatSequence
END
IF
sym
ORS
return
THEN
ORS
Get
sym
expression
x
IF
type
base
ORB
noType
THEN
ORS
Mark
this
is
not
a
function
ELSIF
CompTypes
type
base
x
type
FALSE
THEN
ORS
Mark
wrong
result
type
END
ELSIF
type
base
form
ORB
NoTyp
THEN
ORS
Mark
function
without
result
type
base
ORB
noType
END
ORG
Return
type
base
form
x
locblksize
int
ORB
CloseScope
DEC
level
Check
ORS
end
no
END
IF
sym
ORS
ident
THEN
IF
ORS
id
procid
THEN
ORS
Mark
no
match
END
ORS
Get
sym
ELSE
ORS
Mark
no
proc
id
END
END
END
ProcedureDecl
PROCEDURE
Module
VAR
key
LONGINT
impid
impid1
ORS
Ident
BEGIN
Texts
WriteString
W
compiling
ORS
Get
sym
IF
sym
ORS
module
THEN
ORS
Get
sym
IF
sym
ORS
times
THEN
version
Texts
Write
W
ORS
Get
sym
ELSE
version
END
ORB
Init
ORB
OpenScope
IF
sym
ORS
ident
THEN
ORS
CopyId
modid
ORS
Get
sym
Texts
WriteString
W
modid
Texts
Append
Oberon
Log
W
buf
ELSE
ORS
Mark
identifier
expected
END
Check
ORS
semicolon
no
level
dc
exno
key
IF
sym
ORS
import
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
impid
ORS
Get
sym
IF
sym
ORS
becomes
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
ORS
CopyId
impid1
ORS
Get
sym
ELSE
ORS
Mark
id
expected
END
ELSE
impid1
impid
END
ORB
Import
impid
impid1
IF
sym
ORS
comma
THEN
ORS
Get
sym
ELSIF
sym
ORS
ident
THEN
ORS
Mark
comma
missing
END
END
Check
ORS
semicolon
no
END
ORG
Open
version
Declarations
dc
ORG
SetDataSize
dc
DIV
WHILE
sym
ORS
procedure
DO
ProcedureDecl
Check
ORS
semicolon
no
END
ORG
Header
IF
sym
ORS
begin
THEN
ORS
Get
sym
StatSequence
END
Check
ORS
end
no
END
IF
sym
ORS
ident
THEN
IF
ORS
id
modid
THEN
ORS
Mark
no
match
END
ORS
Get
sym
ELSE
ORS
Mark
identifier
missing
END
IF
sym
ORS
period
THEN
ORS
Mark
period
missing
END
IF
ORS
errcnt
version
THEN
ORB
Export
modid
newSF
key
IF
newSF
THEN
Texts
WriteString
W
new
symbol
file
END
END
IF
ORS
errcnt
THEN
ORG
Close
modid
key
exno
Texts
WriteInt
W
ORG
pc
Texts
WriteInt
W
dc
Texts
WriteHex
W
key
ELSE
Texts
WriteLn
W
Texts
WriteString
W
compilation
FAILED
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
ORB
CloseScope
pbsList
NIL
ELSE
ORS
Mark
must
start
with
MODULE
END
END
Module
PROCEDURE
Option
VAR
S
Texts
Scanner
BEGIN
newSF
FALSE
IF
S
nextCh
THEN
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
S
s
s
THEN
newSF
TRUE
END
END
END
Option
PROCEDURE
Compile
VAR
beg
end
time
LONGINT
T
Texts
Text
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
THEN
IF
S
c
THEN
Option
S
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
ORS
Init
T
beg
Module
END
ELSIF
S
c
THEN
Option
S
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
S
s
NEW
T
Texts
Open
T
S
s
IF
T
len
THEN
ORS
Init
T
Module
END
END
END
END
ELSE
WHILE
S
class
Texts
Name
DO
NEW
T
Texts
Open
T
S
s
IF
T
len
THEN
Option
S
ORS
Init
T
Module
ELSE
Texts
WriteString
W
S
s
Texts
WriteString
W
not
found
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
IF
T
len
ORS
errcnt
THEN
Texts
Scan
S
ELSE
S
class
END
END
END
Oberon
Collect
END
Compile
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
OR
Compiler
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
NEW
dummy
dummy
class
ORB
Var
dummy
type
ORB
intType
expression
expression0
Type
Type0
FormalType
FormalType0
END
ORP
MODULE
ORS
NW
Scanner
in
Oberon
IMPORT
SYSTEM
Texts
Oberon
Oberon
Scanner
does
lexical
analysis
Input
is
Oberon
Text
output
is
sequence
of
symbols
i
e
identifiers
numbers
strings
and
special
symbols
Recognises
all
Oberon
keywords
and
skips
comments
The
keywords
are
recorded
in
a
table
Get
sym
delivers
next
symbol
from
input
text
with
Reader
R
Mark
msg
records
error
and
delivers
error
message
with
Writer
W
If
Get
delivers
ident
then
the
identifier
a
string
is
in
variable
id
if
int
or
char
in
ival
if
real
in
rval
and
if
string
in
str
and
slen
CONST
IdLen
NKW
nof
keywords
maxExp
stringBufSize
lexical
symbols
null
times
rdiv
div
mod
and
plus
minus
or
eql
neq
lss
leq
gtr
geq
in
is
arrow
period
char
int
real
false
true
nil
string
not
lparen
lbrak
lbrace
ident
if
while
repeat
case
for
comma
colon
becomes
upto
rparen
rbrak
rbrace
then
of
do
to
by
semicolon
end
bar
else
elsif
until
return
array
record
pointer
const
type
var
procedure
begin
import
module
eot
TYPE
Ident
ARRAY
IdLen
OF
CHAR
VAR
ival
slen
LONGINT
results
of
Get
rval
REAL
id
Ident
for
identifiers
str
ARRAY
stringBufSize
OF
CHAR
errcnt
INTEGER
ch
CHAR
last
character
read
errpos
LONGINT
R
Texts
Reader
W
Texts
Writer
k
INTEGER
KWX
ARRAY
OF
INTEGER
keyTab
ARRAY
NKW
OF
RECORD
sym
INTEGER
id
ARRAY
OF
CHAR
END
PROCEDURE
CopyId
VAR
ident
Ident
BEGIN
ident
id
END
CopyId
PROCEDURE
Pos
LONGINT
BEGIN
RETURN
Texts
Pos
R
END
Pos
PROCEDURE
Mark
msg
ARRAY
OF
CHAR
VAR
p
LONGINT
BEGIN
p
Pos
IF
p
errpos
errcnt
THEN
Texts
WriteLn
W
Texts
WriteString
W
pos
Texts
WriteInt
W
p
Texts
Write
W
Texts
WriteString
W
msg
Texts
Append
Oberon
Log
W
buf
END
INC
errcnt
errpos
p
END
Mark
PROCEDURE
Identifier
VAR
sym
INTEGER
VAR
i
k
INTEGER
BEGIN
i
REPEAT
IF
i
IdLen
THEN
id
i
ch
INC
i
END
Texts
Read
R
ch
UNTIL
ch
OR
ch
ch
A
OR
ch
Z
ch
a
OR
ch
z
id
i
0X
IF
i
THEN
k
KWX
i
search
for
keyword
WHILE
id
keyTab
k
id
k
KWX
i
DO
INC
k
END
IF
k
KWX
i
THEN
sym
keyTab
k
sym
ELSE
sym
ident
END
ELSE
sym
ident
END
END
Identifier
PROCEDURE
String
VAR
i
INTEGER
BEGIN
i
Texts
Read
R
ch
WHILE
R
eot
ch
22X
DO
IF
ch
THEN
IF
i
stringBufSize
THEN
str
i
ch
INC
i
ELSE
Mark
string
too
long
END
END
Texts
Read
R
ch
END
str
i
0X
INC
i
Texts
Read
R
ch
slen
i
END
String
PROCEDURE
HexString
VAR
i
m
n
INTEGER
BEGIN
i
Texts
Read
R
ch
WHILE
R
eot
ch
DO
WHILE
R
eot
ch
DO
Texts
Read
R
ch
END
skip
IF
ch
ch
THEN
m
ORD
ch
30H
ELSIF
A
ch
ch
F
THEN
m
ORD
ch
37H
ELSE
m
Mark
hexdig
expected
END
Texts
Read
R
ch
IF
ch
ch
THEN
n
ORD
ch
30H
ELSIF
A
ch
ch
F
THEN
n
ORD
ch
37H
ELSE
n
Mark
hexdig
expected
END
IF
i
stringBufSize
THEN
str
i
CHR
m
10H
n
INC
i
ELSE
Mark
string
too
long
END
Texts
Read
R
ch
END
Texts
Read
R
ch
slen
i
no
0X
appended
END
HexString
PROCEDURE
Ten
e
LONGINT
REAL
VAR
x
t
REAL
BEGIN
x
t
WHILE
e
DO
IF
ODD
e
THEN
x
t
x
END
t
t
t
e
e
DIV
END
RETURN
x
END
Ten
PROCEDURE
Number
VAR
sym
INTEGER
CONST
max
VAR
i
k
e
n
s
h
LONGINT
x
REAL
d
ARRAY
OF
INTEGER
negE
BOOLEAN
BEGIN
ival
i
n
k
REPEAT
IF
n
THEN
d
n
ORD
ch
30H
INC
n
ELSE
Mark
too
many
digits
n
END
Texts
Read
R
ch
UNTIL
ch
OR
ch
ch
A
OR
ch
F
IF
ch
H
OR
ch
R
OR
ch
X
THEN
hex
REPEAT
h
d
i
IF
h
THEN
h
h
END
k
k
10H
h
INC
i
no
overflow
check
UNTIL
i
n
IF
ch
X
THEN
sym
char
IF
k
100H
THEN
ival
k
ELSE
Mark
illegal
value
ival
END
ELSIF
ch
R
THEN
sym
real
rval
SYSTEM
VAL
REAL
k
ELSE
sym
int
ival
k
END
Texts
Read
R
ch
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
double
dot
ch
7FX
decimal
integer
REPEAT
IF
d
i
THEN
IF
k
max
d
i
DIV
THEN
k
k
d
i
ELSE
Mark
too
large
k
END
ELSE
Mark
bad
integer
END
INC
i
UNTIL
i
n
sym
int
ival
k
ELSE
real
number
x
e
REPEAT
integer
part
x
x
FLT
d
i
INC
i
UNTIL
i
n
WHILE
ch
ch
DO
fraction
x
x
FLT
ORD
ch
30H
DEC
e
Texts
Read
R
ch
END
IF
ch
E
OR
ch
D
THEN
scale
factor
Texts
Read
R
ch
s
IF
ch
THEN
negE
TRUE
Texts
Read
R
ch
ELSE
negE
FALSE
IF
ch
THEN
Texts
Read
R
ch
END
END
IF
ch
ch
THEN
REPEAT
s
s
ORD
ch
30H
Texts
Read
R
ch
UNTIL
ch
OR
ch
IF
negE
THEN
e
e
s
ELSE
e
e
s
END
ELSE
Mark
digit
END
END
IF
e
THEN
IF
e
maxExp
THEN
x
x
Ten
e
ELSE
x
END
ELSIF
e
THEN
IF
e
maxExp
THEN
x
Ten
e
x
ELSE
x
Mark
too
large
END
END
sym
real
rval
x
END
ELSE
decimal
integer
REPEAT
IF
d
i
THEN
IF
k
max
d
i
DIV
THEN
k
k
d
i
ELSE
Mark
too
large
k
END
ELSE
Mark
bad
integer
END
INC
i
UNTIL
i
n
sym
int
ival
k
END
END
Number
PROCEDURE
comment
BEGIN
Texts
Read
R
ch
REPEAT
WHILE
R
eot
ch
DO
IF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
comment
END
ELSE
Texts
Read
R
ch
END
END
WHILE
ch
DO
Texts
Read
R
ch
END
UNTIL
ch
OR
R
eot
IF
R
eot
THEN
Texts
Read
R
ch
ELSE
Mark
unterminated
comment
END
END
comment
PROCEDURE
Get
VAR
sym
INTEGER
BEGIN
REPEAT
WHILE
R
eot
ch
DO
Texts
Read
R
ch
END
IF
R
eot
THEN
sym
eot
ELSIF
ch
A
THEN
IF
ch
THEN
IF
ch
22X
THEN
String
sym
string
ELSIF
ch
THEN
Texts
Read
R
ch
sym
neq
ELSIF
ch
THEN
HexString
sym
string
ELSIF
ch
THEN
Texts
Read
R
ch
sym
and
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
sym
null
comment
ELSE
sym
lparen
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
rparen
ELSIF
ch
THEN
Texts
Read
R
ch
sym
times
ELSIF
ch
THEN
Texts
Read
R
ch
sym
plus
ELSIF
ch
THEN
Texts
Read
R
ch
sym
comma
ELSIF
ch
THEN
Texts
Read
R
ch
sym
minus
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
upto
ELSE
sym
period
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
rdiv
ELSE
Texts
Read
R
ch
sym
null
END
ELSIF
ch
THEN
Number
sym
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
becomes
ELSE
sym
colon
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
semicolon
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
leq
ELSE
sym
lss
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
eql
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
geq
ELSE
sym
gtr
END
ELSE
Texts
Read
R
ch
sym
null
END
ELSIF
ch
THEN
Identifier
sym
ELSIF
ch
a
THEN
IF
ch
THEN
sym
lbrak
ELSIF
ch
THEN
sym
rbrak
ELSIF
ch
THEN
sym
arrow
ELSE
sym
null
END
Texts
Read
R
ch
ELSIF
ch
THEN
Identifier
sym
ELSE
IF
ch
THEN
sym
lbrace
ELSIF
ch
THEN
sym
rbrace
ELSIF
ch
THEN
sym
bar
ELSIF
ch
THEN
sym
not
ELSIF
ch
7FX
THEN
sym
upto
ELSE
sym
null
END
Texts
Read
R
ch
END
UNTIL
sym
null
END
Get
PROCEDURE
Init
T
Texts
Text
pos
LONGINT
BEGIN
errpos
pos
errcnt
Texts
OpenReader
R
T
pos
Texts
Read
R
ch
END
Init
PROCEDURE
EnterKW
sym
INTEGER
name
ARRAY
OF
CHAR
BEGIN
keyTab
k
id
name
keyTab
k
sym
sym
INC
k
END
EnterKW
BEGIN
Texts
OpenWriter
W
k
KWX
KWX
EnterKW
if
IF
EnterKW
do
DO
EnterKW
of
OF
EnterKW
or
OR
EnterKW
to
TO
EnterKW
in
IN
EnterKW
is
IS
EnterKW
by
BY
KWX
k
EnterKW
end
END
EnterKW
nil
NIL
EnterKW
var
VAR
EnterKW
div
DIV
EnterKW
mod
MOD
EnterKW
for
FOR
KWX
k
EnterKW
else
ELSE
EnterKW
then
THEN
EnterKW
true
TRUE
EnterKW
type
TYPE
EnterKW
case
CASE
KWX
k
EnterKW
elsif
ELSIF
EnterKW
false
FALSE
EnterKW
array
ARRAY
EnterKW
begin
BEGIN
EnterKW
const
CONST
EnterKW
until
UNTIL
EnterKW
while
WHILE
KWX
k
EnterKW
record
RECORD
EnterKW
repeat
REPEAT
EnterKW
return
RETURN
EnterKW
import
IMPORT
EnterKW
module
MODULE
KWX
k
EnterKW
pointer
POINTER
KWX
k
KWX
k
EnterKW
procedure
PROCEDURE
KWX
k
END
ORS
MODULE
ORTool
NW
IMPORT
SYSTEM
Files
Texts
Oberon
ORB
VAR
W
Texts
Writer
Form
INTEGER
result
of
ReadType
mnemo0
mnemo1
ARRAY
OF
CHAR
mnemonics
PROCEDURE
Read
VAR
R
Files
Rider
VAR
n
INTEGER
VAR
b
BYTE
BEGIN
Files
ReadByte
R
b
IF
b
80H
THEN
n
b
ELSE
n
b
100H
END
END
Read
PROCEDURE
ReadType
VAR
R
Files
Rider
VAR
key
len
lev
size
off
INTEGER
ref
mno
class
form
readonly
INTEGER
name
modname
ARRAY
OF
CHAR
BEGIN
Read
R
ref
Texts
Write
W
Texts
Write
W
IF
ref
THEN
Texts
Write
W
Texts
WriteInt
W
ref
ELSE
Texts
WriteInt
W
ref
Read
R
form
Texts
WriteString
W
form
Texts
WriteInt
W
form
IF
form
ORB
Pointer
THEN
ReadType
R
ELSIF
form
ORB
Array
THEN
ReadType
R
Files
ReadNum
R
len
Files
ReadNum
R
size
Texts
WriteString
W
len
Texts
WriteInt
W
len
Texts
WriteString
W
size
Texts
WriteInt
W
size
ELSIF
form
ORB
Record
THEN
ReadType
R
base
type
Files
ReadNum
R
off
Texts
WriteString
W
exno
Texts
WriteInt
W
off
Files
ReadNum
R
off
Texts
WriteString
W
extlev
Texts
WriteInt
W
off
Files
ReadNum
R
size
Texts
WriteString
W
size
Texts
WriteInt
W
size
Texts
Write
W
Texts
Write
W
Read
R
class
WHILE
class
DO
fields
Files
ReadString
R
name
IF
name
0X
THEN
Texts
Write
W
Texts
WriteString
W
name
ReadType
R
ELSE
Texts
WriteString
W
END
Files
ReadNum
R
off
Texts
WriteInt
W
off
Read
R
class
END
Texts
Write
W
ELSIF
form
ORB
Proc
THEN
ReadType
R
Texts
Write
W
Read
R
class
WHILE
class
DO
Texts
WriteString
W
class
Texts
WriteInt
W
class
Read
R
readonly
IF
readonly
THEN
Texts
Write
W
END
ReadType
R
Read
R
class
END
Texts
Write
W
END
Files
ReadString
R
modname
IF
modname
0X
THEN
Files
ReadInt
R
key
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
modname
Texts
Write
W
Texts
WriteString
W
name
Texts
WriteHex
W
key
END
END
Form
form
Texts
Write
W
END
ReadType
PROCEDURE
DecSym
decode
symbol
file
VAR
class
typno
k
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
OR
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadInt
R
k
Files
ReadInt
R
k
Files
ReadString
R
name
Texts
WriteString
W
name
Texts
WriteHex
W
k
Read
R
class
Texts
WriteInt
W
class
sym
file
version
IF
class
ORB
versionkey
THEN
Texts
WriteLn
W
Read
R
class
WHILE
class
DO
Texts
WriteInt
W
class
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
ReadType
R
IF
class
ORB
Typ
THEN
Texts
Write
W
Read
R
class
WHILE
class
DO
pointer
base
fixup
Texts
WriteString
W
Texts
WriteInt
W
class
Read
R
class
END
Texts
Write
W
ELSIF
class
ORB
Const
OR
class
ORB
Var
THEN
Files
ReadNum
R
k
Texts
WriteInt
W
k
Reals
Strings
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Read
R
class
END
ELSE
Texts
WriteString
W
bad
symfile
version
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecSym
PROCEDURE
WriteReg
r
LONGINT
BEGIN
Texts
Write
W
IF
r
THEN
Texts
WriteString
W
R
Texts
WriteInt
W
r
MOD
10H
ELSIF
r
THEN
Texts
WriteString
W
MT
ELSIF
r
THEN
Texts
WriteString
W
SB
ELSIF
r
THEN
Texts
WriteString
W
SP
ELSE
Texts
WriteString
W
LNK
END
END
WriteReg
PROCEDURE
opcode
w
LONGINT
VAR
k
op
u
a
b
c
LONGINT
BEGIN
k
w
DIV
40000000H
MOD
a
w
DIV
1000000H
MOD
10H
b
w
DIV
100000H
MOD
10H
op
w
DIV
10000H
MOD
10H
u
w
DIV
20000000H
MOD
IF
k
THEN
Texts
WriteString
W
mnemo0
op
IF
u
THEN
Texts
Write
W
END
WriteReg
a
WriteReg
b
WriteReg
w
MOD
10H
ELSIF
k
THEN
Texts
WriteString
W
mnemo0
op
IF
u
THEN
Texts
Write
W
END
WriteReg
a
WriteReg
b
w
w
MOD
10000H
IF
w
8000H
THEN
w
w
10000H
END
Texts
WriteInt
W
w
ELSIF
k
THEN
LDR
STR
IF
u
THEN
Texts
WriteString
W
STR
ELSE
Texts
WriteString
W
LDR
END
WriteReg
a
WriteReg
b
w
w
MOD
100000H
IF
w
80000H
THEN
w
w
100000H
END
Texts
WriteInt
W
w
ELSIF
k
THEN
Branch
instr
Texts
Write
W
B
IF
ODD
w
DIV
10000000H
THEN
Texts
Write
W
L
END
Texts
WriteString
W
mnemo1
a
IF
u
THEN
WriteReg
w
MOD
10H
ELSE
w
w
MOD
100000H
IF
w
80000H
THEN
w
w
100000H
END
Texts
WriteInt
W
w
END
END
END
opcode
PROCEDURE
Sync
VAR
R
Files
Rider
VAR
ch
CHAR
BEGIN
Files
Read
R
ch
Texts
WriteString
W
Sync
Texts
Write
W
ch
Texts
WriteLn
W
END
Sync
PROCEDURE
Write
VAR
R
Files
Rider
x
INTEGER
BEGIN
Files
WriteByte
R
x
x
END
Write
PROCEDURE
DecObj
decode
object
file
VAR
class
i
n
key
size
fix
adr
data
len
INTEGER
ch
CHAR
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadString
R
name
Texts
WriteLn
W
Texts
WriteString
W
name
Files
ReadInt
R
key
Texts
WriteHex
W
key
Read
R
class
Texts
WriteInt
W
class
version
Files
ReadInt
R
size
Texts
WriteInt
W
size
Texts
WriteLn
W
Texts
WriteString
W
imports
Texts
WriteLn
W
Files
ReadString
R
name
WHILE
name
0X
DO
Texts
Write
W
9X
Texts
WriteString
W
name
Files
ReadInt
R
key
Texts
WriteHex
W
key
Texts
WriteLn
W
Files
ReadString
R
name
END
Sync
R
Texts
WriteString
W
type
descriptors
Texts
WriteLn
W
Files
ReadInt
R
n
n
n
DIV
i
WHILE
i
n
DO
Files
ReadInt
R
data
Texts
WriteHex
W
data
INC
i
END
Texts
WriteLn
W
Texts
WriteString
W
data
Files
ReadInt
R
data
Texts
WriteInt
W
data
Texts
WriteLn
W
Texts
WriteString
W
strings
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
Read
R
ch
Texts
Write
W
ch
INC
i
END
Texts
WriteLn
W
Texts
WriteString
W
code
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
ReadInt
R
data
Texts
WriteInt
W
i
Texts
Write
W
9X
Texts
WriteHex
W
data
Texts
Write
W
9X
opcode
data
Texts
WriteLn
W
INC
i
END
Sync
R
Texts
WriteString
W
commands
Texts
WriteLn
W
Files
ReadString
R
name
WHILE
name
0X
DO
Texts
Write
W
9X
Texts
WriteString
W
name
Files
ReadInt
R
adr
Texts
WriteInt
W
adr
Texts
WriteLn
W
Files
ReadString
R
name
END
Sync
R
Texts
WriteString
W
entries
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
ReadInt
R
adr
Texts
WriteInt
W
adr
INC
i
END
Texts
WriteLn
W
Sync
R
Texts
WriteString
W
pointer
refs
Texts
WriteLn
W
Files
ReadInt
R
adr
WHILE
adr
DO
Texts
WriteInt
W
adr
Files
ReadInt
R
adr
END
Texts
WriteLn
W
Sync
R
Files
ReadInt
R
data
Texts
WriteString
W
fixP
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
fixD
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
fixT
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
entry
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
Read
R
ch
IF
ch
O
THEN
Texts
WriteString
W
format
eror
Texts
WriteLn
W
END
Sync
R
ELSE
Texts
WriteString
W
not
found
Texts
WriteLn
W
END
Texts
Append
Oberon
Log
W
buf
END
END
DecObj
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
ORTool
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
mnemo0
MOV
mnemo0
LSL
mnemo0
ASR
mnemo0
ROR
mnemo0
AND
mnemo0
ANN
mnemo0
IOR
mnemo0
XOR
mnemo0
ADD
mnemo0
SUB
mnemo0
MUL
mnemo0
DIV
mnemo0
FAD
mnemo0
FSB
mnemo0
FML
mnemo0
FDV
mnemo1
MI
mnemo1
PL
mnemo1
EQ
mnemo1
NE
mnemo1
LS
mnemo1
HI
mnemo1
LT
mnemo1
GE
mnemo1
LE
mnemo1
GT
mnemo1
NO
END
ORTool
MODULE
Rectangles
NW
IMPORT
SYSTEM
Display
Files
Input
Texts
Oberon
Graphics
GraphicFrames
TYPE
Rectangle
POINTER
TO
RectDesc
RectDesc
RECORD
Graphics
ObjectDesc
lw
vers
INTEGER
END
VAR
method
Graphics
Method
tack
grey
INTEGER
PROCEDURE
New
VAR
r
Rectangle
BEGIN
NEW
r
r
do
method
Graphics
New
r
END
New
PROCEDURE
Copy
src
dst
Graphics
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Rectangle
lw
src
Rectangle
lw
dst
Rectangle
vers
src
Rectangle
vers
END
Copy
PROCEDURE
mark
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
GraphicFrames
ReplConst
f
col
x
y
END
mark
PROCEDURE
Draw
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
lw
col
INTEGER
f
GraphicFrames
Frame
PROCEDURE
draw
f
GraphicFrames
Frame
col
x
y
w
h
lw
INTEGER
BEGIN
GraphicFrames
ReplConst
f
col
x
y
w
lw
Display
replace
GraphicFrames
ReplConst
f
col
x
w
lw
y
lw
h
Display
replace
GraphicFrames
ReplConst
f
col
x
y
h
lw
w
lw
Display
replace
GraphicFrames
ReplConst
f
col
x
y
lw
h
Display
replace
END
draw
BEGIN
CASE
M
OF
GraphicFrames
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
lw
obj
Rectangle
lw
IF
x
f
X1
x
w
f
X
y
f
Y1
y
h
f
Y
THEN
IF
M
col
Display
black
THEN
col
obj
col
ELSE
col
M
col
END
IF
M
mode
THEN
draw
f
col
x
y
w
h
lw
IF
obj
selected
THEN
mark
f
Display
white
x
y
END
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
normal
selected
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
selected
normal
ELSIF
M
mode
THEN
draw
f
Display
black
x
y
w
h
lw
mark
f
Display
black
x
y
erase
END
END
END
END
Draw
PROCEDURE
Selectable
obj
Graphics
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
y
y
y
obj
y
END
Selectable
PROCEDURE
Change
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x0
y0
x1
y1
dx
dy
INTEGER
k
SET
BEGIN
CASE
M
OF
Graphics
WidMsg
obj
Rectangle
lw
M
w
Graphics
ColorMsg
obj
col
M
col
END
END
Change
PROCEDURE
Read
obj
Graphics
Object
VAR
R
Files
Rider
VAR
C
Graphics
Context
VAR
b
BYTE
len
INTEGER
BEGIN
Files
ReadByte
R
b
len
Files
ReadByte
R
b
obj
Rectangle
lw
b
Files
ReadByte
R
b
obj
Rectangle
vers
b
END
Read
PROCEDURE
Write
obj
Graphics
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Graphics
Context
BEGIN
Graphics
WriteObj
W
cno
obj
Files
WriteByte
W
Files
WriteByte
W
obj
Rectangle
lw
Files
WriteByte
W
obj
Rectangle
vers
END
Write
PROCEDURE
Print
obj
Graphics
Object
x
y
INTEGER
VAR
w
h
lw
s
INTEGER
BEGIN
INC
x
obj
x
INC
y
obj
y
w
obj
w
h
obj
h
lw
obj
Rectangle
lw
s
obj
Rectangle
vers
Printer
ReplConst
x
y
w
lw
Printer
ReplConst
x
w
lw
y
lw
h
Printer
ReplConst
x
y
h
lw
w
lw
Printer
ReplConst
x
y
lw
h
IF
s
THEN
Printer
ReplPattern
x
y
w
h
s
END
END
Print
PROCEDURE
Make
command
VAR
x0
x1
y0
y1
INTEGER
R
Rectangle
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
x1
G
mark
next
x
y1
G
mark
next
y
NEW
R
R
col
Oberon
CurCol
R
w
ABS
x1
x0
R
h
ABS
y1
y0
IF
x1
x0
THEN
x0
x1
END
IF
y1
y0
THEN
y0
y1
END
R
x
x0
G
x
R
y
y0
G
y
R
lw
Graphics
width
R
vers
R
do
method
Graphics
Add
G
graph
R
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
R
END
END
Make
BEGIN
NEW
method
method
module
Rectangles
method
allocator
New
method
new
New
method
copy
Copy
method
draw
Draw
method
selectable
Selectable
method
change
Change
method
read
Read
method
write
Write
method
print
Print
tack
SYSTEM
ADR
grey
SYSTEM
ADR
END
Rectangles
MODULE
SCC
NW
Ceres
nRF24L01
version
PR
IMPORT
SYSTEM
Kernel
CONST
swi
spiData
spiCtrl
netSelect
spiFast
netEnable
HdrSize
MaxPayload
SubPacket
Wait
SendTries
MaxPacket
HdrSize
MaxPayload
SubPacket
DIV
SubPacket
SubPacket
TYPE
Header
RECORD
valid
BOOLEAN
dadr
sadr
typ
BYTE
len
INTEGER
of
data
following
header
END
VAR
filter
BOOLEAN
Adr
BYTE
rcvd
INTEGER
rx
RECORD
hd
Header
dat
ARRAY
MaxPacket
HdrSize
OF
BYTE
END
PROCEDURE
SPICtrl
s
SET
BEGIN
SYSTEM
PUT
spiCtrl
s
IF
netEnable
IN
s
THEN
LED
55H
ELSE
LED
END
END
SPICtrl
PROCEDURE
SPI
n
INTEGER
BEGIN
send
rcv
into
shift
reg
one
byte
or
word
at
current
speed
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
wait
until
done
END
SPI
PROCEDURE
StartCmd
cmd
INTEGER
BEGIN
SPICtrl
netSelect
SPI
cmd
END
StartCmd
PROCEDURE
WriteReg1
reg
dat
INTEGER
disables
radio
BEGIN
StartCmd
reg
20H
SPI
dat
SPICtrl
W
REGISTER
END
WriteReg1
PROCEDURE
SubRcv
dst
INTEGER
VAR
i
dat
INTEGER
BEGIN
StartCmd
061H
R
RX
PAYLOAD
disables
radio
SPICtrl
netSelect
spiFast
FOR
i
TO
SubPacket
BY
DO
SPI
SYSTEM
GET
spiData
dat
SYSTEM
PUT
dst
i
dat
END
SPICtrl
WriteReg1
40H
done
STATUS
clear
RX
DR
SPICtrl
netEnable
enable
radio
END
SubRcv
PROCEDURE
SubSnd
src
INTEGER
VAR
timeout
BOOLEAN
VAR
i
dat
res
t1
try
INTEGER
x
status
BYTE
BEGIN
already
in
xmit
mode
StartCmd
0A0H
W
TX
PAYLOAD
SPICtrl
netSelect
spiFast
FOR
i
TO
SubPacket
BY
DO
SYSTEM
GET
src
i
dat
SPI
dat
END
SPICtrl
end
W
TX
PAYLOAD
command
try
SPICtrl
netEnable
netSelect
start
xmit
pulse
start
NOP
cmd
REPEAT
t1
Kernel
Time
Wait
REPEAT
wait
for
sent
or
retransmits
exceeded
SPI
0FFH
SYSTEM
GET
spiData
status
NOP
res
status
DIV
10H
MOD
SPICtrl
SPICtrl
netSelect
end
restart
NOP
cmd
end
10us
pulse
on
enable
UNTIL
res
IF
res
THEN
WriteReg1
20H
TX
DS
sent
ack
received
reset
it
ELSIF
res
THEN
WriteReg1
10H
INC
try
MAX
RT
retransmits
exceeded
reset
it
IF
try
SendTries
THEN
res
ELSE
REPEAT
UNTIL
Kernel
Time
t1
SPICtrl
netEnable
netSelect
start
xmit
pulse
start
NOP
cmd
again
END
END
UNTIL
res
timeout
res
END
SubSnd
PROCEDURE
Flush
BEGIN
StartCmd
0E1H
SPICtrl
StartCmd
0E2H
SPICtrl
FLUSH
TX
FLUSH
RX
END
Flush
PROCEDURE
ResetRcv
BEGIN
SYSTEM
PUT
SYSTEM
ADR
rx
rx
hd
len
rcvd
END
ResetRcv
PROCEDURE
Listen
b
BOOLEAN
BEGIN
WriteReg1
07EH
ORD
b
CONFIG
mask
ints
EN
CRC
byte
PWR
UP
PRX
PTX
WriteReg1
70H
STATUS
clear
ints
IF
b
THEN
SPICtrl
netEnable
END
turn
radio
on
END
Listen
PROCEDURE
Start
filt
BOOLEAN
VAR
n
INTEGER
BEGIN
filter
filt
Adr
SYSTEM
GET
swi
n
n
n
DIV
MOD
10H
WriteReg1
n
RF
CH
channel
WriteReg1
07H
RF
SETUP
1Mb
for
better
range
0dBm
WriteReg1
11H
SubPacket
RX
PW
P0
pipe
payload
width
Flush
Listen
TRUE
ResetRcv
END
Start
PROCEDURE
SendPacket
VAR
head
Header
dat
ARRAY
OF
BYTE
VAR
len
i
off
INTEGER
timeout
BOOLEAN
payload
ARRAY
SubPacket
OF
BYTE
BEGIN
let
any
receive
ack
finish
before
turning
radio
off
i
Kernel
Time
Wait
REPEAT
SPICtrl
netEnable
netSelect
SPI
0FFH
SPICtrl
netEnable
NOP
UNTIL
Kernel
Time
i
IF
Adr
THEN
Adr
i
MOD
100H
END
Listen
FALSE
head
sadr
Adr
head
valid
TRUE
SYSTEM
COPY
SYSTEM
ADR
head
SYSTEM
ADR
payload
HdrSize
DIV
i
HdrSize
off
len
head
len
WHILE
len
i
SubPacket
DO
payload
i
dat
off
INC
i
INC
off
DEC
len
END
WHILE
i
SubPacket
DO
payload
i
INC
i
END
SubSnd
SYSTEM
ADR
payload
timeout
WHILE
timeout
len
DO
i
send
the
rest
WHILE
len
i
SubPacket
DO
payload
i
dat
off
INC
i
INC
off
DEC
len
END
WHILE
i
SubPacket
DO
payload
i
INC
i
END
SubSnd
SYSTEM
ADR
payload
timeout
END
Listen
TRUE
END
SendPacket
PROCEDURE
Available
INTEGER
BEGIN
packet
already
rcvd
RETURN
rx
hd
len
rcvd
END
Available
PROCEDURE
Receive
VAR
x
BYTE
BEGIN
packet
already
rcvd
IF
rcvd
rx
hd
len
THEN
x
rx
dat
rcvd
INC
rcvd
ELSE
x
END
END
Receive
PROCEDURE
Rcvd
time
INTEGER
BOOLEAN
VAR
status
fifoStatus
BYTE
rcvd
BOOLEAN
BEGIN
time
time
Kernel
Time
REPEAT
SPICtrl
netEnable
netSelect
SPI
17H
R
REGISTER
FIFO
STATUS
SYSTEM
GET
spiData
status
SPI
SYSTEM
GET
spiData
fifoStatus
SPICtrl
netEnable
rcvd
ODD
status
DIV
40H
OR
ODD
fifoStatus
RX
DR
data
ready
or
RX
FIFO
not
empty
UNTIL
rcvd
OR
Kernel
Time
time
RETURN
rcvd
END
Rcvd
PROCEDURE
ReceiveHead
VAR
head
Header
actually
recv
whole
packet
VAR
adr
n
INTEGER
BEGIN
head
valid
FALSE
IF
Rcvd
THEN
ResetRcv
adr
SYSTEM
ADR
rx
SubRcv
adr
n
rx
hd
len
HdrSize
DIV
SubPacket
IF
rx
hd
len
MaxPayload
rx
hd
dadr
0FFH
OR
filter
OR
Adr
OR
rx
hd
dadr
Adr
THEN
WHILE
n
Rcvd
Wait
DO
INC
adr
SubPacket
SubRcv
adr
DEC
n
END
rx
hd
valid
n
ELSE
WHILE
Rcvd
Wait
DO
SubRcv
adr
END
ResetRcv
discard
packet
END
head
rx
hd
END
END
ReceiveHead
PROCEDURE
Skip
m
INTEGER
VAR
dmy
BYTE
BEGIN
WHILE
m
DO
Receive
dmy
DEC
m
END
END
Skip
PROCEDURE
Stop
BEGIN
SPICtrl
Flush
ResetRcv
END
Stop
BEGIN
Start
TRUE
END
SCC
MODULE
System
JG
NW
NW
IMPORT
SYSTEM
Kernel
FileDir
Files
Modules
Input
Display
Viewers
Fonts
Texts
Oberon
MenuViewers
TextFrames
CONST
StandardMenu
System
Close
System
Copy
System
Grow
Edit
Search
Edit
Store
LogMenu
Edit
Locate
Edit
Search
System
Copy
System
Grow
System
Clear
VAR
W
Texts
Writer
pat
ARRAY
OF
CHAR
PROCEDURE
GetArg
VAR
S
Texts
Scanner
VAR
T
Texts
Text
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
END
GetArg
PROCEDURE
EndLine
BEGIN
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
EndLine
Toolbox
for
system
control
PROCEDURE
SetUser
VAR
i
INTEGER
ch
CHAR
user
ARRAY
OF
CHAR
password
ARRAY
OF
CHAR
BEGIN
i
Input
Read
ch
WHILE
ch
i
DO
user
i
ch
INC
i
Input
Read
ch
END
user
i
0X
i
Input
Read
ch
WHILE
ch
i
DO
password
i
ch
INC
i
Input
Read
ch
END
password
i
0X
Oberon
SetUser
user
password
END
SetUser
PROCEDURE
SetFont
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Oberon
SetFont
Fonts
This
S
s
END
END
SetFont
PROCEDURE
SetColor
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
Oberon
SetColor
S
i
END
END
SetColor
PROCEDURE
SetOffset
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
Oberon
SetOffset
S
i
END
END
SetOffset
PROCEDURE
Date
VAR
S
Texts
Scanner
dt
hr
min
sec
yr
mo
day
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
set
clock
day
S
i
Texts
Scan
S
mo
S
i
Texts
Scan
S
yr
S
i
Texts
Scan
S
hr
S
i
Texts
Scan
S
min
S
i
Texts
Scan
S
sec
S
i
dt
yr
mo
day
hr
min
sec
Kernel
SetClock
dt
ELSE
read
clock
Texts
WriteString
W
System
Clock
dt
Oberon
Clock
Texts
WriteClock
W
dt
EndLine
END
END
Date
PROCEDURE
Collect
BEGIN
Oberon
Collect
END
Collect
Toolbox
for
standard
display
PROCEDURE
Open
open
viewer
in
system
track
VAR
X
Y
INTEGER
V
Viewers
Viewer
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Clear
clear
Log
VAR
T
Texts
Text
F
Display
Frame
buf
Texts
Buffer
BEGIN
F
Oberon
Par
frame
IF
F
NIL
F
next
IS
TextFrames
Frame
F
Oberon
Par
vwr
dsc
THEN
NEW
buf
Texts
OpenBuf
buf
T
F
next
TextFrames
Frame
text
Texts
Delete
T
T
len
buf
END
END
Clear
PROCEDURE
Close
VAR
V
Viewers
Viewer
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
V
Oberon
Par
vwr
ELSE
V
Oberon
MarkedViewer
END
Viewers
Close
V
END
Close
PROCEDURE
CloseTrack
VAR
V
Viewers
Viewer
BEGIN
V
Oberon
MarkedViewer
Viewers
CloseTrack
V
X
END
CloseTrack
PROCEDURE
Recall
VAR
V
Viewers
Viewer
M
Viewers
ViewerMsg
BEGIN
Viewers
Recall
V
IF
V
NIL
V
state
THEN
Viewers
Open
V
V
X
V
Y
V
H
M
id
Viewers
restore
V
handle
V
M
END
END
Recall
PROCEDURE
Copy
VAR
V
V1
Viewers
Viewer
M
Oberon
CopyMsg
N
Viewers
ViewerMsg
BEGIN
V
Oberon
Par
vwr
V
handle
V
M
V1
M
F
Viewers
Viewer
Viewers
Open
V1
V
X
V
Y
V
H
DIV
N
id
Viewers
restore
V1
handle
V1
N
END
Copy
PROCEDURE
Grow
VAR
V
V1
Viewers
Viewer
M
Oberon
CopyMsg
N
Viewers
ViewerMsg
DW
DH
INTEGER
BEGIN
V
Oberon
Par
vwr
DW
Oberon
DisplayWidth
V
X
DH
Oberon
DisplayHeight
V
X
IF
V
H
DH
Viewers
minH
THEN
Oberon
OpenTrack
V
X
V
W
ELSIF
V
W
DW
THEN
Oberon
OpenTrack
Oberon
UserTrack
V
X
DW
END
IF
V
H
DH
Viewers
minH
OR
V
W
DW
THEN
V
handle
V
M
V1
M
F
Viewers
Viewer
Viewers
Open
V1
V
X
DH
N
id
Viewers
restore
V1
handle
V1
N
END
END
Grow
Toolbox
for
module
management
PROCEDURE
Free1
VAR
S
Texts
Scanner
BEGIN
Texts
WriteString
W
S
s
Texts
WriteString
W
unloading
Modules
Free
S
s
IF
Modules
res
THEN
Texts
WriteString
W
failed
END
EndLine
END
Free1
PROCEDURE
Free
VAR
T
Texts
Text
beg
end
time
LONGINT
S
Texts
Scanner
BEGIN
Texts
WriteString
W
System
Free
EndLine
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Free1
S
END
END
ELSE
WHILE
S
class
Texts
Name
DO
Free1
S
Texts
Scan
S
END
END
Oberon
Collect
END
Free
PROCEDURE
FreeFonts
BEGIN
Texts
WriteString
W
System
FreeFonts
Fonts
Free
EndLine
END
FreeFonts
Toolbox
of
file
system
PROCEDURE
List
name
FileDir
FileName
adr
LONGINT
VAR
cont
BOOLEAN
VAR
i0
i
j0
j
INTEGER
hp
FileDir
FileHeader
BEGIN
i
WHILE
pat
i
pat
i
name
i
DO
INC
i
END
IF
pat
i
0X
name
i
0X
THEN
i0
i
j0
i
ELSIF
pat
i
THEN
i0
i
j0
i
WHILE
name
i0
0X
DO
i
i0
j
j0
WHILE
name
i
0X
name
i
pat
j
DO
INC
i
INC
j
END
IF
pat
j
0X
THEN
IF
name
i
0X
THEN
match
j0
j
ELSE
INC
i0
END
ELSIF
pat
j
THEN
i0
i
j0
j
ELSE
INC
i0
END
END
END
IF
name
i0
0X
pat
j0
0X
THEN
found
Texts
WriteString
W
name
IF
pat
j0
THEN
option
Kernel
GetSector
adr
hp
Texts
Write
W
9X
Texts
WriteClock
W
hp
date
Texts
WriteInt
W
hp
aleng
FileDir
SectorSize
hp
bleng
FileDir
HeaderSize
length
Texts
WriteHex
W
adr
END
Texts
WriteLn
W
END
END
List
PROCEDURE
Directory
VAR
X
Y
i
INTEGER
ch
CHAR
R
Texts
Reader
T
t
Texts
Text
V
Viewers
Viewer
beg
end
time
LONGINT
pre
ARRAY
OF
CHAR
BEGIN
Texts
OpenReader
R
Oberon
Par
text
Oberon
Par
pos
Texts
Read
R
ch
WHILE
ch
DO
Texts
Read
R
ch
END
IF
ch
OR
ch
0DX
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenReader
R
T
beg
Texts
Read
R
ch
WHILE
ch
DO
Texts
Read
R
ch
END
END
END
i
WHILE
ch
DO
pat
i
ch
INC
i
Texts
Read
R
ch
END
pat
i
0X
IF
ch
THEN
pat
i
END
directory
option
i
WHILE
pat
i
DO
pre
i
pat
i
INC
i
END
pre
i
0X
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
t
TextFrames
Text
V
MenuViewers
New
TextFrames
NewMenu
System
Directory
StandardMenu
TextFrames
NewText
t
TextFrames
menuH
X
Y
FileDir
Enumerate
pre
List
Texts
Append
t
W
buf
END
Directory
PROCEDURE
CopyFiles
VAR
f
g
Files
File
Rf
Rg
Files
Rider
ch
CHAR
name
ARRAY
OF
CHAR
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
CopyFiles
EndLine
WHILE
S
class
Texts
Name
DO
name
S
s
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteString
W
copying
Texts
Append
Oberon
Log
W
buf
f
Files
Old
name
IF
f
NIL
THEN
g
Files
New
S
s
Files
Set
Rf
f
Files
Set
Rg
g
Files
Read
Rf
ch
WHILE
Rf
eof
DO
Files
Write
Rg
ch
Files
Read
Rf
ch
END
Files
Register
g
ELSE
Texts
WriteString
W
failed
END
EndLine
END
END
END
Texts
Scan
S
END
END
CopyFiles
PROCEDURE
RenameFiles
VAR
res
INTEGER
name
ARRAY
OF
CHAR
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
RenameFiles
EndLine
WHILE
S
class
Texts
Name
DO
name
S
s
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteString
W
renaming
Files
Rename
name
S
s
res
IF
res
THEN
Texts
WriteString
W
failed
END
EndLine
END
END
END
Texts
Scan
S
END
END
RenameFiles
PROCEDURE
DeleteFiles
VAR
res
INTEGER
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
DeleteFiles
EndLine
WHILE
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
Texts
WriteString
W
deleting
Files
Delete
S
s
res
IF
res
THEN
Texts
WriteString
W
failed
END
EndLine
Texts
Scan
S
END
END
DeleteFiles
Toolbox
for
system
inspection
PROCEDURE
Watch
BEGIN
Texts
WriteString
W
System
Watch
Texts
WriteLn
W
Texts
WriteString
W
Modules
space
bytes
Texts
WriteInt
W
Modules
AllocPtr
Texts
WriteInt
W
Modules
AllocPtr
DIV
Kernel
heapOrg
Texts
Write
W
EndLine
Texts
WriteString
W
Heap
speace
Texts
WriteInt
W
Kernel
allocated
Texts
WriteInt
W
Kernel
allocated
DIV
Kernel
heapLim
Kernel
heapOrg
Texts
Write
W
EndLine
Texts
WriteString
W
Disk
sectors
Texts
WriteInt
W
Kernel
NofSectors
Texts
WriteInt
W
Kernel
NofSectors
DIV
10000H
Texts
Write
W
EndLine
Texts
WriteString
W
Tasks
Texts
WriteInt
W
Oberon
NofTasks
EndLine
END
Watch
PROCEDURE
ShowModules
VAR
T
Texts
Text
V
Viewers
Viewer
M
Modules
Module
X
Y
INTEGER
BEGIN
T
TextFrames
Text
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
System
ShowModules
StandardMenu
TextFrames
NewText
T
TextFrames
menuH
X
Y
M
Modules
root
WHILE
M
NIL
DO
IF
M
name
0X
THEN
Texts
WriteString
W
M
name
Texts
Write
W
9X
Texts
WriteHex
W
ORD
M
Texts
WriteHex
W
M
code
Texts
WriteInt
W
M
refcnt
ELSE
Texts
WriteString
W
END
Texts
WriteLn
W
M
M
next
END
Texts
Append
T
W
buf
END
ShowModules
PROCEDURE
ShowCommands
VAR
M
Modules
Module
comadr
LONGINT
ch
CHAR
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
X
Y
INTEGER
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Modules
Load
S
s
M
IF
M
NIL
THEN
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
T
TextFrames
Text
V
MenuViewers
New
TextFrames
NewMenu
System
Commands
StandardMenu
TextFrames
NewText
T
TextFrames
menuH
X
Y
comadr
M
cmd
SYSTEM
GET
comadr
ch
INC
comadr
WHILE
ch
0X
DO
Texts
WriteString
W
S
s
Texts
Write
W
REPEAT
Texts
Write
W
ch
SYSTEM
GET
comadr
ch
INC
comadr
UNTIL
ch
0X
WHILE
comadr
MOD
DO
INC
comadr
END
Texts
WriteLn
W
INC
comadr
SYSTEM
GET
comadr
ch
INC
comadr
END
Texts
Append
T
W
buf
END
END
END
ShowCommands
PROCEDURE
ShowFonts
VAR
fnt
Fonts
Font
BEGIN
Texts
WriteString
W
System
ShowFonts
Texts
WriteLn
W
fnt
Fonts
root
WHILE
fnt
NIL
DO
Texts
Write
W
9X
Texts
WriteString
W
fnt
name
Texts
WriteLn
W
fnt
fnt
next
END
Texts
Append
Oberon
Log
W
buf
END
ShowFonts
PROCEDURE
OpenViewers
VAR
logV
toolV
Viewers
Viewer
menu
main
Display
Frame
d
LONGINT
X
Y
INTEGER
BEGIN
d
Kernel
Clock
Texts
WriteString
W
Oberon
V5
NW
EndLine
Oberon
AllocateSystemViewer
X
Y
menu
TextFrames
NewMenu
System
Log
LogMenu
main
TextFrames
NewText
Oberon
Log
logV
MenuViewers
New
menu
main
TextFrames
menuH
X
Y
Oberon
AllocateSystemViewer
X
Y
menu
TextFrames
NewMenu
System
Tool
StandardMenu
main
TextFrames
NewText
TextFrames
Text
System
Tool
toolV
MenuViewers
New
menu
main
TextFrames
menuH
X
Y
END
OpenViewers
PROCEDURE
ExtendDisplay
VAR
V
Viewers
Viewer
X
Y
DX
DW
DH
INTEGER
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
DX
Viewers
curW
DW
Oberon
DisplayWidth
DX
DH
Oberon
DisplayHeight
DX
Oberon
OpenDisplay
DW
DIV
DW
DIV
DH
Oberon
AllocateSystemViewer
DX
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
ExtendDisplay
PROCEDURE
Trap
VAR
a
INTEGER
b
INTEGER
VAR
u
v
w
INTEGER
mod
Modules
Module
BEGIN
u
SYSTEM
REG
SYSTEM
GET
u
v
w
v
DIV
10H
MOD
10H
trap
number
IF
w
THEN
Kernel
New
a
b
ELSE
trap
Texts
WriteLn
W
Texts
WriteString
W
pos
Texts
WriteInt
W
v
DIV
100H
MOD
10000H
Texts
WriteString
W
TRAP
Texts
WriteInt
W
w
mod
Modules
root
WHILE
mod
NIL
u
mod
code
OR
u
mod
imp
DO
mod
mod
next
END
IF
mod
NIL
THEN
Texts
WriteString
W
in
Texts
WriteString
W
mod
name
END
Texts
WriteString
W
at
Texts
WriteHex
W
u
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Oberon
Reset
END
END
Trap
PROCEDURE
Abort
VAR
n
INTEGER
BEGIN
n
SYSTEM
REG
Texts
WriteString
W
ABORT
Texts
WriteHex
W
n
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Oberon
Reset
END
Abort
BEGIN
Texts
OpenWriter
W
Oberon
OpenLog
TextFrames
Text
OpenViewers
Kernel
Install
SYSTEM
ADR
Trap
20H
Kernel
Install
SYSTEM
ADR
Abort
END
System
MODULE
TextFrames
JG
NW
IMPORT
Modules
Input
Display
Viewers
Fonts
Texts
Oberon
MenuViewers
CONST
replace
insert
delete
unmark
message
id
BS
8X
TAB
9X
CR
0DX
DEL
7FX
TYPE
Line
POINTER
TO
LineDesc
LineDesc
RECORD
len
LONGINT
wid
INTEGER
eot
BOOLEAN
next
Line
END
Location
RECORD
org
pos
LONGINT
dx
x
y
INTEGER
lin
Line
END
Frame
POINTER
TO
FrameDesc
FrameDesc
RECORD
Display
FrameDesc
text
Texts
Text
org
LONGINT
col
INTEGER
lsp
INTEGER
left
right
top
bot
INTEGER
markH
INTEGER
time
LONGINT
hasCar
hasSel
hasMark
BOOLEAN
carloc
Location
selbeg
selend
Location
trailer
Line
END
UpdateMsg
RECORD
Display
FrameMsg
id
INTEGER
text
Texts
Text
beg
end
LONGINT
END
CopyOverMsg
RECORD
Display
FrameMsg
text
Texts
Text
beg
end
LONGINT
END
VAR
TBuf
DelBuf
Texts
Buffer
menuH
barW
left
right
top
bot
lsp
INTEGER
standard
sizes
asr
dsr
selH
markW
eolW
INTEGER
nextCh
CHAR
ScrollMarker
Oberon
Marker
W
KW
Texts
Writer
keyboard
writer
PROCEDURE
Min
i
j
INTEGER
INTEGER
BEGIN
IF
i
j
THEN
j
i
END
RETURN
j
END
Min
display
support
PROCEDURE
ReplConst
col
INTEGER
F
Frame
X
Y
W
H
INTEGER
mode
INTEGER
BEGIN
IF
X
W
F
X
F
W
THEN
Display
ReplConst
col
X
Y
W
H
mode
ELSIF
X
F
X
F
W
THEN
Display
ReplConst
col
X
Y
F
X
F
W
X
H
mode
END
END
ReplConst
PROCEDURE
FlipSM
X
Y
INTEGER
VAR
DW
DH
CL
INTEGER
BEGIN
DW
Display
Width
DH
Display
Height
CL
DW
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
updown
X
Y
Display
invert
END
FlipSM
PROCEDURE
UpdateMark
F
Frame
in
scroll
bar
VAR
oldH
INTEGER
BEGIN
oldH
F
markH
F
markH
F
org
F
H
DIV
F
text
len
IF
F
hasMark
F
left
barW
F
markH
oldH
THEN
Display
ReplConst
Display
white
F
X
F
Y
F
H
oldH
markW
Display
invert
Display
ReplConst
Display
white
F
X
F
Y
F
H
F
markH
markW
Display
invert
END
END
UpdateMark
PROCEDURE
SetChangeMark
F
Frame
on
BOOLEAN
in
corner
BEGIN
IF
F
H
menuH
THEN
IF
on
THEN
Display
CopyPattern
Display
white
Display
block
F
X
F
W
F
Y
F
H
Display
paint
ELSE
Display
ReplConst
F
col
F
X
F
W
F
Y
F
H
Display
replace
END
END
END
SetChangeMark
PROCEDURE
Width
VAR
R
Texts
Reader
len
LONGINT
INTEGER
VAR
patadr
pos
LONGINT
ox
dx
x
y
w
h
INTEGER
BEGIN
pos
ox
WHILE
pos
len
DO
Fonts
GetPat
R
fnt
nextCh
dx
x
y
w
h
patadr
ox
ox
dx
INC
pos
Texts
Read
R
nextCh
END
RETURN
ox
END
Width
PROCEDURE
DisplayLine
F
Frame
L
Line
VAR
R
Texts
Reader
X
Y
INTEGER
len
LONGINT
VAR
patadr
NX
dx
x
y
w
h
INTEGER
BEGIN
NX
F
X
F
W
WHILE
nextCh
CR
R
fnt
NIL
DO
Fonts
GetPat
R
fnt
nextCh
dx
x
y
w
h
patadr
IF
X
x
w
NX
h
THEN
Display
CopyPattern
R
col
patadr
X
x
Y
y
Display
invert
END
X
X
dx
INC
len
Texts
Read
R
nextCh
END
L
len
len
L
wid
X
eolW
F
X
F
left
L
eot
R
fnt
NIL
Texts
Read
R
nextCh
END
DisplayLine
PROCEDURE
Validate
T
Texts
Text
VAR
pos
LONGINT
VAR
R
Texts
Reader
BEGIN
IF
pos
T
len
THEN
pos
T
len
ELSIF
pos
THEN
DEC
pos
Texts
OpenReader
R
T
pos
REPEAT
Texts
Read
R
nextCh
INC
pos
UNTIL
R
eot
OR
nextCh
CR
ELSE
pos
END
END
Validate
PROCEDURE
Mark
F
Frame
on
BOOLEAN
BEGIN
IF
F
H
F
left
barW
F
hasMark
on
OR
F
hasMark
on
THEN
Display
ReplConst
Display
white
F
X
F
Y
F
H
F
markH
markW
Display
invert
END
F
hasMark
on
END
Mark
PROCEDURE
Restore
F
Frame
VAR
R
Texts
Reader
L
l
Line
curY
botY
INTEGER
BEGIN
Display
ReplConst
F
col
F
X
F
Y
F
W
F
H
Display
replace
IF
F
left
barW
THEN
Display
ReplConst
Display
white
F
X
barW
F
Y
F
H
Display
invert
END
Validate
F
text
F
org
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
F
org
Texts
Read
R
nextCh
L
F
trailer
curY
F
Y
F
H
F
top
asr
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
F
markH
F
org
F
H
DIV
F
text
len
END
Restore
PROCEDURE
Suspend
F
Frame
BEGIN
F
trailer
next
F
trailer
END
Suspend
PROCEDURE
Extend
F
Frame
newY
INTEGER
VAR
R
Texts
Reader
L
l
Line
org
LONGINT
curY
botY
INTEGER
BEGIN
Display
ReplConst
F
col
F
X
newY
F
W
F
Y
newY
Display
replace
IF
F
left
barW
THEN
Display
ReplConst
Display
white
F
X
barW
newY
F
Y
newY
Display
invert
END
botY
F
Y
F
bot
dsr
F
H
F
H
F
Y
newY
F
Y
newY
IF
F
trailer
next
F
trailer
THEN
Validate
F
text
F
org
END
L
F
trailer
org
F
org
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
org
org
L
len
curY
curY
lsp
END
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
F
markH
F
org
F
H
DIV
F
text
len
END
Extend
PROCEDURE
Reduce
F
Frame
newY
INTEGER
VAR
L
Line
curY
botY
INTEGER
BEGIN
F
H
F
H
F
Y
newY
F
Y
newY
botY
F
Y
F
bot
dsr
L
F
trailer
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
curY
curY
lsp
END
L
next
F
trailer
IF
curY
asr
F
Y
THEN
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
asr
F
Y
Display
replace
END
F
markH
F
org
F
H
DIV
F
text
len
Mark
F
TRUE
END
Reduce
PROCEDURE
Show
F
Frame
pos
LONGINT
VAR
R
Texts
Reader
L
L0
Line
org
LONGINT
curY
botY
Y0
INTEGER
BEGIN
IF
F
trailer
next
F
trailer
THEN
Validate
F
text
pos
IF
pos
F
org
THEN
Mark
F
FALSE
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
F
H
Display
replace
botY
F
Y
F
Y
F
Y
F
H
F
H
F
org
pos
F
trailer
next
F
trailer
Extend
F
botY
Mark
F
TRUE
ELSIF
pos
F
org
THEN
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
org
pos
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
org
pos
THEN
F
org
org
F
trailer
next
L
Y0
curY
WHILE
L
next
F
trailer
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
Display
CopyBlock
F
X
F
left
curY
dsr
F
W
F
left
Y0
asr
curY
dsr
F
X
F
left
curY
dsr
F
Y
F
H
F
top
asr
Y0
curY
curY
F
Y
F
H
F
top
asr
Y0
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
dsr
F
Y
Display
replace
botY
F
Y
F
bot
dsr
org
org
L
len
curY
curY
lsp
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
L0
DisplayLine
F
L0
R
F
X
F
left
curY
L
next
L0
L
L0
curY
curY
lsp
END
L
next
F
trailer
UpdateMark
F
ELSE
Mark
F
FALSE
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
F
H
Display
replace
botY
F
Y
F
Y
F
Y
F
H
F
H
F
org
pos
F
trailer
next
F
trailer
Extend
F
botY
Mark
F
TRUE
END
END
END
SetChangeMark
F
F
text
changed
END
Show
PROCEDURE
LocateLine
F
Frame
y
INTEGER
VAR
loc
Location
VAR
L
Line
org
LONGINT
cury
INTEGER
BEGIN
org
F
org
L
F
trailer
next
cury
F
H
F
top
asr
WHILE
L
next
F
trailer
cury
y
dsr
DO
org
org
L
len
L
L
next
cury
cury
lsp
END
loc
org
org
loc
lin
L
loc
y
cury
END
LocateLine
PROCEDURE
LocateString
F
Frame
x
y
INTEGER
VAR
loc
Location
VAR
R
Texts
Reader
patadr
bpos
pos
lim
LONGINT
bx
ex
ox
dx
u
v
w
h
INTEGER
BEGIN
LocateLine
F
y
loc
lim
loc
org
loc
lin
len
bpos
loc
org
bx
F
left
pos
loc
org
ox
F
left
Texts
OpenReader
R
F
text
loc
org
Texts
Read
R
nextCh
REPEAT
WHILE
pos
lim
nextCh
DO
scan
string
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
END
ex
ox
WHILE
pos
lim
nextCh
DO
scan
gap
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
END
IF
pos
lim
ox
x
THEN
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
bpos
pos
bx
ox
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
ELSE
pos
lim
END
UNTIL
pos
lim
loc
pos
bpos
loc
dx
ex
bx
loc
x
bx
END
LocateString
PROCEDURE
LocateChar
F
Frame
x
y
INTEGER
VAR
loc
Location
VAR
R
Texts
Reader
patadr
pos
lim
LONGINT
ox
dx
u
v
w
h
INTEGER
BEGIN
LocateLine
F
y
loc
lim
loc
org
loc
lin
len
pos
loc
org
ox
F
left
dx
eolW
Texts
OpenReader
R
F
text
loc
org
WHILE
pos
lim
DO
Texts
Read
R
nextCh
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
IF
ox
dx
x
THEN
INC
pos
ox
ox
dx
IF
pos
lim
THEN
dx
eolW
END
ELSE
lim
pos
END
END
loc
pos
pos
loc
dx
dx
loc
x
ox
END
LocateChar
PROCEDURE
LocatePos
F
Frame
pos
LONGINT
VAR
loc
Location
VAR
T
Texts
Text
R
Texts
Reader
L
Line
org
LONGINT
cury
INTEGER
BEGIN
T
F
text
org
F
org
L
F
trailer
next
cury
F
H
F
top
asr
IF
pos
org
THEN
pos
org
END
WHILE
L
next
F
trailer
pos
org
L
len
DO
org
org
L
len
L
L
next
cury
cury
lsp
END
IF
pos
org
L
len
THEN
pos
org
L
len
END
Texts
OpenReader
R
T
org
Texts
Read
R
nextCh
loc
org
org
loc
pos
pos
loc
lin
L
loc
x
F
left
Width
R
pos
org
loc
y
cury
END
LocatePos
PROCEDURE
Pos
F
Frame
X
Y
INTEGER
LONGINT
VAR
loc
Location
BEGIN
LocateChar
F
X
F
X
Y
F
Y
loc
RETURN
loc
pos
END
Pos
PROCEDURE
FlipCaret
F
Frame
BEGIN
IF
F
carloc
x
F
W
F
carloc
y
F
carloc
x
F
W
THEN
Display
CopyPattern
Display
white
Display
hook
F
X
F
carloc
x
F
Y
F
carloc
y
Display
invert
END
END
FlipCaret
PROCEDURE
SetCaret
F
Frame
pos
LONGINT
BEGIN
LocatePos
F
pos
F
carloc
FlipCaret
F
F
hasCar
TRUE
END
SetCaret
PROCEDURE
TrackCaret
F
Frame
X
Y
INTEGER
VAR
keysum
SET
VAR
loc
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateChar
F
X
F
X
Y
F
Y
F
carloc
FlipCaret
F
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateChar
F
X
F
X
Y
F
Y
loc
IF
loc
pos
F
carloc
pos
THEN
FlipCaret
F
F
carloc
loc
FlipCaret
F
END
UNTIL
keys
F
hasCar
TRUE
END
END
TrackCaret
PROCEDURE
RemoveCaret
F
Frame
BEGIN
IF
F
hasCar
THEN
FlipCaret
F
F
hasCar
FALSE
END
END
RemoveCaret
PROCEDURE
FlipSelection
F
Frame
VAR
beg
end
Location
VAR
L
Line
Y
INTEGER
BEGIN
L
beg
lin
Y
F
Y
beg
y
IF
L
end
lin
THEN
ReplConst
Display
white
F
F
X
beg
x
Y
end
x
beg
x
selH
Display
invert
ELSE
ReplConst
Display
white
F
F
X
beg
x
Y
F
left
L
wid
beg
x
selH
Display
invert
L
L
next
Y
Y
lsp
WHILE
L
end
lin
DO
ReplConst
Display
white
F
F
X
F
left
Y
L
wid
selH
Display
invert
L
L
next
Y
Y
lsp
END
ReplConst
Display
white
F
F
X
F
left
Y
end
x
F
left
selH
Display
invert
END
END
FlipSelection
PROCEDURE
SetSelection
F
Frame
beg
end
LONGINT
BEGIN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
END
LocatePos
F
beg
F
selbeg
LocatePos
F
end
F
selend
IF
F
selbeg
pos
F
selend
pos
THEN
FlipSelection
F
F
selbeg
F
selend
F
time
Oberon
Time
F
hasSel
TRUE
END
END
SetSelection
PROCEDURE
TrackSelection
F
Frame
X
Y
INTEGER
VAR
keysum
SET
VAR
loc
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
END
LocateChar
F
X
F
X
Y
F
Y
loc
IF
F
hasSel
loc
pos
F
selbeg
pos
F
selend
pos
F
selbeg
pos
THEN
LocateChar
F
F
left
Y
F
Y
F
selbeg
ELSE
F
selbeg
loc
END
INC
loc
pos
loc
x
loc
x
loc
dx
F
selend
loc
FlipSelection
F
F
selbeg
F
selend
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateChar
F
X
F
X
Y
F
Y
loc
IF
loc
pos
F
selbeg
pos
THEN
loc
F
selbeg
END
INC
loc
pos
loc
x
loc
x
loc
dx
IF
loc
pos
F
selend
pos
THEN
FlipSelection
F
loc
F
selend
F
selend
loc
ELSIF
loc
pos
F
selend
pos
THEN
FlipSelection
F
F
selend
loc
F
selend
loc
END
UNTIL
keys
F
time
Oberon
Time
F
hasSel
TRUE
END
END
TrackSelection
PROCEDURE
RemoveSelection
F
Frame
BEGIN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
F
hasSel
FALSE
END
END
RemoveSelection
PROCEDURE
TrackLine
F
Frame
X
Y
INTEGER
VAR
org
LONGINT
VAR
keysum
SET
VAR
old
new
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateLine
F
Y
F
Y
old
ReplConst
Display
white
F
F
X
F
left
F
Y
old
y
dsr
old
lin
wid
Display
invert
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouse
ScrollMarker
X
Y
LocateLine
F
Y
F
Y
new
IF
new
org
old
org
THEN
ReplConst
Display
white
F
F
X
F
left
F
Y
old
y
dsr
old
lin
wid
Display
invert
ReplConst
Display
white
F
F
X
F
left
F
Y
new
y
dsr
new
lin
wid
Display
invert
old
new
END
UNTIL
keys
ReplConst
Display
white
F
F
X
F
left
F
Y
new
y
dsr
new
lin
wid
Display
invert
org
new
org
ELSE
org
END
END
TrackLine
PROCEDURE
TrackWord
F
Frame
X
Y
INTEGER
VAR
pos
LONGINT
VAR
keysum
SET
VAR
old
new
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateString
F
X
F
X
Y
F
Y
old
ReplConst
Display
white
F
F
X
old
x
F
Y
old
y
dsr
old
dx
Display
invert
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateString
F
X
F
X
Y
F
Y
new
IF
new
pos
old
pos
THEN
ReplConst
Display
white
F
F
X
old
x
F
Y
old
y
dsr
old
dx
Display
invert
ReplConst
Display
white
F
F
X
new
x
F
Y
new
y
dsr
new
dx
Display
invert
old
new
END
UNTIL
keys
ReplConst
Display
white
F
F
X
new
x
F
Y
new
y
dsr
new
dx
Display
invert
pos
new
pos
ELSE
pos
END
END
TrackWord
PROCEDURE
Replace
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
Line
org
len
LONGINT
curY
wid
INTEGER
BEGIN
IF
end
F
org
THEN
IF
beg
F
org
THEN
beg
F
org
END
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
len
beg
org
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
curY
dsr
L
wid
wid
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
wid
curY
len
org
org
L
len
L
L
next
curY
curY
lsp
WHILE
L
F
trailer
org
end
DO
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
curY
org
org
L
len
L
L
next
curY
curY
lsp
END
END
END
UpdateMark
F
END
Replace
PROCEDURE
Insert
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
L0
l
Line
org
len
LONGINT
curY
botY
Y0
Y1
Y2
dY
wid
INTEGER
BEGIN
IF
beg
F
org
THEN
F
org
F
org
end
beg
ELSE
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
len
beg
org
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
curY
dsr
L
wid
wid
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
wid
curY
len
org
org
L
len
curY
curY
lsp
Y0
curY
L0
L
next
WHILE
org
end
curY
botY
DO
NEW
l
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
org
org
L
len
curY
curY
lsp
END
IF
L0
L
next
THEN
Y1
curY
L
next
L0
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
curY
curY
lsp
END
L
next
F
trailer
dY
Y0
Y1
IF
Y1
curY
dY
THEN
Display
CopyBlock
F
X
F
left
curY
dY
lsp
dsr
F
W
F
left
Y1
curY
dY
F
X
F
left
curY
lsp
dsr
Y2
Y1
dY
ELSE
Y2
curY
END
curY
Y1
L
L0
WHILE
curY
Y2
DO
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
curY
L
L
next
curY
curY
lsp
END
END
END
END
UpdateMark
F
END
Insert
PROCEDURE
Delete
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
L0
l
Line
org
org0
len
LONGINT
curY
botY
Y0
Y1
wid
INTEGER
BEGIN
IF
end
F
org
THEN
F
org
F
org
end
beg
ELSE
IF
beg
F
org
THEN
F
trailer
next
len
F
trailer
next
len
F
org
beg
F
org
beg
END
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
botY
F
Y
F
bot
dsr
org0
org
L0
L
Y0
curY
WHILE
L
F
trailer
org
end
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
Y1
curY
Texts
OpenReader
R
F
text
org0
Texts
Read
R
nextCh
len
beg
org0
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
Y0
dsr
L0
wid
wid
lsp
Display
replace
DisplayLine
F
L0
R
F
X
F
left
wid
Y0
len
Y0
Y0
lsp
IF
L
L0
next
THEN
L0
next
L
L
L0
org
org0
L0
len
WHILE
L
next
F
trailer
DO
L
L
next
org
org
L
len
curY
curY
lsp
END
Display
CopyBlock
F
X
F
left
curY
lsp
dsr
F
W
F
left
Y1
curY
F
X
F
left
curY
lsp
dsr
Y0
Y1
curY
curY
Y0
Y1
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
lsp
F
Y
dsr
Display
replace
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
END
END
END
UpdateMark
F
END
Delete
PROCEDURE
Recall
VAR
B
Texts
Buffer
BEGIN
B
TBuf
NEW
TBuf
Texts
OpenBuf
TBuf
END
Recall
message
handling
PROCEDURE
RemoveMarks
F
Frame
BEGIN
RemoveCaret
F
RemoveSelection
F
END
RemoveMarks
PROCEDURE
NotifyDisplay
T
Texts
Text
op
INTEGER
beg
end
LONGINT
VAR
M
UpdateMsg
BEGIN
M
id
op
M
text
T
M
beg
beg
M
end
end
Viewers
Broadcast
M
END
NotifyDisplay
PROCEDURE
Call
F
Frame
pos
LONGINT
new
BOOLEAN
VAR
S
Texts
Scanner
res
INTEGER
BEGIN
Texts
OpenScanner
S
F
text
pos
Texts
Scan
S
IF
S
class
Texts
Name
S
line
THEN
Oberon
SetPar
F
F
text
pos
S
len
Oberon
Call
S
s
res
IF
res
THEN
Texts
WriteString
W
Call
error
Texts
WriteString
W
Modules
importing
IF
res
THEN
Texts
WriteString
W
module
not
found
ELSIF
res
THEN
Texts
WriteString
W
bad
version
ELSIF
res
THEN
Texts
WriteString
W
imports
Texts
WriteString
W
Modules
imported
Texts
WriteString
W
with
bad
key
ELSIF
res
THEN
Texts
WriteString
W
corrupted
obj
file
ELSIF
res
THEN
Texts
WriteString
W
command
not
found
ELSIF
res
THEN
Texts
WriteString
W
insufficient
space
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
END
Call
PROCEDURE
Write
F
Frame
ch
CHAR
fnt
Fonts
Font
col
voff
INTEGER
VAR
buf
Texts
Buffer
BEGIN
F
hasCar
IF
ch
BS
THEN
backspace
IF
F
carloc
pos
F
org
THEN
Texts
Delete
F
text
F
carloc
pos
F
carloc
pos
DelBuf
SetCaret
F
F
carloc
pos
END
ELSIF
ch
3X
THEN
ctrl
c
copy
IF
F
hasSel
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Save
F
text
F
selbeg
pos
F
selend
pos
TBuf
END
ELSIF
ch
16X
THEN
ctrl
v
paste
NEW
buf
Texts
OpenBuf
buf
Texts
Copy
TBuf
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
TBuf
len
ELSIF
ch
18X
THEN
ctrl
x
cut
IF
F
hasSel
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Delete
F
text
F
selbeg
pos
F
selend
pos
TBuf
END
ELSIF
20X
ch
ch
DEL
OR
ch
CR
OR
ch
TAB
THEN
KW
fnt
fnt
KW
col
col
KW
voff
voff
Texts
Write
KW
ch
Texts
Insert
F
text
F
carloc
pos
KW
buf
SetCaret
F
F
carloc
pos
END
END
Write
PROCEDURE
Defocus
F
Frame
BEGIN
RemoveCaret
F
END
Defocus
PROCEDURE
Neutralize
F
Frame
BEGIN
RemoveMarks
F
END
Neutralize
PROCEDURE
Modify
F
Frame
id
dY
Y
H
INTEGER
BEGIN
Mark
F
FALSE
RemoveMarks
F
SetChangeMark
F
FALSE
IF
id
MenuViewers
extend
THEN
IF
dY
THEN
Display
CopyBlock
F
X
F
Y
F
W
F
H
F
X
F
Y
dY
F
Y
F
Y
dY
END
Extend
F
Y
ELSIF
id
MenuViewers
reduce
THEN
Reduce
F
Y
dY
IF
dY
THEN
Display
CopyBlock
F
X
F
Y
F
W
F
H
F
X
Y
F
Y
Y
END
END
IF
F
H
THEN
Mark
F
TRUE
SetChangeMark
F
F
text
changed
END
END
Modify
PROCEDURE
Open
F
Frame
H
Display
Handler
T
Texts
Text
org
LONGINT
col
left
right
top
bot
lsp
INTEGER
VAR
L
Line
BEGIN
NEW
L
L
len
L
wid
L
eot
FALSE
L
next
L
F
handle
H
F
text
T
F
org
org
F
trailer
L
F
left
left
F
right
right
F
top
top
F
bot
bot
F
lsp
lsp
F
col
col
F
hasMark
FALSE
F
hasCar
FALSE
F
hasSel
FALSE
END
Open
PROCEDURE
Copy
F
Frame
VAR
F1
Frame
BEGIN
NEW
F1
Open
F1
F
handle
F
text
F
org
F
col
F
left
F
right
F
top
F
bot
F
lsp
END
Copy
PROCEDURE
CopyOver
F
Frame
text
Texts
Text
beg
end
LONGINT
VAR
buf
Texts
Buffer
BEGIN
IF
F
hasCar
THEN
NEW
buf
Texts
OpenBuf
buf
Texts
Save
text
beg
end
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
end
beg
END
END
CopyOver
PROCEDURE
GetSelection
F
Frame
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
BEGIN
IF
F
hasSel
THEN
IF
F
text
text
THEN
IF
F
selbeg
pos
beg
THEN
beg
F
selbeg
pos
END
leftmost
IF
F
time
time
THEN
end
F
selend
pos
time
F
time
END
last
selected
ELSIF
F
time
time
THEN
text
F
text
beg
F
selbeg
pos
end
F
selend
pos
time
F
time
END
END
END
GetSelection
PROCEDURE
Update
F
Frame
VAR
M
UpdateMsg
BEGIN
F
text
M
text
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
IF
M
id
replace
THEN
Replace
F
M
beg
M
end
ELSIF
M
id
insert
THEN
Insert
F
M
beg
M
end
ELSIF
M
id
delete
THEN
Delete
F
M
beg
M
end
END
SetChangeMark
F
F
text
changed
END
Update
PROCEDURE
Edit
F
Frame
X
Y
INTEGER
Keys
SET
VAR
M
CopyOverMsg
text
Texts
Text
buf
Texts
Buffer
v
Viewers
Viewer
beg
end
time
pos
LONGINT
keysum
SET
fnt
Fonts
Font
col
voff
INTEGER
BEGIN
IF
X
F
X
Min
F
left
barW
THEN
scroll
bar
Oberon
DrawMouse
ScrollMarker
X
Y
keysum
Keys
IF
Keys
THEN
ML
scroll
up
TrackLine
F
X
Y
pos
keysum
IF
pos
keysum
THEN
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
pos
END
ELSIF
Keys
THEN
MM
keysum
Keys
REPEAT
Input
Mouse
Keys
X
Y
keysum
keysum
Keys
Oberon
DrawMouse
ScrollMarker
X
Y
UNTIL
Keys
IF
keysum
THEN
IF
IN
keysum
THEN
pos
ELSIF
IN
keysum
THEN
pos
F
text
len
ELSE
pos
F
Y
F
H
Y
F
text
len
DIV
F
H
END
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
pos
END
ELSIF
Keys
THEN
MR
scroll
down
TrackLine
F
X
Y
pos
keysum
IF
keysum
THEN
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
F
org
pos
END
END
ELSE
text
area
Oberon
DrawMouseArrow
X
Y
IF
IN
Keys
THEN
MR
select
TrackSelection
F
X
Y
keysum
IF
F
hasSel
THEN
IF
keysum
THEN
MR
ML
delete
text
Oberon
GetSelection
text
beg
end
time
Texts
Delete
text
beg
end
TBuf
Oberon
PassFocus
Viewers
This
F
X
F
Y
SetCaret
F
beg
ELSIF
keysum
THEN
MR
MM
copy
to
caret
Oberon
GetSelection
text
beg
end
time
M
text
text
M
beg
beg
M
end
end
Oberon
FocusViewer
handle
Oberon
FocusViewer
M
END
END
ELSIF
IN
Keys
THEN
MM
call
TrackWord
F
X
Y
pos
keysum
IF
pos
IN
keysum
THEN
Call
F
pos
IN
keysum
END
ELSIF
IN
Keys
THEN
ML
set
caret
Oberon
PassFocus
Viewers
This
F
X
F
Y
TrackCaret
F
X
Y
keysum
IF
keysum
THEN
ML
MM
copy
from
selection
to
caret
Oberon
GetSelection
text
beg
end
time
IF
time
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Save
text
beg
end
TBuf
Texts
Insert
F
text
F
carloc
pos
TBuf
SetSelection
F
F
carloc
pos
F
carloc
pos
end
beg
SetCaret
F
F
carloc
pos
end
beg
ELSIF
TBuf
NIL
THEN
NEW
buf
Texts
OpenBuf
buf
Texts
Copy
TBuf
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
buf
len
END
ELSIF
keysum
THEN
ML
MR
copy
looks
Oberon
GetSelection
text
beg
end
time
IF
time
THEN
Texts
Attributes
F
text
F
carloc
pos
fnt
col
voff
IF
fnt
NIL
THEN
Texts
ChangeLooks
text
beg
end
fnt
col
voff
END
END
END
END
END
END
Edit
PROCEDURE
Handle
F
Display
Frame
VAR
M
Display
FrameMsg
VAR
F1
Frame
buf
Texts
Buffer
BEGIN
CASE
F
OF
Frame
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
Edit
F
M
X
M
Y
M
keys
ELSIF
M
id
Oberon
consume
THEN
IF
F
hasCar
THEN
Write
F
M
ch
M
fnt
M
col
M
voff
END
END
Oberon
ControlMsg
IF
M
id
Oberon
defocus
THEN
Defocus
F
ELSIF
M
id
Oberon
neutralize
THEN
Neutralize
F
END
Oberon
SelectionMsg
GetSelection
F
M
text
M
beg
M
end
M
time
Oberon
CopyMsg
Copy
F
F1
M
F
F1
MenuViewers
ModifyMsg
Modify
F
M
id
M
dY
M
Y
M
H
CopyOverMsg
CopyOver
F
M
text
M
beg
M
end
UpdateMsg
IF
F
text
M
text
THEN
Update
F
M
END
END
END
END
Handle
creation
PROCEDURE
Menu
name
commands
ARRAY
OF
CHAR
Texts
Text
VAR
T
Texts
Text
BEGIN
NEW
T
T
notify
NotifyDisplay
Texts
Open
T
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
commands
Texts
Append
T
W
buf
RETURN
T
END
Menu
PROCEDURE
Text
name
ARRAY
OF
CHAR
Texts
Text
VAR
T
Texts
Text
BEGIN
NEW
T
T
notify
NotifyDisplay
Texts
Open
T
name
RETURN
T
END
Text
PROCEDURE
NewMenu
name
commands
ARRAY
OF
CHAR
Frame
VAR
F
Frame
T
Texts
Text
BEGIN
NEW
F
T
Menu
name
commands
Open
F
Handle
T
Display
white
left
DIV
lsp
RETURN
F
END
NewMenu
PROCEDURE
NewText
text
Texts
Text
pos
LONGINT
Frame
VAR
F
Frame
BEGIN
NEW
F
Open
F
Handle
text
pos
Display
black
left
right
top
bot
lsp
RETURN
F
END
NewText
BEGIN
NEW
TBuf
NEW
DelBuf
Texts
OpenBuf
TBuf
Texts
OpenBuf
DelBuf
lsp
Fonts
Default
height
menuH
lsp
barW
menuH
left
barW
lsp
DIV
right
lsp
DIV
top
lsp
DIV
bot
lsp
DIV
asr
Fonts
Default
maxY
dsr
Fonts
Default
minY
selH
lsp
markW
lsp
DIV
eolW
lsp
DIV
ScrollMarker
Fade
FlipSM
ScrollMarker
Draw
FlipSM
Texts
OpenWriter
W
Texts
OpenWriter
KW
END
TextFrames
MODULE
Texts
JG
NW
IMPORT
Files
Fonts
CONST
scanner
symbol
classes
Inval
invalid
symbol
Name
name
s
length
len
String
literal
string
s
length
len
Int
integer
i
decimal
or
hexadecimal
Real
real
number
x
Char
special
character
c
TextBlock
TextTag
offset
run
run
len
AsciiCode
run
fnt
name
col
voff
len
TAB
9X
CR
0DX
maxD
TextTag
0F1X
replace
insert
delete
unmark
op
codes
TYPE
Piece
POINTER
TO
PieceDesc
PieceDesc
RECORD
f
Files
File
off
len
LONGINT
fnt
Fonts
Font
col
voff
INTEGER
prev
next
Piece
END
Text
POINTER
TO
TextDesc
Notifier
PROCEDURE
T
Text
op
INTEGER
beg
end
LONGINT
TextDesc
RECORD
len
LONGINT
changed
BOOLEAN
notify
Notifier
trailer
Piece
pce
Piece
cache
org
LONGINT
cache
END
Reader
RECORD
eot
BOOLEAN
fnt
Fonts
Font
col
voff
INTEGER
ref
Piece
org
LONGINT
off
LONGINT
rider
Files
Rider
END
Scanner
RECORD
Reader
nextCh
CHAR
line
class
INTEGER
i
LONGINT
x
REAL
y
LONGREAL
c
CHAR
len
INTEGER
s
ARRAY
OF
CHAR
END
Buffer
POINTER
TO
BufDesc
BufDesc
RECORD
len
LONGINT
header
last
Piece
END
Writer
RECORD
buf
Buffer
fnt
Fonts
Font
col
voff
INTEGER
rider
Files
Rider
END
VAR
TrailerFile
Files
File
Filing
PROCEDURE
Trailer
Piece
VAR
Q
Piece
BEGIN
NEW
Q
Q
f
TrailerFile
Q
off
Q
len
Q
fnt
NIL
Q
col
Q
voff
RETURN
Q
END
Trailer
PROCEDURE
Load
VAR
R
Files
Rider
T
Text
VAR
Q
q
p
Piece
off
LONGINT
N
fno
INTEGER
bt
BYTE
f
Files
File
FName
ARRAY
OF
CHAR
Dict
ARRAY
OF
Fonts
Font
BEGIN
f
Files
Base
R
N
Q
Trailer
p
Q
Files
ReadInt
R
off
Files
ReadByte
R
bt
fno
bt
WHILE
fno
DO
IF
fno
N
THEN
Files
ReadString
R
FName
Dict
N
Fonts
This
FName
INC
N
END
NEW
q
q
fnt
Dict
fno
Files
ReadByte
R
bt
q
col
bt
Files
ReadByte
R
bt
q
voff
ASR
LSL
bt
Files
ReadInt
R
q
len
Files
ReadByte
R
bt
fno
bt
q
f
f
q
off
off
off
off
q
len
p
next
q
q
prev
p
p
q
END
p
next
Q
Q
prev
p
T
trailer
Q
Files
ReadInt
R
T
len
Files
Set
R
f
Files
Pos
R
T
len
END
Load
PROCEDURE
Open
T
Text
name
ARRAY
OF
CHAR
VAR
f
Files
File
R
Files
Rider
Q
q
Piece
tag
CHAR
len
LONGINT
BEGIN
f
Files
Old
name
IF
f
NIL
THEN
Files
Set
R
f
Files
Read
R
tag
IF
tag
TextTag
THEN
Load
R
T
ELSE
Ascii
file
len
Files
Length
f
Q
Trailer
NEW
q
q
fnt
Fonts
Default
q
col
q
voff
q
f
f
q
off
q
len
len
Q
next
q
q
prev
Q
q
next
Q
Q
prev
q
T
trailer
Q
T
len
len
END
ELSE
create
new
text
Q
Trailer
Q
next
Q
Q
prev
Q
T
trailer
Q
T
len
END
T
changed
FALSE
T
org
T
pce
T
trailer
init
cache
END
Open
PROCEDURE
Store
VAR
W
Files
Rider
T
Text
VAR
p
q
Piece
R
Files
Rider
off
rlen
pos
LONGINT
N
n
INTEGER
ch
CHAR
Dict
ARRAY
OF
CHAR
BEGIN
pos
Files
Pos
W
Files
WriteInt
W
place
holder
N
p
T
trailer
next
WHILE
p
T
trailer
DO
rlen
p
len
q
p
next
WHILE
q
T
trailer
q
fnt
p
fnt
q
col
p
col
q
voff
p
voff
DO
rlen
rlen
q
len
q
q
next
END
Dict
N
p
fnt
name
n
WHILE
Dict
n
p
fnt
name
DO
INC
n
END
Files
WriteByte
W
n
IF
n
N
THEN
Files
WriteString
W
p
fnt
name
INC
N
END
Files
WriteByte
W
p
col
Files
WriteByte
W
p
voff
Files
WriteInt
W
rlen
p
q
END
Files
WriteByte
W
Files
WriteInt
W
T
len
off
Files
Pos
W
p
T
trailer
next
WHILE
p
T
trailer
DO
rlen
p
len
Files
Set
R
p
f
p
off
WHILE
rlen
DO
Files
Read
R
ch
Files
Write
W
ch
DEC
rlen
END
p
p
next
END
Files
Set
W
Files
Base
W
pos
Files
WriteInt
W
off
fixup
T
changed
FALSE
IF
T
notify
NIL
THEN
T
notify
T
unmark
END
END
Store
PROCEDURE
Close
T
Text
name
ARRAY
OF
CHAR
VAR
f
Files
File
w
Files
Rider
BEGIN
f
Files
New
name
Files
Set
w
f
Files
Write
w
TextTag
Store
w
T
Files
Register
f
END
Close
Editing
PROCEDURE
OpenBuf
B
Buffer
BEGIN
NEW
B
header
null
piece
B
last
B
header
B
len
END
OpenBuf
PROCEDURE
FindPiece
T
Text
pos
LONGINT
VAR
org
LONGINT
VAR
pce
Piece
VAR
p
Piece
porg
LONGINT
BEGIN
p
T
pce
porg
T
org
IF
pos
porg
THEN
WHILE
pos
porg
p
len
DO
INC
porg
p
len
p
p
next
END
ELSE
p
p
prev
DEC
porg
p
len
WHILE
pos
porg
DO
p
p
prev
DEC
porg
p
len
END
END
T
pce
p
T
org
porg
update
cache
pce
p
org
porg
END
FindPiece
PROCEDURE
SplitPiece
p
Piece
off
LONGINT
VAR
pr
Piece
VAR
q
Piece
BEGIN
IF
off
THEN
NEW
q
q
fnt
p
fnt
q
col
p
col
q
voff
p
voff
q
len
p
len
off
q
f
p
f
q
off
p
off
off
p
len
off
q
next
p
next
p
next
q
q
prev
p
q
next
prev
q
pr
q
ELSE
pr
p
END
END
SplitPiece
PROCEDURE
Save
T
Text
beg
end
LONGINT
B
Buffer
VAR
p
q
qb
qe
Piece
org
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
org
p
NEW
qb
qb
p
qb
len
qb
len
beg
org
qb
off
qb
off
beg
org
qe
qb
WHILE
end
org
p
len
DO
org
org
p
len
p
p
next
NEW
q
q
p
qe
next
q
q
prev
qe
qe
q
END
qe
next
NIL
qe
len
qe
len
org
p
len
end
B
last
next
qb
qb
prev
B
last
B
last
qe
B
len
B
len
end
beg
END
Save
PROCEDURE
Copy
SB
DB
Buffer
VAR
Q
q
p
Piece
BEGIN
p
SB
header
Q
DB
last
WHILE
p
SB
last
DO
p
p
next
NEW
q
q
p
Q
next
q
q
prev
Q
Q
q
END
DB
last
Q
DB
len
DB
len
SB
len
END
Copy
PROCEDURE
Insert
T
Text
pos
LONGINT
B
Buffer
VAR
pl
pr
p
qb
qe
Piece
org
end
LONGINT
BEGIN
FindPiece
T
pos
org
p
SplitPiece
p
pos
org
pr
IF
T
org
org
THEN
T
org
org
p
prev
len
T
pce
p
prev
END
pl
pr
prev
qb
B
header
next
IF
qb
NIL
qb
f
pl
f
qb
off
pl
off
pl
len
qb
fnt
pl
fnt
qb
col
pl
col
qb
voff
pl
voff
THEN
pl
len
pl
len
qb
len
qb
qb
next
END
IF
qb
NIL
THEN
qe
B
last
qb
prev
pl
pl
next
qb
qe
next
pr
pr
prev
qe
END
T
len
T
len
B
len
end
pos
B
len
B
last
B
header
B
last
next
NIL
B
len
T
changed
TRUE
T
notify
T
insert
pos
end
END
Insert
PROCEDURE
Append
T
Text
B
Buffer
BEGIN
Insert
T
T
len
B
END
Append
PROCEDURE
Delete
T
Text
beg
end
LONGINT
B
Buffer
VAR
pb
pe
pbr
per
Piece
orgb
orge
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
orgb
pb
SplitPiece
pb
beg
orgb
pbr
FindPiece
T
end
orge
pe
SplitPiece
pe
end
orge
per
IF
T
org
orgb
THEN
adjust
cache
T
org
orgb
pb
prev
len
T
pce
pb
prev
END
B
header
next
pbr
B
last
per
prev
B
last
next
NIL
B
len
end
beg
per
prev
pbr
prev
pbr
prev
next
per
T
len
T
len
B
len
T
changed
TRUE
T
notify
T
delete
beg
end
END
Delete
PROCEDURE
ChangeLooks
T
Text
beg
end
LONGINT
sel
SET
fnt
Fonts
Font
col
voff
INTEGER
VAR
pb
pe
p
Piece
org
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
org
p
SplitPiece
p
beg
org
pb
FindPiece
T
end
org
p
SplitPiece
p
end
org
pe
p
pb
REPEAT
IF
IN
sel
THEN
p
fnt
fnt
END
IF
IN
sel
THEN
p
col
col
END
IF
IN
sel
THEN
p
voff
voff
END
p
p
next
UNTIL
p
pe
T
changed
TRUE
T
notify
T
replace
beg
end
END
ChangeLooks
PROCEDURE
Attributes
T
Text
pos
LONGINT
VAR
fnt
Fonts
Font
VAR
col
voff
INTEGER
VAR
p
Piece
org
LONGINT
BEGIN
FindPiece
T
pos
org
p
fnt
p
fnt
col
p
col
voff
p
voff
END
Attributes
Access
Readers
PROCEDURE
OpenReader
VAR
R
Reader
T
Text
pos
LONGINT
VAR
p
Piece
org
LONGINT
BEGIN
FindPiece
T
pos
org
p
R
ref
p
R
org
org
R
off
pos
org
Files
Set
R
rider
p
f
p
off
R
off
R
eot
FALSE
END
OpenReader
PROCEDURE
Read
VAR
R
Reader
VAR
ch
CHAR
BEGIN
Files
Read
R
rider
ch
R
fnt
R
ref
fnt
R
col
R
ref
col
R
voff
R
ref
voff
INC
R
off
IF
R
off
R
ref
len
THEN
IF
R
ref
f
TrailerFile
THEN
R
eot
TRUE
END
R
org
R
org
R
off
R
off
R
ref
R
ref
next
R
org
R
org
R
off
R
off
Files
Set
R
rider
R
ref
f
R
ref
off
END
END
Read
PROCEDURE
Pos
VAR
R
Reader
LONGINT
BEGIN
RETURN
R
org
R
off
END
Pos
Access
Scanners
NW
PROCEDURE
OpenScanner
VAR
S
Scanner
T
Text
pos
LONGINT
BEGIN
OpenReader
S
T
pos
S
line
S
nextCh
END
OpenScanner
floating
point
formats
x
m
e
bit
sign
bits
e
bits
m
x
m
e
bit
sign
bits
e
bits
m
PROCEDURE
Ten
n
INTEGER
REAL
VAR
t
p
REAL
BEGIN
t
p
compute
n
WHILE
n
DO
IF
ODD
n
THEN
t
p
t
END
p
p
p
n
n
DIV
END
RETURN
t
END
Ten
PROCEDURE
Scan
VAR
S
Scanner
CONST
maxExp
maxM
VAR
ch
term
CHAR
neg
negE
hex
BOOLEAN
i
j
h
d
e
n
s
INTEGER
k
LONGINT
x
REAL
BEGIN
ch
S
nextCh
i
WHILE
S
eot
ch
DO
IF
ch
CR
THEN
INC
S
line
END
Read
S
ch
END
IF
A
ch
ch
Z
OR
a
ch
ch
z
THEN
name
REPEAT
S
s
i
ch
INC
i
Read
S
ch
UNTIL
ch
ch
OR
ch
ch
A
OR
Z
ch
ch
a
OR
z
ch
OR
i
S
s
i
0X
S
len
i
S
class
Name
ELSIF
ch
22X
THEN
string
Read
S
ch
WHILE
ch
22X
ch
i
DO
S
s
i
ch
INC
i
Read
S
ch
END
S
s
i
0X
S
len
i
Read
S
ch
S
class
String
ELSE
hex
FALSE
IF
ch
THEN
neg
TRUE
Read
S
ch
ELSE
neg
FALSE
END
IF
ch
ch
THEN
number
n
ORD
ch
30H
h
n
Read
S
ch
WHILE
ch
ch
OR
A
ch
ch
F
DO
IF
ch
THEN
d
ORD
ch
30H
ELSE
d
ORD
ch
37H
hex
TRUE
END
n
n
d
h
10H
h
d
Read
S
ch
END
IF
ch
H
THEN
hex
integer
Read
S
ch
S
i
h
S
class
Int
neg
ELSIF
ch
THEN
real
number
Read
S
ch
x
e
j
WHILE
ch
ch
DO
fraction
h
n
ORD
ch
30H
IF
h
maxM
THEN
n
h
INC
j
END
Read
S
ch
END
IF
ch
E
THEN
scale
factor
s
Read
S
ch
IF
ch
THEN
negE
TRUE
Read
S
ch
ELSE
negE
FALSE
IF
ch
THEN
Read
S
ch
END
END
WHILE
ch
ch
DO
s
s
ORD
ch
30H
Read
S
ch
END
IF
negE
THEN
DEC
e
s
ELSE
INC
e
s
END
END
x
FLT
n
DEC
e
j
IF
e
THEN
IF
e
maxExp
THEN
x
x
Ten
e
ELSE
x
END
ELSIF
e
THEN
IF
e
maxExp
THEN
x
Ten
e
x
ELSE
x
END
END
IF
neg
THEN
S
x
x
ELSE
S
x
x
END
IF
hex
THEN
S
class
ELSE
S
class
Real
END
ELSE
decimal
integer
IF
neg
THEN
S
i
n
ELSE
S
i
n
END
IF
hex
THEN
S
class
Inval
ELSE
S
class
Int
END
END
ELSE
spectal
character
S
class
Char
IF
neg
THEN
S
c
ELSE
S
c
ch
Read
S
ch
END
END
END
S
nextCh
ch
END
Scan
Access
Writers
NW
PROCEDURE
OpenWriter
VAR
W
Writer
BEGIN
NEW
W
buf
OpenBuf
W
buf
W
fnt
Fonts
Default
W
col
W
voff
Files
Set
W
rider
Files
New
END
OpenWriter
PROCEDURE
SetFont
VAR
W
Writer
fnt
Fonts
Font
BEGIN
W
fnt
fnt
END
SetFont
PROCEDURE
SetColor
VAR
W
Writer
col
INTEGER
BEGIN
W
col
col
END
SetColor
PROCEDURE
SetOffset
VAR
W
Writer
voff
INTEGER
BEGIN
W
voff
voff
END
SetOffset
PROCEDURE
Write
VAR
W
Writer
ch
CHAR
VAR
p
Piece
BEGIN
IF
W
buf
last
fnt
W
fnt
OR
W
buf
last
col
W
col
OR
W
buf
last
voff
W
voff
THEN
NEW
p
p
f
Files
Base
W
rider
p
off
Files
Pos
W
rider
p
len
p
fnt
W
fnt
p
col
W
col
p
voff
W
voff
p
next
NIL
W
buf
last
next
p
p
prev
W
buf
last
W
buf
last
p
END
Files
Write
W
rider
ch
INC
W
buf
last
len
INC
W
buf
len
END
Write
PROCEDURE
WriteLn
VAR
W
Writer
BEGIN
Write
W
CR
END
WriteLn
PROCEDURE
WriteString
VAR
W
Writer
s
ARRAY
OF
CHAR
VAR
i
INTEGER
BEGIN
i
WHILE
s
i
DO
Write
W
s
i
INC
i
END
END
WriteString
PROCEDURE
WriteInt
VAR
W
Writer
x
n
LONGINT
VAR
i
INTEGER
x0
LONGINT
a
ARRAY
OF
CHAR
BEGIN
IF
ROR
x
THEN
WriteString
W
ELSE
i
IF
x
THEN
DEC
n
x0
x
ELSE
x0
x
END
REPEAT
a
i
CHR
x0
MOD
30H
x0
x0
DIV
INC
i
UNTIL
x0
WHILE
n
i
DO
Write
W
DEC
n
END
IF
x
THEN
Write
W
END
REPEAT
DEC
i
Write
W
a
i
UNTIL
i
END
END
WriteInt
PROCEDURE
WriteHex
VAR
W
Writer
x
LONGINT
VAR
i
INTEGER
y
LONGINT
a
ARRAY
OF
CHAR
BEGIN
i
Write
W
REPEAT
y
x
MOD
10H
IF
y
THEN
a
i
CHR
y
30H
ELSE
a
i
CHR
y
37H
END
x
x
DIV
10H
INC
i
UNTIL
i
REPEAT
DEC
i
Write
W
a
i
UNTIL
i
END
WriteHex
PROCEDURE
WriteReal
VAR
W
Writer
x
REAL
n
INTEGER
VAR
e
i
m
INTEGER
d
ARRAY
OF
CHAR
BEGIN
e
ASR
ORD
x
MOD
100H
binary
exponent
IF
e
THEN
WriteString
W
WHILE
n
DO
Write
W
DEC
n
END
ELSIF
e
THEN
WriteString
W
NaN
ELSE
Write
W
WHILE
n
DO
DEC
n
Write
W
END
n
digits
to
be
written
IF
x
THEN
Write
W
x
x
ELSE
Write
W
END
e
e
DIV
decimal
exponent
IF
e
THEN
x
x
Ten
e
ELSE
x
Ten
e
x
END
m
FLOOR
x
i
IF
m
THEN
INC
e
m
m
DIV
END
REPEAT
d
i
CHR
m
MOD
30H
m
m
DIV
INC
i
UNTIL
m
DEC
i
Write
W
d
i
Write
W
IF
i
n
THEN
n
ELSE
n
n
END
WHILE
i
n
DO
DEC
i
Write
W
d
i
END
Write
W
E
INC
e
IF
e
THEN
Write
W
e
e
ELSE
Write
W
END
Write
W
CHR
e
DIV
30H
Write
W
CHR
e
MOD
30H
END
END
WriteReal
PROCEDURE
WriteRealFix
VAR
W
Writer
x
REAL
n
k
INTEGER
VAR
i
m
INTEGER
neg
BOOLEAN
d
ARRAY
OF
CHAR
BEGIN
IF
x
THEN
WriteString
W
ELSE
IF
x
THEN
x
x
neg
TRUE
ELSE
neg
FALSE
END
IF
k
THEN
k
END
x
Ten
k
x
m
FLOOR
x
i
REPEAT
d
i
CHR
m
MOD
30H
m
m
DIV
INC
i
UNTIL
m
Write
W
WHILE
n
i
DO
Write
W
DEC
n
END
IF
neg
THEN
Write
W
DEC
n
ELSE
Write
W
END
WHILE
i
k
DO
DEC
i
Write
W
d
i
END
Write
W
WHILE
k
i
DO
DEC
k
Write
W
END
WHILE
i
DO
DEC
i
Write
W
d
i
END
END
END
WriteRealFix
PROCEDURE
WritePair
VAR
W
Writer
ch
CHAR
x
LONGINT
BEGIN
Write
W
ch
Write
W
CHR
x
DIV
30H
Write
W
CHR
x
MOD
30H
END
WritePair
PROCEDURE
WriteClock
VAR
W
Writer
d
LONGINT
BEGIN
WritePair
W
d
DIV
20000H
MOD
20H
day
WritePair
W
d
DIV
400000H
MOD
10H
month
WritePair
W
d
DIV
4000000H
MOD
40H
year
WritePair
W
d
DIV
1000H
MOD
20H
hour
WritePair
W
d
DIV
40H
MOD
40H
min
WritePair
W
d
MOD
40H
sec
END
WriteClock
BEGIN
TrailerFile
Files
New
END
Texts
MODULE
Viewers
JG
NW
IMPORT
Display
CONST
restore
modify
suspend
message
ids
inf
TYPE
Viewer
POINTER
TO
ViewerDesc
ViewerDesc
RECORD
Display
FrameDesc
state
INTEGER
END
state
displayed
state
filler
state
closed
state
suspended
ViewerMsg
RECORD
Display
FrameMsg
id
INTEGER
X
Y
W
H
INTEGER
state
INTEGER
END
Track
POINTER
TO
TrackDesc
TrackDesc
RECORD
ViewerDesc
under
Display
Frame
END
VAR
curW
minH
DH
INTEGER
FillerTrack
Track
FillerViewer
backup
Viewer
last
closed
viewer
PROCEDURE
Open
V
Viewer
X
Y
INTEGER
VAR
T
u
v
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
X
inf
THEN
IF
Y
DH
THEN
Y
DH
END
T
FillerTrack
next
WHILE
X
T
X
T
W
DO
T
T
next
END
u
T
dsc
v
u
next
WHILE
Y
v
Y
v
H
DO
u
v
v
u
next
END
IF
Y
v
Y
minH
THEN
Y
v
Y
minH
END
IF
v
next
Y
Y
v
Y
v
H
minH
THEN
V
X
T
X
V
W
T
W
V
Y
v
Y
V
H
v
H
M
id
suspend
M
state
v
handle
v
M
v
Viewer
state
V
next
v
next
u
next
V
V
state
ELSE
V
X
T
X
V
W
T
W
V
Y
v
Y
V
H
Y
v
Y
M
id
modify
M
Y
Y
M
H
v
Y
v
H
Y
v
handle
v
M
v
Y
M
Y
v
H
M
H
V
next
v
u
next
V
V
state
END
END
END
Open
PROCEDURE
Change
V
Viewer
Y
INTEGER
VAR
v
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
THEN
IF
Y
DH
THEN
Y
DH
END
v
V
next
IF
v
next
Y
Y
v
Y
v
H
minH
THEN
Y
v
Y
v
H
minH
END
IF
Y
V
Y
minH
THEN
M
id
modify
M
Y
Y
M
H
v
Y
v
H
Y
v
handle
v
M
v
Y
M
Y
v
H
M
H
V
H
Y
V
Y
END
END
END
Change
PROCEDURE
RestoreTrack
S
Display
Frame
VAR
T
t
v
Display
Frame
M
ViewerMsg
BEGIN
t
S
next
WHILE
t
next
S
DO
t
t
next
END
T
S
Track
under
WHILE
T
next
NIL
DO
T
T
next
END
t
next
S
Track
under
T
next
S
next
M
id
restore
REPEAT
t
t
next
v
t
dsc
REPEAT
v
v
next
v
handle
v
M
v
Viewer
state
v
Viewer
state
UNTIL
v
t
dsc
UNTIL
t
T
END
RestoreTrack
PROCEDURE
Close
V
Viewer
VAR
T
U
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
THEN
U
V
next
T
FillerTrack
REPEAT
T
T
next
UNTIL
V
X
T
X
T
W
IF
T
Track
under
NIL
OR
U
next
V
THEN
M
id
suspend
M
state
V
handle
V
M
V
state
backup
V
M
id
modify
M
Y
V
Y
M
H
V
H
U
H
U
handle
U
M
U
Y
M
Y
U
H
M
H
WHILE
U
next
V
DO
U
U
next
END
U
next
V
next
ELSE
close
track
M
id
suspend
M
state
V
handle
V
M
V
state
backup
V
U
handle
U
M
U
Viewer
state
RestoreTrack
T
END
END
END
Close
PROCEDURE
Recall
VAR
V
Viewer
BEGIN
V
backup
END
Recall
PROCEDURE
This
X
Y
INTEGER
Viewer
VAR
T
V
Display
Frame
BEGIN
IF
X
inf
Y
DH
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
V
T
dsc
REPEAT
V
V
next
UNTIL
Y
V
Y
V
H
ELSE
V
NIL
END
RETURN
V
Viewer
END
This
PROCEDURE
Next
V
Viewer
Viewer
BEGIN
RETURN
V
next
Viewer
END
Next
PROCEDURE
Locate
X
H
INTEGER
VAR
fil
bot
alt
max
Display
Frame
VAR
T
V
Display
Frame
BEGIN
IF
X
inf
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
fil
T
dsc
bot
fil
next
IF
bot
next
fil
THEN
alt
bot
next
V
alt
next
WHILE
V
fil
alt
H
H
DO
IF
V
H
alt
H
THEN
alt
V
END
V
V
next
END
ELSE
alt
bot
END
max
T
dsc
V
max
next
WHILE
V
fil
DO
IF
V
H
max
H
THEN
max
V
END
V
V
next
END
END
END
Locate
PROCEDURE
InitTrack
W
H
INTEGER
Filler
Viewer
VAR
S
Display
Frame
T
Track
BEGIN
IF
Filler
state
THEN
Filler
X
curW
Filler
W
W
Filler
Y
Filler
H
H
Filler
state
Filler
next
Filler
NEW
T
T
X
curW
T
W
W
T
Y
T
H
H
T
dsc
Filler
T
under
NIL
FillerViewer
X
curW
W
FillerViewer
W
inf
FillerViewer
X
FillerTrack
X
FillerViewer
X
FillerTrack
W
FillerViewer
W
S
FillerTrack
WHILE
S
next
FillerTrack
DO
S
S
next
END
S
next
T
T
next
FillerTrack
curW
curW
W
END
END
InitTrack
PROCEDURE
OpenTrack
X
W
INTEGER
Filler
Viewer
VAR
newT
Track
S
T
t
v
Display
Frame
M
ViewerMsg
v0
Viewer
BEGIN
IF
X
inf
Filler
state
THEN
S
FillerTrack
T
S
next
WHILE
X
T
X
T
W
DO
S
T
T
S
next
END
WHILE
X
W
T
X
T
W
DO
T
T
next
END
M
id
suspend
t
S
REPEAT
t
t
next
v
t
dsc
REPEAT
v
v
next
M
state
v
Viewer
state
v
handle
v
M
v
Viewer
state
M
state
UNTIL
v
t
dsc
UNTIL
t
T
Filler
X
S
next
X
Filler
W
T
X
T
W
S
next
X
Filler
Y
Filler
H
DH
Filler
state
Filler
next
Filler
NEW
newT
newT
X
Filler
X
newT
W
Filler
W
newT
Y
newT
H
DH
newT
dsc
Filler
newT
under
S
next
S
next
newT
newT
next
T
next
T
next
NIL
END
END
OpenTrack
PROCEDURE
CloseTrack
X
INTEGER
VAR
T
V
Display
Frame
M
ViewerMsg
BEGIN
IF
X
inf
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
IF
T
Track
under
NIL
THEN
M
id
suspend
M
state
V
T
dsc
REPEAT
V
V
next
V
handle
V
M
V
Viewer
state
UNTIL
V
T
dsc
RestoreTrack
T
END
END
END
CloseTrack
PROCEDURE
Broadcast
VAR
M
Display
FrameMsg
VAR
T
V
Display
Frame
BEGIN
T
FillerTrack
next
WHILE
T
FillerTrack
DO
V
T
dsc
REPEAT
V
V
next
V
handle
V
M
UNTIL
V
T
dsc
T
T
next
END
END
Broadcast
BEGIN
backup
NIL
curW
minH
DH
Display
Height
NEW
FillerViewer
FillerViewer
X
FillerViewer
W
inf
FillerViewer
Y
FillerViewer
H
DH
FillerViewer
next
FillerViewer
NEW
FillerTrack
FillerTrack
X
FillerTrack
W
inf
FillerTrack
Y
FillerTrack
H
DH
FillerTrack
dsc
FillerViewer
FillerTrack
next
FillerTrack
END
Viewers
MODULE
Curves
NW
IMPORT
Display
Files
Oberon
Graphics
GraphicFrames
TYPE
Curve
POINTER
TO
CurveDesc
CurveDesc
RECORD
Graphics
ObjectDesc
kind
lw
INTEGER
END
kind
up
line
down
line
circle
ellipse
VAR
method
Graphics
Method
PROCEDURE
Dot
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
IF
x
f
X
x
f
X1
y
f
Y
x
f
Y1
THEN
Display
Dot
col
x
y
Display
replace
END
END
Dot
PROCEDURE
mark
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
DEC
x
DEC
y
IF
x
f
X
x
f
X1
y
f
Y
y
f
Y1
THEN
IF
col
Display
black
THEN
Display
ReplConst
Display
black
x
y
Display
replace
ELSE
Display
CopyPattern
col
GraphicFrames
tack
x
y
Display
replace
END
END
END
mark
PROCEDURE
line
f
GraphicFrames
Frame
col
INTEGER
x
y
w
h
d
LONGINT
VAR
x1
y1
u
LONGINT
BEGIN
IF
h
w
THEN
x1
x
w
u
h
w
DIV
IF
d
THEN
INC
y
h
END
WHILE
x
x1
DO
Dot
f
col
x
y
INC
x
IF
u
THEN
INC
u
h
ELSE
INC
u
h
w
INC
y
d
END
END
ELSE
y1
y
h
u
w
h
DIV
IF
d
THEN
INC
x
w
END
WHILE
y
y1
DO
Dot
f
col
x
y
INC
y
IF
u
THEN
INC
u
w
ELSE
INC
u
w
h
INC
x
d
END
END
END
END
line
PROCEDURE
circle
f
GraphicFrames
Frame
col
INTEGER
x0
y0
r
LONGINT
VAR
x
y
u
LONGINT
BEGIN
u
r
x
r
y
WHILE
y
x
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
x
y0
y
IF
u
THEN
INC
u
y
ELSE
INC
u
y
x
DEC
x
END
INC
y
END
END
circle
PROCEDURE
ellipse
f
GraphicFrames
Frame
col
INTEGER
x0
y0
a
b
LONGINT
VAR
x
y
y1
aa
bb
d
g
h
LONGINT
BEGIN
aa
a
a
bb
b
b
h
aa
DIV
b
aa
bb
g
aa
DIV
b
aa
bb
x
y
b
WHILE
g
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
IF
h
THEN
d
x
bb
INC
g
d
ELSE
d
x
bb
y
aa
INC
g
d
aa
DEC
y
END
INC
h
d
INC
x
END
y1
y
h
bb
DIV
a
bb
aa
x
a
y
WHILE
y
y1
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
IF
h
THEN
INC
h
y
aa
ELSE
INC
h
y
aa
x
bb
DEC
x
END
INC
y
END
END
ellipse
PROCEDURE
New
VAR
c
Curve
BEGIN
NEW
c
c
do
method
Graphics
New
c
END
New
PROCEDURE
Copy
src
dst
Graphics
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Curve
kind
src
Curve
kind
dst
Curve
lw
src
Curve
lw
END
Copy
PROCEDURE
Draw
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
col
INTEGER
f
GraphicFrames
Frame
BEGIN
CASE
M
OF
GraphicFrames
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
M
col
Display
black
THEN
col
obj
col
ELSE
col
M
col
END
IF
x
f
X1
f
X
x
w
y
f
Y1
f
Y
y
h
THEN
IF
obj
Curve
kind
THEN
up
line
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
y
END
line
f
col
x
y
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
ELSIF
M
mode
THEN
mark
f
f
col
x
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
line
f
Display
black
x
y
w
h
END
ELSIF
obj
Curve
kind
THEN
down
line
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
y
h
END
line
f
col
x
y
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
h
ELSIF
M
mode
THEN
mark
f
f
col
x
y
h
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
h
line
f
Display
black
x
y
w
h
END
ELSIF
obj
Curve
kind
THEN
circle
w
w
DIV
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
w
y
END
circle
f
col
x
w
y
w
w
ELSIF
M
mode
THEN
mark
f
Display
white
x
w
y
ELSIF
M
mode
THEN
mark
f
f
col
x
w
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
w
y
circle
f
Display
black
x
w
y
w
w
END
ELSIF
obj
Curve
kind
THEN
ellipse
w
w
DIV
h
h
DIV
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
w
y
END
ellipse
f
col
x
w
y
h
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
w
y
ELSIF
M
mode
THEN
mark
f
f
col
x
w
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
w
y
ellipse
f
Display
black
x
w
y
h
w
h
END
END
END
END
END
Draw
PROCEDURE
Selectable
obj
Graphics
Object
x
y
INTEGER
BOOLEAN
VAR
xm
y0
w
h
INTEGER
res
BOOLEAN
BEGIN
IF
obj
Curve
kind
THEN
line
w
obj
w
h
obj
h
IF
obj
Curve
kind
THEN
y0
obj
y
h
h
h
ELSE
y0
obj
y
END
res
obj
x
x
x
obj
x
w
ABS
y
y0
w
x
obj
x
h
w
ELSE
circle
or
ellipse
xm
obj
w
DIV
obj
x
res
xm
x
x
xm
obj
y
y
y
obj
y
END
RETURN
res
END
Selectable
PROCEDURE
Change
obj
Graphics
Object
VAR
M
Graphics
Msg
BEGIN
IF
M
IS
Graphics
ColorMsg
THEN
obj
col
M
Graphics
ColorMsg
col
END
END
Change
PROCEDURE
Read
obj
Graphics
Object
VAR
R
Files
Rider
VAR
C
Graphics
Context
VAR
len
BYTE
BEGIN
Files
ReadByte
R
len
Files
ReadByte
R
len
obj
Curve
kind
len
Files
ReadByte
R
len
obj
Curve
lw
len
END
Read
PROCEDURE
Write
obj
Graphics
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Graphics
Context
BEGIN
Graphics
WriteObj
W
cno
obj
Files
WriteByte
W
Files
WriteByte
W
obj
Curve
kind
Files
WriteByte
W
obj
Curve
lw
END
Write
PROCEDURE
MakeLine
command
VAR
x0
x1
y0
y1
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
x1
G
mark
next
x
y1
G
mark
next
y
NEW
c
c
col
Oberon
CurCol
c
w
ABS
x1
x0
c
h
ABS
y1
y0
c
lw
Graphics
width
IF
x0
x1
THEN
c
x
x0
IF
y0
y1
THEN
c
kind
c
y
y0
ELSE
c
kind
c
y
y1
END
ELSE
c
x
x1
IF
y1
y0
THEN
c
kind
c
y
y1
ELSE
c
kind
c
y
y0
END
END
DEC
c
x
G
x
DEC
c
y
G
y
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
MakeLine
PROCEDURE
MakeCircle
command
VAR
x0
y0
r
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
r
ABS
G
mark
next
x
x0
IF
r
THEN
NEW
c
c
x
x0
r
G
x
c
y
y0
r
G
y
c
w
r
c
h
c
w
c
kind
c
col
Oberon
CurCol
c
lw
Graphics
width
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
END
MakeCircle
PROCEDURE
MakeEllipse
command
VAR
x0
y0
a
b
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
G
mark
next
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
a
ABS
G
mark
next
x
x0
b
ABS
G
mark
next
next
y
y0
IF
a
b
THEN
NEW
c
c
x
x0
a
G
x
c
y
y0
b
G
y
c
w
a
c
h
b
c
kind
c
col
Oberon
CurCol
c
lw
Graphics
width
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
END
MakeEllipse
BEGIN
NEW
method
method
module
Curves
method
allocator
New
method
new
New
method
copy
Copy
method
draw
Draw
method
selectable
Selectable
method
change
Change
method
read
Read
method
write
Write
END
Curves
MODULE
Display
NW
IMPORT
SYSTEM
CONST
black
white
black
background
replace
paint
invert
modes
base
0E7F00H
adr
of
x
pixel
monocolor
display
frame
TYPE
Frame
POINTER
TO
FrameDesc
FrameMsg
RECORD
END
Handler
PROCEDURE
F
Frame
VAR
M
FrameMsg
FrameDesc
RECORD
next
dsc
Frame
X
Y
W
H
INTEGER
handle
Handler
END
VAR
Base
Width
Height
INTEGER
arrow
star
hook
updown
block
cross
grey
INTEGER
a
pattern
is
an
array
of
bytes
the
first
is
its
width
the
second
its
height
the
rest
the
raster
PROCEDURE
Handle
F
Frame
VAR
M
FrameMsg
BEGIN
IF
F
NIL
F
handle
NIL
THEN
F
handle
F
M
END
END
Handle
raster
ops
PROCEDURE
Dot
col
x
y
mode
INTEGER
VAR
a
INTEGER
u
s
SET
BEGIN
a
base
x
DIV
y
s
x
MOD
SYSTEM
GET
a
u
IF
mode
paint
THEN
SYSTEM
PUT
a
u
s
ELSIF
mode
invert
THEN
SYSTEM
PUT
a
u
s
ELSE
mode
replace
IF
col
black
THEN
SYSTEM
PUT
a
u
s
ELSE
SYSTEM
PUT
a
u
s
END
END
END
Dot
PROCEDURE
ReplConst
col
x
y
w
h
mode
INTEGER
VAR
al
ar
a0
a1
INTEGER
left
right
mid
pix
pixl
pixr
SET
BEGIN
al
base
y
ar
x
w
DIV
al
al
x
DIV
al
IF
ar
al
THEN
mid
x
MOD
x
w
MOD
FOR
a1
al
TO
al
h
BY
DO
SYSTEM
GET
a1
pix
IF
mode
invert
THEN
SYSTEM
PUT
a1
pix
mid
ELSIF
mode
replace
col
black
THEN
erase
SYSTEM
PUT
a1
pix
mid
ELSE
mode
paint
OR
mode
replace
col
black
SYSTEM
PUT
a1
pix
mid
END
END
ELSIF
ar
al
THEN
left
x
MOD
right
x
w
MOD
FOR
a0
al
TO
al
h
BY
DO
SYSTEM
GET
a0
pixl
SYSTEM
GET
ar
pixr
IF
mode
invert
THEN
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
PUT
a1
pix
END
SYSTEM
PUT
ar
pixr
right
ELSIF
mode
replace
col
black
THEN
erase
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
PUT
a1
END
SYSTEM
PUT
ar
pixr
right
ELSE
mode
paint
OR
mode
replace
col
black
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
PUT
a1
END
SYSTEM
PUT
ar
pixr
right
END
INC
ar
END
END
END
ReplConst
PROCEDURE
CopyPattern
col
patadr
x
y
mode
INTEGER
only
for
modes
paint
invert
VAR
a
a0
pwd
INTEGER
w
h
pbt
BYTE
pix
SET
BEGIN
SYSTEM
GET
patadr
w
SYSTEM
GET
patadr
h
INC
patadr
a
base
x
DIV
y
FOR
a0
a
TO
a
h
BY
DO
build
pattern
line
w
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
100H
pwd
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
10000H
pwd
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
1000000H
pwd
END
END
END
SYSTEM
GET
a0
pix
IF
mode
invert
THEN
SYSTEM
PUT
a0
SYSTEM
VAL
SET
LSL
pwd
x
MOD
pix
ELSE
SYSTEM
PUT
a0
SYSTEM
VAL
SET
LSL
pwd
x
MOD
pix
END
IF
x
MOD
w
THEN
spill
over
SYSTEM
GET
a0
pix
IF
mode
invert
THEN
SYSTEM
PUT
a0
SYSTEM
VAL
SET
ASR
pwd
x
MOD
pix
ELSE
SYSTEM
PUT
a0
SYSTEM
VAL
SET
ASR
pwd
x
MOD
pix
END
END
END
END
CopyPattern
PROCEDURE
CopyBlock
sx
sy
w
h
dx
dy
mode
INTEGER
only
for
mode
replace
VAR
sa
da
sa0
sa1
d
len
INTEGER
u0
u1
u2
u3
v0
v1
v2
v3
n
INTEGER
end
step
INTEGER
src
dst
spill
SET
m0
m1
m2
m3
SET
BEGIN
u0
sx
DIV
u1
sx
MOD
u2
sx
w
DIV
u3
sx
w
MOD
v0
dx
DIV
v1
dx
MOD
v2
dx
w
DIV
v3
dx
w
MOD
sa
base
u0
sy
da
base
v0
dy
d
da
sa
n
u1
v1
displacement
in
words
and
bits
len
u2
u0
m0
v1
m2
v3
m3
m0
m2
IF
d
THEN
copy
up
scan
down
sa0
sa
h
end
sa
step
ELSE
copy
down
scan
up
sa0
sa
end
sa
h
step
END
WHILE
sa0
end
DO
IF
n
THEN
shift
right
m1
n
IF
v1
w
THEN
SYSTEM
GET
sa0
len
src
src
ROR
src
n
SYSTEM
GET
sa0
len
d
dst
SYSTEM
PUT
sa0
len
d
dst
m2
src
m2
spill
src
m1
FOR
sa1
sa0
len
TO
sa0
BY
DO
SYSTEM
GET
sa1
src
src
ROR
src
n
SYSTEM
PUT
sa1
d
spill
src
m1
spill
src
m1
END
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
SYSTEM
PUT
sa0
d
src
m0
dst
m0
ELSE
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
SYSTEM
PUT
sa0
d
src
m3
dst
m3
END
ELSE
shift
left
m1
n
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
IF
v1
w
THEN
SYSTEM
PUT
sa0
d
dst
m3
src
m3
ELSE
SYSTEM
PUT
sa0
d
dst
m0
src
m0
spill
src
m1
FOR
sa1
sa0
TO
sa0
len
BY
DO
SYSTEM
GET
sa1
src
src
ROR
src
n
SYSTEM
PUT
sa1
d
spill
src
m1
spill
src
m1
END
SYSTEM
GET
sa0
len
src
src
ROR
src
n
SYSTEM
GET
sa0
len
d
dst
SYSTEM
PUT
sa0
len
d
src
m2
dst
m2
END
END
INC
sa0
step
END
END
CopyBlock
PROCEDURE
ReplPattern
col
patadr
x
y
w
h
mode
INTEGER
pattern
width
fixed
pattern
starts
at
patadr
for
mode
invert
only
VAR
al
ar
a0
a1
INTEGER
pta0
pta1
INTEGER
pattern
addresses
ph
BYTE
left
right
mid
pix
pixl
pixr
ptw
SET
BEGIN
al
base
y
SYSTEM
GET
patadr
ph
pta0
patadr
pta1
ph
pta0
ar
x
w
DIV
al
al
x
DIV
al
IF
ar
al
THEN
mid
x
MOD
x
w
MOD
FOR
a1
al
TO
al
h
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
GET
pta0
ptw
SYSTEM
PUT
a1
pix
mid
pix
ptw
mid
INC
pta0
IF
pta0
pta1
THEN
pta0
patadr
END
END
ELSIF
ar
al
THEN
left
x
MOD
right
x
w
MOD
FOR
a0
al
TO
al
h
BY
DO
SYSTEM
GET
a0
pixl
SYSTEM
GET
pta0
ptw
SYSTEM
PUT
a0
pixl
left
pixl
ptw
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
PUT
a1
pix
ptw
END
SYSTEM
GET
ar
pixr
SYSTEM
PUT
ar
pixr
right
pixr
ptw
right
INC
pta0
INC
ar
IF
pta0
pta1
THEN
pta0
patadr
END
END
END
END
ReplPattern
BEGIN
Base
base
Width
Height
arrow
SYSTEM
ADR
0F0F
001C
000E
C101
E300
3F00
1F00
3F00
7F00
FF00
star
SYSTEM
ADR
0F0F
A002
C001
7F7F
C001
A002
hook
SYSTEM
ADR
0C0C
070F
C703
E701
F700
7F00
3F00
1F00
0F00
updown
SYSTEM
ADR
080E
183C
7EFF
FF7E3C18
block
SYSTEM
ADR
FFFF
C3C3
C3C3
FFFF
cross
SYSTEM
ADR
0F0F
grey
SYSTEM
ADR
AAAA
AAAA
END
Display
MODULE
Draw
NW
IMPORT
Files
Fonts
Viewers
Texts
Oberon
TextFrames
MenuViewers
Graphics
GraphicFrames
CONST
Menu
System
Close
System
Copy
System
Grow
Draw
Delete
Draw
Ticks
Draw
Restore
Draw
Store
VAR
W
Texts
Writer
Exported
commands
Open
Delete
SetWidth
ChangeColor
ChangeWidth
ChangeFont
Store
Print
Macro
Ticks
Restore
PROCEDURE
Open
VAR
X
Y
INTEGER
beg
end
t
LONGINT
G
Graphics
Graph
F
GraphicFrames
Frame
V
Viewers
Viewer
S
Texts
Scanner
text
Texts
Text
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
text
beg
end
t
IF
t
THEN
Texts
OpenScanner
S
text
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
THEN
NEW
G
Graphics
Open
G
S
s
NEW
F
GraphicFrames
Open
F
G
Oberon
AllocateUserViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
Menu
F
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Delete
VAR
F
GraphicFrames
Frame
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
F
Oberon
Par
vwr
dsc
next
GraphicFrames
Frame
GraphicFrames
Erase
F
Graphics
Delete
F
graph
END
END
Delete
PROCEDURE
GetArg
VAR
S
Texts
Scanner
VAR
T
Texts
Text
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
END
GetArg
PROCEDURE
SetWidth
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
S
i
S
i
THEN
Graphics
SetWidth
S
i
END
END
SetWidth
PROCEDURE
ChangeColor
VAR
S
Texts
Scanner
CM
Graphics
ColorMsg
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
CM
col
S
i
MOD
GraphicFrames
Change
GraphicFrames
Selected
CM
END
END
ChangeColor
PROCEDURE
ChangeWidth
VAR
S
Texts
Scanner
WM
Graphics
WidMsg
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
WM
w
S
i
GraphicFrames
Change
GraphicFrames
Selected
WM
END
END
ChangeWidth
PROCEDURE
ChangeFont
VAR
S
Texts
Scanner
FM
Graphics
FontMsg
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
FM
fnt
Fonts
This
S
s
IF
FM
fnt
NIL
THEN
GraphicFrames
Change
GraphicFrames
Selected
FM
END
END
END
ChangeFont
PROCEDURE
Redraw
Q
BOOLEAN
VAR
v
Viewers
Viewer
G
GraphicFrames
Frame
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
v
Oberon
Par
vwr
ELSE
v
Oberon
MarkedViewer
END
IF
v
NIL
v
dsc
NIL
v
dsc
next
IS
GraphicFrames
Frame
THEN
G
v
dsc
next
GraphicFrames
Frame
G
ticked
Q
OR
G
ticked
GraphicFrames
Restore
G
END
END
Redraw
PROCEDURE
Ticks
BEGIN
Redraw
FALSE
END
Ticks
PROCEDURE
Restore
BEGIN
Redraw
TRUE
END
Restore
PROCEDURE
Backup
VAR
name
ARRAY
OF
CHAR
VAR
res
i
INTEGER
ch
CHAR
bak
ARRAY
OF
CHAR
BEGIN
i
ch
name
WHILE
ch
0X
DO
bak
i
ch
INC
i
ch
name
i
END
IF
i
THEN
bak
i
bak
i
B
bak
i
a
bak
i
k
bak
i
0X
Files
Rename
name
bak
res
END
END
Backup
PROCEDURE
Store
VAR
S
Texts
Scanner
Menu
TextFrames
Frame
G
GraphicFrames
Frame
v
Viewers
Viewer
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
Menu
Oberon
Par
vwr
dsc
TextFrames
Frame
G
Menu
next
GraphicFrames
Frame
Texts
OpenScanner
S
Menu
text
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
S
s
Texts
WriteString
W
storing
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
GraphicFrames
Store
G
S
s
END
ELSE
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
v
Oberon
MarkedViewer
IF
v
dsc
NIL
v
dsc
next
IS
GraphicFrames
Frame
THEN
G
v
dsc
next
GraphicFrames
Frame
Texts
WriteString
W
S
s
Texts
WriteString
W
storing
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
GraphicFrames
Store
G
S
s
END
END
END
END
Store
PROCEDURE
Macro
VAR
S
Texts
Scanner
T
Texts
Text
time
beg
end
LONGINT
Lname
ARRAY
OF
CHAR
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Lname
S
s
Texts
Scan
S
IF
S
class
Texts
Name
THEN
GraphicFrames
Macro
Lname
S
s
END
END
END
Macro
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
Draw
NW
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
Draw
MODULE
Edit
JG
NW
IMPORT
Files
Fonts
Texts
Display
Viewers
Oberon
MenuViewers
TextFrames
CONST
CR
0DX
maxlen
StandardMenu
System
Close
System
Copy
System
Grow
Edit
Search
Edit
Store
VAR
W
Texts
Writer
time
LONGINT
M
INTEGER
pat
ARRAY
maxlen
OF
CHAR
d
ARRAY
OF
INTEGER
PROCEDURE
Max
i
j
LONGINT
LONGINT
VAR
m
LONGINT
BEGIN
IF
i
j
THEN
m
i
ELSE
m
j
END
RETURN
m
END
Max
PROCEDURE
Open
VAR
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
X
Y
INTEGER
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
OR
S
line
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
THEN
Oberon
AllocateUserViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Store
VAR
V
Viewers
Viewer
Text
TextFrames
Frame
T
Texts
Text
S
Texts
Scanner
f
Files
File
R
Files
Rider
beg
end
time
len
LONGINT
PROCEDURE
Backup
VAR
name
ARRAY
OF
CHAR
VAR
res
i
INTEGER
bak
ARRAY
OF
CHAR
BEGIN
i
WHILE
name
i
0X
DO
bak
i
name
i
INC
i
END
bak
i
bak
i
B
bak
i
a
bak
i
k
bak
i
0X
Files
Rename
name
bak
res
END
Backup
BEGIN
Texts
WriteString
W
Edit
Store
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
V
Oberon
Par
vwr
Texts
OpenScanner
S
V
dsc
TextFrames
Frame
text
ELSE
V
Oberon
MarkedViewer
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
END
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
Texts
WriteString
W
S
s
Texts
WriteInt
W
Text
text
len
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
Texts
Close
Text
text
S
s
END
END
Store
PROCEDURE
CopyLooks
VAR
T
Texts
Text
F
TextFrames
Frame
v
Viewers
Viewer
beg
end
time
LONGINT
fnt
Fonts
Font
col
voff
INTEGER
BEGIN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
v
Oberon
FocusViewer
IF
v
NIL
v
dsc
NIL
v
dsc
next
IS
TextFrames
Frame
THEN
F
v
dsc
next
TextFrames
Frame
Texts
Attributes
F
text
F
carloc
pos
fnt
col
voff
Texts
ChangeLooks
T
beg
end
fnt
col
voff
END
END
END
CopyLooks
PROCEDURE
ChangeFont
VAR
S
Texts
Scanner
T
Texts
Text
beg
end
LONGINT
BEGIN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
ChangeLooks
T
beg
end
Fonts
This
S
s
END
END
END
ChangeFont
PROCEDURE
ChangeColor
VAR
S
Texts
Scanner
T
Texts
Text
col
INTEGER
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
col
S
i
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
ChangeLooks
T
beg
end
NIL
col
END
END
END
ChangeColor
PROCEDURE
ChangeOffset
VAR
S
Texts
Scanner
T
Texts
Text
voff
INTEGER
ch
CHAR
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
voff
S
i
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
ChangeLooks
T
beg
end
NIL
voff
END
END
END
ChangeOffset
PROCEDURE
Search
uses
global
variables
M
pat
d
for
Boyer
Moore
search
VAR
Text
TextFrames
Frame
V
Viewers
Viewer
R
Texts
Reader
T
Texts
Text
pos
beg
end
prevTime
len
LONGINT
n
i
j
INTEGER
buf
ARRAY
OF
CHAR
PROCEDURE
Forward
n
INTEGER
VAR
R
Texts
Reader
VAR
buf
ARRAY
OF
CHAR
VAR
m
INTEGER
j
INTEGER
BEGIN
m
M
n
j
WHILE
j
m
DO
buf
j
buf
n
j
INC
j
END
WHILE
j
M
DO
Texts
Read
R
buf
j
INC
j
END
END
Forward
BEGIN
V
Oberon
Par
vwr
IF
Oberon
Par
frame
V
dsc
THEN
V
Oberon
FocusViewer
END
IF
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
prevTime
time
Oberon
GetSelection
T
beg
end
time
IF
time
prevTime
THEN
Texts
OpenReader
R
T
beg
i
pos
beg
REPEAT
Texts
Read
R
pat
i
INC
i
INC
pos
UNTIL
i
maxlen
OR
pos
end
M
i
j
WHILE
j
DO
d
j
M
INC
j
END
j
WHILE
j
M
DO
d
ORD
pat
j
M
j
INC
j
END
END
IF
Text
hasCar
THEN
pos
Text
carloc
pos
ELSE
pos
END
len
Text
text
len
Texts
OpenReader
R
Text
text
pos
Forward
M
R
buf
pos
pos
M
j
M
REPEAT
DEC
j
UNTIL
j
OR
buf
j
pat
j
WHILE
j
pos
len
DO
n
d
ORD
buf
M
Forward
n
R
buf
INC
pos
n
j
M
REPEAT
DEC
j
UNTIL
j
OR
buf
j
pat
j
END
IF
j
THEN
TextFrames
RemoveSelection
Text
TextFrames
RemoveCaret
Text
Oberon
RemoveMarks
Text
X
Text
Y
Text
W
Text
H
TextFrames
Show
Text
pos
Oberon
PassFocus
V
TextFrames
SetCaret
Text
pos
END
END
END
Search
PROCEDURE
Locate
VAR
Text
TextFrames
Frame
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
beg
end
time
LONGINT
BEGIN
V
Oberon
FocusViewer
IF
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
REPEAT
Texts
Scan
S
UNTIL
S
class
Texts
Int
skip
names
IF
S
class
Texts
Int
THEN
TextFrames
RemoveSelection
Text
TextFrames
RemoveCaret
Text
Oberon
RemoveMarks
Text
X
Text
Y
Text
W
Text
H
TextFrames
Show
Text
Max
S
i
Oberon
PassFocus
V
TextFrames
SetCaret
Text
S
i
END
END
END
END
Locate
PROCEDURE
Recall
VAR
Menu
Main
Display
Frame
buf
Texts
Buffer
V
Viewers
Viewer
pos
LONGINT
M
TextFrames
Frame
BEGIN
V
Oberon
FocusViewer
IF
V
NIL
V
IS
MenuViewers
Viewer
THEN
Menu
V
dsc
Main
V
dsc
next
IF
Main
IS
TextFrames
Frame
THEN
M
Main
TextFrames
Frame
IF
M
hasCar
THEN
TextFrames
Recall
buf
pos
M
carloc
pos
buf
len
Texts
Insert
M
text
M
carloc
pos
buf
TextFrames
SetCaret
M
pos
END
ELSIF
Menu
IS
TextFrames
Frame
THEN
M
Menu
TextFrames
Frame
IF
M
hasCar
THEN
TextFrames
Recall
buf
pos
M
carloc
pos
buf
len
Texts
Insert
M
text
M
carloc
pos
buf
TextFrames
SetCaret
M
pos
END
END
END
END
Recall
BEGIN
Texts
OpenWriter
W
END
Edit
MODULE
FileDir
NW
IMPORT
SYSTEM
Kernel
File
Directory
is
a
B
tree
with
its
root
page
at
DirRootAdr
Each
entry
contains
a
file
name
and
the
disk
address
of
the
file
s
head
sector
CONST
FnLength
SecTabSize
ExTabSize
SectorSize
IndexSize
SectorSize
DIV
HeaderSize
DirRootAdr
DirPgSize
N
DirPgSize
DIV
DirMark
9B1EA38DH
HeaderMark
9BA71D86H
FillerSize
TYPE
DiskAdr
INTEGER
FileName
ARRAY
FnLength
OF
CHAR
SectorTable
ARRAY
SecTabSize
OF
DiskAdr
ExtensionTable
ARRAY
ExTabSize
OF
DiskAdr
EntryHandler
PROCEDURE
name
FileName
sec
DiskAdr
VAR
continue
BOOLEAN
FileHeader
RECORD
first
page
of
each
file
on
disk
mark
INTEGER
name
FileName
aleng
bleng
date
INTEGER
ext
ExtensionTable
sec
SectorTable
fill
ARRAY
SectorSize
HeaderSize
OF
BYTE
END
FileHd
POINTER
TO
FileHeader
IndexSector
ARRAY
IndexSize
OF
DiskAdr
DataSector
ARRAY
SectorSize
OF
BYTE
DirEntry
B
tree
node
RECORD
name
FileName
adr
DiskAdr
sec
no
of
file
header
p
DiskAdr
sec
no
of
descendant
in
directory
END
DirPage
RECORD
mark
INTEGER
m
INTEGER
p0
DiskAdr
sec
no
of
left
descendant
in
directory
fill
ARRAY
FillerSize
OF
BYTE
e
ARRAY
DirPgSize
OF
DirEntry
END
Exported
procedures
Search
Insert
Delete
Enumerate
Init
PROCEDURE
Search
name
FileName
VAR
A
DiskAdr
VAR
i
L
R
INTEGER
dadr
DiskAdr
a
DirPage
BEGIN
dadr
DirRootAdr
A
REPEAT
Kernel
GetSector
dadr
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
a
m
name
a
e
R
name
THEN
A
a
e
R
adr
found
ELSIF
R
THEN
dadr
a
p0
ELSE
dadr
a
e
R
p
END
UNTIL
dadr
OR
A
END
Search
PROCEDURE
insert
name
FileName
dpg0
DiskAdr
VAR
h
BOOLEAN
VAR
v
DirEntry
fad
DiskAdr
h
tree
has
become
higher
and
v
is
ascending
element
VAR
ch
CHAR
i
j
L
R
INTEGER
dpg1
DiskAdr
u
DirEntry
a
DirPage
BEGIN
h
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
a
m
name
a
e
R
name
THEN
a
e
R
adr
fad
Kernel
PutSector
dpg0
a
replace
ELSE
not
on
this
page
IF
R
THEN
dpg1
a
p0
ELSE
dpg1
a
e
R
p
END
IF
dpg1
THEN
not
in
tree
insert
u
adr
fad
u
p
h
TRUE
j
REPEAT
ch
name
j
u
name
j
ch
INC
j
UNTIL
ch
0X
WHILE
j
FnLength
DO
u
name
j
0X
INC
j
END
ELSE
insert
name
dpg1
h
u
fad
END
IF
h
THEN
insert
u
to
the
left
of
e
R
IF
a
m
DirPgSize
THEN
h
FALSE
i
a
m
WHILE
i
R
DO
DEC
i
a
e
i
a
e
i
END
a
e
R
u
INC
a
m
ELSE
split
page
and
assign
the
middle
element
to
v
a
m
N
a
mark
DirMark
IF
R
N
THEN
insert
in
left
half
v
a
e
N
i
N
WHILE
i
R
DO
DEC
i
a
e
i
a
e
i
END
a
e
R
u
Kernel
PutSector
dpg0
a
Kernel
AllocSector
dpg0
dpg0
i
WHILE
i
N
DO
a
e
i
a
e
i
N
INC
i
END
ELSE
insert
in
right
half
Kernel
PutSector
dpg0
a
Kernel
AllocSector
dpg0
dpg0
DEC
R
N
i
IF
R
THEN
v
u
ELSE
v
a
e
N
WHILE
i
R
DO
a
e
i
a
e
N
i
INC
i
END
a
e
i
u
INC
i
END
WHILE
i
N
DO
a
e
i
a
e
N
i
INC
i
END
END
a
p0
v
p
v
p
dpg0
END
Kernel
PutSector
dpg0
a
END
END
END
insert
PROCEDURE
Insert
name
FileName
fad
DiskAdr
VAR
oldroot
DiskAdr
h
BOOLEAN
U
DirEntry
a
DirPage
BEGIN
h
FALSE
insert
name
DirRootAdr
h
U
fad
IF
h
THEN
root
overflow
Kernel
GetSector
DirRootAdr
a
ASSERT
a
mark
DirMark
Kernel
AllocSector
DirRootAdr
oldroot
Kernel
PutSector
oldroot
a
a
mark
DirMark
a
m
a
p0
oldroot
a
e
U
Kernel
PutSector
DirRootAdr
a
END
END
Insert
PROCEDURE
underflow
VAR
c
DirPage
ancestor
page
dpg0
DiskAdr
s
INTEGER
insertion
point
in
c
VAR
h
BOOLEAN
c
undersize
VAR
i
k
INTEGER
dpg1
DiskAdr
a
b
DirPage
a
underflowing
page
b
neighbouring
page
BEGIN
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
h
a
m
N
dpg0
c
e
s
p
IF
s
c
m
THEN
b
page
to
the
right
of
a
dpg1
c
e
s
p
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
k
b
m
N
DIV
k
no
of
items
available
on
page
b
a
e
N
c
e
s
a
e
N
p
b
p0
IF
k
THEN
move
k
items
from
b
to
a
one
to
c
i
WHILE
i
k
DO
a
e
i
N
b
e
i
INC
i
END
c
e
s
b
e
i
b
p0
c
e
s
p
c
e
s
p
dpg1
b
m
b
m
k
i
WHILE
i
b
m
DO
b
e
i
b
e
i
k
INC
i
END
Kernel
PutSector
dpg1
b
a
m
N
k
h
FALSE
ELSE
merge
pages
a
and
b
discard
b
i
WHILE
i
N
DO
a
e
i
N
b
e
i
INC
i
END
i
s
DEC
c
m
WHILE
i
c
m
DO
c
e
i
c
e
i
INC
i
END
a
m
N
h
c
m
N
END
Kernel
PutSector
dpg0
a
ELSE
b
page
to
the
left
of
a
DEC
s
IF
s
THEN
dpg1
c
p0
ELSE
dpg1
c
e
s
p
END
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
k
b
m
N
DIV
k
no
of
items
available
on
page
b
IF
k
THEN
i
N
WHILE
i
DO
DEC
i
a
e
i
k
a
e
i
END
i
k
a
e
i
c
e
s
a
e
i
p
a
p0
move
k
items
from
b
to
a
one
to
c
b
m
b
m
k
WHILE
i
DO
DEC
i
a
e
i
b
e
i
b
m
END
c
e
s
b
e
b
m
a
p0
c
e
s
p
c
e
s
p
dpg0
a
m
N
k
h
FALSE
Kernel
PutSector
dpg0
a
ELSE
merge
pages
a
and
b
discard
a
c
e
s
p
a
p0
b
e
N
c
e
s
i
WHILE
i
N
DO
b
e
i
N
a
e
i
INC
i
END
b
m
N
DEC
c
m
h
c
m
N
END
Kernel
PutSector
dpg1
b
END
END
underflow
PROCEDURE
delete
name
FileName
dpg0
DiskAdr
VAR
h
BOOLEAN
VAR
fad
DiskAdr
search
and
delete
entry
with
key
name
if
a
page
underflow
arises
balance
with
adjacent
page
or
merge
h
page
dpg0
is
undersize
VAR
i
L
R
INTEGER
dpg1
DiskAdr
a
DirPage
PROCEDURE
del
VAR
a
DirPage
R
INTEGER
dpg1
DiskAdr
VAR
h
BOOLEAN
VAR
dpg2
DiskAdr
global
a
R
b
DirPage
BEGIN
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
dpg2
b
e
b
m
p
IF
dpg2
THEN
del
a
R
dpg2
h
IF
h
THEN
underflow
b
dpg2
b
m
h
Kernel
PutSector
dpg1
b
END
ELSE
b
e
b
m
p
a
e
R
p
a
e
R
b
e
b
m
DEC
b
m
h
b
m
N
Kernel
PutSector
dpg1
b
END
END
del
BEGIN
h
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
THEN
dpg1
a
p0
ELSE
dpg1
a
e
R
p
END
IF
R
a
m
name
a
e
R
name
THEN
found
now
delete
fad
a
e
R
adr
IF
dpg1
THEN
a
is
a
leaf
page
DEC
a
m
h
a
m
N
i
R
WHILE
i
a
m
DO
a
e
i
a
e
i
INC
i
END
ELSE
del
a
R
dpg1
h
IF
h
THEN
underflow
a
dpg1
R
h
END
END
Kernel
PutSector
dpg0
a
ELSIF
dpg1
THEN
delete
name
dpg1
h
fad
IF
h
THEN
underflow
a
dpg1
R
h
Kernel
PutSector
dpg0
a
END
ELSE
not
in
tree
fad
END
END
delete
PROCEDURE
Delete
name
FileName
VAR
fad
DiskAdr
VAR
h
BOOLEAN
newroot
DiskAdr
a
DirPage
BEGIN
h
FALSE
delete
name
DirRootAdr
h
fad
IF
h
THEN
root
underflow
Kernel
GetSector
DirRootAdr
a
ASSERT
a
mark
DirMark
IF
a
m
a
p0
THEN
newroot
a
p0
Kernel
GetSector
newroot
a
ASSERT
a
mark
DirMark
Kernel
PutSector
DirRootAdr
a
discard
newroot
END
END
END
Delete
PROCEDURE
enumerate
prefix
ARRAY
OF
CHAR
dpg
DiskAdr
proc
EntryHandler
VAR
continue
BOOLEAN
VAR
i
j
INTEGER
pfx
nmx
CHAR
dpg1
DiskAdr
a
DirPage
BEGIN
Kernel
GetSector
dpg
a
ASSERT
a
mark
DirMark
i
WHILE
i
a
m
continue
DO
j
REPEAT
pfx
prefix
j
nmx
a
e
i
name
j
INC
j
UNTIL
nmx
pfx
OR
pfx
0X
IF
nmx
pfx
THEN
IF
i
THEN
dpg1
a
p0
ELSE
dpg1
a
e
i
p
END
IF
dpg1
THEN
enumerate
prefix
dpg1
proc
continue
END
IF
pfx
0X
THEN
IF
continue
THEN
proc
a
e
i
name
a
e
i
adr
continue
END
ELSE
continue
FALSE
END
END
INC
i
END
IF
continue
i
a
e
i
p
THEN
enumerate
prefix
a
e
i
p
proc
continue
END
END
enumerate
PROCEDURE
Enumerate
prefix
ARRAY
OF
CHAR
proc
EntryHandler
VAR
b
BOOLEAN
BEGIN
b
TRUE
enumerate
prefix
DirRootAdr
proc
b
END
Enumerate
initialization
PROCEDURE
Init
VAR
k
INTEGER
A
ARRAY
OF
DiskAdr
PROCEDURE
MarkSectors
VAR
A
ARRAY
OF
DiskAdr
k
INTEGER
VAR
L
R
i
j
n
INTEGER
x
DiskAdr
hd
FileHeader
B
IndexSector
PROCEDURE
sift
VAR
A
ARRAY
OF
DiskAdr
L
R
INTEGER
VAR
i
j
INTEGER
x
DiskAdr
BEGIN
j
L
x
A
j
REPEAT
i
j
j
j
IF
j
R
A
j
A
j
THEN
INC
j
END
IF
j
R
x
A
j
THEN
A
i
A
j
END
UNTIL
j
R
OR
x
A
j
A
i
x
END
sift
BEGIN
L
k
DIV
R
k
heapsort
WHILE
L
DO
DEC
L
sift
A
L
R
END
WHILE
R
DO
DEC
R
x
A
A
A
R
A
R
x
sift
A
L
R
END
WHILE
L
k
DO
Kernel
GetSector
A
L
hd
ASSERT
hd
mark
HeaderMark
IF
hd
aleng
SecTabSize
THEN
j
hd
aleng
REPEAT
DEC
j
Kernel
MarkSector
hd
sec
j
UNTIL
j
ELSE
j
SecTabSize
REPEAT
DEC
j
Kernel
MarkSector
hd
sec
j
UNTIL
j
n
hd
aleng
SecTabSize
DIV
i
WHILE
i
n
DO
Kernel
MarkSector
hd
ext
i
Kernel
GetSector
hd
ext
i
B
index
sector
IF
i
n
THEN
j
ELSE
j
hd
aleng
SecTabSize
MOD
END
REPEAT
DEC
j
Kernel
MarkSector
B
j
UNTIL
j
INC
i
END
END
INC
L
END
END
MarkSectors
PROCEDURE
TraverseDir
VAR
A
ARRAY
OF
DiskAdr
VAR
k
INTEGER
dpg
DiskAdr
VAR
i
INTEGER
a
DirPage
BEGIN
Kernel
GetSector
dpg
a
ASSERT
a
mark
DirMark
Kernel
MarkSector
dpg
i
WHILE
i
a
m
DO
A
k
a
e
i
adr
INC
k
INC
i
IF
k
THEN
MarkSectors
A
k
k
END
END
IF
a
p0
THEN
TraverseDir
A
k
a
p0
i
WHILE
i
a
m
DO
TraverseDir
A
k
a
e
i
p
INC
i
END
END
END
TraverseDir
BEGIN
k
TraverseDir
A
k
DirRootAdr
MarkSectors
A
k
END
Init
END
FileDir
MODULE
Files
NW
IMPORT
SYSTEM
Kernel
FileDir
A
file
consists
of
a
sequence
of
pages
The
first
page
contains
the
header
Part
of
the
header
is
the
page
table
an
array
of
disk
addresses
to
the
pages
A
file
is
referenced
through
riders
A
rider
indicates
a
current
position
and
refers
to
a
file
CONST
MaxBufs
HS
FileDir
HeaderSize
SS
FileDir
SectorSize
STS
FileDir
SecTabSize
XS
FileDir
IndexSize
TYPE
DiskAdr
INTEGER
File
POINTER
TO
FileDesc
Buffer
POINTER
TO
BufferRecord
Index
POINTER
TO
IndexRecord
Rider
RECORD
eof
BOOLEAN
res
INTEGER
file
File
apos
bpos
INTEGER
buf
Buffer
END
FileDesc
RECORD
next
INTEGER
list
of
files
invisible
to
the
GC
nofbufs
aleng
bleng
INTEGER
modH
registered
BOOLEAN
firstbuf
Buffer
sechint
DiskAdr
name
FileDir
FileName
date
INTEGER
ext
ARRAY
FileDir
ExTabSize
OF
Index
sec
FileDir
SectorTable
END
BufferRecord
RECORD
apos
lim
INTEGER
mod
BOOLEAN
next
Buffer
data
FileDir
DataSector
END
IndexRecord
RECORD
adr
DiskAdr
mod
BOOLEAN
sec
FileDir
IndexSector
END
aleng
SS
bleng
length
including
header
apos
SS
bpos
current
position
bpos
lim
SS
apos
aleng
PgTabSize
apos
aleng
lim
SS
OR
apos
aleng
VAR
root
INTEGER
File
list
of
open
files
PROCEDURE
Check
s
ARRAY
OF
CHAR
VAR
name
FileDir
FileName
VAR
res
INTEGER
VAR
i
INTEGER
ch
CHAR
BEGIN
ch
s
i
IF
ch
A
ch
Z
OR
ch
a
ch
z
THEN
REPEAT
name
i
ch
INC
i
ch
s
i
UNTIL
ch
ch
OR
ch
A
ch
Z
OR
ch
a
ch
z
OR
ch
OR
i
FileDir
FnLength
IF
i
FileDir
FnLength
THEN
res
ELSIF
ch
0X
THEN
res
WHILE
i
FileDir
FnLength
DO
name
i
0X
INC
i
END
ELSE
res
END
ELSIF
ch
0X
THEN
name
0X
res
ELSE
res
END
END
Check
PROCEDURE
Old
name
ARRAY
OF
CHAR
File
VAR
i
k
res
INTEGER
f
File
header
DiskAdr
buf
Buffer
F
FileDir
FileHd
namebuf
FileDir
FileName
inxpg
Index
BEGIN
f
NIL
Check
name
namebuf
res
IF
res
THEN
FileDir
Search
namebuf
header
IF
header
THEN
f
SYSTEM
VAL
File
root
WHILE
f
NIL
f
sec
header
DO
f
SYSTEM
VAL
File
f
next
END
IF
f
NIL
THEN
file
not
yet
present
NEW
buf
buf
apos
buf
next
buf
buf
mod
FALSE
F
SYSTEM
VAL
FileDir
FileHd
SYSTEM
ADR
buf
data
Kernel
GetSector
header
buf
data
ASSERT
F
mark
FileDir
HeaderMark
NEW
f
f
aleng
F
aleng
f
bleng
F
bleng
f
date
F
date
IF
f
aleng
THEN
buf
lim
f
bleng
ELSE
buf
lim
SS
END
f
firstbuf
buf
f
nofbufs
f
name
namebuf
f
registered
TRUE
f
sec
F
sec
k
f
aleng
XS
STS
DIV
XS
i
WHILE
i
k
DO
NEW
inxpg
inxpg
adr
F
ext
i
inxpg
mod
FALSE
Kernel
GetSector
inxpg
adr
inxpg
sec
f
ext
i
inxpg
INC
i
END
WHILE
i
FileDir
ExTabSize
DO
f
ext
i
NIL
INC
i
END
f
sechint
header
f
modH
FALSE
f
next
root
root
SYSTEM
VAL
INTEGER
f
END
END
END
RETURN
f
END
Old
PROCEDURE
New
name
ARRAY
OF
CHAR
File
VAR
i
res
INTEGER
f
File
buf
Buffer
F
FileDir
FileHd
namebuf
FileDir
FileName
BEGIN
f
NIL
Check
name
namebuf
res
IF
res
THEN
NEW
buf
buf
apos
buf
mod
TRUE
buf
lim
HS
buf
next
buf
F
SYSTEM
VAL
FileDir
FileHd
SYSTEM
ADR
buf
data
F
mark
FileDir
HeaderMark
F
aleng
F
bleng
HS
F
name
namebuf
F
date
Kernel
Clock
NEW
f
f
aleng
f
bleng
HS
f
modH
TRUE
f
registered
FALSE
f
date
F
date
f
firstbuf
buf
f
nofbufs
f
name
namebuf
f
sechint
i
REPEAT
f
ext
i
NIL
F
ext
i
INC
i
UNTIL
i
FileDir
ExTabSize
i
REPEAT
f
sec
i
F
sec
i
INC
i
UNTIL
i
STS
END
RETURN
f
END
New
PROCEDURE
UpdateHeader
f
File
VAR
F
FileDir
FileHeader
VAR
k
INTEGER
BEGIN
F
aleng
f
aleng
F
bleng
f
bleng
F
sec
f
sec
k
f
aleng
XS
STS
DIV
XS
WHILE
k
DO
DEC
k
F
ext
k
f
ext
k
adr
END
END
UpdateHeader
PROCEDURE
ReadBuf
f
File
buf
Buffer
pos
INTEGER
VAR
sec
DiskAdr
BEGIN
IF
pos
STS
THEN
sec
f
sec
pos
ELSE
sec
f
ext
pos
STS
DIV
XS
sec
pos
STS
MOD
XS
END
Kernel
GetSector
sec
buf
data
IF
pos
f
aleng
THEN
buf
lim
SS
ELSE
buf
lim
f
bleng
END
buf
apos
pos
buf
mod
FALSE
END
ReadBuf
PROCEDURE
WriteBuf
f
File
buf
Buffer
VAR
i
k
INTEGER
secadr
DiskAdr
inx
Index
BEGIN
IF
buf
apos
STS
THEN
secadr
f
sec
buf
apos
IF
secadr
THEN
Kernel
AllocSector
f
sechint
secadr
f
modH
TRUE
f
sec
buf
apos
secadr
f
sechint
secadr
END
IF
buf
apos
THEN
UpdateHeader
f
SYSTEM
VAL
FileDir
FileHeader
buf
data
f
modH
FALSE
END
ELSE
i
buf
apos
STS
DIV
XS
inx
f
ext
i
IF
inx
NIL
THEN
NEW
inx
inx
adr
inx
sec
f
ext
i
inx
f
modH
TRUE
END
k
buf
apos
STS
MOD
XS
secadr
inx
sec
k
IF
secadr
THEN
Kernel
AllocSector
f
sechint
secadr
f
modH
TRUE
inx
mod
TRUE
inx
sec
k
secadr
f
sechint
secadr
END
END
Kernel
PutSector
secadr
buf
data
buf
mod
FALSE
END
WriteBuf
PROCEDURE
Buf
f
File
pos
INTEGER
Buffer
VAR
buf
Buffer
BEGIN
buf
f
firstbuf
WHILE
buf
apos
pos
buf
next
f
firstbuf
DO
buf
buf
next
END
IF
buf
apos
pos
THEN
buf
NIL
END
RETURN
buf
END
Buf
PROCEDURE
GetBuf
f
File
pos
INTEGER
Buffer
VAR
buf
Buffer
BEGIN
buf
f
firstbuf
WHILE
buf
apos
pos
buf
next
f
firstbuf
DO
buf
buf
next
END
IF
buf
apos
pos
THEN
IF
f
nofbufs
MaxBufs
THEN
allocate
new
buffer
NEW
buf
buf
next
f
firstbuf
next
f
firstbuf
next
buf
INC
f
nofbufs
ELSE
reuse
a
buffer
f
firstbuf
buf
IF
buf
mod
THEN
WriteBuf
f
buf
END
END
IF
pos
f
aleng
THEN
ReadBuf
f
buf
pos
ELSE
buf
apos
pos
buf
lim
buf
mod
FALSE
END
END
RETURN
buf
END
GetBuf
PROCEDURE
Unbuffer
f
File
VAR
i
k
INTEGER
buf
Buffer
inx
Index
head
FileDir
FileHeader
BEGIN
buf
f
firstbuf
REPEAT
IF
buf
mod
THEN
WriteBuf
f
buf
END
buf
buf
next
UNTIL
buf
f
firstbuf
k
f
aleng
XS
STS
DIV
XS
i
WHILE
i
k
DO
inx
f
ext
i
INC
i
IF
inx
mod
THEN
IF
inx
adr
THEN
Kernel
AllocSector
f
sechint
inx
adr
f
sechint
inx
adr
f
modH
TRUE
END
Kernel
PutSector
inx
adr
inx
sec
inx
mod
FALSE
END
END
IF
f
modH
THEN
Kernel
GetSector
f
sec
head
UpdateHeader
f
head
Kernel
PutSector
f
sec
head
f
modH
FALSE
END
END
Unbuffer
PROCEDURE
Register
f
File
BEGIN
IF
f
NIL
f
name
0X
THEN
Unbuffer
f
IF
f
registered
THEN
FileDir
Insert
f
name
f
sec
f
registered
TRUE
f
next
root
root
SYSTEM
VAL
INTEGER
f
END
END
END
Register
PROCEDURE
Close
f
File
BEGIN
IF
f
NIL
THEN
Unbuffer
f
END
END
Close
PROCEDURE
Purge
f
File
VAR
a
i
j
k
INTEGER
ind
FileDir
IndexSector
BEGIN
IF
f
NIL
THEN
a
f
aleng
f
aleng
f
bleng
HS
IF
a
STS
THEN
i
a
ELSE
i
STS
DEC
a
i
j
a
MOD
XS
k
a
DIV
XS
WHILE
k
DO
Kernel
GetSector
f
ext
k
adr
ind
REPEAT
DEC
j
Kernel
FreeSector
ind
j
UNTIL
j
Kernel
FreeSector
f
ext
k
adr
j
XS
DEC
k
END
END
REPEAT
DEC
i
Kernel
FreeSector
f
sec
i
UNTIL
i
END
END
Purge
PROCEDURE
Delete
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
adr
DiskAdr
namebuf
FileDir
FileName
BEGIN
Check
name
namebuf
res
IF
res
THEN
FileDir
Delete
namebuf
adr
IF
adr
THEN
res
END
END
END
Delete
PROCEDURE
Rename
old
new
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
adr
DiskAdr
oldbuf
newbuf
FileDir
FileName
head
FileDir
FileHeader
BEGIN
Check
old
oldbuf
res
IF
res
THEN
Check
new
newbuf
res
IF
res
THEN
FileDir
Delete
oldbuf
adr
IF
adr
THEN
FileDir
Insert
newbuf
adr
Kernel
GetSector
adr
head
head
name
newbuf
Kernel
PutSector
adr
head
ELSE
res
END
END
END
END
Rename
PROCEDURE
Length
f
File
INTEGER
BEGIN
RETURN
f
aleng
SS
f
bleng
HS
END
Length
PROCEDURE
Date
f
File
INTEGER
BEGIN
RETURN
f
date
END
Date
Read
PROCEDURE
Set
VAR
r
Rider
f
File
pos
INTEGER
VAR
a
b
INTEGER
BEGIN
r
eof
FALSE
r
res
IF
f
NIL
THEN
IF
pos
THEN
a
b
HS
ELSIF
pos
f
aleng
SS
f
bleng
HS
THEN
a
pos
HS
DIV
SS
b
pos
HS
MOD
SS
ELSE
a
f
aleng
b
f
bleng
END
r
file
f
r
apos
a
r
bpos
b
r
buf
f
firstbuf
ELSE
r
file
NIL
END
END
Set
PROCEDURE
Pos
VAR
r
Rider
INTEGER
BEGIN
RETURN
r
apos
SS
r
bpos
HS
END
Pos
PROCEDURE
Base
VAR
r
Rider
File
BEGIN
RETURN
r
file
END
Base
PROCEDURE
ReadByte
VAR
r
Rider
VAR
x
BYTE
VAR
buf
Buffer
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
x
r
buf
data
r
bpos
INC
r
bpos
ELSIF
r
apos
r
file
aleng
THEN
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
buf
mod
THEN
WriteBuf
r
file
r
buf
END
ReadBuf
r
file
r
buf
r
apos
ELSE
r
buf
buf
END
x
r
buf
data
r
bpos
ELSE
x
r
eof
TRUE
END
END
ReadByte
PROCEDURE
ReadBytes
VAR
r
Rider
VAR
x
ARRAY
OF
BYTE
n
INTEGER
VAR
i
INTEGER
BEGIN
i
this
implementation
is
to
be
improved
WHILE
i
n
DO
ReadByte
r
x
i
INC
i
END
END
ReadBytes
PROCEDURE
Read
VAR
r
Rider
VAR
ch
CHAR
VAR
buf
Buffer
same
as
ReadByte
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
ch
CHR
r
buf
data
r
bpos
INC
r
bpos
ELSIF
r
apos
r
file
aleng
THEN
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
buf
mod
THEN
WriteBuf
r
file
r
buf
END
ReadBuf
r
file
r
buf
r
apos
ELSE
r
buf
buf
END
ch
CHR
r
buf
data
r
bpos
ELSE
ch
0X
r
eof
TRUE
END
END
Read
PROCEDURE
ReadInt
VAR
R
Rider
VAR
x
INTEGER
VAR
x0
x1
x2
x3
BYTE
BEGIN
ReadByte
R
x0
ReadByte
R
x1
ReadByte
R
x2
ReadByte
R
x3
x
x3
100H
x2
100H
x1
100H
x0
END
ReadInt
PROCEDURE
ReadSet
VAR
R
Rider
VAR
s
SET
VAR
n
INTEGER
BEGIN
ReadInt
R
SYSTEM
VAL
INTEGER
s
END
ReadSet
PROCEDURE
ReadReal
VAR
R
Rider
VAR
x
REAL
VAR
n
INTEGER
BEGIN
ReadInt
R
SYSTEM
VAL
INTEGER
x
END
ReadReal
PROCEDURE
ReadString
VAR
R
Rider
VAR
x
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
i
Read
R
ch
WHILE
ch
0X
DO
IF
i
LEN
x
THEN
x
i
ch
INC
i
END
Read
R
ch
END
x
i
0X
END
ReadString
PROCEDURE
ReadNum
VAR
R
Rider
VAR
x
INTEGER
VAR
n
y
INTEGER
b
BYTE
BEGIN
n
y
ReadByte
R
b
WHILE
b
80H
DO
y
ROR
y
b
80H
DEC
n
ReadByte
R
b
END
IF
n
THEN
x
ROR
y
b
MOD
10H
ELSE
x
ASR
ROR
y
b
n
END
END
ReadNum
Write
PROCEDURE
NewExt
f
File
VAR
i
k
INTEGER
ext
Index
BEGIN
k
f
aleng
STS
DIV
XS
NEW
ext
ext
adr
ext
mod
TRUE
f
ext
k
ext
i
XS
REPEAT
DEC
i
ext
sec
i
UNTIL
i
END
NewExt
PROCEDURE
WriteByte
VAR
r
Rider
x
BYTE
VAR
f
File
buf
Buffer
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
IF
r
bpos
SS
THEN
INC
r
buf
lim
INC
r
file
bleng
r
file
modH
TRUE
ELSE
f
r
file
WriteBuf
f
r
buf
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
apos
f
aleng
THEN
ReadBuf
f
r
buf
r
apos
ELSE
r
buf
apos
r
apos
r
buf
lim
f
aleng
f
aleng
f
bleng
f
modH
TRUE
IF
f
aleng
STS
MOD
XS
THEN
NewExt
f
END
END
ELSE
r
buf
buf
END
r
bpos
END
END
r
buf
data
r
bpos
x
INC
r
bpos
r
buf
mod
TRUE
END
WriteByte
PROCEDURE
WriteBytes
VAR
r
Rider
x
ARRAY
OF
BYTE
n
INTEGER
VAR
i
INTEGER
BEGIN
i
this
implementation
is
to
be
improed
WHILE
i
n
DO
WriteByte
r
x
i
INC
i
END
END
WriteBytes
PROCEDURE
Write
VAR
r
Rider
ch
CHAR
VAR
f
File
buf
Buffer
BEGIN
same
as
WriteByte
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
IF
r
bpos
SS
THEN
INC
r
buf
lim
INC
r
file
bleng
r
file
modH
TRUE
ELSE
f
r
file
WriteBuf
f
r
buf
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
apos
f
aleng
THEN
ReadBuf
f
r
buf
r
apos
ELSE
r
buf
apos
r
apos
r
buf
lim
f
aleng
f
aleng
f
bleng
f
modH
TRUE
IF
f
aleng
STS
MOD
XS
THEN
NewExt
f
END
END
ELSE
r
buf
buf
END
r
bpos
END
END
r
buf
data
r
bpos
ORD
ch
INC
r
bpos
r
buf
mod
TRUE
END
Write
PROCEDURE
WriteInt
VAR
R
Rider
x
INTEGER
BEGIN
WriteByte
R
x
MOD
100H
WriteByte
R
x
DIV
100H
MOD
100H
WriteByte
R
x
DIV
10000H
MOD
100H
WriteByte
R
x
DIV
1000000H
MOD
100H
END
WriteInt
PROCEDURE
WriteSet
VAR
R
Rider
s
SET
BEGIN
WriteInt
R
ORD
s
END
WriteSet
PROCEDURE
WriteReal
VAR
R
Rider
x
REAL
BEGIN
WriteInt
R
ORD
x
END
WriteReal
PROCEDURE
WriteString
VAR
R
Rider
x
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
i
REPEAT
ch
x
i
Write
R
ch
INC
i
UNTIL
ch
0X
END
WriteString
PROCEDURE
WriteNum
VAR
R
Rider
x
INTEGER
BEGIN
WHILE
x
40H
OR
x
40H
DO
WriteByte
R
x
MOD
80H
80H
x
ASR
x
END
WriteByte
R
x
MOD
80H
END
WriteNum
System
use
PROCEDURE
Init
BEGIN
root
Kernel
Init
FileDir
Init
END
Init
PROCEDURE
RestoreList
after
mark
phase
of
garbage
collection
VAR
f
f0
INTEGER
PROCEDURE
mark
f
INTEGER
INTEGER
VAR
m
INTEGER
BEGIN
IF
f
THEN
m
ELSE
SYSTEM
GET
f
m
END
RETURN
m
END
mark
BEGIN
field
next
has
offset
WHILE
mark
root
DO
SYSTEM
GET
root
root
END
f
root
WHILE
f
DO
f0
f
REPEAT
SYSTEM
GET
f0
f0
UNTIL
mark
f0
SYSTEM
PUT
f
f0
f
f0
END
END
RestoreList
END
Files
MODULE
Fonts
JG
PDR
NW
IMPORT
SYSTEM
Files
CONST
FontFileId
0DBH
TYPE
Font
POINTER
TO
FontDesc
FontDesc
RECORD
name
ARRAY
OF
CHAR
height
minX
maxX
minY
maxY
INTEGER
next
Font
T
ARRAY
OF
INTEGER
raster
ARRAY
OF
BYTE
END
LargeFontDesc
RECORD
FontDesc
ext
ARRAY
OF
BYTE
END
LargeFont
POINTER
TO
LargeFontDesc
raster
sizes
Syntax8
Syntax10
Syntax12
Syntax14
Syntax14b
Syntax16
Syntax20
Syntac24
Syntax24b
VAR
Default
root
Font
PROCEDURE
GetPat
fnt
Font
ch
CHAR
VAR
dx
x
y
w
h
patadr
INTEGER
VAR
pa
INTEGER
dxb
xb
yb
wb
hb
BYTE
BEGIN
pa
fnt
T
ORD
ch
MOD
80H
patadr
pa
SYSTEM
GET
pa
dxb
SYSTEM
GET
pa
xb
SYSTEM
GET
pa
yb
SYSTEM
GET
pa
wb
SYSTEM
GET
pa
hb
dx
dxb
x
xb
y
yb
w
wb
h
hb
IF
yb
THEN
y
yb
ELSE
y
yb
END
END
GetPat
PROCEDURE
This
name
ARRAY
OF
CHAR
Font
TYPE
RunRec
RECORD
beg
end
BYTE
END
BoxRec
RECORD
dx
x
y
w
h
BYTE
END
VAR
F
Font
LF
LargeFont
f
Files
File
R
Files
Rider
NofRuns
NofBoxes
BYTE
NofBytes
INTEGER
height
minX
maxX
minY
maxY
BYTE
i
j
k
m
n
INTEGER
a
a0
INTEGER
b
beg
end
BYTE
run
ARRAY
OF
RunRec
box
ARRAY
OF
BoxRec
PROCEDURE
RdInt16
VAR
R
Files
Rider
VAR
b0
BYTE
VAR
b1
BYTE
BEGIN
Files
ReadByte
R
b0
Files
ReadByte
R
b1
END
RdInt16
BEGIN
F
root
WHILE
F
NIL
name
F
name
DO
F
F
next
END
IF
F
NIL
THEN
f
Files
Old
name
IF
f
NIL
THEN
Files
Set
R
f
Files
ReadByte
R
b
IF
b
FontFileId
THEN
Files
ReadByte
R
b
abstraction
Files
ReadByte
R
b
family
Files
ReadByte
R
b
variant
NEW
F
F
name
name
RdInt16
R
height
RdInt16
R
minX
RdInt16
R
maxX
RdInt16
R
minY
RdInt16
R
maxY
RdInt16
R
NofRuns
NofBoxes
k
WHILE
k
NofRuns
DO
RdInt16
R
beg
run
k
beg
beg
RdInt16
R
end
run
k
end
end
NofBoxes
NofBoxes
end
beg
INC
k
END
NofBytes
j
WHILE
j
NofBoxes
DO
RdInt16
R
box
j
dx
RdInt16
R
box
j
x
RdInt16
R
box
j
y
RdInt16
R
box
j
w
RdInt16
R
box
j
h
NofBytes
NofBytes
box
j
w
DIV
box
j
h
INC
j
END
IF
NofBytes
THEN
NEW
F
ELSE
NEW
LF
F
LF
END
F
name
name
F
height
height
F
minX
minX
F
maxX
maxX
F
maxY
maxY
IF
minY
80H
THEN
F
minY
minY
100H
ELSE
F
minY
minY
END
a0
SYSTEM
ADR
F
raster
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
null
pattern
for
characters
not
in
a
run
INC
a0
a
a0
j
k
m
WHILE
k
NofRuns
DO
WHILE
m
run
k
beg
m
DO
F
T
m
a0
INC
m
END
WHILE
m
run
k
end
m
DO
F
T
m
a
SYSTEM
PUT
a
box
j
dx
SYSTEM
PUT
a
box
j
x
SYSTEM
PUT
a
box
j
y
SYSTEM
PUT
a
box
j
w
SYSTEM
PUT
a
box
j
h
INC
a
n
box
j
w
DIV
box
j
h
WHILE
n
DO
DEC
n
Files
ReadByte
R
b
SYSTEM
PUT
a
b
INC
a
END
INC
j
INC
m
END
INC
k
END
WHILE
m
DO
F
T
m
a0
INC
m
END
F
next
root
root
F
ELSE
bad
file
id
F
Default
END
ELSE
font
file
not
available
F
Default
END
END
RETURN
F
END
This
PROCEDURE
Free
remove
all
but
first
two
from
font
list
VAR
f
Font
BEGIN
f
root
next
IF
f
NIL
THEN
f
f
next
END
f
next
NIL
END
Free
BEGIN
root
NIL
Default
This
Oberon10
Scn
Fnt
END
Fonts
MODULE
GraphicFrames
NW
IMPORT
SYSTEM
Display
Viewers
Input
Fonts
Texts
Graphics
Oberon
MenuViewers
CONST
update
message
ids
drawobj
drawobjs
drawobjd
drawnorm
drawsel
drawdel
markW
TYPE
Frame
POINTER
TO
FrameDesc
Location
POINTER
TO
LocDesc
LocDesc
RECORD
x
y
INTEGER
next
Location
END
FrameDesc
RECORD
Display
FrameDesc
graph
Graphics
Graph
Xg
Yg
INTEGER
pos
rel
to
graph
origin
X1
Y1
INTEGER
right
and
upper
margins
x
y
col
INTEGER
x
X
Xg
y
Y
Yg
marked
ticked
BOOLEAN
mark
LocDesc
END
DrawMsg
RECORD
Graphics
Msg
f
Frame
x
y
col
mode
INTEGER
END
UpdateMsg
RECORD
Display
FrameMsg
id
INTEGER
graph
Graphics
Graph
obj
Graphics
Object
END
ChangedMsg
RECORD
Display
FrameMsg
f
Frame
graph
Graphics
Graph
mode
INTEGER
END
SelQuery
RECORD
Display
FrameMsg
f
Frame
time
LONGINT
END
FocusQuery
RECORD
Display
FrameMsg
f
Frame
END
PosQuery
RECORD
Display
FrameMsg
f
Frame
x
y
INTEGER
END
DispMsg
RECORD
Display
FrameMsg
x1
y1
w
INTEGER
pat
INTEGER
graph
Graphics
Graph
END
VAR
Crosshair
Oberon
Marker
tack
dotted
dotted1
INTEGER
patterns
newcap
Graphics
Caption
TBuf
Texts
Buffer
DW
DH
CL
INTEGER
W
Texts
Writer
Exported
procedures
Restore
Focus
Selected
This
Draw
DrawNorm
Erase
DrawObj
EraseObj
Change
Defocus
Deselect
Macro
Open
PROCEDURE
SetChangeMark
F
Frame
col
INTEGER
set
mark
in
corner
of
frame
BEGIN
IF
F
H
THEN
IF
col
THEN
Display
ReplConst
Display
black
F
X
F
W
F
Y
F
H
Display
replace
ELSE
Display
CopyPattern
Display
white
Display
block
F
X
F
W
F
Y
F
H
Display
paint
END
END
END
SetChangeMark
PROCEDURE
Restore
F
Frame
VAR
x
x0
y
INTEGER
M
DrawMsg
BEGIN
F
X1
F
X
F
W
F
Y1
F
Y
F
H
F
x
F
X
F
Xg
DIV
F
y
F
Y
F
Yg
DIV
F
marked
FALSE
F
mark
next
NIL
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Display
ReplConst
F
col
F
X
F
Y
F
W
F
H
IF
F
ticked
THEN
x0
F
X
DIV
y
F
Y
DIV
WHILE
y
F
Y1
DO
x
x0
WHILE
x
F
X1
DO
Display
Dot
Display
white
x
y
Display
replace
INC
x
END
INC
y
END
END
M
f
F
M
x
F
x
M
y
F
y
M
col
M
mode
Graphics
Draw
F
graph
M
IF
F
graph
changed
THEN
SetChangeMark
F
END
END
Restore
PROCEDURE
FlipCross
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
cross
X
Y
Display
invert
END
FlipCross
PROCEDURE
Focus
Frame
VAR
FQ
FocusQuery
BEGIN
FQ
f
NIL
Viewers
Broadcast
FQ
RETURN
FQ
f
END
Focus
PROCEDURE
Selected
Frame
VAR
SQ
SelQuery
BEGIN
SQ
f
NIL
SQ
time
Viewers
Broadcast
SQ
RETURN
SQ
f
END
Selected
PROCEDURE
This
x
y
INTEGER
Frame
VAR
PQ
PosQuery
BEGIN
PQ
f
NIL
PQ
x
x
PQ
y
y
Viewers
Broadcast
PQ
RETURN
PQ
f
END
This
PROCEDURE
Mark
F
Frame
mode
INTEGER
VAR
CM
ChangedMsg
BEGIN
CM
f
F
CM
graph
F
graph
CM
mode
mode
Viewers
Broadcast
CM
END
Mark
PROCEDURE
Draw
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawsel
UM
graph
F
graph
Viewers
Broadcast
UM
END
Draw
PROCEDURE
DrawNorm
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawnorm
UM
graph
F
graph
Viewers
Broadcast
UM
END
DrawNorm
PROCEDURE
Erase
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawdel
UM
graph
F
graph
Viewers
Broadcast
UM
Mark
F
END
Erase
PROCEDURE
DrawObj
F
Frame
obj
Graphics
Object
VAR
UM
UpdateMsg
BEGIN
UM
id
drawobj
UM
graph
F
graph
UM
obj
obj
Viewers
Broadcast
UM
END
DrawObj
PROCEDURE
EraseObj
F
Frame
obj
Graphics
Object
VAR
UM
UpdateMsg
BEGIN
UM
id
drawobjd
UM
graph
F
graph
UM
obj
obj
Viewers
Broadcast
UM
END
EraseObj
PROCEDURE
Change
F
Frame
VAR
msg
Graphics
Msg
BEGIN
IF
F
NIL
THEN
Erase
F
Graphics
Change
F
graph
msg
Draw
F
END
END
Change
PROCEDURE
FlipMark
x
y
INTEGER
BEGIN
Display
ReplConst
Display
white
x
y
Display
ReplConst
Display
white
x
y
END
FlipMark
PROCEDURE
Defocus
F
Frame
VAR
m
Location
BEGIN
newcap
NIL
IF
F
marked
THEN
FlipMark
F
mark
x
F
mark
y
m
F
mark
next
WHILE
m
NIL
DO
FlipMark
m
x
m
y
m
m
next
END
F
marked
FALSE
F
mark
next
NIL
END
END
Defocus
PROCEDURE
Deselect
F
Frame
VAR
UM
UpdateMsg
BEGIN
IF
F
NIL
THEN
UM
id
drawnorm
UM
graph
F
graph
Viewers
Broadcast
UM
Graphics
Deselect
F
graph
END
END
Deselect
PROCEDURE
Macro
Lname
Mname
ARRAY
OF
CHAR
VAR
x
y
INTEGER
F
Frame
mac
Graphics
Macro
mh
Graphics
MacHead
L
Graphics
Library
BEGIN
F
Focus
IF
F
NIL
THEN
x
F
mark
x
F
x
y
F
mark
y
F
y
Graphics
GetLib
Lname
FALSE
L
IF
L
NIL
THEN
mh
Graphics
ThisMac
L
Mname
IF
mh
NIL
THEN
Deselect
F
Defocus
F
NEW
mac
mac
x
x
mac
y
y
mac
w
mh
w
mac
h
mh
h
mac
mac
mh
mac
do
Graphics
MacMethod
mac
col
Oberon
CurCol
Graphics
Add
F
graph
mac
DrawObj
F
mac
Mark
F
END
ELSE
Texts
WriteString
W
Lname
Texts
WriteString
W
not
available
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
END
Macro
PROCEDURE
CaptionCopy
F
Frame
x1
y1
INTEGER
T
Texts
Text
beg
end
LONGINT
Graphics
Caption
VAR
ch
CHAR
dx
w
x2
y2
w1
h1
INTEGER
cap
Graphics
Caption
pat
INTEGER
R
Texts
Reader
BEGIN
Texts
Write
W
0DX
NEW
cap
cap
len
end
beg
cap
pos
Graphics
T
len
cap
do
Graphics
CapMethod
Texts
OpenReader
R
T
beg
Texts
Read
R
ch
W
fnt
R
fnt
W
col
R
col
w
cap
x
x1
F
x
cap
y
y1
F
y
R
fnt
minY
WHILE
beg
end
DO
Fonts
GetPat
R
fnt
ch
dx
x2
y2
w1
h1
pat
INC
w
dx
INC
beg
Texts
Write
W
ch
Texts
Read
R
ch
END
cap
w
w
cap
h
W
fnt
height
cap
col
W
col
Texts
Append
Graphics
T
W
buf
Graphics
Add
F
graph
cap
Mark
F
RETURN
cap
END
CaptionCopy
PROCEDURE
NewLine
F
Frame
G
Graphics
Graph
x
y
w
h
INTEGER
VAR
line
Graphics
Line
BEGIN
NEW
line
line
col
Oberon
CurCol
line
x
x
F
x
line
y
y
F
y
line
w
w
line
h
h
line
do
Graphics
LineMethod
Graphics
Add
G
line
Mark
F
END
NewLine
PROCEDURE
Edit
F
Frame
x0
y0
INTEGER
k0
SET
VAR
obj
Graphics
Object
x1
y1
w
h
t
INTEGER
beg
end
time
LONGINT
k1
k2
SET
mark
newmark
Location
T
Texts
Text
Fd
Frame
G
Graphics
Graph
BEGIN
k1
k0
G
F
graph
REPEAT
Input
Mouse
k2
x1
y1
k1
k1
k2
DEC
x1
x1
F
x
MOD
DEC
y1
y1
F
y
MOD
Oberon
DrawMouse
Crosshair
x1
y1
UNTIL
k2
Oberon
FadeMouse
IF
k0
THEN
left
key
w
ABS
x1
x0
h
ABS
y1
y0
IF
k1
THEN
IF
w
h
THEN
set
mark
IF
x1
markW
F
X
x1
markW
F
X1
y1
markW
F
Y
y1
markW
F
Y1
THEN
Defocus
F
Oberon
PassFocus
Viewers
This
F
X
F
Y
F
mark
x
x1
F
mark
y
y1
F
marked
TRUE
FlipMark
x1
y1
END
ELSE
draw
line
Deselect
F
IF
w
h
THEN
IF
y1
y0
THEN
y0
y1
END
NewLine
F
G
x0
y0
Graphics
width
h
ELSE
IF
x1
x0
THEN
x0
x1
END
NewLine
F
G
x0
y0
w
Graphics
width
END
Draw
F
END
ELSIF
k1
THEN
copy
text
selection
to
mark
Deselect
F
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
DrawObj
F
CaptionCopy
F
x1
y1
T
beg
end
Mark
F
END
ELSIF
k1
THEN
IF
F
marked
THEN
set
secondary
mark
NEW
newmark
newmark
x
x1
newmark
y
y1
newmark
next
NIL
FlipMark
x1
y1
mark
F
mark
next
IF
mark
NIL
THEN
F
mark
next
newmark
ELSE
WHILE
mark
next
NIL
DO
mark
mark
next
END
mark
next
newmark
END
END
END
ELSIF
k0
THEN
middle
key
IF
k1
THEN
move
IF
x0
x1
OR
y0
y1
THEN
Fd
This
x1
y1
Erase
F
IF
Fd
F
THEN
Graphics
Move
G
x1
x0
y1
y0
ELSIF
Fd
NIL
Fd
graph
G
THEN
Graphics
Move
G
x1
Fd
x
x0
F
x
DIV
y1
Fd
y
y0
F
y
DIV
END
Draw
F
Mark
F
END
ELSIF
k1
THEN
copy
Fd
This
x1
y1
IF
Fd
NIL
THEN
DrawNorm
F
IF
Fd
F
THEN
Graphics
Copy
G
G
x1
x0
y1
y0
ELSE
Deselect
Fd
Graphics
Copy
G
Fd
graph
x1
Fd
x
x0
F
x
DIV
y1
Fd
y
y0
F
y
DIV
END
Draw
Fd
Mark
F
END
ELSIF
k1
THEN
shift
graph
INC
F
Xg
x1
x0
INC
F
Yg
y1
y0
Restore
F
END
ELSIF
k0
THEN
right
key
select
newcap
NIL
IF
k1
THEN
Deselect
F
END
IF
ABS
x0
x1
ABS
y0
y1
THEN
obj
Graphics
ThisObj
G
x1
F
x
y1
F
y
IF
obj
NIL
THEN
Graphics
SelectObj
G
obj
DrawObj
F
obj
END
ELSE
IF
x1
x0
THEN
t
x0
x0
x1
x1
t
END
IF
y1
y0
THEN
t
y0
y0
y1
y1
t
END
Graphics
SelectArea
G
x0
F
x
y0
F
y
x1
F
x
y1
F
y
Draw
F
END
END
END
Edit
PROCEDURE
NewCaption
F
Frame
col
INTEGER
font
Fonts
Font
BEGIN
Texts
Write
W
0DX
NEW
newcap
newcap
x
F
mark
x
F
x
newcap
y
F
mark
y
F
y
font
minY
newcap
w
newcap
h
font
height
newcap
col
col
newcap
pos
Graphics
T
len
newcap
len
newcap
do
Graphics
CapMethod
Graphics
Add
F
graph
newcap
W
fnt
font
Mark
F
END
NewCaption
PROCEDURE
InsertChar
F
Frame
ch
CHAR
VAR
w1
h1
INTEGER
DM
DispMsg
BEGIN
DM
graph
F
graph
Fonts
GetPat
W
fnt
ch
DM
w
DM
x1
DM
y1
w1
h1
DM
pat
DEC
DM
y1
W
fnt
minY
IF
newcap
x
newcap
w
DM
w
F
x
F
X1
THEN
Viewers
Broadcast
DM
INC
newcap
w
DM
w
INC
newcap
len
Texts
Write
W
ch
END
Texts
Append
Graphics
T
W
buf
END
InsertChar
PROCEDURE
DeleteChar
F
Frame
VAR
w1
h1
INTEGER
ch
CHAR
pos
LONGINT
DM
DispMsg
R
Texts
Reader
BEGIN
DM
graph
F
graph
IF
newcap
len
THEN
pos
Graphics
T
len
Texts
OpenReader
R
Graphics
T
pos
backspace
Texts
Read
R
ch
IF
ch
THEN
Fonts
GetPat
R
fnt
ch
DM
w
DM
x1
DM
y1
w1
h1
DM
pat
DEC
newcap
w
DM
w
DEC
newcap
len
DEC
DM
y1
R
fnt
minY
Viewers
Broadcast
DM
Texts
Delete
Graphics
T
pos
pos
TBuf
END
END
END
DeleteChar
PROCEDURE
GetSelection
F
Frame
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
VAR
obj
Graphics
Object
BEGIN
obj
F
graph
sel
IF
obj
NIL
F
graph
time
time
THEN
CASE
obj
OF
Graphics
Caption
beg
obj
pos
end
obj
pos
obj
len
text
Graphics
T
time
F
graph
time
END
END
END
GetSelection
PROCEDURE
Handle
G
Display
Frame
VAR
M
Display
FrameMsg
VAR
x
y
h
INTEGER
DM
DispMsg
dM
DrawMsg
G1
Frame
BEGIN
CASE
G
OF
Frame
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
x
M
X
M
X
G
x
MOD
y
M
Y
M
Y
G
y
MOD
IF
M
keys
THEN
Edit
G
x
y
M
keys
ELSE
Oberon
DrawMouse
Crosshair
x
y
END
ELSIF
M
id
Oberon
consume
THEN
IF
M
ch
7FX
THEN
DEL
Erase
G
Graphics
Delete
G
graph
Mark
G
ELSIF
M
ch
20X
M
ch
7FX
THEN
IF
newcap
NIL
THEN
InsertChar
G
M
ch
Mark
G
ELSIF
G
marked
THEN
Defocus
G
Deselect
G
NewCaption
G
M
col
M
fnt
InsertChar
G
M
ch
END
ELSIF
M
ch
8X
newcap
NIL
THEN
DeleteChar
G
Mark
G
END
END
UpdateMsg
IF
M
graph
G
graph
THEN
dM
f
G
dM
x
G
x
dM
y
G
y
dM
col
IF
M
id
drawobj
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawobjs
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawobjd
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawsel
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
ELSIF
M
id
drawnorm
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
ELSIF
M
id
drawdel
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
END
END
ChangedMsg
IF
M
graph
G
graph
THEN
SetChangeMark
G
M
mode
END
SelQuery
IF
G
graph
sel
NIL
M
time
G
graph
time
THEN
M
f
G
Frame
M
time
G
graph
time
END
FocusQuery
IF
G
marked
THEN
M
f
G
END
PosQuery
IF
G
X
M
x
M
x
G
X1
G
Y
M
y
M
y
G
Y1
THEN
M
f
G
END
DispMsg
DM
M
x
G
x
newcap
x
newcap
w
y
G
y
newcap
y
IF
DM
graph
G
graph
x
G
X
x
DM
w
G
X1
y
G
Y
y
G
Y1
THEN
Display
CopyPattern
Oberon
CurCol
DM
pat
x
DM
x1
y
DM
y1
Display
ReplConst
Display
white
x
y
DM
w
newcap
h
END
Oberon
ControlMsg
IF
M
id
Oberon
neutralize
THEN
Oberon
RemoveMarks
G
X
G
Y
G
W
G
H
Defocus
G
DrawNorm
G
Graphics
Deselect
G
graph
ELSIF
M
id
Oberon
defocus
THEN
Defocus
G
END
Oberon
SelectionMsg
GetSelection
G
M
text
M
beg
M
end
M
time
Oberon
CopyMsg
Oberon
RemoveMarks
G
X
G
Y
G
W
G
H
Defocus
G
NEW
G1
G1
G
M
F
G1
MenuViewers
ModifyMsg
G
Y
M
Y
G
H
M
H
Restore
G
END
END
END
Handle
PROCEDURE
Store
F
Frame
name
ARRAY
OF
CHAR
BEGIN
Mark
F
Graphics
WriteFile
F
graph
name
END
Store
Draw
Methods
PROCEDURE
ReplConst
F
Frame
col
x
y
w
h
mode
INTEGER
BEGIN
IF
x
F
X
THEN
DEC
w
F
X
x
x
F
X
END
IF
x
w
F
X1
THEN
w
F
X1
x
END
IF
y
F
Y
THEN
DEC
h
F
Y
y
y
F
Y
END
IF
y
h
F
Y1
THEN
h
F
Y1
y
END
Display
ReplConst
col
x
y
w
h
mode
END
ReplConst
PROCEDURE
ReplPattern
F
Frame
col
patadr
x
y
w
h
mode
INTEGER
BEGIN
IF
x
F
X
THEN
DEC
w
F
X
x
x
F
X
END
IF
x
w
F
X1
THEN
w
F
X1
x
END
IF
y
F
Y
THEN
DEC
h
F
Y
y
y
F
Y
END
IF
y
h
F
Y1
THEN
h
F
Y1
y
END
Display
ReplPattern
col
patadr
x
y
w
h
mode
END
ReplPattern
PROCEDURE
DrawLine
obj
Graphics
Object
VAR
M
Graphics
Msg
M
mode
draw
according
to
state
normal
selected
selected
normal
erase
VAR
x
y
w
h
col
INTEGER
f
Frame
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
x
w
f
X
x
f
X1
y
h
f
Y
y
f
Y1
THEN
col
obj
col
IF
M
mode
obj
selected
OR
M
mode
THEN
ReplPattern
f
col
Display
grey
x
y
w
h
Display
replace
ELSIF
M
mode
IN
THEN
ReplConst
f
col
x
y
w
h
Display
replace
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
erase
END
END
END
END
DrawLine
PROCEDURE
DrawCaption
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
dx
x0
x1
y0
y1
w
h
w1
h1
col
INTEGER
f
Frame
ch
CHAR
pat
INTEGER
fnt
Fonts
Font
R
Texts
Reader
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
f
X
x
x
f
X1
f
Y
y
y
h
f
Y1
THEN
IF
x
w
f
X1
THEN
w
f
X1
x
END
Texts
OpenReader
R
Graphics
T
obj
Graphics
Caption
pos
Texts
Read
R
ch
IF
M
mode
THEN
IF
ch
THEN
fnt
R
fnt
x0
x
y0
y
fnt
minY
col
obj
col
REPEAT
Fonts
GetPat
fnt
ch
dx
x1
y1
w1
h1
pat
IF
x0
x1
w1
f
X1
THEN
Display
CopyPattern
col
pat
x0
x1
y0
y1
Display
paint
INC
x0
dx
Texts
Read
R
ch
ELSE
ch
0X
END
UNTIL
ch
IF
obj
selected
THEN
ReplConst
f
Display
white
x
y
w
h
Display
invert
END
END
ELSIF
M
mode
IN
THEN
ReplConst
f
Display
white
x
y
w
h
Display
invert
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
END
END
END
END
DrawCaption
PROCEDURE
DrawMacro
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
INTEGER
f
Frame
M1
DrawMsg
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
x
w
f
X
x
f
X1
y
h
f
Y
y
f
Y1
THEN
M1
x
x
M1
y
y
IF
M
mode
THEN
M1
f
f
M1
col
obj
col
M1
mode
Graphics
DrawMac
obj
Graphics
Macro
mac
M1
IF
obj
selected
THEN
ReplPattern
f
Display
white
dotted
x
y
w
h
Display
invert
END
ELSIF
M
mode
IN
THEN
ReplPattern
f
Display
white
dotted
x
y
w
h
Display
invert
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
END
END
END
END
DrawMacro
PROCEDURE
Open
G
Frame
graph
Graphics
Graph
BEGIN
G
graph
graph
G
Xg
G
Yg
G
x
G
X
G
y
G
Y
G
col
Display
black
G
marked
FALSE
G
mark
next
NIL
G
ticked
TRUE
G
handle
Handle
END
Open
BEGIN
DW
Display
Width
DH
Display
Height
CL
Texts
OpenWriter
W
tack
SYSTEM
ADR
dotted
SYSTEM
ADR
dotted1
SYSTEM
ADR
Crosshair
Fade
FlipCross
Crosshair
Draw
FlipCross
Graphics
InstallDrawMethods
DrawLine
DrawCaption
DrawMacro
END
GraphicFrames
MODULE
Graphics
NW
IMPORT
SYSTEM
Files
Modules
Fonts
Printer
Texts
Oberon
CONST
NameLen
GraphFileId
0FAX
LibFileId
0FBX
TYPE
Graph
POINTER
TO
GraphDesc
Object
POINTER
TO
ObjectDesc
Method
POINTER
TO
MethodDesc
Line
POINTER
TO
LineDesc
Caption
POINTER
TO
CaptionDesc
Macro
POINTER
TO
MacroDesc
ObjectDesc
RECORD
x
y
w
h
INTEGER
col
BYTE
selected
marked
BOOLEAN
do
Method
next
Object
END
Msg
RECORD
END
WidMsg
RECORD
Msg
w
INTEGER
END
ColorMsg
RECORD
Msg
col
INTEGER
END
FontMsg
RECORD
Msg
fnt
Fonts
Font
END
Name
ARRAY
NameLen
OF
CHAR
GraphDesc
RECORD
time
LONGINT
sel
first
Object
changed
BOOLEAN
END
MacHead
POINTER
TO
MacHeadDesc
MacExt
POINTER
TO
MacExtDesc
Library
POINTER
TO
LibraryDesc
MacHeadDesc
RECORD
name
Name
w
h
INTEGER
ext
MacExt
lib
Library
first
Object
next
MacHead
END
LibraryDesc
RECORD
name
Name
first
MacHead
next
Library
END
MacExtDesc
RECORD
END
Context
RECORD
nofonts
noflibs
nofclasses
INTEGER
font
ARRAY
OF
Fonts
Font
lib
ARRAY
OF
Library
class
ARRAY
OF
Modules
Command
END
MethodDesc
RECORD
module
allocator
Name
new
Modules
Command
copy
PROCEDURE
from
to
Object
draw
change
PROCEDURE
obj
Object
VAR
msg
Msg
selectable
PROCEDURE
obj
Object
x
y
INTEGER
BOOLEAN
read
PROCEDURE
obj
Object
VAR
R
Files
Rider
VAR
C
Context
write
PROCEDURE
obj
Object
cno
INTEGER
VAR
R
Files
Rider
VAR
C
Context
print
PROCEDURE
obj
Object
x
y
INTEGER
END
LineDesc
RECORD
ObjectDesc
unused
INTEGER
END
CaptionDesc
RECORD
ObjectDesc
pos
len
INTEGER
END
MacroDesc
RECORD
ObjectDesc
mac
MacHead
END
VAR
width
res
INTEGER
new
Object
T
Texts
Text
captions
LineMethod
CapMethod
MacMethod
Method
GetLib0
PROCEDURE
name
ARRAY
OF
CHAR
replace
BOOLEAN
VAR
Lib
Library
FirstLib
Library
W
TW
XW
Texts
Writer
PROCEDURE
New
obj
Object
BEGIN
new
obj
END
New
PROCEDURE
Add
G
Graph
obj
Object
BEGIN
obj
marked
FALSE
obj
selected
TRUE
obj
next
G
first
G
first
obj
G
sel
obj
G
time
Oberon
Time
G
changed
TRUE
END
Add
PROCEDURE
ThisObj
G
Graph
x
y
INTEGER
Object
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
obj
do
selectable
obj
x
y
DO
obj
obj
next
END
RETURN
obj
END
ThisObj
PROCEDURE
SelectObj
G
Graph
obj
Object
BEGIN
IF
obj
NIL
THEN
obj
selected
TRUE
G
sel
obj
G
time
Oberon
Time
END
END
SelectObj
PROCEDURE
SelectArea
G
Graph
x0
y0
x1
y1
INTEGER
VAR
obj
Object
t
INTEGER
BEGIN
obj
G
first
IF
x1
x0
THEN
t
x0
x0
x1
x1
t
END
IF
y1
y0
THEN
t
y0
y0
y1
y1
t
END
WHILE
obj
NIL
DO
IF
x0
obj
x
obj
x
obj
w
x1
y0
obj
y
obj
y
obj
h
y1
THEN
obj
selected
TRUE
G
sel
obj
END
obj
obj
next
END
IF
G
sel
NIL
THEN
G
time
Oberon
Time
END
END
SelectArea
PROCEDURE
Draw
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
obj
do
draw
obj
M
obj
obj
next
END
END
Draw
PROCEDURE
List
G
Graph
VAR
obj
Object
tag
INTEGER
BEGIN
obj
G
first
WHILE
obj
NIL
DO
Texts
Write
XW
9X
Texts
WriteHex
XW
ORD
obj
Texts
Write
XW
9X
Texts
WriteInt
XW
obj
x
Texts
WriteInt
XW
obj
y
Texts
WriteInt
XW
obj
w
Texts
WriteInt
XW
obj
h
Texts
Write
XW
SYSTEM
GET
ORD
obj
tag
Texts
WriteHex
XW
tag
SYSTEM
GET
ORD
obj
tag
Texts
WriteHex
XW
tag
Texts
WriteLn
XW
obj
obj
next
END
Texts
Append
Oberon
Log
XW
buf
END
List
procedures
operating
on
selection
PROCEDURE
Deselect
G
Graph
VAR
obj
Object
BEGIN
obj
G
first
G
sel
NIL
G
time
WHILE
obj
NIL
DO
obj
selected
FALSE
obj
obj
next
END
END
Deselect
PROCEDURE
DrawSel
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
draw
obj
M
END
obj
obj
next
END
END
DrawSel
PROCEDURE
Change
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
G
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
change
obj
M
END
obj
obj
next
END
END
Change
PROCEDURE
Move
G
Graph
dx
dy
INTEGER
VAR
obj
ob0
Object
x0
x1
y0
y1
INTEGER
BEGIN
obj
G
first
G
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
obj
IS
Caption
THEN
x0
obj
x
x1
obj
w
x0
y0
obj
y
y1
obj
h
y0
IF
dx
THEN
vertical
move
ob0
G
first
WHILE
ob0
NIL
DO
IF
ob0
selected
ob0
IS
Line
x0
ob0
x
ob0
x
x1
ob0
w
ob0
h
THEN
IF
y0
ob0
y
ob0
y
y1
THEN
INC
ob0
y
dy
DEC
ob0
h
dy
ob0
marked
TRUE
ELSIF
y0
ob0
y
ob0
h
ob0
y
ob0
h
y1
THEN
INC
ob0
h
dy
ob0
marked
TRUE
END
END
ob0
ob0
next
END
ELSIF
dy
THEN
horizontal
move
ob0
G
first
WHILE
ob0
NIL
DO
IF
ob0
selected
ob0
IS
Line
y0
ob0
y
ob0
y
y1
ob0
h
ob0
w
THEN
IF
x0
ob0
x
ob0
x
x1
THEN
INC
ob0
x
dx
DEC
ob0
w
dx
ob0
marked
TRUE
ELSIF
x0
ob0
x
ob0
w
ob0
x
ob0
w
x1
THEN
INC
ob0
w
dx
ob0
marked
TRUE
END
END
ob0
ob0
next
END
END
END
obj
obj
next
END
obj
G
first
now
move
WHILE
obj
NIL
DO
IF
obj
selected
THEN
INC
obj
x
dx
INC
obj
y
dy
END
obj
marked
FALSE
obj
obj
next
END
END
Move
PROCEDURE
Copy
Gs
Gd
Graph
dx
dy
INTEGER
VAR
obj
Object
BEGIN
obj
Gs
first
Gd
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
new
obj
do
copy
obj
new
INC
new
x
dx
INC
new
y
dy
obj
selected
FALSE
Add
Gd
new
END
obj
obj
next
END
new
NIL
END
Copy
PROCEDURE
Delete
G
Graph
VAR
obj
pred
Object
BEGIN
G
sel
NIL
G
changed
TRUE
obj
G
first
WHILE
obj
NIL
obj
selected
DO
obj
obj
next
END
G
first
obj
IF
obj
NIL
THEN
pred
obj
obj
obj
next
WHILE
obj
NIL
DO
IF
obj
selected
THEN
pred
next
obj
next
ELSE
pred
obj
END
obj
obj
next
END
END
END
Delete
Storing
PROCEDURE
WMsg
s0
s1
ARRAY
OF
CHAR
BEGIN
Texts
WriteString
W
s0
Texts
WriteString
W
s1
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
WMsg
PROCEDURE
InitContext
VAR
C
Context
BEGIN
C
nofonts
C
noflibs
C
nofclasses
C
class
LineMethod
new
C
class
CapMethod
new
C
class
MacMethod
new
END
InitContext
PROCEDURE
FontNo
VAR
W
Files
Rider
VAR
C
Context
fnt
Fonts
Font
INTEGER
VAR
fno
INTEGER
BEGIN
fno
WHILE
fno
C
nofonts
C
font
fno
fnt
DO
INC
fno
END
IF
fno
C
nofonts
THEN
Files
WriteByte
W
Files
WriteByte
W
Files
WriteByte
W
fno
Files
WriteString
W
fnt
name
C
font
fno
fnt
INC
C
nofonts
END
RETURN
fno
END
FontNo
PROCEDURE
StoreElems
VAR
W
Files
Rider
VAR
C
Context
obj
Object
VAR
cno
INTEGER
BEGIN
WHILE
obj
NIL
DO
cno
WHILE
cno
C
nofclasses
obj
do
new
C
class
cno
DO
INC
cno
END
IF
cno
C
nofclasses
THEN
Files
WriteByte
W
Files
WriteByte
W
Files
WriteByte
W
cno
Files
WriteString
W
obj
do
module
Files
WriteString
W
obj
do
allocator
C
class
cno
obj
do
new
INC
C
nofclasses
END
obj
do
write
obj
cno
W
C
obj
obj
next
END
Files
WriteByte
W
END
StoreElems
PROCEDURE
Store
G
Graph
VAR
W
Files
Rider
VAR
C
Context
BEGIN
InitContext
C
StoreElems
W
C
G
first
G
changed
FALSE
END
Store
PROCEDURE
WriteObj
VAR
W
Files
Rider
cno
INTEGER
obj
Object
BEGIN
Files
WriteByte
W
cno
Files
WriteInt
W
obj
y
10000H
obj
x
Files
WriteInt
W
obj
h
10000H
obj
w
Files
WriteByte
W
obj
col
END
WriteObj
PROCEDURE
WriteFile
G
Graph
name
ARRAY
OF
CHAR
VAR
F
Files
File
W
Files
Rider
C
Context
BEGIN
F
Files
New
name
Files
Set
W
F
Files
Write
W
GraphFileId
InitContext
C
StoreElems
W
C
G
first
Files
Register
F
END
WriteFile
PROCEDURE
Print
G
Graph
x0
y0
INTEGER
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
obj
do
print
obj
x0
y0
obj
obj
next
END
END
Print
Loading
PROCEDURE
GetClass
module
allocator
ARRAY
OF
CHAR
VAR
com
Modules
Command
VAR
mod
Modules
Module
BEGIN
Modules
Load
module
mod
IF
mod
NIL
THEN
com
Modules
ThisCommand
mod
allocator
IF
com
NIL
THEN
WMsg
allocator
unknown
END
ELSE
WMsg
module
not
available
com
NIL
END
END
GetClass
PROCEDURE
Font
VAR
R
Files
Rider
VAR
C
Context
Fonts
Font
VAR
fno
BYTE
BEGIN
Files
ReadByte
R
fno
RETURN
C
font
fno
END
Font
PROCEDURE
ReadObj
VAR
R
Files
Rider
obj
Object
VAR
xy
wh
INTEGER
dmy
BYTE
BEGIN
Files
ReadInt
R
xy
obj
y
xy
DIV
10000H
obj
x
xy
10000H
DIV
10000H
Files
ReadInt
R
wh
obj
h
wh
DIV
10000H
obj
w
wh
10000H
DIV
10000H
Files
ReadByte
R
obj
col
END
ReadObj
PROCEDURE
LoadElems
VAR
R
Files
Rider
VAR
C
Context
VAR
fobj
Object
VAR
cno
m
n
len
BYTE
pos
INTEGER
obj
Object
fnt
Fonts
Font
name
name1
ARRAY
OF
CHAR
BEGIN
obj
NIL
Files
ReadByte
R
cno
WHILE
R
eof
cno
DO
IF
cno
THEN
Files
ReadByte
R
m
Files
ReadByte
R
n
Files
ReadString
R
name
IF
m
THEN
fnt
Fonts
This
name
C
font
n
fnt
ELSIF
m
THEN
GetLib0
name
FALSE
C
lib
n
ELSIF
m
THEN
Files
ReadString
R
name1
GetClass
name
name1
C
class
n
END
ELSIF
C
class
cno
NIL
THEN
C
class
cno
ReadObj
R
new
new
selected
FALSE
new
marked
FALSE
new
next
obj
obj
new
new
do
read
new
R
C
ELSE
ReadObj
R
new
Files
ReadByte
R
len
pos
Files
Pos
R
Files
Set
R
Files
Base
R
pos
len
END
Files
ReadByte
R
cno
END
new
NIL
fobj
obj
END
LoadElems
PROCEDURE
Load
G
Graph
VAR
R
Files
Rider
VAR
C
Context
BEGIN
G
sel
NIL
InitContext
C
LoadElems
R
C
G
first
END
Load
PROCEDURE
Open
G
Graph
name
ARRAY
OF
CHAR
VAR
tag
CHAR
F
Files
File
R
Files
Rider
C
Context
BEGIN
G
first
NIL
G
sel
NIL
G
time
G
changed
FALSE
F
Files
Old
name
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
tag
IF
tag
GraphFileId
THEN
InitContext
C
LoadElems
R
C
G
first
res
ELSE
res
END
ELSE
res
END
END
Open
PROCEDURE
SetWidth
w
INTEGER
BEGIN
width
w
END
SetWidth
Macros
Libraries
PROCEDURE
GetLib
name
ARRAY
OF
CHAR
replace
BOOLEAN
VAR
Lib
Library
VAR
i
wh
INTEGER
ch
CHAR
L
Library
mh
MacHead
obj
Object
F
Files
File
R
Files
Rider
C
Context
Lname
Fname
ARRAY
OF
CHAR
BEGIN
L
FirstLib
i
WHILE
L
NIL
L
name
name
DO
L
L
next
END
IF
L
NIL
THEN
load
library
from
file
i
WHILE
name
i
0X
DO
Fname
i
name
i
INC
i
END
Fname
i
Fname
i
L
Fname
i
i
Fname
i
b
Fname
i
0X
F
Files
Old
Fname
IF
F
NIL
THEN
WMsg
loading
Fname
Files
Set
R
F
Files
Read
R
ch
IF
ch
LibFileId
THEN
IF
L
NIL
THEN
NEW
L
L
name
name
L
next
FirstLib
FirstLib
L
END
L
first
NIL
InitContext
C
LoadElems
R
C
obj
WHILE
obj
NIL
DO
NEW
mh
mh
first
obj
Files
ReadInt
R
wh
mh
h
wh
DIV
10000H
MOD
10000H
mh
w
wh
MOD
10000H
Files
ReadString
R
mh
name
mh
lib
L
mh
next
L
first
L
first
mh
LoadElems
R
C
obj
END
ELSE
L
NIL
END
ELSE
L
NIL
END
END
Lib
L
END
GetLib
PROCEDURE
NewLib
Lname
ARRAY
OF
CHAR
Library
VAR
L
Library
BEGIN
NEW
L
L
name
Lname
L
first
NIL
L
next
FirstLib
FirstLib
L
RETURN
L
END
NewLib
PROCEDURE
StoreLib
L
Library
Fname
ARRAY
OF
CHAR
VAR
i
INTEGER
mh
MacHead
F
Files
File
W
Files
Rider
C
Context
Gname
ARRAY
OF
CHAR
BEGIN
L
FirstLib
WHILE
L
NIL
L
name
Fname
DO
L
L
next
END
IF
L
NIL
THEN
i
WHILE
Fname
i
0X
DO
Gname
i
Fname
i
INC
i
END
Gname
i
Gname
i
L
Gname
i
i
Gname
i
b
Gname
i
0X
F
Files
New
Gname
Files
Set
W
F
Files
Write
W
LibFileId
InitContext
C
mh
L
first
WHILE
mh
NIL
DO
StoreElems
W
C
mh
first
Files
WriteInt
W
mh
h
10000H
mh
w
Files
WriteString
W
mh
name
mh
mh
next
END
Files
WriteByte
W
Files
Register
F
ELSE
Texts
WriteString
TW
Fname
Texts
WriteString
TW
not
found
Texts
WriteLn
TW
Texts
Append
Oberon
Log
TW
buf
END
END
StoreLib
PROCEDURE
RemoveLibraries
BEGIN
FirstLib
NIL
END
RemoveLibraries
PROCEDURE
ThisMac
L
Library
Mname
ARRAY
OF
CHAR
MacHead
VAR
mh
MacHead
BEGIN
mh
L
first
WHILE
mh
NIL
mh
name
Mname
DO
mh
mh
next
END
RETURN
mh
END
ThisMac
PROCEDURE
DrawMac
mh
MacHead
VAR
M
Msg
VAR
elem
Object
BEGIN
elem
mh
first
WHILE
elem
NIL
DO
elem
do
draw
elem
M
elem
elem
next
END
END
DrawMac
Procedures
for
designing
macros
PROCEDURE
OpenMac
mh
MacHead
G
Graph
x
y
INTEGER
VAR
obj
Object
BEGIN
obj
mh
first
WHILE
obj
NIL
DO
obj
do
new
obj
do
copy
obj
new
INC
new
x
x
INC
new
y
y
new
selected
TRUE
Add
G
new
obj
obj
next
END
new
NIL
END
OpenMac
PROCEDURE
MakeMac
G
Graph
VAR
head
MacHead
VAR
x0
y0
x1
y1
INTEGER
obj
last
Object
mh
MacHead
BEGIN
obj
G
first
last
NIL
x0
x1
y0
y1
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
new
obj
do
copy
obj
new
new
next
last
new
selected
FALSE
last
new
IF
obj
x
x0
THEN
x0
obj
x
END
IF
obj
x
obj
w
x1
THEN
x1
obj
x
obj
w
END
IF
obj
y
y0
THEN
y0
obj
y
END
IF
obj
y
obj
h
y1
THEN
y1
obj
y
obj
h
END
END
obj
obj
next
END
obj
last
WHILE
obj
NIL
DO
obj
x
obj
x
x0
obj
y
obj
y
y0
obj
obj
next
END
NEW
mh
mh
w
x1
x0
mh
h
y1
y0
mh
first
last
mh
ext
NIL
new
NIL
head
mh
END
MakeMac
PROCEDURE
InsertMac
mh
MacHead
L
Library
VAR
new
BOOLEAN
VAR
mh1
MacHead
BEGIN
mh
lib
L
mh1
L
first
WHILE
mh1
NIL
mh1
name
mh
name
DO
mh1
mh1
next
END
IF
mh1
NIL
THEN
new
TRUE
mh
next
L
first
L
first
mh
ELSE
new
FALSE
mh1
w
mh
w
mh1
h
mh
h
mh1
first
mh
first
END
END
InsertMac
Line
Methods
PROCEDURE
NewLine
VAR
line
Line
BEGIN
NEW
line
new
line
line
do
LineMethod
END
NewLine
PROCEDURE
CopyLine
src
dst
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
END
CopyLine
PROCEDURE
ChangeLine
obj
Object
VAR
M
Msg
BEGIN
CASE
M
OF
WidMsg
IF
obj
w
obj
h
THEN
IF
obj
w
THEN
obj
w
M
w
END
ELSIF
obj
h
THEN
obj
h
M
w
END
ColorMsg
obj
col
M
col
END
END
ChangeLine
PROCEDURE
LineSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
w
obj
y
y
y
obj
y
obj
h
END
LineSelectable
PROCEDURE
ReadLine
obj
Object
VAR
R
Files
Rider
VAR
C
Context
BEGIN
END
ReadLine
PROCEDURE
WriteLine
obj
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Context
BEGIN
WriteObj
W
cno
obj
END
WriteLine
PROCEDURE
PrintLine
obj
Object
x
y
INTEGER
VAR
w
h
INTEGER
BEGIN
w
obj
w
h
obj
h
IF
w
h
THEN
h
h
ELSE
w
w
END
Printer
ReplConst
obj
x
x
obj
y
y
w
h
END
PrintLine
Caption
Methods
PROCEDURE
NewCaption
VAR
cap
Caption
BEGIN
NEW
cap
new
cap
cap
do
CapMethod
END
NewCaption
PROCEDURE
CopyCaption
src
dst
Object
VAR
ch
CHAR
R
Texts
Reader
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Caption
pos
T
len
dst
Caption
len
src
Caption
len
Texts
Write
TW
0DX
Texts
OpenReader
R
T
src
Caption
pos
Texts
Read
R
ch
TW
fnt
R
fnt
WHILE
ch
0DX
DO
Texts
Write
TW
ch
Texts
Read
R
ch
END
Texts
Append
T
TW
buf
END
CopyCaption
PROCEDURE
ChangeCaption
obj
Object
VAR
M
Msg
VAR
dx
x1
dy
y1
w
w1
h1
len
INTEGER
pos
LONGINT
ch
CHAR
patadr
INTEGER
fnt
Fonts
Font
R
Texts
Reader
BEGIN
CASE
M
OF
FontMsg
fnt
M
FontMsg
fnt
w
len
pos
obj
Caption
pos
Texts
OpenReader
R
T
pos
Texts
Read
R
ch
dy
R
fnt
minY
WHILE
ch
0DX
DO
Fonts
GetPat
fnt
ch
dx
x1
y1
w1
h1
patadr
INC
w
dx
INC
len
Texts
Read
R
ch
END
INC
obj
y
fnt
minY
dy
obj
w
w
obj
h
fnt
height
Texts
ChangeLooks
T
pos
pos
len
fnt
ColorMsg
obj
col
M
ColorMsg
col
END
END
ChangeCaption
PROCEDURE
CaptionSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
w
obj
y
y
y
obj
y
obj
h
END
CaptionSelectable
PROCEDURE
ReadCaption
obj
Object
VAR
R
Files
Rider
VAR
C
Context
VAR
ch
CHAR
fno
BYTE
len
INTEGER
BEGIN
obj
Caption
pos
T
len
Texts
Write
TW
0DX
Files
ReadByte
R
fno
TW
fnt
C
font
fno
len
Files
Read
R
ch
WHILE
ch
0DX
DO
Texts
Write
TW
ch
INC
len
Files
Read
R
ch
END
obj
Caption
len
len
Texts
Append
T
TW
buf
END
ReadCaption
PROCEDURE
WriteCaption
obj
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Context
VAR
ch
CHAR
fno
BYTE
TR
Texts
Reader
BEGIN
IF
obj
Caption
len
THEN
Texts
OpenReader
TR
T
obj
Caption
pos
Texts
Read
TR
ch
fno
FontNo
W
C
TR
fnt
WriteObj
W
cno
obj
Files
WriteByte
W
fno
WHILE
ch
0DX
DO
Files
Write
W
ch
Texts
Read
TR
ch
END
Files
Write
W
0X
END
END
WriteCaption
PROCEDURE
PrintCaption
obj
Object
x
y
INTEGER
VAR
fnt
Fonts
Font
i
INTEGER
ch
CHAR
R
Texts
Reader
s
ARRAY
OF
CHAR
BEGIN
IF
obj
Caption
len
THEN
Texts
OpenReader
R
T
obj
Caption
pos
Texts
Read
R
ch
fnt
R
fnt
DEC
y
fnt
minY
i
WHILE
ch
DO
s
i
ch
INC
i
Texts
Read
R
ch
END
s
i
0X
IF
i
THEN
Printer
String
obj
x
x
obj
y
y
s
fnt
name
END
END
END
PrintCaption
Macro
Methods
PROCEDURE
NewMacro
VAR
mac
Macro
BEGIN
NEW
mac
new
mac
mac
do
MacMethod
END
NewMacro
PROCEDURE
CopyMacro
src
dst
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Macro
mac
src
Macro
mac
END
CopyMacro
PROCEDURE
ChangeMacro
obj
Object
VAR
M
Msg
BEGIN
CASE
M
OF
ColorMsg
obj
col
M
col
END
END
ChangeMacro
PROCEDURE
MacroSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
y
y
y
obj
y
END
MacroSelectable
PROCEDURE
ReadMacro
obj
Object
VAR
R
Files
Rider
VAR
C
Context
VAR
lno
BYTE
name
ARRAY
OF
CHAR
BEGIN
Files
ReadByte
R
lno
Files
ReadString
R
name
obj
Macro
mac
ThisMac
C
lib
lno
name
END
ReadMacro
PROCEDURE
WriteMacro
obj
Object
cno
INTEGER
VAR
W1
Files
Rider
VAR
C
Context
VAR
lno
INTEGER
BEGIN
lno
WHILE
lno
C
noflibs
obj
Macro
mac
lib
C
lib
lno
DO
INC
lno
END
IF
lno
C
noflibs
THEN
Files
WriteByte
W1
Files
WriteByte
W1
Files
WriteByte
W1
lno
Files
WriteString
W1
obj
Macro
mac
lib
name
C
lib
lno
obj
Macro
mac
lib
INC
C
noflibs
END
WriteObj
W1
cno
obj
Files
WriteByte
W1
lno
Files
WriteString
W1
obj
Macro
mac
name
END
WriteMacro
PROCEDURE
PrintMacro
obj
Object
x
y
INTEGER
VAR
elem
Object
mh
MacHead
BEGIN
mh
obj
Macro
mac
IF
mh
NIL
THEN
elem
mh
first
WHILE
elem
NIL
DO
elem
do
print
elem
obj
x
x
obj
y
y
elem
elem
next
END
END
END
PrintMacro
PROCEDURE
Notify
T
Texts
Text
op
INTEGER
beg
end
LONGINT
BEGIN
END
Notify
PROCEDURE
InstallDrawMethods
drawLine
drawCaption
drawMacro
PROCEDURE
obj
Object
VAR
msg
Msg
BEGIN
LineMethod
draw
drawLine
CapMethod
draw
drawCaption
MacMethod
draw
drawMacro
END
InstallDrawMethods
BEGIN
Texts
OpenWriter
W
Texts
OpenWriter
TW
Texts
OpenWriter
XW
width
GetLib0
GetLib
NEW
T
Texts
Open
T
T
notify
Notify
NEW
LineMethod
LineMethod
new
NewLine
LineMethod
copy
CopyLine
LineMethod
selectable
LineSelectable
LineMethod
change
ChangeLine
LineMethod
read
ReadLine
LineMethod
write
WriteLine
LineMethod
print
PrintLine
NEW
CapMethod
CapMethod
new
NewCaption
CapMethod
copy
CopyCaption
CapMethod
selectable
CaptionSelectable
CapMethod
change
ChangeCaption
CapMethod
read
ReadCaption
CapMethod
write
WriteCaption
CapMethod
print
PrintCaption
NEW
MacMethod
MacMethod
new
NewMacro
MacMethod
copy
CopyMacro
MacMethod
selectable
MacroSelectable
MacMethod
change
ChangeMacro
MacMethod
read
ReadMacro
MacMethod
write
WriteMacro
MacMethod
print
PrintMacro
END
Graphics
MODULE
GraphTool
NW
IMPORT
Files
Texts
Oberon
CONST
Context
Line
Caption
Macro
Rectangles
VAR
W
Texts
Writer
PROCEDURE
DecGraph
VAR
ch
CHAR
class
col
fno
cat
inx
libno
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0F8X
THEN
Files
ReadByte
R
class
WHILE
R
eof
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Files
Read
R
ch
Texts
WriteInt
W
col
Texts
Write
W
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Macro
THEN
Files
ReadByte
R
libno
Files
ReadString
R
name
Texts
WriteInt
W
libno
Texts
Write
W
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
file
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecGraph
PROCEDURE
DecGraph1
VAR
ch
CHAR
class
col
fno
len
lw
vers
cat
inx
libno
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0FAX
THEN
Files
ReadByte
R
class
WHILE
R
eof
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Texts
WriteInt
W
col
Texts
Write
W
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Macro
THEN
Files
ReadByte
R
libno
Files
ReadString
R
name
Texts
WriteInt
W
libno
Texts
Write
W
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
len
Texts
WriteInt
W
len
Files
ReadByte
R
lw
Texts
WriteInt
W
lw
Files
ReadByte
R
vers
Texts
WriteInt
W
vers
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
file
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecGraph1
PROCEDURE
DecLibrary1
VAR
ch
CHAR
class
col
fno
cat
inx
libno
len
lnw
vers
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
library1
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0FBX
THEN
Files
ReadByte
R
class
WHILE
class
R
eof
DO
WHILE
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Texts
WriteInt
W
col
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Texts
Write
W
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Texts
Write
W
Files
ReadByte
R
len
Texts
WriteInt
W
len
Files
ReadByte
R
lnw
Texts
WriteInt
W
lnw
Files
ReadByte
R
vers
Texts
WriteInt
W
vers
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
end
macro
Texts
WriteString
W
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
MOD
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
library
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecLibrary1
PROCEDURE
ConvertFontname
VAR
x
ARRAY
OF
CHAR
BEGIN
Syntax
Oberon
IF
x
S
x
y
x
n
x
t
x
a
x
x
THEN
x
O
x
b
x
e
x
r
x
o
x
n
END
END
ConvertFontname
PROCEDURE
ConvertLibrary
VAR
ch
CHAR
class
col
fno
cat
inx
libno
len
lnw
vers
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
G
Files
File
R
Q
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
convert
library
Texts
WriteString
W
S
s
F
Files
Old
S
s
IF
F
NIL
THEN
Texts
Scan
S
G
Files
New
S
s
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Files
Set
R
F
Files
Set
Q
G
Files
Read
R
ch
IF
ch
0FDX
THEN
Files
Write
Q
0FBX
Files
ReadByte
R
class
WHILE
class
R
eof
DO
WHILE
class
DO
Files
WriteByte
Q
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
WriteByte
Q
cat
Files
WriteByte
Q
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
font
ConvertFontname
name
END
Files
WriteString
Q
name
IF
cat
THEN
class
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
Files
WriteString
Q
name
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
ELSE
Files
ReadInt
R
xy
Files
WriteInt
Q
xy
Files
ReadInt
R
wh
Files
WriteInt
Q
wh
Files
ReadByte
R
col
Files
Read
R
ch
Files
WriteByte
Q
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Files
WriteByte
Q
fno
Files
ReadString
R
name
Files
WriteString
Q
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
len
Files
WriteByte
Q
len
Files
ReadByte
R
len
Files
ReadByte
R
lnw
Files
WriteByte
Q
lnw
Files
ReadByte
R
vers
Files
WriteByte
Q
vers
ELSE
Texts
WriteString
W
alien
class
Texts
WriteInt
W
class
END
END
Files
ReadByte
R
class
END
Files
WriteByte
Q
end
macro
Files
ReadInt
R
wh
Files
WriteInt
Q
wh
Files
ReadString
R
name
Files
WriteString
Q
name
Texts
WriteString
W
name
Texts
WriteInt
W
wh
MOD
10000H
Texts
WriteInt
W
wh
DIV
10000H
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
library
END
Files
Register
G
Texts
WriteString
W
done
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
ConvertLibrary
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
GraphTool
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
GraphTool
MODULE
Input
NW
Ceres
PDR
NW
Ceres
IMPORT
SYSTEM
CONST
msAdr
kbdAdr
VAR
kbdCode
BYTE
last
keyboard
code
read
Recd
Up
Shift
Ctrl
Ext
BOOLEAN
KTabAdr
INTEGER
keyboard
code
translation
table
MW
MH
MX
MY
INTEGER
mouse
limits
and
coords
MK
SET
mouse
keys
FIFO
implemented
in
hardware
because
every
read
must
be
handled
including
tracking
the
state
of
the
Shift
and
Ctrl
keys
PROCEDURE
Peek
BEGIN
IF
SYSTEM
BIT
msAdr
THEN
SYSTEM
GET
kbdAdr
kbdCode
IF
kbdCode
0F0H
THEN
Up
TRUE
ELSIF
kbdCode
0E0H
THEN
Ext
TRUE
ELSE
IF
kbdCode
12H
OR
kbdCode
59H
THEN
shift
Shift
Up
ELSIF
kbdCode
14H
THEN
ctrl
Ctrl
Up
ELSIF
Up
THEN
Recd
TRUE
real
key
going
down
END
Up
FALSE
Ext
FALSE
END
END
END
Peek
PROCEDURE
Available
INTEGER
BEGIN
Peek
RETURN
ORD
Recd
END
Available
PROCEDURE
Read
VAR
ch
CHAR
BEGIN
WHILE
Recd
DO
Peek
END
IF
Shift
OR
Ctrl
THEN
INC
kbdCode
80H
END
ctrl
implies
shift
ch
kbdTab
kbdCode
SYSTEM
GET
KTabAdr
kbdCode
ch
IF
Ctrl
THEN
ch
CHR
ORD
ch
MOD
20H
END
Recd
FALSE
END
Read
PROCEDURE
Mouse
VAR
keys
SET
VAR
x
y
INTEGER
VAR
w
INTEGER
BEGIN
SYSTEM
GET
msAdr
w
keys
SYSTEM
VAL
SET
w
DIV
1000000H
MOD
x
w
MOD
400H
y
w
DIV
1000H
MOD
400H
IF
y
MH
THEN
y
MH
END
END
Mouse
PROCEDURE
SetMouseLimits
w
h
INTEGER
BEGIN
MW
w
MH
h
END
SetMouseLimits
PROCEDURE
Init
BEGIN
Up
FALSE
Shift
FALSE
Ctrl
FALSE
Recd
FALSE
KTabAdr
SYSTEM
ADR
1A
7A
6E
6D
6A
2C
6B
6F
2E
2F
6C
3B
2D
5B
3D
0D
5D
5C
7F
1B
7E
5A
4E
5E
4D
4A
2A
3C
4B
4F
3E
3F
4C
3A
5F
7B
2B
0D
7D
7C
7F
1B
END
Init
BEGIN
Init
END
Input
MODULE
Kernel
NW
PR
IMPORT
SYSTEM
CONST
SectorLength
timer
spiData
spiCtrl
CARD0
SPIFAST
FSoffset
80000H
256MB
in
byte
blocks
mapsize
10000H
1K
sectors
64MB
TYPE
Sector
ARRAY
SectorLength
OF
BYTE
VAR
allocated
NofSectors
INTEGER
heapOrg
heapLim
INTEGER
stackOrg
stackSize
MemLim
INTEGER
clock
INTEGER
list0
list1
list2
list3
INTEGER
lists
of
free
blocks
of
size
n
bytes
data
INTEGER
SPI
data
in
sectorMap
ARRAY
mapsize
DIV
OF
SET
New
heap
allocation
PROCEDURE
GetBlock
VAR
p
LONGINT
len
LONGINT
len
is
multiple
of
VAR
q0
q1
q2
size
LONGINT
done
BOOLEAN
BEGIN
q0
q1
list0
done
FALSE
WHILE
done
q1
DO
SYSTEM
GET
q1
size
SYSTEM
GET
q1
q2
IF
size
len
THEN
no
fit
q0
q1
q1
q2
ELSIF
size
len
THEN
extract
p
done
TRUE
p
q1
IF
q0
THEN
SYSTEM
PUT
q0
q2
ELSE
list0
q2
END
ELSE
reduce
size
done
TRUE
p
q1
q1
q1
len
SYSTEM
PUT
q1
size
len
SYSTEM
PUT
q1
SYSTEM
PUT
q1
q2
IF
q0
THEN
SYSTEM
PUT
q0
q1
ELSE
list0
q1
END
END
END
IF
done
THEN
p
END
END
GetBlock
PROCEDURE
GetBlock128
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list1
THEN
p
list1
SYSTEM
GET
list1
list1
ELSE
GetBlock
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list1
list1
q
p
q
END
END
GetBlock128
PROCEDURE
GetBlock64
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list2
THEN
p
list2
SYSTEM
GET
list2
list2
ELSE
GetBlock128
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list2
list2
q
p
q
END
END
GetBlock64
PROCEDURE
GetBlock32
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list3
THEN
p
list3
SYSTEM
GET
list3
list3
ELSE
GetBlock64
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list3
list3
q
p
q
END
END
GetBlock32
PROCEDURE
New
VAR
ptr
LONGINT
tag
LONGINT
called
by
NEW
via
MT
ptr
and
tag
are
pointers
VAR
p
size
lim
LONGINT
BEGIN
SYSTEM
GET
tag
size
IF
size
THEN
GetBlock32
p
ELSIF
size
THEN
GetBlock64
p
ELSIF
size
THEN
GetBlock128
p
ELSE
GetBlock
p
size
DIV
END
IF
p
THEN
ptr
ELSE
ptr
p
SYSTEM
PUT
p
tag
lim
p
size
INC
p
INC
allocated
size
WHILE
p
lim
DO
SYSTEM
PUT
p
INC
p
END
END
END
New
Garbage
collector
PROCEDURE
Mark
pref
LONGINT
VAR
pvadr
offadr
offset
tag
p
q
r
LONGINT
BEGIN
SYSTEM
GET
pref
pvadr
pointers
heapOrg
considered
NIL
WHILE
pvadr
DO
SYSTEM
GET
pvadr
p
SYSTEM
GET
p
offadr
IF
p
heapOrg
offadr
THEN
q
p
mark
elements
in
data
structure
with
root
p
REPEAT
SYSTEM
GET
p
offadr
IF
offadr
THEN
SYSTEM
GET
p
tag
offadr
tag
ELSE
INC
offadr
END
SYSTEM
PUT
p
offadr
SYSTEM
GET
offadr
offset
IF
offset
THEN
down
SYSTEM
GET
p
offset
r
SYSTEM
GET
r
offadr
IF
r
heapOrg
offadr
THEN
SYSTEM
PUT
p
offset
q
q
p
p
r
END
ELSE
up
SYSTEM
GET
q
offadr
SYSTEM
GET
offadr
offset
IF
p
q
THEN
SYSTEM
GET
q
offset
r
SYSTEM
PUT
q
offset
p
p
q
q
r
END
END
UNTIL
p
q
offset
END
INC
pref
SYSTEM
GET
pref
pvadr
END
END
Mark
PROCEDURE
Scan
VAR
p
q
mark
tag
size
LONGINT
BEGIN
p
heapOrg
REPEAT
SYSTEM
GET
p
mark
q
p
WHILE
mark
DO
SYSTEM
GET
p
tag
SYSTEM
GET
tag
size
INC
p
size
SYSTEM
GET
p
mark
END
size
p
q
DEC
allocated
size
size
of
free
block
IF
size
THEN
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list3
list3
q
INC
q
DEC
size
END
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list2
list2
q
INC
q
DEC
size
END
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list1
list1
q
INC
q
DEC
size
END
IF
size
THEN
SYSTEM
PUT
q
size
SYSTEM
PUT
q
SYSTEM
PUT
q
list0
list0
q
INC
q
size
END
END
IF
mark
THEN
SYSTEM
GET
p
tag
SYSTEM
GET
tag
size
SYSTEM
PUT
p
INC
p
size
ELSE
free
SYSTEM
GET
p
size
INC
p
size
END
UNTIL
p
heapLim
END
Scan
Disk
storage
management
PROCEDURE
SPIIdle
n
INTEGER
send
n
FFs
slowly
with
no
card
selected
BEGIN
SYSTEM
PUT
spiCtrl
WHILE
n
DO
DEC
n
SYSTEM
PUT
spiData
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
END
END
SPIIdle
PROCEDURE
SPI
n
INTEGER
send
rcv
byte
slowly
with
card
selected
BEGIN
SYSTEM
PUT
spiCtrl
CARD0
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
END
SPI
PROCEDURE
SPICmd
n
arg
INTEGER
VAR
i
crc
INTEGER
BEGIN
send
cmd
REPEAT
SPIIdle
UNTIL
data
flush
while
unselected
REPEAT
SPI
UNTIL
data
flush
while
selected
IF
n
THEN
crc
ELSIF
n
THEN
crc
ELSE
crc
END
SPI
n
MOD
send
command
FOR
i
TO
BY
DO
SPI
ROR
arg
i
END
send
arg
SPI
crc
i
REPEAT
SPI
DEC
i
UNTIL
data
80H
OR
i
END
SPICmd
PROCEDURE
SDShift
VAR
n
INTEGER
VAR
data
INTEGER
BEGIN
SPICmd
CMD58
get
card
capacity
bit
SYSTEM
GET
spiData
data
SPI
IF
data
OR
SYSTEM
BIT
spiData
THEN
n
n
END
non
SDHC
card
SPI
SPI
SPIIdle
flush
response
END
SDShift
PROCEDURE
ReadSD
src
dst
INTEGER
VAR
i
INTEGER
BEGIN
SDShift
src
SPICmd
src
ASSERT
data
CMD17
read
one
block
i
wait
for
start
data
marker
REPEAT
SPI
INC
i
UNTIL
data
SYSTEM
PUT
spiCtrl
SPIFAST
CARD0
FOR
i
TO
BY
DO
SYSTEM
PUT
spiData
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
SYSTEM
PUT
dst
data
INC
dst
END
SPI
SPI
SPIIdle
may
be
a
checksum
deselect
card
END
ReadSD
PROCEDURE
WriteSD
dst
src
INTEGER
VAR
i
n
INTEGER
x
BYTE
BEGIN
SDShift
dst
SPICmd
dst
ASSERT
data
CMD24
write
one
block
SPI
write
start
data
marker
SYSTEM
PUT
spiCtrl
SPIFAST
CARD0
FOR
i
TO
BY
DO
SYSTEM
GET
src
n
INC
src
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
END
SPI
SPI
dummy
checksum
i
REPEAT
SPI
INC
i
UNTIL
data
MOD
OR
i
ASSERT
data
MOD
SPIIdle
deselect
card
END
WriteSD
PROCEDURE
InitSecMap
VAR
i
INTEGER
BEGIN
NofSectors
sectorMap
sectorMap
FOR
i
TO
mapsize
DIV
DO
sectorMap
i
END
END
InitSecMap
PROCEDURE
MarkSector
sec
INTEGER
BEGIN
sec
sec
DIV
ASSERT
SYSTEM
H
INCL
sectorMap
sec
DIV
sec
MOD
INC
NofSectors
END
MarkSector
PROCEDURE
FreeSector
sec
INTEGER
BEGIN
sec
sec
DIV
ASSERT
SYSTEM
H
EXCL
sectorMap
sec
DIV
sec
MOD
DEC
NofSectors
END
FreeSector
PROCEDURE
AllocSector
hint
INTEGER
VAR
sec
INTEGER
VAR
s
INTEGER
BEGIN
find
free
sector
starting
after
hint
hint
hint
DIV
ASSERT
SYSTEM
H
s
hint
REPEAT
INC
s
IF
s
mapsize
THEN
s
END
UNTIL
s
MOD
IN
sectorMap
s
DIV
INCL
sectorMap
s
DIV
s
MOD
INC
NofSectors
sec
s
END
AllocSector
PROCEDURE
GetSector
src
INTEGER
VAR
dst
Sector
BEGIN
src
src
DIV
ASSERT
SYSTEM
H
src
src
FSoffset
ReadSD
src
SYSTEM
ADR
dst
ReadSD
src
SYSTEM
ADR
dst
END
GetSector
PROCEDURE
PutSector
dst
INTEGER
VAR
src
Sector
BEGIN
dst
dst
DIV
ASSERT
SYSTEM
H
dst
dst
FSoffset
WriteSD
dst
SYSTEM
ADR
src
WriteSD
dst
SYSTEM
ADR
src
END
PutSector
Miscellaneous
procedures
PROCEDURE
Time
INTEGER
VAR
t
INTEGER
BEGIN
SYSTEM
GET
timer
t
RETURN
t
END
Time
PROCEDURE
Clock
INTEGER
BEGIN
RETURN
clock
END
Clock
PROCEDURE
SetClock
dt
INTEGER
BEGIN
clock
dt
END
SetClock
PROCEDURE
Install
Padr
at
INTEGER
BEGIN
SYSTEM
PUT
at
0E7000000H
Padr
at
DIV
END
Install
PROCEDURE
Trap
VAR
a
INTEGER
b
INTEGER
VAR
u
v
w
INTEGER
BEGIN
u
SYSTEM
REG
SYSTEM
GET
u
v
w
v
DIV
10H
MOD
10H
trap
number
IF
w
THEN
New
a
b
ELSE
stop
LED
w
REPEAT
UNTIL
FALSE
END
END
Trap
PROCEDURE
Init
BEGIN
Install
SYSTEM
ADR
Trap
20H
install
temporary
trap
SYSTEM
GET
MemLim
SYSTEM
GET
heapOrg
stackOrg
heapOrg
stackSize
8000H
heapLim
MemLim
list1
list2
list3
list0
heapOrg
SYSTEM
PUT
list0
heapLim
heapOrg
SYSTEM
PUT
list0
SYSTEM
PUT
list0
allocated
clock
InitSecMap
END
Init
END
Kernel
MODULE
MenuViewers
JG
NW
IMPORT
Input
Display
Viewers
Oberon
CONST
extend
reduce
FrameColor
Display
white
TYPE
Viewer
POINTER
TO
ViewerDesc
ViewerDesc
RECORD
Viewers
ViewerDesc
menuH
INTEGER
END
ModifyMsg
RECORD
Display
FrameMsg
id
INTEGER
dY
Y
H
INTEGER
END
PROCEDURE
Copy
V
Viewer
VAR
V1
Viewer
VAR
Menu
Main
Display
Frame
M
Oberon
CopyMsg
BEGIN
Menu
V
dsc
Main
V
dsc
next
NEW
V1
V1
V
V1
state
M
F
NIL
Menu
handle
Menu
M
V1
dsc
M
F
M
F
NIL
Main
handle
Main
M
V1
dsc
next
M
F
END
Copy
PROCEDURE
Draw
V
Viewers
Viewer
BEGIN
Display
ReplConst
FrameColor
V
X
V
Y
V
H
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
V
Y
V
H
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
W
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
H
V
W
Display
replace
END
Draw
PROCEDURE
Extend
V
Viewer
newY
INTEGER
VAR
dH
INTEGER
BEGIN
dH
V
Y
newY
IF
dH
THEN
Display
ReplConst
Display
black
V
X
newY
V
W
dH
Display
replace
Display
ReplConst
FrameColor
V
X
newY
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
newY
dH
Display
replace
Display
ReplConst
FrameColor
V
X
newY
V
W
Display
replace
END
END
Extend
PROCEDURE
Reduce
V
Viewer
newY
INTEGER
BEGIN
Display
ReplConst
FrameColor
V
X
newY
V
W
Display
replace
END
Reduce
PROCEDURE
Grow
V
Viewer
oldH
INTEGER
VAR
dH
INTEGER
BEGIN
dH
V
H
oldH
IF
dH
THEN
Display
ReplConst
FrameColor
V
X
V
Y
oldH
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
V
Y
oldH
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
H
V
W
Display
replace
END
END
Grow
PROCEDURE
Shrink
V
Viewer
newH
INTEGER
BEGIN
Display
ReplConst
FrameColor
V
X
V
Y
newH
V
W
Display
replace
END
Shrink
PROCEDURE
Adjust
F
Display
Frame
id
dY
Y
H
INTEGER
VAR
M
ModifyMsg
BEGIN
M
id
id
M
dY
dY
M
Y
Y
M
H
H
F
handle
F
M
F
Y
Y
F
H
H
END
Adjust
PROCEDURE
Restore
V
Viewer
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
Draw
V
Menu
X
V
X
Menu
Y
V
Y
V
H
Menu
W
V
W
Menu
H
Main
X
V
X
Main
Y
V
Y
V
H
V
menuH
Main
W
V
W
Main
H
IF
V
H
V
menuH
THEN
Adjust
Menu
extend
V
Y
V
H
V
menuH
V
menuH
Adjust
Main
extend
V
Y
V
H
V
menuH
ELSE
Adjust
Menu
extend
V
Y
V
H
END
END
Restore
PROCEDURE
Modify
V
Viewer
Y
H
INTEGER
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
IF
Y
V
Y
THEN
extend
Oberon
RemoveMarks
V
X
Y
V
W
V
Y
Y
Extend
V
Y
IF
H
V
menuH
THEN
Adjust
Menu
extend
Y
H
V
menuH
V
menuH
Adjust
Main
extend
Y
H
V
menuH
ELSE
Adjust
Menu
extend
Y
H
END
ELSIF
Y
V
Y
THEN
reduce
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
IF
H
V
menuH
THEN
Adjust
Main
reduce
Y
H
V
menuH
Adjust
Menu
reduce
Y
H
V
menuH
V
menuH
ELSE
Adjust
Main
reduce
Y
H
V
menuH
Adjust
Menu
reduce
Y
H
END
Reduce
V
Y
END
END
Modify
PROCEDURE
Change
V
Viewer
X
Y
INTEGER
Keys
SET
VAR
Menu
Main
Display
Frame
V1
Viewers
Viewer
keysum
SET
Y0
dY
H
INTEGER
BEGIN
Keys
Menu
V
dsc
Main
V
dsc
next
Oberon
DrawMouseArrow
X
Y
Display
ReplConst
Display
white
V
X
V
Y
V
H
V
dsc
H
V
W
V
dsc
H
Display
invert
Y0
Y
keysum
Keys
Input
Mouse
Keys
X
Y
WHILE
Keys
DO
keysum
keysum
Keys
Oberon
DrawMouseArrow
X
Y
Input
Mouse
Keys
X
Y
END
Display
ReplConst
Display
white
V
X
V
Y
V
H
V
dsc
H
V
W
V
dsc
H
Display
invert
IF
IN
keysum
THEN
IF
IN
keysum
THEN
V1
Viewers
This
X
Y
IF
V1
IS
Viewer
Y
V1
Y
V1
H
V1
Viewer
menuH
THEN
Y
V1
Y
V1
H
END
IF
Y
V1
Y
V
menuH
THEN
Y
V1
Y
V
menuH
END
Viewers
Close
V
Viewers
Open
V
X
Y
Restore
V
ELSE
IF
Y
Y0
THEN
extend
dY
Y
Y0
V1
Viewers
Next
V
IF
V1
state
THEN
CASE
V1
OF
Viewer
IF
V1
H
V1
menuH
THEN
dY
ELSIF
V1
H
V1
menuH
dY
THEN
dY
V1
H
V1
menuH
END
Viewers
Viewer
IF
V1
H
dY
THEN
dY
V1
H
END
END
ELSIF
V1
H
dY
THEN
dY
V1
H
END
Viewers
Change
V
V
Y
V
H
dY
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
Grow
V
V
H
dY
IF
V
H
V
menuH
THEN
Adjust
Menu
extend
dY
V
Y
V
H
V
menuH
V
menuH
Adjust
Main
extend
dY
V
Y
V
H
V
menuH
ELSE
V
H
Adjust
Menu
extend
dY
V
Y
V
H
Adjust
Main
extend
dY
V
Y
V
H
V
menuH
END
ELSIF
Y
Y0
THEN
reduce
dY
Y0
Y
IF
V
H
V
menuH
THEN
IF
V
H
V
menuH
dY
THEN
dY
V
H
V
menuH
END
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
H
V
H
dY
Adjust
Main
reduce
dY
V
Y
H
V
menuH
Adjust
Menu
reduce
dY
V
Y
H
V
menuH
V
menuH
Shrink
V
H
Viewers
Change
V
V
Y
H
END
END
END
END
END
Change
PROCEDURE
Suspend
V
Viewer
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
Adjust
Main
reduce
V
Y
V
H
V
menuH
Adjust
Menu
reduce
V
Y
V
H
END
Suspend
PROCEDURE
Handle
V
Display
Frame
VAR
M
Display
FrameMsg
VAR
X
Y
INTEGER
Menu
Main
Display
Frame
V1
Viewer
BEGIN
Menu
V
dsc
Main
V
dsc
next
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
X
M
X
Y
M
Y
IF
Y
V
Y
THEN
Oberon
DrawMouseArrow
X
Y
ELSIF
Y
V
Y
V
H
V
Viewer
menuH
THEN
Main
handle
Main
M
ELSIF
Y
V
Y
V
H
V
Viewer
menuH
THEN
Menu
handle
Menu
M
ELSIF
Y
V
Y
V
H
THEN
IF
IN
M
keys
THEN
Change
V
Viewer
X
Y
M
keys
ELSE
Menu
handle
Menu
M
END
ELSE
Oberon
DrawMouseArrow
X
Y
END
ELSE
Menu
handle
Menu
M
Main
handle
Main
M
END
Oberon
ControlMsg
IF
M
id
Oberon
mark
THEN
X
M
X
Y
M
Y
Oberon
DrawMouseArrow
X
Y
Oberon
DrawPointer
X
Y
ELSE
Menu
handle
Menu
M
Main
handle
Main
M
END
Oberon
CopyMsg
Copy
V
Viewer
V1
M
F
V1
Viewers
ViewerMsg
IF
M
id
Viewers
restore
THEN
Restore
V
Viewer
ELSIF
M
id
Viewers
modify
THEN
Modify
V
Viewer
M
Y
M
H
ELSIF
M
id
Viewers
suspend
THEN
Suspend
V
Viewer
END
Display
FrameMsg
Menu
handle
Menu
M
Main
handle
Main
M
END
END
Handle
PROCEDURE
New
Menu
Main
Display
Frame
menuH
X
Y
INTEGER
Viewer
VAR
V
Viewer
BEGIN
NEW
V
V
handle
Handle
V
dsc
Menu
V
dsc
next
Main
V
menuH
menuH
Viewers
Open
V
X
Y
Restore
V
RETURN
V
END
New
END
MenuViewers
MODULE
Modules
Link
and
load
on
RISC
NW
IMPORT
SYSTEM
Files
CONST
versionkey
1X
MT
DescSize
TYPE
Module
POINTER
TO
ModDesc
Command
PROCEDURE
ModuleName
ARRAY
OF
CHAR
ModDesc
RECORD
name
ModuleName
next
Module
key
num
size
refcnt
INTEGER
data
code
imp
cmd
ent
ptr
unused
INTEGER
addresses
END
VAR
root
M
Module
MTOrg
AllocPtr
res
INTEGER
importing
imported
ModuleName
limit
INTEGER
PROCEDURE
ThisFile
name
ARRAY
OF
CHAR
Files
File
VAR
i
INTEGER
filename
ModuleName
BEGIN
i
WHILE
name
i
0X
DO
filename
i
name
i
INC
i
END
filename
i
filename
i
r
filename
i
s
filename
i
c
filename
i
0X
RETURN
Files
Old
filename
END
ThisFile
PROCEDURE
error
n
INTEGER
name
ARRAY
OF
CHAR
BEGIN
res
n
importing
name
END
error
PROCEDURE
Check
s
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
ch
s
res
i
IF
ch
A
ch
Z
OR
ch
a
ch
z
THEN
REPEAT
ch
s
i
INC
i
UNTIL
ch
ch
OR
ch
A
ch
Z
OR
ch
a
ch
z
OR
ch
OR
i
IF
i
ch
0X
THEN
res
END
END
END
Check
PROCEDURE
Load
name
ARRAY
OF
CHAR
VAR
newmod
Module
search
module
in
list
if
not
found
load
module
res
already
present
or
loaded
res
file
not
available
res
key
conflict
res
bad
file
version
res
corrupted
file
res
no
space
VAR
mod
impmod
Module
i
n
key
impkey
mno
nofimps
size
INTEGER
p
u
v
w
INTEGER
addresses
ch
CHAR
body
Command
fixorgP
fixorgD
fixorgT
INTEGER
disp
adr
inst
pno
vno
dest
offset
INTEGER
name1
impname
ModuleName
F
Files
File
R
Files
Rider
import
ARRAY
OF
Module
BEGIN
mod
root
res
nofimps
WHILE
mod
NIL
name
mod
name
DO
mod
mod
next
END
IF
mod
NIL
THEN
load
Check
name
IF
res
THEN
F
ThisFile
name
ELSE
F
NIL
END
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadString
R
name1
Files
ReadInt
R
key
Files
Read
R
ch
Files
ReadInt
R
size
importing
name1
IF
ch
versionkey
THEN
Files
ReadString
R
impname
imports
WHILE
impname
0X
res
DO
Files
ReadInt
R
impkey
Load
impname
impmod
import
nofimps
impmod
importing
name1
IF
res
THEN
IF
impmod
key
impkey
THEN
INC
impmod
refcnt
INC
nofimps
ELSE
error
name1
imported
impname
END
END
Files
ReadString
R
impname
END
ELSE
error
name1
END
ELSE
error
name
END
IF
res
THEN
search
for
a
hole
in
the
list
allocate
and
link
INC
size
DescSize
mod
root
WHILE
mod
NIL
mod
name
0X
mod
size
size
DO
mod
mod
next
END
IF
mod
NIL
THEN
no
large
enough
hole
was
found
IF
AllocPtr
size
limit
THEN
allocate
p
AllocPtr
mod
SYSTEM
VAL
Module
p
AllocPtr
p
size
100H
DIV
20H
20H
mod
size
AllocPtr
p
mod
num
root
num
mod
next
root
root
mod
ELSE
error
name1
END
ELSE
fill
hole
p
SYSTEM
VAL
INTEGER
mod
END
END
IF
res
THEN
read
file
INC
p
DescSize
allocate
descriptor
mod
name
name
mod
key
key
mod
refcnt
mod
data
p
data
SYSTEM
PUT
mod
num
MTOrg
p
module
table
entry
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
type
descriptors
Files
ReadInt
R
n
WHILE
n
DO
SYSTEM
PUT
p
INC
p
DEC
n
END
variable
space
Files
ReadInt
R
n
WHILE
n
DO
Files
Read
R
ch
SYSTEM
PUT
p
ch
INC
p
DEC
n
END
strings
mod
code
p
program
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
program
code
mod
imp
p
copy
imports
i
WHILE
i
nofimps
DO
SYSTEM
PUT
p
import
i
INC
p
INC
i
END
mod
cmd
p
commands
Files
Read
R
ch
WHILE
ch
0X
DO
REPEAT
SYSTEM
PUT
p
ch
INC
p
Files
Read
R
ch
UNTIL
ch
0X
REPEAT
SYSTEM
PUT
p
0X
INC
p
UNTIL
p
MOD
Files
ReadInt
R
n
SYSTEM
PUT
p
n
INC
p
Files
Read
R
ch
END
REPEAT
SYSTEM
PUT
p
0X
INC
p
UNTIL
p
MOD
mod
ent
p
entries
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
mod
ptr
p
pointer
references
Files
ReadInt
R
w
WHILE
w
DO
SYSTEM
PUT
p
mod
data
w
INC
p
Files
ReadInt
R
w
END
SYSTEM
PUT
p
INC
p
Files
ReadInt
R
fixorgP
Files
ReadInt
R
fixorgD
Files
ReadInt
R
fixorgT
Files
ReadInt
R
w
body
SYSTEM
VAL
Command
mod
code
w
Files
Read
R
ch
IF
ch
O
THEN
corrupted
file
mod
NIL
error
name
END
END
IF
res
THEN
fixup
of
BL
adr
mod
code
fixorgP
WHILE
adr
mod
code
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
100000H
MOD
10H
pno
inst
DIV
1000H
MOD
100H
disp
inst
MOD
1000H
SYSTEM
GET
mod
imp
mno
impmod
SYSTEM
GET
impmod
ent
pno
dest
dest
dest
impmod
code
offset
dest
adr
DIV
SYSTEM
PUT
adr
offset
MOD
1000000H
0F7000000H
adr
adr
disp
END
fixup
of
LDR
STR
ADD
adr
mod
code
fixorgD
WHILE
adr
mod
code
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
100000H
MOD
10H
disp
inst
MOD
1000H
IF
mno
THEN
global
SYSTEM
PUT
adr
inst
DIV
1000000H
10H
MT
100000H
mod
num
ELSE
import
SYSTEM
GET
mod
imp
mno
impmod
v
impmod
num
SYSTEM
PUT
adr
inst
DIV
1000000H
10H
MT
100000H
v
SYSTEM
GET
adr
inst
vno
inst
MOD
100H
SYSTEM
GET
impmod
ent
vno
offset
IF
ODD
inst
DIV
100H
THEN
offset
offset
impmod
code
impmod
data
END
SYSTEM
PUT
adr
inst
DIV
10000H
10000H
offset
END
adr
adr
disp
END
fixup
of
type
descriptors
adr
mod
data
fixorgT
WHILE
adr
mod
data
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
1000000H
MOD
10H
vno
inst
DIV
1000H
MOD
1000H
disp
inst
MOD
1000H
IF
mno
THEN
global
inst
mod
data
vno
ELSE
import
SYSTEM
GET
mod
imp
mno
impmod
SYSTEM
GET
impmod
ent
vno
offset
inst
impmod
data
offset
END
SYSTEM
PUT
adr
inst
adr
adr
disp
END
body
initialize
module
ELSIF
res
THEN
importing
name
WHILE
nofimps
DO
DEC
nofimps
DEC
import
nofimps
refcnt
END
END
END
newmod
mod
END
Load
PROCEDURE
ThisCommand
mod
Module
name
ARRAY
OF
CHAR
Command
VAR
k
adr
w
INTEGER
ch
CHAR
s
ARRAY
OF
CHAR
BEGIN
res
w
IF
mod
NIL
THEN
adr
mod
cmd
SYSTEM
GET
adr
ch
WHILE
ch
0X
res
DO
k
read
command
name
REPEAT
s
k
ch
INC
k
INC
adr
SYSTEM
GET
adr
ch
UNTIL
ch
0X
s
k
0X
REPEAT
INC
adr
UNTIL
adr
MOD
SYSTEM
GET
adr
k
INC
adr
IF
s
name
THEN
res
w
mod
code
k
ELSE
SYSTEM
GET
adr
ch
END
END
END
RETURN
SYSTEM
VAL
Command
w
END
ThisCommand
PROCEDURE
Free
name
ARRAY
OF
CHAR
VAR
mod
imp
Module
p
q
INTEGER
BEGIN
mod
root
res
WHILE
mod
NIL
mod
name
name
DO
mod
mod
next
END
IF
mod
NIL
THEN
IF
mod
refcnt
THEN
mod
name
0X
p
mod
imp
q
mod
cmd
WHILE
p
q
DO
SYSTEM
GET
p
imp
DEC
imp
refcnt
INC
p
END
ELSE
res
END
END
END
Free
PROCEDURE
Init
BEGIN
Files
Init
MTOrg
SYSTEM
REG
MT
SYSTEM
GET
AllocPtr
SYSTEM
GET
root
SYSTEM
GET
limit
DEC
limit
8000H
END
Init
BEGIN
Init
Load
Oberon
M
LED
res
REPEAT
UNTIL
FALSE
only
if
load
fails
END
Modules
MODULE
Net
NW
PR
IMPORT
SYSTEM
SCC
Files
Viewers
Texts
TextFrames
MenuViewers
Oberon
CONST
PakSize
T0
T1
timeouts
T0
T1
timeouts
ACK
10H
NAK
25H
NPR
26H
acknowledgements
NRQ
34H
NRS
35H
name
request
response
SND
41H
REC
42H
MSG
44H
TRQ
46H
TIM
47H
time
requests
VAR
W
Texts
Writer
Server
Oberon
Task
head0
head1
SCC
Header
partner
ARRAY
OF
CHAR
dmy
ARRAY
OF
BYTE
protected
BOOLEAN
write
protection
PROCEDURE
SetPartner
name
ARRAY
OF
CHAR
BEGIN
head0
dadr
head1
sadr
partner
name
END
SetPartner
PROCEDURE
Send
t
BYTE
L
INTEGER
data
ARRAY
OF
BYTE
BEGIN
head0
typ
t
head0
len
L
SCC
SendPacket
head0
data
END
Send
PROCEDURE
ReceiveHead
timeout
LONGINT
VAR
time
LONGINT
BEGIN
time
Oberon
Time
timeout
REPEAT
SCC
ReceiveHead
head1
IF
head1
valid
head1
sadr
head0
dadr
THEN
SCC
Skip
head1
len
head1
valid
FALSE
END
IF
head1
valid
Oberon
Time
time
THEN
head1
typ
0FFH
END
UNTIL
head1
valid
OR
head1
typ
0FFH
END
ReceiveHead
PROCEDURE
FindPartner
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
time
LONGINT
k
INTEGER
Id
ARRAY
OF
CHAR
IdB
ARRAY
OF
BYTE
BEGIN
SCC
Skip
SCC
Available
res
k
WHILE
k
name
k
0X
DO
Id
k
name
k
IdB
k
ORD
Id
k
INC
k
END
Id
k
0X
IdB
k
also
terminate
IdB
IF
Id
partner
THEN
head0
dadr
0FFH
Send
NRQ
k
IdB
time
Oberon
Time
T1
REPEAT
SCC
ReceiveHead
head1
IF
head1
valid
THEN
IF
head1
typ
NRS
THEN
SetPartner
Id
ELSE
SCC
Skip
head1
len
head1
valid
FALSE
END
ELSIF
Oberon
Time
time
THEN
res
partner
0X
END
UNTIL
head1
valid
OR
res
END
END
FindPartner
PROCEDURE
AppendS
s
ARRAY
OF
CHAR
VAR
d
ARRAY
OF
BYTE
VAR
k
INTEGER
VAR
i
INTEGER
ch
CHAR
BEGIN
i
REPEAT
ch
s
i
d
k
ORD
ch
INC
i
INC
k
UNTIL
ch
0X
END
AppendS
PROCEDURE
AppendW
s
LONGINT
VAR
d
ARRAY
OF
BYTE
n
INTEGER
VAR
k
INTEGER
VAR
i
INTEGER
BEGIN
i
REPEAT
d
k
s
MOD
100H
s
s
DIV
100H
INC
i
INC
k
UNTIL
i
n
END
AppendW
PROCEDURE
PickS
VAR
s
ARRAY
OF
CHAR
VAR
i
INTEGER
x
BYTE
BEGIN
i
REPEAT
SCC
Receive
x
s
i
CHR
x
INC
i
UNTIL
x
END
PickS
PROCEDURE
PickQ
VAR
w
LONGINT
VAR
x0
x1
x2
x3
BYTE
BEGIN
SCC
Receive
x0
SCC
Receive
x1
SCC
Receive
x2
SCC
Receive
x3
w
x0
100H
x1
100H
x2
100H
x3
END
PickQ
PROCEDURE
SendData
F
Files
File
VAR
k
seqno
INTEGER
x
BYTE
len
LONGINT
R
Files
Rider
buf
ARRAY
PakSize
OF
BYTE
BEGIN
Files
Set
R
F
len
seqno
REPEAT
k
REPEAT
Files
ReadByte
R
x
IF
R
eof
THEN
buf
k
x
INC
k
END
UNTIL
R
eof
OR
k
PakSize
REPEAT
Send
seqno
k
buf
ReceiveHead
T1
UNTIL
head1
typ
seqno
ACK
seqno
seqno
MOD
len
len
k
IF
head1
typ
seqno
ACK
THEN
Texts
WriteString
W
failed
k
END
UNTIL
k
PakSize
Texts
WriteInt
W
len
END
SendData
PROCEDURE
ReceiveData
F
Files
File
VAR
done
BOOLEAN
VAR
k
retry
seqno
INTEGER
x
BYTE
len
LONGINT
R
Files
Rider
BEGIN
Files
Set
R
F
seqno
len
retry
k
PakSize
REPEAT
IF
head1
typ
seqno
THEN
seqno
seqno
MOD
len
len
head1
len
retry
Send
seqno
ACK
dmy
k
WHILE
k
head1
len
DO
SCC
Receive
x
Files
WriteByte
R
x
INC
k
END
IF
k
PakSize
THEN
done
TRUE
END
ELSE
DEC
retry
IF
retry
THEN
Texts
WriteString
W
failed
done
FALSE
k
END
Send
seqno
ACK
dmy
END
ReceiveHead
T0
UNTIL
k
PakSize
Texts
WriteInt
W
len
END
ReceiveData
PROCEDURE
reply
msg
INTEGER
BEGIN
IF
msg
THEN
Texts
WriteString
W
no
link
ELSIF
msg
THEN
Texts
WriteString
W
no
permission
ELSIF
msg
THEN
Texts
WriteString
W
not
done
ELSIF
msg
THEN
Texts
WriteString
W
not
found
ELSIF
msg
THEN
Texts
WriteString
W
no
response
ELSIF
msg
THEN
Texts
WriteString
W
time
set
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
reply
PROCEDURE
Serve
VAR
i
INTEGER
done
BOOLEAN
x
BYTE
F
Files
File
pw
clock
newclock
LONGINT
Id
ARRAY
OF
CHAR
IdB
ARRAY
OF
BYTE
FileName
ARRAY
OF
CHAR
BEGIN
SCC
ReceiveHead
head1
IF
head1
valid
THEN
IF
head1
typ
SND
THEN
PickS
Id
PickQ
pw
PickS
FileName
Texts
WriteString
W
Id
Texts
Write
W
Texts
WriteString
W
FileName
F
Files
Old
FileName
IF
F
NIL
THEN
Texts
WriteString
W
sending
SetPartner
Id
Texts
Append
Oberon
Log
W
buf
SendData
F
ELSE
Send
NAK
dmy
Texts
Write
W
END
reply
ELSIF
head1
typ
REC
THEN
PickS
Id
PickQ
pw
PickS
FileName
IF
protected
THEN
Texts
WriteString
W
Id
Texts
Write
W
Texts
WriteString
W
FileName
F
Files
New
FileName
IF
F
NIL
THEN
Texts
WriteString
W
receiving
SetPartner
Id
Texts
Append
Oberon
Log
W
buf
Send
ACK
dmy
ReceiveHead
T0
ReceiveData
F
done
IF
done
THEN
Files
Register
F
END
ELSE
Send
NAK
dmy
Texts
Write
W
END
reply
ELSE
Send
NPR
dmy
END
ELSIF
head1
typ
MSG
THEN
i
WHILE
i
head1
len
DO
SCC
Receive
x
Texts
Write
W
CHR
x
INC
i
END
Send
ACK
dmy
reply
ELSIF
head1
typ
TRQ
THEN
i
AppendW
Oberon
Clock
IdB
i
Send
TIM
IdB
ELSIF
head1
typ
TIM
THEN
PickQ
newclock
PickS
Id
PickQ
pw
clock
Oberon
Clock
IF
protected
Id
0X
ABS
pw
clock
THEN
Oberon
SetClock
newclock
Texts
WriteString
W
Id
Texts
WriteString
W
changed
System
Date
Texts
WriteClock
W
newclock
reply
END
ELSIF
head1
typ
NRQ
THEN
i
REPEAT
SCC
Receive
x
Id
i
CHR
x
INC
i
IF
i
THEN
Id
0X
x
END
UNTIL
x
WHILE
i
head1
len
DO
SCC
Receive
x
INC
i
END
IF
Id
Oberon
User
THEN
SetPartner
Id
Send
NRS
dmy
END
ELSE
SCC
Skip
head1
len
END
END
END
Serve
PROCEDURE
GetPar1
VAR
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
END
GetPar1
PROCEDURE
GetPar
VAR
S
Texts
Scanner
VAR
end
LONGINT
VAR
T
Texts
Text
beg
tm
LONGINT
BEGIN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
tm
IF
tm
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
ELSE
end
Oberon
Par
text
len
END
END
GetPar
PROCEDURE
SendFiles
VAR
k
INTEGER
end
LONGINT
S
Texts
Scanner
F
Files
File
buf
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
k
IF
k
THEN
GetPar
S
end
WHILE
Texts
Pos
S
end
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
k
AppendS
Oberon
User
buf
k
AppendW
Oberon
Password
buf
k
AppendS
S
s
buf
k
IF
S
nextCh
THEN
prefix
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
THEN
buf
k
ORD
AppendS
S
s
buf
k
Texts
Write
W
Texts
WriteString
W
S
s
END
END
F
Files
Old
S
s
IF
F
NIL
THEN
Send
REC
k
buf
ReceiveHead
T0
IF
head1
typ
ACK
THEN
Texts
WriteString
W
sending
Texts
Append
Oberon
Log
W
buf
SendData
F
reply
ELSIF
head1
typ
NPR
THEN
reply
end
ELSIF
head1
typ
NAK
THEN
reply
end
ELSE
reply
end
END
ELSE
reply
END
Texts
Scan
S
END
ELSE
reply
END
END
END
SendFiles
PROCEDURE
ReceiveFiles
VAR
k
INTEGER
done
BOOLEAN
end
LONGINT
S
Texts
Scanner
F
Files
File
buf
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
k
IF
k
THEN
GetPar
S
end
WHILE
Texts
Pos
S
end
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
k
AppendS
Oberon
User
buf
k
AppendW
Oberon
Password
buf
k
AppendS
S
s
buf
k
IF
S
nextCh
THEN
prefix
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
THEN
buf
k
ORD
AppendS
S
s
buf
k
Texts
Write
W
Texts
WriteString
W
S
s
END
END
Send
SND
k
buf
Texts
WriteString
W
receiving
Texts
Append
Oberon
Log
W
buf
ReceiveHead
T1
IF
head1
typ
THEN
F
Files
New
S
s
IF
F
NIL
THEN
ReceiveData
F
done
IF
done
THEN
Files
Register
F
reply
ELSE
end
END
ELSE
reply
Send
NAK
dmy
END
ELSIF
head1
typ
NAK
THEN
reply
ELSIF
head1
typ
NPR
THEN
reply
end
ELSE
reply
end
END
Texts
Scan
S
END
ELSE
reply
END
END
END
ReceiveFiles
PROCEDURE
SendMsg
VAR
i
INTEGER
ch
CHAR
S
Texts
Scanner
msg
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
i
IF
i
THEN
Texts
Read
S
ch
WHILE
ch
i
DO
msg
i
ORD
ch
INC
i
Texts
Read
S
ch
END
Send
MSG
i
msg
ReceiveHead
T0
IF
head1
typ
ACK
THEN
reply
END
ELSE
reply
END
END
END
SendMsg
PROCEDURE
GetTime
VAR
dt
res
INTEGER
S
Texts
Scanner
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
res
IF
res
THEN
Send
TRQ
dmy
ReceiveHead
T1
IF
head1
typ
TIM
THEN
PickQ
dt
Oberon
SetClock
dt
reply
END
ELSE
reply
END
END
END
GetTime
PROCEDURE
StartServer
BEGIN
protected
TRUE
partner
0X
SCC
Start
TRUE
Oberon
Remove
Server
Oberon
Install
Server
Texts
WriteString
W
Server
started
as
Texts
WriteString
W
Oberon
User
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
StartServer
PROCEDURE
Unprotect
BEGIN
protected
FALSE
END
Unprotect
PROCEDURE
WProtect
BEGIN
protected
TRUE
END
WProtect
PROCEDURE
Reset
BEGIN
SCC
Start
TRUE
END
Reset
PROCEDURE
StopServer
BEGIN
Oberon
Remove
Server
Texts
WriteString
W
Server
stopped
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
StopServer
PROCEDURE
SCCStatus
BEGIN
Texts
WriteString
W
SCC
Available
Texts
WriteInt
W
SCC
Available
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
SCCStatus
BEGIN
Texts
OpenWriter
W
Server
Oberon
NewTask
Serve
END
Net
MODULE
Oberon
JG
NW
IMPORT
SYSTEM
Kernel
Files
Modules
Input
Display
Viewers
Fonts
Texts
CONST
message
ids
consume
track
defocus
neutralize
mark
off
idle
active
task
states
BasicCycle
ESC
1BX
SETSTAR
1AX
TYPE
Painter
PROCEDURE
x
y
INTEGER
Marker
RECORD
Fade
Draw
Painter
END
Cursor
RECORD
marker
Marker
on
BOOLEAN
X
Y
INTEGER
END
InputMsg
RECORD
Display
FrameMsg
id
INTEGER
keys
SET
X
Y
INTEGER
ch
CHAR
fnt
Fonts
Font
col
voff
INTEGER
END
SelectionMsg
RECORD
Display
FrameMsg
time
LONGINT
text
Texts
Text
beg
end
LONGINT
END
ControlMsg
RECORD
Display
FrameMsg
id
X
Y
INTEGER
END
CopyMsg
RECORD
Display
FrameMsg
F
Display
Frame
END
Task
POINTER
TO
TaskDesc
Handler
PROCEDURE
TaskDesc
RECORD
state
nextTime
period
INTEGER
next
Task
handle
Handler
END
VAR
User
ARRAY
OF
CHAR
Password
LONGINT
Arrow
Star
Marker
Mouse
Pointer
Cursor
FocusViewer
Viewers
Viewer
Log
Texts
Text
Par
RECORD
vwr
Viewers
Viewer
frame
Display
Frame
text
Texts
Text
pos
LONGINT
END
CurFnt
Fonts
Font
CurCol
CurOff
INTEGER
NofTasks
INTEGER
CurTask
Task
DW
DH
CL
INTEGER
ActCnt
INTEGER
action
count
for
GC
Mod
Modules
Module
user
identification
PROCEDURE
Code
VAR
s
ARRAY
OF
CHAR
LONGINT
VAR
i
INTEGER
a
b
c
LONGINT
BEGIN
a
b
i
WHILE
s
i
0X
DO
c
b
b
a
a
c
MOD
ORD
s
i
INC
i
END
IF
b
THEN
b
b
END
RETURN
b
a
END
Code
PROCEDURE
SetUser
VAR
user
password
ARRAY
OF
CHAR
BEGIN
User
user
Password
Code
password
END
SetUser
PROCEDURE
Clock
LONGINT
BEGIN
RETURN
Kernel
Clock
END
Clock
PROCEDURE
SetClock
d
LONGINT
BEGIN
Kernel
SetClock
d
END
SetClock
PROCEDURE
Time
LONGINT
BEGIN
RETURN
Kernel
Time
END
Time
cursor
handling
PROCEDURE
FlipArrow
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
arrow
X
Y
Display
invert
END
FlipArrow
PROCEDURE
FlipStar
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
star
X
Y
Display
invert
END
FlipStar
PROCEDURE
OpenCursor
VAR
c
Cursor
BEGIN
c
on
FALSE
c
X
c
Y
END
OpenCursor
PROCEDURE
FadeCursor
VAR
c
Cursor
BEGIN
IF
c
on
THEN
c
marker
Fade
c
X
c
Y
c
on
FALSE
END
END
FadeCursor
PROCEDURE
DrawCursor
VAR
c
Cursor
m
Marker
x
y
INTEGER
BEGIN
IF
c
on
x
c
X
OR
y
c
Y
OR
m
Draw
c
marker
Draw
THEN
c
marker
Fade
c
X
c
Y
c
on
FALSE
END
IF
c
on
THEN
m
Draw
x
y
c
marker
m
c
X
x
c
Y
y
c
on
TRUE
END
END
DrawCursor
PROCEDURE
DrawMouse
m
Marker
x
y
INTEGER
BEGIN
DrawCursor
Mouse
m
x
y
END
DrawMouse
PROCEDURE
DrawMouseArrow
x
y
INTEGER
BEGIN
DrawCursor
Mouse
Arrow
x
y
END
DrawMouseArrow
PROCEDURE
FadeMouse
BEGIN
FadeCursor
Mouse
END
FadeMouse
PROCEDURE
DrawPointer
x
y
INTEGER
BEGIN
DrawCursor
Pointer
Star
x
y
END
DrawPointer
display
management
PROCEDURE
RemoveMarks
X
Y
W
H
INTEGER
BEGIN
IF
Mouse
X
X
Mouse
X
X
W
Mouse
Y
Y
Mouse
Y
Y
H
THEN
FadeCursor
Mouse
END
IF
Pointer
X
X
Pointer
X
X
W
Pointer
Y
Y
Pointer
Y
Y
H
THEN
FadeCursor
Pointer
END
END
RemoveMarks
PROCEDURE
HandleFiller
V
Display
Frame
VAR
M
Display
FrameMsg
BEGIN
CASE
M
OF
InputMsg
IF
M
id
track
THEN
DrawCursor
Mouse
Arrow
M
X
M
Y
END
ControlMsg
IF
M
id
mark
THEN
DrawCursor
Pointer
Star
M
X
M
Y
END
Viewers
ViewerMsg
IF
M
id
Viewers
restore
V
W
V
H
THEN
RemoveMarks
V
X
V
Y
V
W
V
H
Display
ReplConst
Display
black
V
X
V
Y
V
W
V
H
Display
replace
ELSIF
M
id
Viewers
modify
M
Y
V
Y
THEN
RemoveMarks
V
X
M
Y
V
W
V
Y
M
Y
Display
ReplConst
Display
black
V
X
M
Y
V
W
V
Y
M
Y
Display
replace
END
END
END
HandleFiller
PROCEDURE
OpenDisplay
UW
SW
H
INTEGER
VAR
Filler
Viewers
Viewer
BEGIN
Input
SetMouseLimits
Viewers
curW
UW
SW
H
Display
ReplConst
Display
black
Viewers
curW
UW
SW
H
Display
replace
NEW
Filler
Filler
handle
HandleFiller
Viewers
InitTrack
UW
H
Filler
init
user
track
NEW
Filler
Filler
handle
HandleFiller
Viewers
InitTrack
SW
H
Filler
init
system
track
END
OpenDisplay
PROCEDURE
DisplayWidth
X
INTEGER
INTEGER
BEGIN
RETURN
DW
END
DisplayWidth
PROCEDURE
DisplayHeight
X
INTEGER
INTEGER
BEGIN
RETURN
DH
END
DisplayHeight
PROCEDURE
OpenTrack
X
W
INTEGER
VAR
Filler
Viewers
Viewer
BEGIN
NEW
Filler
Filler
handle
HandleFiller
Viewers
OpenTrack
X
W
Filler
END
OpenTrack
PROCEDURE
UserTrack
X
INTEGER
INTEGER
BEGIN
RETURN
X
DIV
DW
DW
END
UserTrack
PROCEDURE
SystemTrack
X
INTEGER
INTEGER
BEGIN
RETURN
X
DIV
DW
DW
DW
DIV
END
SystemTrack
PROCEDURE
UY
X
INTEGER
INTEGER
VAR
h
INTEGER
fil
bot
alt
max
Display
Frame
BEGIN
Viewers
Locate
X
fil
bot
alt
max
IF
fil
H
DH
DIV
THEN
h
DH
ELSE
h
max
Y
max
H
DIV
END
RETURN
h
END
UY
PROCEDURE
AllocateUserViewer
DX
INTEGER
VAR
X
Y
INTEGER
BEGIN
IF
Pointer
on
THEN
X
Pointer
X
Y
Pointer
Y
ELSE
X
DX
DIV
DW
DW
Y
UY
X
END
END
AllocateUserViewer
PROCEDURE
SY
X
INTEGER
INTEGER
VAR
H0
H1
H2
H3
y
INTEGER
fil
bot
alt
max
Display
Frame
BEGIN
H3
DH
DH
DIV
H2
H3
H3
DIV
H1
DH
DIV
H0
DH
DIV
Viewers
Locate
X
DH
fil
bot
alt
max
IF
fil
H
DH
DIV
THEN
y
DH
ELSIF
max
H
DH
H0
THEN
y
max
Y
H3
ELSIF
max
H
H3
H0
THEN
y
max
Y
H2
ELSIF
max
H
H2
H0
THEN
y
max
Y
H1
ELSIF
max
bot
THEN
y
max
Y
max
H
DIV
ELSIF
bot
H
H1
THEN
y
bot
H
DIV
ELSE
y
alt
Y
alt
H
DIV
END
RETURN
y
END
SY
PROCEDURE
AllocateSystemViewer
DX
INTEGER
VAR
X
Y
INTEGER
BEGIN
IF
Pointer
on
THEN
X
Pointer
X
Y
Pointer
Y
ELSE
X
DX
DIV
DW
DW
DW
DIV
Y
SY
X
END
END
AllocateSystemViewer
PROCEDURE
MarkedViewer
Viewers
Viewer
BEGIN
RETURN
Viewers
This
Pointer
X
Pointer
Y
END
MarkedViewer
PROCEDURE
PassFocus
V
Viewers
Viewer
VAR
M
ControlMsg
BEGIN
M
id
defocus
FocusViewer
handle
FocusViewer
M
FocusViewer
V
END
PassFocus
PROCEDURE
OpenLog
T
Texts
Text
BEGIN
Log
T
END
OpenLog
command
interpretation
PROCEDURE
SetPar
F
Display
Frame
T
Texts
Text
pos
LONGINT
BEGIN
Par
vwr
Viewers
This
F
X
F
Y
Par
frame
F
Par
text
T
Par
pos
pos
END
SetPar
PROCEDURE
Call
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
mod
Modules
Module
P
Modules
Command
i
j
INTEGER
ch
CHAR
Mname
Cname
ARRAY
OF
CHAR
BEGIN
i
ch
name
WHILE
ch
ch
0X
DO
Mname
i
ch
INC
i
ch
name
i
END
IF
ch
THEN
Mname
i
0X
INC
i
Modules
Load
Mname
mod
res
Modules
res
IF
Modules
res
THEN
j
ch
name
i
INC
i
WHILE
ch
0X
DO
Cname
j
ch
INC
j
ch
name
i
INC
i
END
Cname
j
0X
P
Modules
ThisCommand
mod
Cname
res
Modules
res
IF
Modules
res
THEN
P
END
END
ELSE
res
END
END
Call
PROCEDURE
GetSelection
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
VAR
M
SelectionMsg
BEGIN
M
time
Viewers
Broadcast
M
time
M
time
IF
time
THEN
text
M
text
beg
M
beg
end
M
end
END
END
GetSelection
PROCEDURE
GC
VAR
mod
Modules
Module
BEGIN
IF
ActCnt
OR
Kernel
allocated
Kernel
heapLim
Kernel
heapOrg
10000H
THEN
mod
Modules
root
LED
21H
WHILE
mod
NIL
DO
IF
mod
name
0X
THEN
Kernel
Mark
mod
ptr
END
mod
mod
next
END
LED
23H
Files
RestoreList
LED
27H
Kernel
Scan
LED
20H
ActCnt
BasicCycle
END
END
GC
PROCEDURE
NewTask
h
Handler
period
INTEGER
Task
VAR
t
Task
BEGIN
NEW
t
t
state
off
t
next
t
t
handle
h
t
period
period
RETURN
t
END
NewTask
PROCEDURE
Install
T
Task
BEGIN
IF
T
state
off
THEN
T
next
CurTask
next
CurTask
next
T
T
state
idle
T
nextTime
INC
NofTasks
END
END
Install
PROCEDURE
Remove
T
Task
VAR
t
Task
BEGIN
IF
T
state
off
THEN
t
T
WHILE
t
next
T
DO
t
t
next
END
t
next
T
next
T
state
off
T
next
NIL
CurTask
t
DEC
NofTasks
END
END
Remove
PROCEDURE
Collect
count
INTEGER
BEGIN
ActCnt
count
END
Collect
PROCEDURE
SetFont
fnt
Fonts
Font
BEGIN
CurFnt
fnt
END
SetFont
PROCEDURE
SetColor
col
INTEGER
BEGIN
CurCol
col
END
SetColor
PROCEDURE
SetOffset
voff
INTEGER
BEGIN
CurOff
voff
END
SetOffset
PROCEDURE
Loop
VAR
V
Viewers
Viewer
M
InputMsg
N
ControlMsg
prevX
prevY
X
Y
t
INTEGER
keys
SET
ch
CHAR
BEGIN
REPEAT
Input
Mouse
keys
X
Y
IF
Input
Available
THEN
Input
Read
ch
IF
ch
ESC
THEN
N
id
neutralize
Viewers
Broadcast
N
FadeCursor
Pointer
LED
ELSIF
ch
SETSTAR
THEN
N
id
mark
N
X
X
N
Y
Y
V
Viewers
This
X
Y
V
handle
V
N
ELSE
M
id
consume
M
ch
ch
M
fnt
CurFnt
M
col
CurCol
M
voff
CurOff
FocusViewer
handle
FocusViewer
M
DEC
ActCnt
END
ELSIF
keys
THEN
M
id
track
M
X
X
M
Y
Y
M
keys
keys
REPEAT
V
Viewers
This
M
X
M
Y
V
handle
V
M
Input
Mouse
M
keys
M
X
M
Y
UNTIL
M
keys
DEC
ActCnt
ELSE
IF
X
prevX
OR
Y
prevY
OR
Mouse
on
THEN
M
id
track
M
X
X
IF
Y
Display
Height
THEN
Y
Display
Height
END
M
Y
Y
M
keys
keys
V
Viewers
This
X
Y
V
handle
V
M
prevX
X
prevY
Y
END
CurTask
CurTask
next
t
Kernel
Time
IF
t
CurTask
nextTime
THEN
CurTask
nextTime
t
CurTask
period
CurTask
state
active
CurTask
handle
CurTask
state
idle
END
END
UNTIL
FALSE
END
Loop
PROCEDURE
Reset
BEGIN
IF
CurTask
state
active
THEN
Remove
CurTask
END
SYSTEM
LDREG
Kernel
stackOrg
reset
stack
pointer
Loop
END
Reset
BEGIN
User
0X
Arrow
Fade
FlipArrow
Arrow
Draw
FlipArrow
Star
Fade
FlipStar
Star
Draw
FlipStar
OpenCursor
Mouse
OpenCursor
Pointer
DW
Display
Width
DH
Display
Height
CL
DW
OpenDisplay
DW
DIV
DW
DIV
DH
FocusViewer
Viewers
This
CurFnt
Fonts
Default
CurCol
Display
white
CurOff
ActCnt
CurTask
NewTask
GC
Install
CurTask
Modules
Load
System
Mod
Mod
NIL
Loop
END
Oberon
MODULE
ORB
NW
in
Oberon
IMPORT
Files
ORS
Definition
of
data
types
Object
and
Type
which
together
form
the
data
structure
called
symbol
table
Contains
procedures
for
creation
of
Objects
and
for
search
NewObj
this
thisimport
thisfield
and
OpenScope
CloseScope
Handling
of
import
and
export
i
e
reading
and
writing
of
symbol
files
is
done
by
procedures
Import
and
Export
This
module
contains
the
list
of
standard
identifiers
with
which
the
symbol
table
universe
and
that
of
the
pseudo
module
SYSTEM
are
initialized
CONST
versionkey
maxTypTab
class
values
Head
Const
Var
Par
Fld
Typ
SProc
SFunc
Mod
form
values
Byte
Bool
Char
Int
Real
Set
Pointer
NilTyp
NoTyp
Proc
String
Array
Record
TYPE
Object
POINTER
TO
ObjDesc
Module
POINTER
TO
ModDesc
Type
POINTER
TO
TypeDesc
ObjDesc
RECORD
class
exno
BYTE
expo
rdo
BOOLEAN
exported
read
only
lev
INTEGER
next
dsc
Object
type
Type
name
ORS
Ident
val
LONGINT
END
ModDesc
RECORD
ObjDesc
orgname
ORS
Ident
END
TypeDesc
RECORD
form
ref
mno
INTEGER
ref
is
only
used
for
import
export
nofpar
INTEGER
for
procedures
extension
level
for
records
len
LONGINT
for
arrays
len
open
array
for
records
adr
of
descriptor
dsc
typobj
Object
base
Type
for
arrays
records
pointers
size
LONGINT
in
bytes
always
multiple
of
except
for
Byte
Bool
and
Char
END
Object
classes
and
the
meaning
of
val
class
val
Var
address
Par
address
Const
value
Fld
offset
Typ
type
descriptor
TD
address
SProc
inline
code
number
SFunc
inline
code
number
Mod
key
Type
forms
and
the
meaning
of
dsc
and
base
form
dsc
base
Pointer
type
of
dereferenced
object
Proc
params
result
type
Array
type
of
elements
Record
fields
extension
VAR
topScope
universe
system
Object
byteType
boolType
charType
Type
intType
realType
setType
nilType
noType
strType
Type
nofmod
Ref
INTEGER
typtab
ARRAY
maxTypTab
OF
Type
PROCEDURE
NewObj
VAR
obj
Object
id
ORS
Ident
class
INTEGER
insert
new
Object
with
name
id
VAR
new
x
Object
BEGIN
x
topScope
WHILE
x
next
NIL
x
next
name
id
DO
x
x
next
END
IF
x
next
NIL
THEN
NEW
new
new
name
id
new
class
class
new
next
NIL
new
rdo
FALSE
new
dsc
NIL
x
next
new
obj
new
ELSE
obj
x
next
ORS
Mark
mult
def
END
END
NewObj
PROCEDURE
thisObj
Object
VAR
s
x
Object
BEGIN
s
topScope
REPEAT
x
s
next
WHILE
x
NIL
x
name
ORS
id
DO
x
x
next
END
s
s
dsc
UNTIL
x
NIL
OR
s
NIL
RETURN
x
END
thisObj
PROCEDURE
thisimport
mod
Object
Object
VAR
obj
Object
BEGIN
IF
mod
rdo
THEN
IF
mod
name
0X
THEN
obj
mod
dsc
WHILE
obj
NIL
obj
name
ORS
id
DO
obj
obj
next
END
ELSE
obj
NIL
END
ELSE
obj
NIL
END
RETURN
obj
END
thisimport
PROCEDURE
thisfield
rec
Type
Object
VAR
fld
Object
BEGIN
fld
rec
dsc
WHILE
fld
NIL
fld
name
ORS
id
DO
fld
fld
next
END
RETURN
fld
END
thisfield
PROCEDURE
OpenScope
VAR
s
Object
BEGIN
NEW
s
s
class
Head
s
dsc
topScope
s
next
NIL
topScope
s
END
OpenScope
PROCEDURE
CloseScope
BEGIN
topScope
topScope
dsc
END
CloseScope
Import
PROCEDURE
MakeFileName
VAR
FName
ORS
Ident
name
ext
ARRAY
OF
CHAR
VAR
i
j
INTEGER
BEGIN
i
j
assume
name
suffix
less
than
characters
WHILE
i
ORS
IdLen
name
i
0X
DO
FName
i
name
i
INC
i
END
REPEAT
FName
i
ext
j
INC
i
INC
j
UNTIL
ext
j
0X
FName
i
0X
END
MakeFileName
PROCEDURE
ThisModule
name
orgname
ORS
Ident
non
BOOLEAN
key
LONGINT
Object
VAR
mod
Module
obj
obj1
Object
BEGIN
obj1
topScope
obj
obj1
next
search
for
module
WHILE
obj
NIL
obj
name
name
DO
obj1
obj
obj
obj1
next
END
IF
obj
NIL
THEN
insert
new
module
NEW
mod
mod
class
Mod
mod
rdo
FALSE
mod
name
name
mod
orgname
orgname
mod
val
key
mod
lev
nofmod
INC
nofmod
mod
type
noType
mod
dsc
NIL
mod
next
NIL
obj1
next
mod
obj
mod
ELSE
module
already
present
IF
non
THEN
ORS
Mark
invalid
import
order
END
END
RETURN
obj
END
ThisModule
PROCEDURE
Read
VAR
R
Files
Rider
VAR
x
INTEGER
VAR
b
BYTE
BEGIN
Files
ReadByte
R
b
IF
b
80H
THEN
x
b
ELSE
x
b
100H
END
END
Read
PROCEDURE
InType
VAR
R
Files
Rider
thismod
Object
VAR
T
Type
VAR
key
LONGINT
ref
class
form
np
readonly
INTEGER
fld
par
obj
mod
Object
t
Type
name
modname
ORS
Ident
BEGIN
Read
R
ref
IF
ref
THEN
T
typtab
ref
already
read
ELSE
NEW
t
T
t
typtab
ref
t
t
mno
thismod
lev
Read
R
form
t
form
form
IF
form
Pointer
THEN
InType
R
thismod
t
base
t
size
ELSIF
form
Array
THEN
InType
R
thismod
t
base
Files
ReadNum
R
t
len
Files
ReadNum
R
t
size
ELSIF
form
Record
THEN
InType
R
thismod
t
base
IF
t
base
form
NoTyp
THEN
t
base
NIL
obj
NIL
ELSE
obj
t
base
dsc
END
Files
ReadNum
R
t
len
TD
adr
exno
Files
ReadNum
R
t
nofpar
ext
level
Files
ReadNum
R
t
size
Read
R
class
WHILE
class
DO
fields
NEW
fld
fld
class
class
Files
ReadString
R
fld
name
IF
fld
name
0X
THEN
fld
expo
TRUE
InType
R
thismod
fld
type
ELSE
fld
expo
FALSE
fld
type
nilType
END
Files
ReadNum
R
fld
val
fld
next
obj
obj
fld
Read
R
class
END
t
dsc
obj
ELSIF
form
Proc
THEN
InType
R
thismod
t
base
obj
NIL
np
Read
R
class
WHILE
class
DO
parameters
NEW
par
par
class
class
Read
R
readonly
par
rdo
readonly
InType
R
thismod
par
type
par
next
obj
obj
par
INC
np
Read
R
class
END
t
dsc
obj
t
nofpar
np
t
size
END
Files
ReadString
R
modname
IF
modname
0X
THEN
re
import
Files
ReadInt
R
key
Files
ReadString
R
name
mod
ThisModule
modname
modname
FALSE
key
obj
mod
dsc
search
type
WHILE
obj
NIL
obj
name
name
DO
obj
obj
next
END
IF
obj
NIL
THEN
T
obj
type
type
object
found
in
object
list
of
mod
ELSE
insert
new
type
object
in
object
list
of
mod
NEW
obj
obj
name
name
obj
class
Typ
obj
next
mod
dsc
mod
dsc
obj
obj
type
t
t
mno
mod
lev
t
typobj
obj
T
t
END
typtab
ref
T
END
END
END
InType
PROCEDURE
Import
VAR
modid
modid1
ORS
Ident
VAR
key
LONGINT
class
k
INTEGER
obj
Object
t
Type
thismod
Object
modname
fname
ORS
Ident
F
Files
File
R
Files
Rider
BEGIN
IF
modid1
SYSTEM
THEN
thismod
ThisModule
modid
modid1
TRUE
key
DEC
nofmod
thismod
lev
thismod
dsc
system
thismod
rdo
TRUE
ELSE
MakeFileName
fname
modid1
smb
F
Files
Old
fname
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadInt
R
key
Files
ReadInt
R
key
Files
ReadString
R
modname
thismod
ThisModule
modid
modid1
TRUE
key
thismod
rdo
TRUE
Read
R
class
version
key
IF
class
versionkey
THEN
ORS
Mark
wrong
version
END
Read
R
class
WHILE
class
DO
NEW
obj
obj
class
class
Files
ReadString
R
obj
name
InType
R
thismod
obj
type
obj
lev
thismod
lev
IF
class
Typ
THEN
t
obj
type
t
typobj
obj
Read
R
k
fixup
bases
of
previously
declared
pointer
types
WHILE
k
DO
typtab
k
base
t
Read
R
k
END
ELSE
IF
class
Const
THEN
IF
obj
type
form
Real
THEN
Files
ReadInt
R
obj
val
ELSE
Files
ReadNum
R
obj
val
END
ELSIF
class
Var
THEN
Files
ReadNum
R
obj
val
obj
rdo
TRUE
END
END
obj
next
thismod
dsc
thismod
dsc
obj
Read
R
class
END
ELSE
ORS
Mark
import
not
available
END
END
END
Import
Export
PROCEDURE
Write
VAR
R
Files
Rider
x
INTEGER
BEGIN
Files
WriteByte
R
x
END
Write
PROCEDURE
OutType
VAR
R
Files
Rider
t
Type
VAR
obj
mod
fld
Object
PROCEDURE
OutPar
VAR
R
Files
Rider
par
Object
n
INTEGER
VAR
cl
INTEGER
BEGIN
IF
n
THEN
OutPar
R
par
next
n
cl
par
class
Write
R
cl
IF
par
rdo
THEN
Write
R
ELSE
Write
R
END
OutType
R
par
type
END
END
OutPar
PROCEDURE
FindHiddenPointers
VAR
R
Files
Rider
typ
Type
offset
LONGINT
VAR
fld
Object
i
n
LONGINT
BEGIN
IF
typ
form
Pointer
OR
typ
form
NilTyp
THEN
Write
R
Fld
Write
R
Files
WriteNum
R
offset
ELSIF
typ
form
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindHiddenPointers
R
fld
type
fld
val
offset
fld
fld
next
END
ELSIF
typ
form
Array
THEN
i
n
typ
len
WHILE
i
n
DO
FindHiddenPointers
R
typ
base
typ
base
size
i
offset
INC
i
END
END
END
FindHiddenPointers
BEGIN
IF
t
ref
THEN
type
was
already
output
Write
R
t
ref
ELSE
obj
t
typobj
IF
obj
NIL
THEN
Write
R
Ref
t
ref
Ref
INC
Ref
ELSE
anonymous
Write
R
END
Write
R
t
form
IF
t
form
Pointer
THEN
OutType
R
t
base
ELSIF
t
form
Array
THEN
OutType
R
t
base
Files
WriteNum
R
t
len
Files
WriteNum
R
t
size
ELSIF
t
form
Record
THEN
IF
t
base
NIL
THEN
OutType
R
t
base
ELSE
OutType
R
noType
END
IF
obj
NIL
THEN
Files
WriteNum
R
obj
exno
ELSE
Write
R
END
Files
WriteNum
R
t
nofpar
Files
WriteNum
R
t
size
fld
t
dsc
WHILE
fld
NIL
DO
fields
IF
fld
expo
THEN
Write
R
Fld
Files
WriteString
R
fld
name
OutType
R
fld
type
Files
WriteNum
R
fld
val
offset
ELSE
FindHiddenPointers
R
fld
type
fld
val
END
fld
fld
next
END
Write
R
ELSIF
t
form
Proc
THEN
OutType
R
t
base
OutPar
R
t
dsc
t
nofpar
Write
R
END
IF
t
mno
obj
NIL
THEN
re
export
output
name
mod
topScope
next
WHILE
mod
NIL
mod
lev
t
mno
DO
mod
mod
next
END
IF
mod
NIL
THEN
Files
WriteString
R
mod
Module
orgname
Files
WriteInt
R
mod
val
Files
WriteString
R
obj
name
ELSE
ORS
Mark
re
export
not
found
Write
R
END
ELSE
Write
R
END
END
END
OutType
PROCEDURE
Export
VAR
modid
ORS
Ident
VAR
newSF
BOOLEAN
VAR
key
LONGINT
VAR
x
sum
oldkey
LONGINT
obj
obj0
Object
filename
ORS
Ident
F
F1
Files
File
R
R1
Files
Rider
BEGIN
Ref
Record
MakeFileName
filename
modid
smb
F
Files
New
filename
Files
Set
R
F
Files
WriteInt
R
placeholder
Files
WriteInt
R
placeholder
for
key
to
be
inserted
at
the
end
Files
WriteString
R
modid
Write
R
versionkey
obj
topScope
next
WHILE
obj
NIL
DO
IF
obj
expo
THEN
Write
R
obj
class
Files
WriteString
R
obj
name
OutType
R
obj
type
IF
obj
class
Typ
THEN
IF
obj
type
form
Record
THEN
obj0
topScope
next
check
whether
this
is
base
of
previously
declared
pointer
types
WHILE
obj0
obj
DO
IF
obj0
type
form
Pointer
obj0
type
base
obj
type
obj0
type
ref
THEN
Write
R
obj0
type
ref
END
obj0
obj0
next
END
END
Write
R
ELSIF
obj
class
Const
THEN
IF
obj
type
form
Proc
THEN
Files
WriteNum
R
obj
exno
ELSIF
obj
type
form
Real
THEN
Files
WriteInt
R
obj
val
ELSE
Files
WriteNum
R
obj
val
END
ELSIF
obj
class
Var
THEN
Files
WriteNum
R
obj
exno
END
END
obj
obj
next
END
REPEAT
Write
R
UNTIL
Files
Length
F
MOD
FOR
Ref
Record
TO
maxTypTab
DO
typtab
Ref
NIL
END
Files
Set
R
F
sum
Files
ReadInt
R
x
compute
key
checksum
WHILE
R
eof
DO
sum
sum
x
Files
ReadInt
R
x
END
F1
Files
Old
filename
sum
is
new
key
IF
F1
NIL
THEN
Files
Set
R1
F1
Files
ReadInt
R1
oldkey
ELSE
oldkey
sum
END
IF
sum
oldkey
THEN
IF
newSF
OR
F1
NIL
THEN
key
sum
newSF
TRUE
Files
Set
R
F
Files
WriteInt
R
sum
Files
Register
F
insert
checksum
ELSE
ORS
Mark
new
symbol
file
inhibited
END
ELSE
newSF
FALSE
key
sum
END
END
Export
PROCEDURE
Init
BEGIN
topScope
universe
nofmod
END
Init
PROCEDURE
type
ref
form
INTEGER
size
LONGINT
Type
VAR
tp
Type
BEGIN
NEW
tp
tp
form
form
tp
size
size
tp
ref
ref
tp
base
NIL
typtab
ref
tp
RETURN
tp
END
type
PROCEDURE
enter
name
ARRAY
OF
CHAR
cl
INTEGER
type
Type
n
LONGINT
VAR
obj
Object
BEGIN
NEW
obj
obj
name
name
obj
class
cl
obj
type
type
obj
val
n
obj
dsc
NIL
IF
cl
Typ
THEN
type
typobj
obj
END
obj
next
system
system
obj
END
enter
BEGIN
byteType
type
Byte
Int
boolType
type
Bool
Bool
charType
type
Char
Char
intType
type
Int
Int
realType
type
Real
Real
setType
type
Set
Set
nilType
type
NilTyp
NilTyp
noType
type
NoTyp
NoTyp
strType
type
String
String
initialize
universe
with
data
types
and
in
line
procedures
LONGINT
is
synonym
to
INTEGER
LONGREAL
to
REAL
LED
ADC
SBC
LDPSR
LDREG
REG
COND
are
not
in
language
definition
system
NIL
n
procno
nofpar
enter
UML
SFunc
intType
functions
enter
SBC
SFunc
intType
enter
ADC
SFunc
intType
enter
ROR
SFunc
intType
enter
ASR
SFunc
intType
enter
LSL
SFunc
intType
enter
LEN
SFunc
intType
enter
CHR
SFunc
charType
enter
ORD
SFunc
intType
enter
FLT
SFunc
realType
enter
FLOOR
SFunc
intType
enter
ODD
SFunc
boolType
enter
ABS
SFunc
intType
enter
LED
SProc
noType
procedures
enter
UNPK
SProc
noType
enter
PACK
SProc
noType
enter
NEW
SProc
noType
enter
ASSERT
SProc
noType
enter
EXCL
SProc
noType
enter
INCL
SProc
noType
enter
DEC
SProc
noType
enter
INC
SProc
noType
enter
SET
Typ
setType
types
enter
BOOLEAN
Typ
boolType
enter
BYTE
Typ
byteType
enter
CHAR
Typ
charType
enter
LONGREAL
Typ
realType
enter
REAL
Typ
realType
enter
LONGINT
Typ
intType
enter
INTEGER
Typ
intType
topScope
NIL
OpenScope
topScope
next
system
universe
topScope
system
NIL
initialize
unsafe
pseudo
module
SYSTEM
enter
H
SFunc
intType
functions
enter
COND
SFunc
boolType
enter
SIZE
SFunc
intType
enter
ADR
SFunc
intType
enter
VAL
SFunc
intType
enter
REG
SFunc
intType
enter
BIT
SFunc
boolType
enter
LDREG
SProc
noType
procedures
enter
LDPSR
SProc
noType
enter
COPY
SProc
noType
enter
PUT
SProc
noType
enter
GET
SProc
noType
END
ORB
MODULE
ORG
N
Wirth
Oberon
compiler
code
generator
for
RISC
IMPORT
SYSTEM
Files
ORS
ORB
Code
generator
for
Oberon
compiler
for
RISC
processor
Procedural
interface
to
Parser
OSAP
result
in
array
code
Procedure
Close
writes
code
files
CONST
WordSize
StkOrg0
VarOrg0
for
RISC
only
MT
SP
LNK
dedicated
registers
maxCode
maxStrx
maxTD
C24
1000000H
Reg
RegI
Cond
internal
item
modes
frequently
used
opcodes
U
2000H
V
1000H
Mov
Lsl
Asr
Ror
And
Ann
Ior
Xor
Add
Sub
Cmp
Mul
Div
Fad
Fsb
Fml
Fdv
Ldr
Str
BR
BLR
BC
BL
MI
PL
EQ
NE
LT
GE
LE
GT
TYPE
Item
RECORD
mode
INTEGER
type
ORB
Type
a
b
r
LONGINT
rdo
BOOLEAN
read
only
END
Item
forms
and
meaning
of
fields
mode
r
a
b
Const
value
proc
adr
immediate
value
Var
base
off
direct
adr
Par
off0
off1
indirect
adr
Reg
regno
RegI
regno
off
Cond
cond
Fchain
Tchain
VAR
pc
varsize
LONGINT
program
counter
data
index
tdx
strx
LONGINT
entry
LONGINT
main
entry
point
RH
LONGINT
available
registers
R
R
H
frame
LONGINT
frame
offset
changed
in
SaveRegs
and
RestoreRegs
fixorgP
fixorgD
fixorgT
LONGINT
origins
of
lists
of
locations
to
be
fixed
up
by
loader
check
BOOLEAN
emit
run
time
checks
version
INTEGER
RISC
RISC
relmap
ARRAY
OF
INTEGER
condition
codes
for
relations
code
ARRAY
maxCode
OF
LONGINT
data
ARRAY
maxTD
OF
LONGINT
type
descriptors
str
ARRAY
maxStrx
OF
CHAR
instruction
assemblers
according
to
formats
PROCEDURE
Put0
op
a
b
c
LONGINT
BEGIN
emit
format
instruction
code
pc
a
10H
b
10H
op
10000H
c
INC
pc
END
Put0
PROCEDURE
Put1
op
a
b
im
LONGINT
BEGIN
emit
format
instruction
10000H
im
10000H
IF
im
THEN
INC
op
V
END
code
pc
a
40H
10H
b
10H
op
10000H
im
MOD
10000H
INC
pc
END
Put1
PROCEDURE
Put1a
op
a
b
im
LONGINT
BEGIN
same
as
Put1
but
with
range
test
10000H
im
10000H
IF
im
10000H
im
0FFFFH
THEN
Put1
op
a
b
im
ELSE
Put1
Mov
U
RH
im
DIV
10000H
IF
im
MOD
10000H
THEN
Put1
Ior
RH
RH
im
MOD
10000H
END
Put0
op
a
b
RH
END
END
Put1a
PROCEDURE
Put2
op
a
b
off
LONGINT
BEGIN
emit
load
store
instruction
code
pc
op
10H
a
10H
b
100000H
off
MOD
100000H
INC
pc
END
Put2
PROCEDURE
Put3
op
cond
off
LONGINT
BEGIN
emit
branch
instruction
code
pc
op
10H
cond
1000000H
off
MOD
1000000H
INC
pc
END
Put3
PROCEDURE
incR
BEGIN
IF
RH
MT
THEN
INC
RH
ELSE
ORS
Mark
register
stack
overflow
END
END
incR
PROCEDURE
CheckRegs
BEGIN
IF
RH
THEN
ORS
Mark
Reg
Stack
RH
END
IF
pc
maxCode
THEN
ORS
Mark
program
too
long
END
IF
frame
THEN
ORS
Mark
frame
error
frame
END
END
CheckRegs
PROCEDURE
SetCC
VAR
x
Item
n
LONGINT
BEGIN
x
mode
Cond
x
a
x
b
x
r
n
END
SetCC
PROCEDURE
Trap
cond
num
LONGINT
BEGIN
Put3
BLR
cond
ORS
Pos
100H
num
10H
MT
END
Trap
handling
of
forward
reference
fixups
of
branch
addresses
and
constant
tables
PROCEDURE
negated
cond
LONGINT
LONGINT
BEGIN
IF
cond
THEN
cond
cond
ELSE
cond
cond
END
RETURN
cond
END
negated
PROCEDURE
fix
at
with
LONGINT
BEGIN
code
at
code
at
DIV
C24
C24
with
MOD
C24
END
fix
PROCEDURE
FixOne
at
LONGINT
BEGIN
fix
at
pc
at
END
FixOne
PROCEDURE
FixLink
L
LONGINT
VAR
L1
LONGINT
BEGIN
WHILE
L
DO
L1
code
L
MOD
40000H
fix
L
pc
L
L
L1
END
END
FixLink
PROCEDURE
FixLinkWith
L0
dst
LONGINT
VAR
L1
LONGINT
BEGIN
WHILE
L0
DO
L1
code
L0
MOD
C24
code
L0
code
L0
DIV
C24
C24
dst
L0
MOD
C24
L0
L1
END
END
FixLinkWith
PROCEDURE
merged
L0
L1
LONGINT
LONGINT
VAR
L2
L3
LONGINT
BEGIN
IF
L0
THEN
L3
L0
REPEAT
L2
L3
L3
code
L2
MOD
40000H
UNTIL
L3
code
L2
code
L2
L1
L1
L0
END
RETURN
L1
END
merged
loading
of
operands
and
addresses
into
registers
PROCEDURE
GetSB
base
LONGINT
BEGIN
IF
version
THEN
Put1
Mov
RH
VarOrg0
ELSE
Put2
Ldr
RH
base
pc
fixorgD
fixorgD
pc
END
END
GetSB
PROCEDURE
NilCheck
BEGIN
IF
check
THEN
Trap
EQ
END
END
NilCheck
PROCEDURE
load
VAR
x
Item
VAR
op
LONGINT
BEGIN
IF
x
type
size
THEN
op
Ldr
ELSE
op
Ldr
END
IF
x
mode
Reg
THEN
IF
x
mode
ORB
Const
THEN
IF
x
type
form
ORB
Proc
THEN
IF
x
r
THEN
ORS
Mark
not
allowed
ELSIF
x
r
THEN
Put3
BL
Put1a
Sub
RH
LNK
pc
x
a
ELSE
GetSB
x
r
Put1
Add
RH
RH
x
a
100H
mark
as
progbase
relative
END
ELSIF
x
a
0FFFFH
x
a
10000H
THEN
Put1
Mov
RH
x
a
ELSE
Put1
Mov
U
RH
x
a
DIV
10000H
MOD
10000H
IF
x
a
MOD
10000H
THEN
Put1
Ior
RH
RH
x
a
MOD
10000H
END
END
x
r
RH
incR
ELSIF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
op
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put2
op
RH
RH
x
a
END
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
op
RH
RH
x
b
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
Put2
op
x
r
x
r
x
a
ELSIF
x
mode
Cond
THEN
Put3
BC
negated
x
r
FixLink
x
b
Put1
Mov
RH
Put3
BC
FixLink
x
a
Put1
Mov
RH
x
r
RH
incR
END
x
mode
Reg
END
END
load
PROCEDURE
loadAdr
VAR
x
Item
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put1a
Add
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put1a
Add
RH
RH
x
a
END
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
IF
x
b
THEN
Put1a
Add
RH
RH
x
b
END
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
IF
x
a
THEN
Put1a
Add
x
r
x
r
x
a
END
ELSE
ORS
Mark
address
error
END
x
mode
Reg
END
loadAdr
PROCEDURE
loadCond
VAR
x
Item
BEGIN
IF
x
type
form
ORB
Bool
THEN
IF
x
mode
ORB
Const
THEN
x
r
x
a
ELSE
load
x
IF
code
pc
DIV
40000000H
THEN
Put1
Cmp
x
r
x
r
END
x
r
NE
DEC
RH
END
x
mode
Cond
x
a
x
b
ELSE
ORS
Mark
not
Boolean
END
END
loadCond
PROCEDURE
loadTypTagAdr
T
ORB
Type
VAR
x
Item
BEGIN
x
mode
ORB
Var
x
a
T
len
x
r
T
mno
loadAdr
x
END
loadTypTagAdr
PROCEDURE
loadStringAdr
VAR
x
Item
BEGIN
GetSB
Put1a
Add
RH
RH
varsize
x
a
x
mode
Reg
x
r
RH
incR
END
loadStringAdr
Items
Conversion
from
constants
or
from
Objects
on
the
Heap
to
Items
on
the
Stack
PROCEDURE
MakeConstItem
VAR
x
Item
typ
ORB
Type
val
LONGINT
BEGIN
x
mode
ORB
Const
x
type
typ
x
a
val
END
MakeConstItem
PROCEDURE
MakeRealItem
VAR
x
Item
val
REAL
BEGIN
x
mode
ORB
Const
x
type
ORB
realType
x
a
SYSTEM
VAL
LONGINT
val
END
MakeRealItem
PROCEDURE
MakeStringItem
VAR
x
Item
len
LONGINT
copies
string
from
ORS
buffer
to
ORG
string
array
VAR
i
LONGINT
BEGIN
x
mode
ORB
Const
x
type
ORB
strType
x
a
strx
x
b
len
i
IF
strx
len
maxStrx
THEN
WHILE
len
DO
str
strx
ORS
str
i
INC
strx
INC
i
DEC
len
END
WHILE
strx
MOD
DO
str
strx
0X
INC
strx
END
ELSE
ORS
Mark
too
many
strings
END
END
MakeStringItem
PROCEDURE
MakeItem
VAR
x
Item
y
ORB
Object
curlev
LONGINT
BEGIN
x
mode
y
class
x
type
y
type
x
a
y
val
x
rdo
y
rdo
IF
y
class
ORB
Par
THEN
x
b
ELSIF
y
class
ORB
Const
y
type
form
ORB
String
THEN
x
b
y
lev
len
ELSE
x
r
y
lev
END
IF
y
lev
y
lev
curlev
y
class
ORB
Const
THEN
ORS
Mark
not
accessible
END
END
MakeItem
Code
generation
for
Selectors
Variables
Constants
PROCEDURE
Field
VAR
x
Item
y
ORB
Object
x
x
y
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
x
a
x
a
y
val
ELSE
loadAdr
x
x
mode
RegI
x
a
y
val
END
ELSIF
x
mode
RegI
THEN
x
a
x
a
y
val
ELSIF
x
mode
ORB
Par
THEN
x
b
x
b
y
val
END
END
Field
PROCEDURE
Index
VAR
x
y
Item
x
x
y
VAR
s
lim
LONGINT
BEGIN
s
x
type
base
size
lim
x
type
len
IF
y
mode
ORB
Const
lim
THEN
IF
y
a
OR
y
a
lim
THEN
ORS
Mark
bad
index
END
IF
x
mode
IN
ORB
Var
RegI
THEN
x
a
y
a
s
x
a
ELSIF
x
mode
ORB
Par
THEN
x
b
y
a
s
x
b
END
ELSE
load
y
IF
check
THEN
check
array
bounds
IF
lim
THEN
Put1a
Cmp
RH
y
r
lim
ELSE
open
array
IF
x
mode
IN
ORB
Var
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put0
Cmp
RH
y
r
RH
ELSE
ORS
Mark
error
in
Index
END
END
Trap
BCC
END
IF
s
THEN
Put1
Lsl
y
r
y
r
ELSIF
s
THEN
Put1a
Mul
y
r
y
r
s
END
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
Put0
Add
y
r
SP
y
r
INC
x
a
frame
ELSE
GetSB
x
r
IF
x
r
THEN
Put0
Add
y
r
RH
y
r
ELSE
Put1a
Add
RH
RH
x
a
Put0
Add
y
r
RH
y
r
x
a
END
END
x
r
y
r
x
mode
RegI
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put0
Add
y
r
RH
y
r
x
mode
RegI
x
r
y
r
x
a
x
b
ELSIF
x
mode
RegI
THEN
Put0
Add
x
r
x
r
y
r
DEC
RH
END
END
END
Index
PROCEDURE
DeRef
VAR
x
Item
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
Ldr
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put2
Ldr
RH
RH
x
a
END
NilCheck
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
Ldr
RH
RH
x
b
NilCheck
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
Put2
Ldr
x
r
x
r
x
a
NilCheck
ELSIF
x
mode
Reg
THEN
ORS
Mark
bad
mode
in
DeRef
END
x
mode
RegI
x
a
x
b
END
DeRef
PROCEDURE
Q
T
ORB
Type
VAR
dcw
LONGINT
BEGIN
one
entry
of
type
descriptor
extension
table
IF
T
base
NIL
THEN
Q
T
base
dcw
data
dcw
T
mno
1000H
T
len
1000H
dcw
fixorgT
fixorgT
dcw
INC
dcw
END
END
Q
PROCEDURE
FindPtrFlds
typ
ORB
Type
off
LONGINT
VAR
dcw
LONGINT
VAR
fld
ORB
Object
i
s
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
data
dcw
off
INC
dcw
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindPtrFlds
fld
type
fld
val
off
dcw
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
s
typ
base
size
FOR
i
TO
typ
len
DO
FindPtrFlds
typ
base
i
s
off
dcw
END
END
END
FindPtrFlds
PROCEDURE
BuildTD
T
ORB
Type
VAR
dc
LONGINT
VAR
dcw
k
s
LONGINT
dcw
word
address
BEGIN
dcw
dc
DIV
s
T
size
convert
size
for
heap
allocation
IF
s
THEN
s
ELSIF
s
THEN
s
ELSIF
s
THEN
s
ELSE
s
s
DIV
END
T
len
dc
data
dcw
s
INC
dcw
len
used
as
address
k
T
nofpar
extension
level
IF
k
THEN
ORS
Mark
ext
level
too
large
ELSE
Q
T
dcw
WHILE
k
DO
data
dcw
INC
dcw
INC
k
END
END
FindPtrFlds
T
dcw
data
dcw
INC
dcw
tdx
dcw
dc
dcw
IF
tdx
maxTD
THEN
ORS
Mark
too
many
record
types
tdx
END
END
BuildTD
PROCEDURE
TypeTest
VAR
x
Item
T
ORB
Type
varpar
isguard
BOOLEAN
VAR
pc0
LONGINT
BEGIN
fetch
tag
into
RH
IF
varpar
THEN
Put2
Ldr
RH
SP
x
a
frame
ELSE
load
x
pc0
pc
Put3
BC
EQ
NIL
belongs
to
every
pointer
type
Put2
Ldr
RH
x
r
END
Put2
Ldr
RH
RH
T
nofpar
incR
loadTypTagAdr
T
tag
of
T
Put0
Cmp
RH
RH
RH
DEC
RH
IF
varpar
THEN
fix
pc0
pc
pc0
END
IF
isguard
THEN
IF
check
THEN
Trap
NE
END
ELSE
SetCC
x
EQ
IF
varpar
THEN
DEC
RH
END
END
END
TypeTest
Code
generation
for
Boolean
operators
PROCEDURE
Not
VAR
x
Item
x
x
VAR
t
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
x
r
negated
x
r
t
x
a
x
a
x
b
x
b
t
END
Not
PROCEDURE
And1
VAR
x
Item
x
x
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
x
a
x
a
pc
FixLink
x
b
x
b
END
And1
PROCEDURE
And2
VAR
x
y
Item
BEGIN
IF
y
mode
Cond
THEN
loadCond
y
END
x
a
merged
y
a
x
a
x
b
y
b
x
r
y
r
END
And2
PROCEDURE
Or1
VAR
x
Item
x
x
OR
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
x
r
x
b
x
b
pc
FixLink
x
a
x
a
END
Or1
PROCEDURE
Or2
VAR
x
y
Item
BEGIN
IF
y
mode
Cond
THEN
loadCond
y
END
x
a
y
a
x
b
merged
y
b
x
b
x
r
y
r
END
Or2
Code
generation
for
arithmetic
operators
PROCEDURE
Neg
VAR
x
Item
x
x
BEGIN
IF
x
type
form
ORB
Int
THEN
IF
x
mode
ORB
Const
THEN
x
a
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Sub
x
r
RH
x
r
END
ELSIF
x
type
form
ORB
Real
THEN
IF
x
mode
ORB
Const
THEN
x
a
x
a
7FFFFFFFH
ELSE
load
x
Put1
Mov
RH
Put0
Fsb
x
r
RH
x
r
END
ELSE
form
Set
IF
x
mode
ORB
Const
THEN
x
a
x
a
ELSE
load
x
Put1
Xor
x
r
x
r
END
END
END
Neg
PROCEDURE
AddOp
op
LONGINT
VAR
x
y
Item
x
x
y
BEGIN
IF
op
ORS
plus
THEN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
y
a
THEN
Put1a
Add
x
r
x
r
y
a
END
ELSE
load
x
load
y
Put0
Add
RH
x
r
y
r
DEC
RH
x
r
RH
END
ELSE
op
ORS
minus
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
y
a
THEN
Put1a
Sub
x
r
x
r
y
a
END
ELSE
load
x
load
y
Put0
Sub
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
END
AddOp
PROCEDURE
log2
m
LONGINT
VAR
e
LONGINT
LONGINT
BEGIN
e
WHILE
ODD
m
DO
m
m
DIV
INC
e
END
RETURN
m
END
log2
PROCEDURE
MulOp
VAR
x
y
Item
x
x
y
VAR
e
LONGINT
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
Put1
Lsl
x
r
x
r
e
ELSIF
y
mode
ORB
Const
THEN
load
x
Put1a
Mul
x
r
x
r
y
a
ELSIF
x
mode
ORB
Const
x
a
log2
x
a
e
THEN
load
y
Put1
Lsl
y
r
y
r
e
x
mode
Reg
x
r
y
r
ELSIF
x
mode
ORB
Const
THEN
load
y
Put1a
Mul
y
r
y
r
x
a
x
mode
Reg
x
r
y
r
ELSE
load
x
load
y
Put0
Mul
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
MulOp
PROCEDURE
DivOp
op
LONGINT
VAR
x
y
Item
x
x
op
y
VAR
e
LONGINT
BEGIN
IF
op
ORS
div
THEN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
y
a
THEN
x
a
x
a
DIV
y
a
ELSE
ORS
Mark
bad
divisor
END
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
Put1
Asr
x
r
x
r
e
ELSIF
y
mode
ORB
Const
THEN
IF
y
a
THEN
load
x
Put1a
Div
x
r
x
r
y
a
ELSE
ORS
Mark
bad
divisor
END
ELSE
load
y
IF
check
THEN
Trap
LE
END
load
x
Put0
Div
RH
x
r
y
r
DEC
RH
x
r
RH
END
ELSE
op
ORS
mod
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
y
a
THEN
x
a
x
a
MOD
y
a
ELSE
ORS
Mark
bad
modulus
END
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
IF
e
THEN
Put1
And
x
r
x
r
y
a
ELSE
Put1
Lsl
x
r
x
r
e
Put1
Ror
x
r
x
r
e
END
ELSIF
y
mode
ORB
Const
THEN
IF
y
a
THEN
load
x
Put1a
Div
x
r
x
r
y
a
Put0
Mov
U
x
r
ELSE
ORS
Mark
bad
modulus
END
ELSE
load
y
IF
check
THEN
Trap
LE
END
load
x
Put0
Div
RH
x
r
y
r
Put0
Mov
U
RH
DEC
RH
x
r
RH
END
END
END
DivOp
Code
generation
for
REAL
operators
PROCEDURE
RealOp
op
INTEGER
VAR
x
y
Item
x
x
op
y
BEGIN
load
x
load
y
IF
op
ORS
plus
THEN
Put0
Fad
RH
x
r
y
r
ELSIF
op
ORS
minus
THEN
Put0
Fsb
RH
x
r
y
r
ELSIF
op
ORS
times
THEN
Put0
Fml
RH
x
r
y
r
ELSIF
op
ORS
rdiv
THEN
Put0
Fdv
RH
x
r
y
r
END
DEC
RH
x
r
RH
END
RealOp
Code
generation
for
set
operators
PROCEDURE
Singleton
VAR
x
Item
x
x
BEGIN
IF
x
mode
ORB
Const
THEN
x
a
LSL
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Lsl
x
r
RH
x
r
END
END
Singleton
PROCEDURE
Set
VAR
x
y
Item
x
x
y
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
x
a
y
a
THEN
x
a
LSL
y
a
LSL
x
a
ELSE
x
a
END
ELSE
IF
x
mode
ORB
Const
x
a
THEN
x
a
LSL
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Lsl
x
r
RH
x
r
END
IF
y
mode
ORB
Const
y
a
THEN
Put1
Mov
RH
LSL
y
a
y
mode
Reg
y
r
RH
incR
ELSE
load
y
Put1
Mov
RH
Put0
Lsl
y
r
RH
y
r
END
IF
x
mode
ORB
Const
THEN
IF
x
a
THEN
Put1
Xor
y
r
y
r
Put1a
And
RH
y
r
x
a
END
x
mode
Reg
x
r
RH
ELSE
DEC
RH
Put0
Ann
RH
x
r
y
r
END
END
END
Set
PROCEDURE
In
VAR
x
y
Item
x
x
IN
y
BEGIN
load
y
IF
x
mode
ORB
Const
THEN
Put1
Ror
y
r
y
r
x
a
MOD
20H
DEC
RH
ELSE
load
x
Put1
Add
x
r
x
r
Put0
Ror
y
r
y
r
x
r
DEC
RH
END
SetCC
x
MI
END
In
PROCEDURE
SetOp
op
LONGINT
VAR
x
y
Item
x
x
op
y
VAR
xset
yset
SET
x
type
form
Set
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
xset
SYSTEM
VAL
SET
x
a
yset
SYSTEM
VAL
SET
y
a
IF
op
ORS
plus
THEN
xset
xset
yset
ELSIF
op
ORS
minus
THEN
xset
xset
yset
ELSIF
op
ORS
times
THEN
xset
xset
yset
ELSIF
op
ORS
rdiv
THEN
xset
xset
yset
END
x
a
SYSTEM
VAL
LONGINT
xset
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
op
ORS
plus
THEN
Put1a
Ior
x
r
x
r
y
a
ELSIF
op
ORS
minus
THEN
Put1a
Ann
x
r
x
r
y
a
ELSIF
op
ORS
times
THEN
Put1a
And
x
r
x
r
y
a
ELSIF
op
ORS
rdiv
THEN
Put1a
Xor
x
r
x
r
y
a
END
ELSE
load
x
load
y
IF
op
ORS
plus
THEN
Put0
Ior
RH
x
r
y
r
ELSIF
op
ORS
minus
THEN
Put0
Ann
RH
x
r
y
r
ELSIF
op
ORS
times
THEN
Put0
And
RH
x
r
y
r
ELSIF
op
ORS
rdiv
THEN
Put0
Xor
RH
x
r
y
r
END
DEC
RH
x
r
RH
END
END
SetOp
Code
generation
for
relations
PROCEDURE
IntRelation
op
INTEGER
VAR
x
y
Item
x
x
y
BEGIN
IF
y
mode
ORB
Const
y
type
form
ORB
Proc
THEN
load
x
IF
y
a
OR
op
IN
ORS
eql
ORS
neq
OR
code
pc
DIV
40000000H
THEN
Put1a
Cmp
x
r
x
r
y
a
END
DEC
RH
ELSE
IF
x
mode
Cond
OR
y
mode
Cond
THEN
ORS
Mark
not
implemented
END
load
x
load
y
Put0
Cmp
x
r
x
r
y
r
DEC
RH
END
SetCC
x
relmap
op
ORS
eql
END
IntRelation
PROCEDURE
RealRelation
op
INTEGER
VAR
x
y
Item
x
x
y
BEGIN
load
x
IF
y
mode
ORB
Const
y
a
THEN
DEC
RH
ELSE
load
y
Put0
Fsb
x
r
x
r
y
r
DEC
RH
END
SetCC
x
relmap
op
ORS
eql
END
RealRelation
PROCEDURE
StringRelation
op
INTEGER
VAR
x
y
Item
x
x
y
x
y
are
char
arrays
or
strings
BEGIN
IF
x
type
form
ORB
String
THEN
loadStringAdr
x
ELSE
loadAdr
x
END
IF
y
type
form
ORB
String
THEN
loadStringAdr
y
ELSE
loadAdr
y
END
Put2
Ldr
RH
x
r
Put1
Add
x
r
x
r
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put0
Cmp
RH
RH
RH
Put3
BC
NE
Put1
Cmp
RH
RH
Put3
BC
NE
DEC
RH
SetCC
x
relmap
op
ORS
eql
END
StringRelation
Code
generation
of
Assignments
PROCEDURE
StrToChar
VAR
x
Item
BEGIN
x
type
ORB
charType
DEC
strx
x
a
ORD
str
x
a
END
StrToChar
PROCEDURE
Store
VAR
x
y
Item
x
y
VAR
op
LONGINT
BEGIN
load
y
IF
x
type
size
THEN
op
Str
ELSE
op
Str
END
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
op
y
r
SP
x
a
frame
ELSE
GetSB
x
r
Put2
op
y
r
RH
x
a
END
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
op
y
r
RH
x
b
ELSIF
x
mode
RegI
THEN
Put2
op
y
r
x
r
x
a
DEC
RH
ELSE
ORS
Mark
bad
mode
in
Store
END
DEC
RH
END
Store
PROCEDURE
StoreStruct
VAR
x
y
Item
x
y
frame
VAR
s
pc0
LONGINT
BEGIN
IF
y
type
size
THEN
loadAdr
x
loadAdr
y
IF
x
type
form
ORB
Array
x
type
len
THEN
IF
y
type
len
THEN
IF
x
type
size
y
type
size
THEN
Put1a
Mov
RH
y
type
size
DIV
ELSE
ORS
Mark
different
length
size
not
implemented
END
ELSE
y
open
array
Put2
Ldr
RH
SP
y
a
s
y
type
base
size
element
size
pc0
pc
Put3
BC
EQ
IF
s
THEN
Put1
Add
RH
RH
Put1
Asr
RH
RH
ELSIF
s
THEN
Put1a
Mul
RH
RH
s
DIV
END
IF
check
THEN
Put1a
Mov
RH
x
type
size
DIV
Put0
Cmp
RH
RH
RH
Trap
GT
END
fix
pc0
pc
pc0
END
ELSIF
x
type
form
ORB
Record
THEN
Put1a
Mov
RH
x
type
size
DIV
ELSE
ORS
Mark
inadmissible
assignment
END
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put2
Str
RH
x
r
Put1
Add
x
r
x
r
Put1
Sub
RH
RH
Put3
BC
NE
END
RH
END
StoreStruct
PROCEDURE
CopyString
VAR
x
y
Item
x
y
VAR
len
LONGINT
BEGIN
loadAdr
x
len
x
type
len
IF
len
THEN
IF
len
y
b
THEN
ORS
Mark
string
too
long
END
ELSIF
check
THEN
Put2
Ldr
RH
SP
x
a
open
array
len
frame
Put1
Cmp
RH
RH
y
b
Trap
LT
END
loadStringAdr
y
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put2
Str
RH
x
r
Put1
Add
x
r
x
r
Put1
Asr
RH
RH
Put3
BC
NE
RH
END
CopyString
Code
generation
for
parameters
PROCEDURE
OpenArrayParam
VAR
x
Item
BEGIN
loadAdr
x
IF
x
type
len
THEN
Put1a
Mov
RH
x
type
len
ELSE
Put2
Ldr
RH
SP
x
a
frame
END
incR
END
OpenArrayParam
PROCEDURE
VarParam
VAR
x
Item
ftype
ORB
Type
VAR
xmd
INTEGER
BEGIN
xmd
x
mode
loadAdr
x
IF
ftype
form
ORB
Array
ftype
len
THEN
open
array
IF
x
type
len
THEN
Put1a
Mov
RH
x
type
len
ELSE
Put2
Ldr
RH
SP
x
a
frame
END
incR
ELSIF
ftype
form
ORB
Record
THEN
IF
xmd
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
incR
ELSE
loadTypTagAdr
x
type
END
END
END
VarParam
PROCEDURE
ValueParam
VAR
x
Item
BEGIN
load
x
END
ValueParam
PROCEDURE
StringParam
VAR
x
Item
BEGIN
loadStringAdr
x
Put1
Mov
RH
x
b
incR
len
END
StringParam
For
Statements
PROCEDURE
For0
VAR
x
y
Item
BEGIN
load
y
END
For0
PROCEDURE
For1
VAR
x
y
z
w
Item
VAR
L
LONGINT
BEGIN
IF
z
mode
ORB
Const
THEN
Put1a
Cmp
RH
y
r
z
a
ELSE
load
z
Put0
Cmp
RH
y
r
z
r
DEC
RH
END
L
pc
IF
w
a
THEN
Put3
BC
GT
ELSIF
w
a
THEN
Put3
BC
LT
ELSE
ORS
Mark
zero
increment
Put3
BC
MI
END
Store
x
y
END
For1
PROCEDURE
For2
VAR
x
y
w
Item
BEGIN
load
x
DEC
RH
Put1a
Add
x
r
x
r
w
a
END
For2
Branches
procedure
calls
procedure
prolog
and
epilog
PROCEDURE
Here
LONGINT
BEGIN
RETURN
pc
END
Here
PROCEDURE
FJump
VAR
L
LONGINT
BEGIN
Put3
BC
L
L
pc
END
FJump
PROCEDURE
CFJump
VAR
x
Item
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
x
a
FixLink
x
b
x
a
pc
END
CFJump
PROCEDURE
BJump
L
LONGINT
BEGIN
Put3
BC
L
pc
END
BJump
PROCEDURE
CBJump
VAR
x
Item
L
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
L
pc
FixLink
x
b
FixLinkWith
x
a
L
END
CBJump
PROCEDURE
Fixup
VAR
x
Item
BEGIN
FixLink
x
a
END
Fixup
PROCEDURE
SaveRegs
r
LONGINT
R
r
VAR
r0
LONGINT
BEGIN
r
r0
Put1
Sub
SP
SP
r
INC
frame
r
REPEAT
Put2
Str
r0
SP
r
r0
INC
r0
UNTIL
r0
r
END
SaveRegs
PROCEDURE
RestoreRegs
r
LONGINT
R
r
VAR
r0
LONGINT
BEGIN
r
r0
r
REPEAT
DEC
r0
Put2
Ldr
r0
SP
r
r0
UNTIL
r0
Put1
Add
SP
SP
r
DEC
frame
r
END
RestoreRegs
PROCEDURE
PrepCall
VAR
x
Item
VAR
r
LONGINT
BEGIN
x
type
form
ORB
Proc
IF
x
mode
ORB
Par
THEN
load
x
END
r
RH
IF
RH
THEN
SaveRegs
RH
RH
END
END
PrepCall
PROCEDURE
Call
VAR
x
Item
r
LONGINT
BEGIN
x
type
form
ORB
Proc
IF
x
mode
ORB
Const
THEN
IF
x
r
THEN
Put3
BL
x
a
DIV
pc
ELSE
imported
IF
pc
fixorgP
1000H
THEN
Put3
BL
x
r
100H
x
a
1000H
pc
fixorgP
fixorgP
pc
ELSE
ORS
Mark
fixup
impossible
END
END
ELSE
IF
x
mode
ORB
Par
THEN
load
x
DEC
RH
ELSE
Put2
Ldr
RH
SP
Put1
Add
SP
SP
DEC
r
DEC
frame
END
IF
check
THEN
Trap
EQ
END
Put3
BLR
RH
END
IF
x
type
base
form
ORB
NoTyp
THEN
procedure
RH
ELSE
function
IF
r
THEN
Put0
Mov
r
RestoreRegs
r
END
x
mode
Reg
x
r
r
RH
r
END
END
Call
PROCEDURE
Enter
parblksize
locblksize
LONGINT
int
BOOLEAN
VAR
a
r
LONGINT
BEGIN
frame
IF
int
THEN
procedure
prolog
IF
locblksize
10000H
THEN
ORS
Mark
too
many
locals
END
a
r
Put1
Sub
SP
SP
locblksize
Put2
Str
LNK
SP
WHILE
a
parblksize
DO
Put2
Str
r
SP
a
INC
r
INC
a
END
ELSE
interrupt
procedure
Put1
Sub
SP
SP
locblksize
Put2
Str
SP
Put2
Str
SP
Put2
Str
SP
R0
R1
R2
saved
on
stack
END
END
Enter
PROCEDURE
Return
form
INTEGER
VAR
x
Item
size
LONGINT
int
BOOLEAN
BEGIN
IF
form
ORB
NoTyp
THEN
load
x
END
IF
int
THEN
procedure
epilog
Put2
Ldr
LNK
SP
Put1
Add
SP
SP
size
Put3
BR
LNK
ELSE
interrupt
return
restore
R2
R1
R0
Put2
Ldr
SP
Put2
Ldr
SP
Put2
Ldr
SP
Put1
Add
SP
SP
size
Put3
BR
10H
RTI
END
RH
END
Return
In
line
code
procedures
PROCEDURE
Increment
upordown
LONGINT
VAR
x
y
Item
VAR
op
zr
v
LONGINT
BEGIN
frame
IF
upordown
THEN
op
Add
ELSE
op
Sub
END
IF
x
type
ORB
byteType
THEN
v
ELSE
v
END
IF
y
type
form
ORB
NoTyp
THEN
y
mode
ORB
Const
y
a
END
IF
x
mode
ORB
Var
x
r
THEN
zr
RH
Put2
Ldr
v
zr
SP
x
a
incR
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
y
a
ELSE
load
y
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
v
zr
SP
x
a
DEC
RH
ELSE
loadAdr
x
zr
RH
Put2
Ldr
v
RH
x
r
incR
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
y
a
ELSE
load
y
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
v
zr
x
r
DEC
RH
END
END
Increment
PROCEDURE
Include
inorex
LONGINT
VAR
x
y
Item
VAR
op
zr
LONGINT
BEGIN
loadAdr
x
zr
RH
Put2
Ldr
RH
x
r
incR
IF
inorex
THEN
op
Ior
ELSE
op
Ann
END
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
LSL
y
a
ELSE
load
y
Put1
Mov
RH
Put0
Lsl
y
r
RH
y
r
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
zr
x
r
DEC
RH
END
Include
PROCEDURE
Assert
VAR
x
Item
VAR
cond
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
IF
x
a
THEN
cond
negated
x
r
ELSE
Put3
BC
x
r
x
b
FixLink
x
a
x
b
pc
cond
END
Trap
cond
FixLink
x
b
END
Assert
PROCEDURE
New
VAR
x
Item
BEGIN
loadAdr
x
loadTypTagAdr
x
type
base
Trap
RH
END
New
PROCEDURE
Pack
VAR
x
y
Item
VAR
z
Item
BEGIN
z
x
load
x
load
y
Put1
Lsl
y
r
y
r
Put0
Add
x
r
x
r
y
r
DEC
RH
Store
z
x
END
Pack
PROCEDURE
Unpk
VAR
x
y
Item
VAR
z
e0
Item
BEGIN
z
x
load
x
e0
mode
Reg
e0
r
RH
e0
type
ORB
intType
Put1
Asr
RH
x
r
Put1
Sub
RH
RH
Store
y
e0
incR
Put1
Lsl
RH
RH
Put0
Sub
x
r
x
r
RH
Store
z
x
END
Unpk
PROCEDURE
Led
VAR
x
Item
BEGIN
load
x
Put1
Mov
RH
Put2
Str
x
r
RH
DEC
RH
END
Led
PROCEDURE
Get
VAR
x
y
Item
BEGIN
load
x
x
type
y
type
x
mode
RegI
x
a
Store
y
x
END
Get
PROCEDURE
Put
VAR
x
y
Item
BEGIN
load
x
x
type
y
type
x
mode
RegI
x
a
Store
x
y
END
Put
PROCEDURE
Copy
VAR
x
y
z
Item
BEGIN
load
x
load
y
IF
z
mode
ORB
Const
THEN
IF
z
a
THEN
load
z
ELSE
ORS
Mark
bad
count
END
ELSE
load
z
IF
check
THEN
Trap
LT
END
Put3
BC
EQ
END
Put2
Ldr
RH
x
r
Put1
Add
x
r
x
r
Put2
Str
RH
y
r
Put1
Add
y
r
y
r
Put1
Sub
z
r
z
r
Put3
BC
NE
DEC
RH
END
Copy
PROCEDURE
LDPSR
VAR
x
Item
BEGIN
x
mode
Const
Put3
x
a
20H
END
LDPSR
PROCEDURE
LDREG
VAR
x
y
Item
BEGIN
IF
y
mode
ORB
Const
THEN
Put1a
Mov
x
a
y
a
ELSE
load
y
Put0
Mov
x
a
y
r
DEC
RH
END
END
LDREG
In
line
code
functions
PROCEDURE
Abs
VAR
x
Item
BEGIN
IF
x
mode
ORB
Const
THEN
x
a
ABS
x
a
ELSE
load
x
IF
x
type
form
ORB
Real
THEN
Put1
Lsl
x
r
x
r
Put1
Ror
x
r
x
r
ELSE
Put1
Cmp
x
r
x
r
Put3
BC
GE
Put1
Mov
RH
Put0
Sub
x
r
RH
x
r
END
END
END
Abs
PROCEDURE
Odd
VAR
x
Item
BEGIN
load
x
Put1
And
x
r
x
r
SetCC
x
NE
DEC
RH
END
Odd
PROCEDURE
Floor
VAR
x
Item
BEGIN
load
x
Put1
Mov
U
RH
4B00H
Put0
Fad
V
x
r
x
r
RH
END
Floor
PROCEDURE
Float
VAR
x
Item
BEGIN
load
x
Put1
Mov
U
RH
4B00H
Put0
Fad
U
x
r
x
r
RH
END
Float
PROCEDURE
Ord
VAR
x
Item
BEGIN
IF
x
mode
IN
ORB
Var
ORB
Par
RegI
Cond
THEN
load
x
END
END
Ord
PROCEDURE
Len
VAR
x
Item
BEGIN
IF
x
type
len
THEN
IF
x
mode
RegI
THEN
DEC
RH
END
x
mode
ORB
Const
x
a
x
type
len
ELSE
open
array
Put2
Ldr
RH
SP
x
a
frame
x
mode
Reg
x
r
RH
incR
END
END
Len
PROCEDURE
Shift
fct
LONGINT
VAR
x
y
Item
VAR
op
LONGINT
BEGIN
load
x
IF
fct
THEN
op
Lsl
ELSIF
fct
THEN
op
Asr
ELSE
op
Ror
END
IF
y
mode
ORB
Const
THEN
Put1
op
x
r
x
r
y
a
MOD
20H
ELSE
load
y
Put0
op
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
Shift
PROCEDURE
ADC
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Add
2000H
x
r
x
r
y
r
DEC
RH
END
ADC
PROCEDURE
SBC
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Sub
2000H
x
r
x
r
y
r
DEC
RH
END
SBC
PROCEDURE
UML
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Mul
2000H
x
r
x
r
y
r
DEC
RH
END
UML
PROCEDURE
Bit
VAR
x
y
Item
BEGIN
load
x
Put2
Ldr
x
r
x
r
IF
y
mode
ORB
Const
THEN
Put1
Ror
x
r
x
r
y
a
DEC
RH
ELSE
load
y
Put1
Add
y
r
y
r
Put0
Ror
x
r
x
r
y
r
DEC
RH
END
SetCC
x
MI
END
Bit
PROCEDURE
Register
VAR
x
Item
BEGIN
x
mode
Const
Put0
Mov
RH
x
a
MOD
10H
x
mode
Reg
x
r
RH
incR
END
Register
PROCEDURE
H
VAR
x
Item
BEGIN
x
mode
Const
Put0
Mov
U
x
a
MOD
V
RH
x
mode
Reg
x
r
RH
incR
END
H
PROCEDURE
Adr
VAR
x
Item
BEGIN
IF
x
mode
IN
ORB
Var
ORB
Par
RegI
THEN
loadAdr
x
ELSIF
x
mode
ORB
Const
x
type
form
ORB
Proc
THEN
load
x
ELSIF
x
mode
ORB
Const
x
type
form
ORB
String
THEN
loadStringAdr
x
ELSE
ORS
Mark
not
addressable
END
END
Adr
PROCEDURE
Condition
VAR
x
Item
BEGIN
x
mode
Const
SetCC
x
x
a
END
Condition
PROCEDURE
Open
v
INTEGER
BEGIN
pc
tdx
strx
RH
fixorgP
fixorgD
fixorgT
check
v
version
v
IF
v
THEN
pc
REPEAT
code
pc
INC
pc
UNTIL
pc
END
END
Open
PROCEDURE
SetDataSize
dc
LONGINT
BEGIN
varsize
dc
END
SetDataSize
PROCEDURE
Header
BEGIN
entry
pc
IF
version
THEN
code
0E7000000H
pc
Put1a
Mov
SP
StkOrg0
RISC
ELSE
Put1
Sub
SP
SP
Put2
Str
LNK
SP
END
END
Header
PROCEDURE
NofPtrs
typ
ORB
Type
LONGINT
VAR
fld
ORB
Object
n
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
n
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
n
WHILE
fld
NIL
DO
n
NofPtrs
fld
type
n
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
n
NofPtrs
typ
base
typ
len
ELSE
n
END
RETURN
n
END
NofPtrs
PROCEDURE
FindPtrs
VAR
R
Files
Rider
typ
ORB
Type
adr
LONGINT
VAR
fld
ORB
Object
i
s
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
Files
WriteInt
R
adr
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindPtrs
R
fld
type
fld
val
adr
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
s
typ
base
size
FOR
i
TO
typ
len
DO
FindPtrs
R
typ
base
i
s
adr
END
END
END
FindPtrs
PROCEDURE
Close
VAR
modid
ORS
Ident
key
nofent
LONGINT
VAR
obj
ORB
Object
i
comsize
nofimps
nofptrs
size
LONGINT
name
ORS
Ident
F
Files
File
R
Files
Rider
BEGIN
exit
code
IF
version
THEN
Put1
Mov
Put3
BR
RISC
ELSE
Put2
Ldr
LNK
SP
Put1
Add
SP
SP
Put3
BR
LNK
END
obj
ORB
topScope
next
nofimps
comsize
nofptrs
WHILE
obj
NIL
DO
IF
obj
class
ORB
Mod
obj
dsc
ORB
system
THEN
INC
nofimps
count
imports
ELSIF
obj
exno
obj
class
ORB
Const
obj
type
form
ORB
Proc
obj
type
nofpar
obj
type
base
ORB
noType
THEN
i
count
commands
WHILE
obj
name
i
0X
DO
INC
i
END
i
i
DIV
INC
comsize
i
ELSIF
obj
class
ORB
Var
THEN
INC
nofptrs
NofPtrs
obj
type
count
pointers
END
obj
obj
next
END
size
varsize
strx
comsize
pc
nofimps
nofent
nofptrs
varsize
includes
type
descriptors
ORB
MakeFileName
name
modid
rsc
write
code
file
F
Files
New
name
Files
Set
R
F
Files
WriteString
R
modid
Files
WriteInt
R
key
Files
Write
R
CHR
version
Files
WriteInt
R
size
obj
ORB
topScope
next
WHILE
obj
NIL
obj
class
ORB
Mod
DO
imports
IF
obj
dsc
ORB
system
THEN
Files
WriteString
R
obj
ORB
Module
orgname
Files
WriteInt
R
obj
val
END
obj
obj
next
END
Files
Write
R
0X
Files
WriteInt
R
tdx
i
WHILE
i
tdx
DO
Files
WriteInt
R
data
i
INC
i
END
type
descriptors
Files
WriteInt
R
varsize
tdx
data
Files
WriteInt
R
strx
FOR
i
TO
strx
DO
Files
Write
R
str
i
END
strings
Files
WriteInt
R
pc
code
len
FOR
i
TO
pc
DO
Files
WriteInt
R
code
i
END
program
obj
ORB
topScope
next
WHILE
obj
NIL
DO
commands
IF
obj
exno
obj
class
ORB
Const
obj
type
form
ORB
Proc
obj
type
nofpar
obj
type
base
ORB
noType
THEN
Files
WriteString
R
obj
name
Files
WriteInt
R
obj
val
END
obj
obj
next
END
Files
Write
R
0X
Files
WriteInt
R
nofent
Files
WriteInt
R
entry
obj
ORB
topScope
next
WHILE
obj
NIL
DO
entries
IF
obj
exno
THEN
IF
obj
class
ORB
Const
obj
type
form
ORB
Proc
OR
obj
class
ORB
Var
THEN
Files
WriteInt
R
obj
val
ELSIF
obj
class
ORB
Typ
THEN
IF
obj
type
form
ORB
Record
THEN
Files
WriteInt
R
obj
type
len
MOD
10000H
ELSIF
obj
type
form
ORB
Pointer
obj
type
base
typobj
NIL
OR
obj
type
base
typobj
exno
THEN
Files
WriteInt
R
obj
type
base
len
MOD
10000H
END
END
END
obj
obj
next
END
obj
ORB
topScope
next
WHILE
obj
NIL
DO
pointer
variables
IF
obj
class
ORB
Var
THEN
FindPtrs
R
obj
type
obj
val
END
obj
obj
next
END
Files
WriteInt
R
Files
WriteInt
R
fixorgP
Files
WriteInt
R
fixorgD
Files
WriteInt
R
fixorgT
Files
WriteInt
R
entry
Files
Write
R
O
Files
Register
F
END
Close
BEGIN
relmap
relmap
relmap
relmap
relmap
relmap
END
ORG
MODULE
ORP
N
Wirth
Oberon
compiler
for
RISC
in
Oberon
IMPORT
Texts
Oberon
ORS
ORB
ORG
Author
Niklaus
Wirth
Parser
of
Oberon
RISC
compiler
Uses
Scanner
ORS
to
obtain
symbols
tokens
ORB
for
definition
of
data
structures
and
for
handling
import
and
export
and
ORG
to
produce
binary
code
ORP
performs
type
checking
and
data
allocation
Parser
is
target
independent
except
for
part
of
the
handling
of
allocations
TYPE
PtrBase
POINTER
TO
PtrBaseDesc
PtrBaseDesc
RECORD
list
of
names
of
pointer
base
types
name
ORS
Ident
type
ORB
Type
next
PtrBase
END
VAR
sym
INTEGER
last
symbol
read
dc
LONGINT
data
counter
level
exno
version
INTEGER
newSF
BOOLEAN
option
flag
expression
PROCEDURE
VAR
x
ORG
Item
to
avoid
forward
reference
Type
PROCEDURE
VAR
type
ORB
Type
FormalType
PROCEDURE
VAR
typ
ORB
Type
dim
INTEGER
modid
ORS
Ident
pbsList
PtrBase
list
of
names
of
pointer
base
types
dummy
ORB
Object
W
Texts
Writer
PROCEDURE
Check
s
INTEGER
msg
ARRAY
OF
CHAR
BEGIN
IF
sym
s
THEN
ORS
Get
sym
ELSE
ORS
Mark
msg
END
END
Check
PROCEDURE
qualident
VAR
obj
ORB
Object
BEGIN
obj
ORB
thisObj
ORS
Get
sym
IF
obj
NIL
THEN
ORS
Mark
undef
obj
dummy
END
IF
sym
ORS
period
obj
class
ORB
Mod
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
obj
ORB
thisimport
obj
ORS
Get
sym
IF
obj
NIL
THEN
ORS
Mark
undef
obj
dummy
END
ELSE
ORS
Mark
identifier
expected
obj
dummy
END
END
END
qualident
PROCEDURE
CheckBool
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Bool
THEN
ORS
Mark
not
Boolean
x
type
ORB
boolType
END
END
CheckBool
PROCEDURE
CheckInt
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Int
THEN
ORS
Mark
not
Integer
x
type
ORB
intType
END
END
CheckInt
PROCEDURE
CheckReal
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Real
THEN
ORS
Mark
not
Real
x
type
ORB
realType
END
END
CheckReal
PROCEDURE
CheckSet
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Set
THEN
ORS
Mark
not
Set
x
type
ORB
setType
END
END
CheckSet
PROCEDURE
CheckSetVal
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Int
THEN
ORS
Mark
not
Int
x
type
ORB
setType
ELSIF
x
mode
ORB
Const
THEN
IF
x
a
OR
x
a
THEN
ORS
Mark
invalid
set
END
END
END
CheckSetVal
PROCEDURE
CheckConst
VAR
x
ORG
Item
BEGIN
IF
x
mode
ORB
Const
THEN
ORS
Mark
not
a
constant
x
mode
ORB
Const
END
END
CheckConst
PROCEDURE
CheckReadOnly
VAR
x
ORG
Item
BEGIN
IF
x
rdo
THEN
ORS
Mark
read
only
END
END
CheckReadOnly
PROCEDURE
CheckExport
VAR
expo
BOOLEAN
BEGIN
IF
sym
ORS
times
THEN
expo
TRUE
ORS
Get
sym
IF
level
THEN
ORS
Mark
remove
asterisk
END
ELSE
expo
FALSE
END
END
CheckExport
PROCEDURE
IsExtension
t0
t1
ORB
Type
BOOLEAN
BEGIN
t1
is
an
extension
of
t0
RETURN
t0
t1
OR
t1
NIL
IsExtension
t0
t1
base
END
IsExtension
expressions
PROCEDURE
TypeTest
VAR
x
ORG
Item
T
ORB
Type
guard
BOOLEAN
VAR
xt
ORB
Type
BEGIN
xt
x
type
IF
T
form
xt
form
T
form
ORB
Pointer
OR
T
form
ORB
Record
x
mode
ORB
Par
THEN
WHILE
xt
T
xt
NIL
DO
xt
xt
base
END
IF
xt
T
THEN
xt
x
type
IF
xt
form
ORB
Pointer
THEN
IF
IsExtension
xt
base
T
base
THEN
ORG
TypeTest
x
T
base
FALSE
guard
x
type
T
ELSE
ORS
Mark
not
an
extension
END
ELSIF
xt
form
ORB
Record
x
mode
ORB
Par
THEN
IF
IsExtension
xt
T
THEN
ORG
TypeTest
x
T
TRUE
guard
x
type
T
ELSE
ORS
Mark
not
an
extension
END
ELSE
ORS
Mark
incompatible
types
END
ELSIF
guard
THEN
ORG
MakeConstItem
x
ORB
boolType
END
ELSE
ORS
Mark
type
mismatch
END
IF
guard
THEN
x
type
ORB
boolType
END
END
TypeTest
PROCEDURE
selector
VAR
x
ORG
Item
VAR
y
ORG
Item
obj
ORB
Object
BEGIN
WHILE
sym
ORS
lbrak
OR
sym
ORS
period
OR
sym
ORS
arrow
OR
sym
ORS
lparen
x
type
form
IN
ORB
Record
ORB
Pointer
DO
IF
sym
ORS
lbrak
THEN
REPEAT
ORS
Get
sym
expression
y
IF
x
type
form
ORB
Array
THEN
CheckInt
y
ORG
Index
x
y
x
type
x
type
base
ELSE
ORS
Mark
not
an
array
END
UNTIL
sym
ORS
comma
Check
ORS
rbrak
no
ELSIF
sym
ORS
period
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
IF
x
type
form
ORB
Pointer
THEN
ORG
DeRef
x
x
type
x
type
base
END
IF
x
type
form
ORB
Record
THEN
obj
ORB
thisfield
x
type
ORS
Get
sym
IF
obj
NIL
THEN
ORG
Field
x
obj
x
type
obj
type
ELSE
ORS
Mark
undef
END
ELSE
ORS
Mark
not
a
record
END
ELSE
ORS
Mark
ident
END
ELSIF
sym
ORS
arrow
THEN
ORS
Get
sym
IF
x
type
form
ORB
Pointer
THEN
ORG
DeRef
x
x
type
x
type
base
ELSE
ORS
Mark
not
a
pointer
END
ELSIF
sym
ORS
lparen
x
type
form
IN
ORB
Record
ORB
Pointer
THEN
type
guard
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
TypeTest
x
obj
type
TRUE
ELSE
ORS
Mark
guard
type
expected
END
ELSE
ORS
Mark
not
an
identifier
END
Check
ORS
rparen
missing
END
END
END
selector
PROCEDURE
EqualSignatures
t0
t1
ORB
Type
BOOLEAN
VAR
p0
p1
ORB
Object
com
BOOLEAN
BEGIN
com
TRUE
IF
t0
base
t1
base
t0
nofpar
t1
nofpar
THEN
p0
t0
dsc
p1
t1
dsc
WHILE
p0
NIL
DO
IF
p0
class
p1
class
p0
rdo
p1
rdo
p0
type
p1
type
OR
p0
type
form
ORB
Array
p1
type
form
ORB
Array
p0
type
len
p1
type
len
p0
type
base
p1
type
base
OR
p0
type
form
ORB
Proc
p1
type
form
ORB
Proc
EqualSignatures
p0
type
p1
type
THEN
p0
p0
next
p1
p1
next
ELSE
p0
NIL
com
FALSE
END
END
ELSE
com
FALSE
END
RETURN
com
END
EqualSignatures
PROCEDURE
CompTypes
t0
t1
ORB
Type
varpar
BOOLEAN
BOOLEAN
BEGIN
check
for
assignment
compatibility
RETURN
t0
t1
openarray
assignment
disallowed
in
ORG
OR
t0
form
ORB
Array
t1
form
ORB
Array
t0
base
t1
base
t0
len
t1
len
OR
t0
form
ORB
Record
t1
form
ORB
Record
IsExtension
t0
t1
OR
varpar
t0
form
ORB
Pointer
t1
form
ORB
Pointer
IsExtension
t0
base
t1
base
OR
t0
form
ORB
Proc
t1
form
ORB
Proc
EqualSignatures
t0
t1
OR
t0
form
IN
ORB
Pointer
ORB
Proc
t1
form
ORB
NilTyp
END
CompTypes
PROCEDURE
Parameter
par
ORB
Object
VAR
x
ORG
Item
varpar
BOOLEAN
BEGIN
expression
x
IF
par
NIL
THEN
varpar
par
class
ORB
Par
IF
CompTypes
par
type
x
type
varpar
THEN
IF
varpar
THEN
ORG
ValueParam
x
ELSE
par
class
Par
IF
par
rdo
THEN
CheckReadOnly
x
END
ORG
VarParam
x
par
type
END
ELSIF
x
type
form
ORB
Array
par
type
form
ORB
Array
x
type
base
par
type
base
par
type
len
THEN
IF
par
rdo
THEN
CheckReadOnly
x
END
ORG
OpenArrayParam
x
ELSIF
x
type
form
ORB
String
varpar
par
rdo
par
type
form
ORB
Array
par
type
base
form
ORB
Char
par
type
len
THEN
ORG
StringParam
x
ELSIF
varpar
par
type
form
ORB
Int
x
type
form
ORB
Int
THEN
ORG
ValueParam
x
BYTE
ELSIF
x
type
form
ORB
String
x
b
par
class
ORB
Var
par
type
form
ORB
Char
THEN
ORG
StrToChar
x
ORG
ValueParam
x
ELSIF
par
type
form
ORB
Array
par
type
base
ORB
byteType
par
type
len
par
type
size
x
type
size
THEN
ORG
VarParam
x
par
type
ELSE
ORS
Mark
incompatible
parameters
END
END
END
Parameter
PROCEDURE
ParamList
VAR
x
ORG
Item
VAR
n
INTEGER
par
ORB
Object
BEGIN
par
x
type
dsc
n
IF
sym
ORS
rparen
THEN
Parameter
par
n
WHILE
sym
ORS
comma
DO
Check
sym
comma
IF
par
NIL
THEN
par
par
next
END
INC
n
Parameter
par
END
Check
ORS
rparen
missing
ELSE
ORS
Get
sym
END
IF
n
x
type
nofpar
THEN
ORS
Mark
too
few
params
ELSIF
n
x
type
nofpar
THEN
ORS
Mark
too
many
params
END
END
ParamList
PROCEDURE
StandFunc
VAR
x
ORG
Item
fct
LONGINT
restyp
ORB
Type
VAR
y
ORG
Item
n
npar
LONGINT
BEGIN
Check
ORS
lparen
no
npar
fct
MOD
fct
fct
DIV
expression
x
n
WHILE
sym
ORS
comma
DO
ORS
Get
sym
expression
y
INC
n
END
Check
ORS
rparen
no
IF
n
npar
THEN
IF
fct
THEN
ABS
IF
x
type
form
IN
ORB
Int
ORB
Real
THEN
ORG
Abs
x
restyp
x
type
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
ODD
CheckInt
x
ORG
Odd
x
ELSIF
fct
THEN
FLOOR
CheckReal
x
ORG
Floor
x
ELSIF
fct
THEN
FLT
CheckInt
x
ORG
Float
x
ELSIF
fct
THEN
ORD
IF
x
type
form
ORB
Proc
THEN
ORG
Ord
x
ELSIF
x
type
form
ORB
String
x
b
THEN
ORG
StrToChar
x
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
CHR
CheckInt
x
ORG
Ord
x
ELSIF
fct
THEN
LEN
IF
x
type
form
ORB
Array
THEN
ORG
Len
x
ELSE
ORS
Mark
not
an
array
END
ELSIF
fct
IN
THEN
LSL
ASR
ROR
CheckInt
y
IF
x
type
form
IN
ORB
Int
ORB
Set
THEN
ORG
Shift
fct
x
y
restyp
x
type
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
ADC
ORG
ADC
x
y
ELSIF
fct
THEN
SBC
ORG
SBC
x
y
ELSIF
fct
THEN
UML
ORG
UML
x
y
ELSIF
fct
THEN
BIT
CheckInt
x
CheckInt
y
ORG
Bit
x
y
ELSIF
fct
THEN
REG
CheckConst
x
CheckInt
x
ORG
Register
x
ELSIF
fct
THEN
VAL
IF
x
mode
ORB
Typ
x
type
size
y
type
size
THEN
restyp
x
type
x
y
ELSE
ORS
Mark
casting
not
allowed
END
ELSIF
fct
THEN
ADR
ORG
Adr
x
ELSIF
fct
THEN
SIZE
IF
x
mode
ORB
Typ
THEN
ORG
MakeConstItem
x
ORB
intType
x
type
size
ELSE
ORS
Mark
must
be
a
type
END
ELSIF
fct
THEN
COND
CheckConst
x
CheckInt
x
ORG
Condition
x
ELSIF
fct
THEN
H
CheckConst
x
CheckInt
x
ORG
H
x
END
x
type
restyp
ELSE
ORS
Mark
wrong
nof
params
END
END
StandFunc
PROCEDURE
element
VAR
x
ORG
Item
VAR
y
ORG
Item
BEGIN
expression
x
CheckSetVal
x
IF
sym
ORS
upto
THEN
ORS
Get
sym
expression
y
CheckSetVal
y
ORG
Set
x
y
ELSE
ORG
Singleton
x
END
x
type
ORB
setType
END
element
PROCEDURE
set
VAR
x
ORG
Item
VAR
y
ORG
Item
BEGIN
IF
sym
ORS
if
THEN
IF
sym
ORS
rbrace
THEN
ORS
Mark
missing
END
ORG
MakeConstItem
x
ORB
setType
empty
set
ELSE
element
x
WHILE
sym
ORS
rparen
OR
sym
ORS
rbrace
DO
IF
sym
ORS
comma
THEN
ORS
Get
sym
ELSIF
sym
ORS
rbrace
THEN
ORS
Mark
missing
comma
END
element
y
ORG
SetOp
ORS
plus
x
y
END
END
END
set
PROCEDURE
factor
VAR
x
ORG
Item
VAR
obj
ORB
Object
rx
LONGINT
BEGIN
sync
IF
sym
ORS
char
OR
sym
ORS
ident
THEN
ORS
Mark
expression
expected
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
char
sym
ORS
for
OR
sym
ORS
then
END
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
SFunc
THEN
StandFunc
x
obj
val
obj
type
ELSE
ORG
MakeItem
x
obj
level
selector
x
IF
sym
ORS
lparen
THEN
ORS
Get
sym
IF
x
type
form
ORB
Proc
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ParamList
x
ORG
Call
x
rx
x
type
x
type
base
ELSE
ORS
Mark
not
a
function
ParamList
x
END
END
END
ELSIF
sym
ORS
int
THEN
ORG
MakeConstItem
x
ORB
intType
ORS
ival
ORS
Get
sym
ELSIF
sym
ORS
real
THEN
ORG
MakeRealItem
x
ORS
rval
ORS
Get
sym
ELSIF
sym
ORS
char
THEN
ORG
MakeConstItem
x
ORB
charType
ORS
ival
ORS
Get
sym
ELSIF
sym
ORS
nil
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
nilType
ELSIF
sym
ORS
string
THEN
ORG
MakeStringItem
x
ORS
slen
ORS
Get
sym
ELSIF
sym
ORS
lparen
THEN
ORS
Get
sym
expression
x
Check
ORS
rparen
no
ELSIF
sym
ORS
lbrace
THEN
ORS
Get
sym
set
x
Check
ORS
rbrace
no
ELSIF
sym
ORS
not
THEN
ORS
Get
sym
factor
x
CheckBool
x
ORG
Not
x
ELSIF
sym
ORS
false
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
boolType
ELSIF
sym
ORS
true
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
boolType
ELSE
ORS
Mark
not
a
factor
ORG
MakeConstItem
x
ORB
intType
END
END
factor
PROCEDURE
term
VAR
x
ORG
Item
VAR
y
ORG
Item
op
f
INTEGER
BEGIN
factor
x
f
x
type
form
WHILE
sym
ORS
times
sym
ORS
and
DO
op
sym
ORS
Get
sym
IF
op
ORS
times
THEN
IF
f
ORB
Int
THEN
factor
y
CheckInt
y
ORG
MulOp
x
y
ELSIF
f
ORB
Real
THEN
factor
y
CheckReal
y
ORG
RealOp
op
x
y
ELSIF
f
ORB
Set
THEN
factor
y
CheckSet
y
ORG
SetOp
op
x
y
ELSE
ORS
Mark
bad
type
END
ELSIF
op
ORS
div
OR
op
ORS
mod
THEN
CheckInt
x
factor
y
CheckInt
y
ORG
DivOp
op
x
y
ELSIF
op
ORS
rdiv
THEN
IF
f
ORB
Real
THEN
factor
y
CheckReal
y
ORG
RealOp
op
x
y
ELSIF
f
ORB
Set
THEN
factor
y
CheckSet
y
ORG
SetOp
op
x
y
ELSE
ORS
Mark
bad
type
END
ELSE
op
and
CheckBool
x
ORG
And1
x
factor
y
CheckBool
y
ORG
And2
x
y
END
END
END
term
PROCEDURE
SimpleExpression
VAR
x
ORG
Item
VAR
y
ORG
Item
op
INTEGER
BEGIN
IF
sym
ORS
minus
THEN
ORS
Get
sym
term
x
IF
x
type
form
IN
ORB
Int
ORB
Real
ORB
Set
THEN
ORG
Neg
x
ELSE
CheckInt
x
END
ELSIF
sym
ORS
plus
THEN
ORS
Get
sym
term
x
ELSE
term
x
END
WHILE
sym
ORS
plus
sym
ORS
or
DO
op
sym
ORS
Get
sym
IF
op
ORS
or
THEN
ORG
Or1
x
CheckBool
x
term
y
CheckBool
y
ORG
Or2
x
y
ELSIF
x
type
form
ORB
Int
THEN
term
y
CheckInt
y
ORG
AddOp
op
x
y
ELSIF
x
type
form
ORB
Real
THEN
term
y
CheckReal
y
ORG
RealOp
op
x
y
ELSE
CheckSet
x
term
y
CheckSet
y
ORG
SetOp
op
x
y
END
END
END
SimpleExpression
PROCEDURE
expression0
VAR
x
ORG
Item
VAR
y
ORG
Item
obj
ORB
Object
rel
xf
yf
INTEGER
BEGIN
SimpleExpression
x
IF
sym
ORS
eql
sym
ORS
geq
THEN
rel
sym
ORS
Get
sym
SimpleExpression
y
xf
x
type
form
yf
y
type
form
IF
x
type
y
type
THEN
IF
xf
IN
ORB
Char
ORB
Int
THEN
ORG
IntRelation
rel
x
y
ELSIF
xf
ORB
Real
THEN
ORG
RealRelation
rel
x
y
ELSIF
xf
IN
ORB
Set
ORB
Pointer
ORB
Proc
ORB
NilTyp
ORB
Bool
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Array
x
type
base
form
ORB
Char
OR
xf
ORB
String
THEN
ORG
StringRelation
rel
x
y
ELSE
ORS
Mark
illegal
comparison
END
ELSIF
xf
IN
ORB
Pointer
ORB
Proc
yf
ORB
NilTyp
OR
yf
IN
ORB
Pointer
ORB
Proc
xf
ORB
NilTyp
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Pointer
yf
ORB
Pointer
IsExtension
x
type
base
y
type
base
OR
IsExtension
y
type
base
x
type
base
OR
xf
ORB
Proc
yf
ORB
Proc
EqualSignatures
x
type
y
type
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Array
x
type
base
form
ORB
Char
yf
ORB
String
OR
yf
ORB
Array
y
type
base
form
ORB
Char
OR
yf
ORB
Array
y
type
base
form
ORB
Char
xf
ORB
String
THEN
ORG
StringRelation
rel
x
y
ELSIF
xf
ORB
Char
yf
ORB
String
y
b
THEN
ORG
StrToChar
y
ORG
IntRelation
rel
x
y
ELSIF
yf
ORB
Char
xf
ORB
String
x
b
THEN
ORG
StrToChar
x
ORG
IntRelation
rel
x
y
ELSIF
xf
ORB
Int
yf
ORB
Int
THEN
ORG
IntRelation
rel
x
y
BYTE
ELSE
ORS
Mark
illegal
comparison
END
x
type
ORB
boolType
ELSIF
sym
ORS
in
THEN
ORS
Get
sym
CheckInt
x
SimpleExpression
y
CheckSet
y
ORG
In
x
y
x
type
ORB
boolType
ELSIF
sym
ORS
is
THEN
ORS
Get
sym
qualident
obj
TypeTest
x
obj
type
FALSE
x
type
ORB
boolType
END
END
expression0
statements
PROCEDURE
StandProc
pno
LONGINT
VAR
nap
npar
LONGINT
nof
actual
formal
parameters
x
y
z
ORG
Item
BEGIN
Check
ORS
lparen
no
npar
pno
MOD
pno
pno
DIV
expression
x
nap
IF
sym
ORS
comma
THEN
ORS
Get
sym
expression
y
nap
z
type
ORB
noType
WHILE
sym
ORS
comma
DO
ORS
Get
sym
expression
z
INC
nap
END
ELSE
y
type
ORB
noType
END
Check
ORS
rparen
no
IF
npar
nap
OR
pno
IN
THEN
IF
pno
IN
THEN
INC
DEC
CheckInt
x
CheckReadOnly
x
IF
y
type
ORB
noType
THEN
CheckInt
y
END
ORG
Increment
pno
x
y
ELSIF
pno
IN
THEN
INCL
EXCL
CheckSet
x
CheckReadOnly
x
CheckInt
y
ORG
Include
pno
x
y
ELSIF
pno
THEN
CheckBool
x
ORG
Assert
x
ELSIF
pno
THEN
NEW
CheckReadOnly
x
IF
x
type
form
ORB
Pointer
x
type
base
form
ORB
Record
THEN
ORG
New
x
ELSE
ORS
Mark
not
a
pointer
to
record
END
ELSIF
pno
THEN
CheckReal
x
CheckInt
y
CheckReadOnly
x
ORG
Pack
x
y
ELSIF
pno
THEN
CheckReal
x
CheckInt
y
CheckReadOnly
x
ORG
Unpk
x
y
ELSIF
pno
THEN
IF
x
type
form
ORB
Set
THEN
ORG
Led
x
ELSE
ORS
Mark
bad
type
END
ELSIF
pno
THEN
CheckInt
x
ORG
Get
x
y
ELSIF
pno
THEN
CheckInt
x
ORG
Put
x
y
ELSIF
pno
THEN
CheckInt
x
CheckInt
y
CheckInt
z
ORG
Copy
x
y
z
ELSIF
pno
THEN
CheckConst
x
CheckInt
x
ORG
LDPSR
x
ELSIF
pno
THEN
CheckInt
x
ORG
LDREG
x
y
END
ELSE
ORS
Mark
wrong
nof
parameters
END
END
StandProc
PROCEDURE
StatSequence
VAR
obj
ORB
Object
orgtype
ORB
Type
original
type
of
case
var
x
y
z
w
ORG
Item
L0
L1
rx
LONGINT
PROCEDURE
TypeCase
obj
ORB
Object
VAR
x
ORG
Item
VAR
typobj
ORB
Object
BEGIN
IF
sym
ORS
ident
THEN
qualident
typobj
ORG
MakeItem
x
obj
level
IF
typobj
class
ORB
Typ
THEN
ORS
Mark
not
a
type
END
TypeTest
x
typobj
type
FALSE
obj
type
typobj
type
ORG
CFJump
x
Check
ORS
colon
expected
StatSequence
ELSE
ORG
CFJump
x
ORS
Mark
type
id
expected
END
END
TypeCase
PROCEDURE
SkipCase
BEGIN
WHILE
sym
ORS
colon
DO
ORS
Get
sym
END
ORS
Get
sym
StatSequence
END
SkipCase
BEGIN
StatSequence
REPEAT
sync
obj
NIL
IF
sym
ORS
ident
sym
ORS
for
OR
sym
ORS
semicolon
THEN
ORS
Mark
statement
expected
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
ident
END
IF
sym
ORS
ident
THEN
qualident
obj
ORG
MakeItem
x
obj
level
IF
x
mode
ORB
SProc
THEN
StandProc
obj
val
ELSE
selector
x
IF
sym
ORS
becomes
THEN
assignment
ORS
Get
sym
CheckReadOnly
x
expression
y
IF
CompTypes
x
type
y
type
FALSE
THEN
IF
x
type
form
ORB
Pointer
OR
x
type
form
ORB
Proc
THEN
ORG
Store
x
y
ELSE
ORG
StoreStruct
x
y
END
ELSIF
x
type
form
ORB
Array
y
type
form
ORB
Array
x
type
base
y
type
base
y
type
len
THEN
ORG
StoreStruct
x
y
ELSIF
x
type
form
ORB
Array
x
type
base
form
ORB
Char
y
type
form
ORB
String
THEN
ORG
CopyString
x
y
ELSIF
x
type
form
ORB
Int
y
type
form
ORB
Int
THEN
ORG
Store
x
y
BYTE
ELSIF
x
type
form
ORB
Char
y
type
form
ORB
String
y
b
THEN
ORG
StrToChar
y
ORG
Store
x
y
ELSE
ORS
Mark
illegal
assignment
END
ELSIF
sym
ORS
eql
THEN
ORS
Mark
should
be
ORS
Get
sym
expression
y
ELSIF
sym
ORS
lparen
THEN
procedure
call
ORS
Get
sym
IF
x
type
form
ORB
Proc
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ParamList
x
ORG
Call
x
rx
ELSE
ORS
Mark
not
a
procedure
ParamList
x
END
ELSIF
x
type
form
ORB
Proc
THEN
procedure
call
without
parameters
IF
x
type
nofpar
THEN
ORS
Mark
missing
parameters
END
IF
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ORG
Call
x
rx
ELSE
ORS
Mark
not
a
procedure
END
ELSIF
x
mode
ORB
Typ
THEN
ORS
Mark
illegal
assignment
ELSE
ORS
Mark
not
a
procedure
END
END
ELSIF
sym
ORS
if
THEN
ORS
Get
sym
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
then
no
THEN
StatSequence
L0
WHILE
sym
ORS
elsif
DO
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
then
no
THEN
StatSequence
END
IF
sym
ORS
else
THEN
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
StatSequence
ELSE
ORG
Fixup
x
END
ORG
FixLink
L0
Check
ORS
end
no
END
ELSIF
sym
ORS
while
THEN
ORS
Get
sym
L0
ORG
Here
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
do
no
DO
StatSequence
ORG
BJump
L0
WHILE
sym
ORS
elsif
DO
ORS
Get
sym
ORG
Fixup
x
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
do
no
DO
StatSequence
ORG
BJump
L0
END
ORG
Fixup
x
Check
ORS
end
no
END
ELSIF
sym
ORS
repeat
THEN
ORS
Get
sym
L0
ORG
Here
StatSequence
IF
sym
ORS
until
THEN
ORS
Get
sym
expression
x
CheckBool
x
ORG
CBJump
x
L0
ELSE
ORS
Mark
missing
UNTIL
END
ELSIF
sym
ORS
for
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
ORG
MakeItem
x
obj
level
CheckInt
x
CheckReadOnly
x
IF
sym
ORS
becomes
THEN
ORS
Get
sym
expression
y
CheckInt
y
ORG
For0
x
y
L0
ORG
Here
Check
ORS
to
no
TO
expression
z
CheckInt
z
obj
rdo
TRUE
IF
sym
ORS
by
THEN
ORS
Get
sym
expression
w
CheckConst
w
CheckInt
w
ELSE
ORG
MakeConstItem
w
ORB
intType
END
Check
ORS
do
no
DO
ORG
For1
x
y
z
w
L1
StatSequence
Check
ORS
end
no
END
ORG
For2
x
y
w
ORG
BJump
L0
ORG
FixLink
L1
obj
rdo
FALSE
ELSE
ORS
Mark
expected
END
ELSE
ORS
Mark
identifier
expected
END
ELSIF
sym
ORS
case
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
orgtype
obj
type
IF
orgtype
form
ORB
Pointer
OR
orgtype
form
ORB
Record
obj
class
ORB
Par
THEN
Check
ORS
of
OF
expected
TypeCase
obj
x
L0
WHILE
sym
ORS
bar
DO
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
obj
type
orgtype
TypeCase
obj
x
END
ORG
Fixup
x
ORG
FixLink
L0
obj
type
orgtype
ELSE
ORS
Mark
numeric
case
not
implemented
Check
ORS
of
OF
expected
SkipCase
WHILE
sym
ORS
bar
DO
SkipCase
END
END
ELSE
ORS
Mark
ident
expected
END
Check
ORS
end
no
END
END
ORG
CheckRegs
IF
sym
ORS
semicolon
THEN
ORS
Get
sym
ELSIF
sym
ORS
semicolon
THEN
ORS
Mark
missing
semicolon
END
UNTIL
sym
ORS
semicolon
END
StatSequence
Types
and
declarations
PROCEDURE
IdentList
class
INTEGER
VAR
first
ORB
Object
VAR
obj
ORB
Object
BEGIN
IF
sym
ORS
ident
THEN
ORB
NewObj
first
ORS
id
class
ORS
Get
sym
CheckExport
first
expo
WHILE
sym
ORS
comma
DO
ORS
Get
sym
IF
sym
ORS
ident
THEN
ORB
NewObj
obj
ORS
id
class
ORS
Get
sym
CheckExport
obj
expo
ELSE
ORS
Mark
ident
END
END
IF
sym
ORS
colon
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
ELSE
first
NIL
END
END
IdentList
PROCEDURE
ArrayType
VAR
type
ORB
Type
VAR
x
ORG
Item
typ
ORB
Type
len
LONGINT
BEGIN
NEW
typ
typ
form
ORB
NoTyp
expression
x
IF
x
mode
ORB
Const
x
type
form
ORB
Int
x
a
THEN
len
x
a
ELSE
len
ORS
Mark
not
a
valid
length
END
IF
sym
ORS
of
THEN
ORS
Get
sym
Type
typ
base
IF
typ
base
form
ORB
Array
typ
base
len
THEN
ORS
Mark
dyn
array
not
allowed
END
ELSIF
sym
ORS
comma
THEN
ORS
Get
sym
ArrayType
typ
base
ELSE
ORS
Mark
missing
OF
typ
base
ORB
intType
END
typ
size
len
typ
base
size
DIV
typ
form
ORB
Array
typ
len
len
type
typ
END
ArrayType
PROCEDURE
RecordType
VAR
type
ORB
Type
VAR
obj
obj0
new
bot
base
ORB
Object
typ
tp
ORB
Type
offset
off
n
LONGINT
BEGIN
NEW
typ
typ
form
ORB
NoTyp
typ
base
NIL
typ
mno
level
typ
nofpar
offset
bot
NIL
IF
sym
ORS
lparen
THEN
ORS
Get
sym
record
extension
IF
level
THEN
ORS
Mark
extension
of
local
types
not
implemented
END
IF
sym
ORS
ident
THEN
qualident
base
IF
base
class
ORB
Typ
THEN
IF
base
type
form
ORB
Record
THEN
typ
base
base
type
ELSE
typ
base
ORB
intType
ORS
Mark
invalid
extension
END
typ
nofpar
typ
base
nofpar
nofpar
here
abused
for
extension
level
bot
typ
base
dsc
offset
typ
base
size
ELSE
ORS
Mark
type
expected
END
ELSE
ORS
Mark
ident
expected
END
Check
ORS
rparen
no
END
WHILE
sym
ORS
ident
DO
fields
n
obj
bot
WHILE
sym
ORS
ident
DO
obj0
obj
WHILE
obj0
NIL
obj0
name
ORS
id
DO
obj0
obj0
next
END
IF
obj0
NIL
THEN
ORS
Mark
mult
def
END
NEW
new
ORS
CopyId
new
name
new
class
ORB
Fld
new
next
obj
obj
new
INC
n
ORS
Get
sym
CheckExport
new
expo
IF
sym
ORS
comma
sym
ORS
colon
THEN
ORS
Mark
comma
expected
ELSIF
sym
ORS
comma
THEN
ORS
Get
sym
END
END
Check
ORS
colon
colon
expected
Type
tp
IF
tp
form
ORB
Array
tp
len
THEN
ORS
Mark
dyn
array
not
allowed
END
IF
tp
size
THEN
offset
offset
DIV
END
offset
offset
n
tp
size
off
offset
obj0
obj
WHILE
obj0
bot
DO
obj0
type
tp
obj0
lev
off
off
tp
size
obj0
val
off
obj0
obj0
next
END
bot
obj
IF
sym
ORS
semicolon
THEN
ORS
Get
sym
ELSIF
sym
ORS
end
THEN
ORS
Mark
or
END
END
END
typ
form
ORB
Record
typ
dsc
bot
typ
size
offset
DIV
type
typ
END
RecordType
PROCEDURE
FPSection
VAR
adr
LONGINT
VAR
nofpar
INTEGER
VAR
obj
first
ORB
Object
tp
ORB
Type
parsize
LONGINT
cl
INTEGER
rdo
BOOLEAN
BEGIN
IF
sym
ORS
var
THEN
ORS
Get
sym
cl
ORB
Par
ELSE
cl
ORB
Var
END
IdentList
cl
first
FormalType
tp
rdo
FALSE
IF
cl
ORB
Var
tp
form
ORB
Array
THEN
cl
ORB
Par
rdo
TRUE
END
IF
tp
form
ORB
Array
tp
len
OR
tp
form
ORB
Record
THEN
parsize
ORG
WordSize
open
array
or
record
needs
second
word
for
length
or
type
tag
ELSE
parsize
ORG
WordSize
END
obj
first
WHILE
obj
NIL
DO
INC
nofpar
obj
class
cl
obj
type
tp
obj
rdo
rdo
obj
lev
level
obj
val
adr
adr
adr
parsize
obj
obj
next
END
IF
adr
THEN
ORS
Mark
too
many
parameters
END
END
FPSection
PROCEDURE
ProcedureType
ptype
ORB
Type
VAR
parblksize
LONGINT
VAR
obj
ORB
Object
size
LONGINT
nofpar
INTEGER
BEGIN
ptype
base
ORB
noType
size
parblksize
nofpar
ptype
dsc
NIL
IF
sym
ORS
lparen
THEN
ORS
Get
sym
IF
sym
ORS
rparen
THEN
ORS
Get
sym
ELSE
FPSection
size
nofpar
WHILE
sym
ORS
semicolon
DO
ORS
Get
sym
FPSection
size
nofpar
END
Check
ORS
rparen
no
END
IF
sym
ORS
colon
THEN
function
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
ptype
base
obj
type
IF
obj
class
ORB
Typ
obj
type
form
IN
ORB
Byte
ORB
Pointer
ORB
Proc
THEN
ORS
Mark
illegal
function
type
END
ELSE
ORS
Mark
type
identifier
expected
END
END
END
ptype
nofpar
nofpar
parblksize
size
END
ProcedureType
PROCEDURE
FormalType0
VAR
typ
ORB
Type
dim
INTEGER
VAR
obj
ORB
Object
dmy
LONGINT
BEGIN
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
typ
obj
type
ELSE
ORS
Mark
not
a
type
typ
ORB
intType
END
ELSIF
sym
ORS
array
THEN
ORS
Get
sym
Check
ORS
of
OF
IF
dim
THEN
ORS
Mark
multi
dimensional
open
arrays
not
implemented
END
NEW
typ
typ
form
ORB
Array
typ
len
typ
size
ORG
WordSize
FormalType
typ
base
dim
ELSIF
sym
ORS
procedure
THEN
ORS
Get
sym
ORB
OpenScope
NEW
typ
typ
form
ORB
Proc
typ
size
ORG
WordSize
dmy
ProcedureType
typ
dmy
typ
dsc
ORB
topScope
next
ORB
CloseScope
ELSE
ORS
Mark
identifier
expected
typ
ORB
noType
END
END
FormalType0
PROCEDURE
CheckRecLevel
lev
INTEGER
BEGIN
IF
lev
THEN
ORS
Mark
ptr
base
must
be
global
END
END
CheckRecLevel
PROCEDURE
Type0
VAR
type
ORB
Type
VAR
dmy
LONGINT
obj
ORB
Object
ptbase
PtrBase
BEGIN
type
ORB
intType
sync
IF
sym
ORS
ident
sym
ORS
array
THEN
ORS
Mark
not
a
type
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
ident
OR
sym
ORS
array
END
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
IF
obj
type
NIL
obj
type
form
ORB
NoTyp
THEN
type
obj
type
END
ELSE
ORS
Mark
not
a
type
or
undefined
END
ELSIF
sym
ORS
array
THEN
ORS
Get
sym
ArrayType
type
ELSIF
sym
ORS
record
THEN
ORS
Get
sym
RecordType
type
Check
ORS
end
no
END
ELSIF
sym
ORS
pointer
THEN
ORS
Get
sym
Check
ORS
to
no
TO
NEW
type
type
form
ORB
Pointer
type
size
ORG
WordSize
type
base
ORB
intType
IF
sym
ORS
ident
THEN
obj
ORB
thisObj
IF
obj
NIL
THEN
IF
obj
class
ORB
Typ
obj
type
form
IN
ORB
Record
ORB
NoTyp
THEN
CheckRecLevel
obj
lev
type
base
obj
type
ELSIF
obj
class
ORB
Mod
THEN
ORS
Mark
external
base
type
not
implemented
ELSE
ORS
Mark
no
valid
base
type
END
ELSE
CheckRecLevel
level
enter
into
list
of
forward
references
to
be
fixed
in
Declarations
NEW
ptbase
ORS
CopyId
ptbase
name
ptbase
type
type
ptbase
next
pbsList
pbsList
ptbase
END
ORS
Get
sym
ELSE
Type
type
base
IF
type
base
form
ORB
Record
OR
type
base
typobj
NIL
THEN
ORS
Mark
must
point
to
named
record
END
CheckRecLevel
level
END
ELSIF
sym
ORS
procedure
THEN
ORS
Get
sym
ORB
OpenScope
NEW
type
type
form
ORB
Proc
type
size
ORG
WordSize
dmy
ProcedureType
type
dmy
type
dsc
ORB
topScope
next
ORB
CloseScope
ELSE
ORS
Mark
illegal
type
END
END
Type0
PROCEDURE
Declarations
VAR
varsize
LONGINT
VAR
obj
first
ORB
Object
x
ORG
Item
tp
ORB
Type
ptbase
PtrBase
expo
BOOLEAN
id
ORS
Ident
BEGIN
sync
pbsList
NIL
IF
sym
ORS
const
sym
ORS
end
sym
ORS
return
THEN
ORS
Mark
declaration
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
const
OR
sym
ORS
end
OR
sym
ORS
return
END
IF
sym
ORS
const
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
id
ORS
Get
sym
CheckExport
expo
IF
sym
ORS
eql
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
expression
x
IF
x
type
form
ORB
String
x
b
THEN
ORG
StrToChar
x
END
ORB
NewObj
obj
id
ORB
Const
obj
expo
expo
IF
x
mode
ORB
Const
THEN
obj
val
x
a
obj
lev
x
b
obj
type
x
type
ELSE
ORS
Mark
expression
not
constant
obj
type
ORB
intType
END
Check
ORS
semicolon
missing
END
END
IF
sym
ORS
type
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
id
ORS
Get
sym
CheckExport
expo
IF
sym
ORS
eql
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
Type
tp
ORB
NewObj
obj
id
ORB
Typ
obj
type
tp
obj
expo
expo
obj
lev
level
IF
tp
typobj
NIL
THEN
tp
typobj
obj
END
IF
expo
obj
type
form
ORB
Record
THEN
obj
exno
exno
INC
exno
ELSE
obj
exno
END
IF
tp
form
ORB
Record
THEN
ptbase
pbsList
check
whether
this
is
base
of
a
pointer
type
search
and
fixup
WHILE
ptbase
NIL
DO
IF
obj
name
ptbase
name
THEN
ptbase
type
base
obj
type
END
ptbase
ptbase
next
END
IF
level
THEN
ORG
BuildTD
tp
dc
END
type
descriptor
len
used
as
its
address
END
Check
ORS
semicolon
missing
END
END
IF
sym
ORS
var
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
IdentList
ORB
Var
first
Type
tp
obj
first
WHILE
obj
NIL
DO
obj
type
tp
obj
lev
level
IF
tp
size
THEN
varsize
varsize
DIV
align
END
obj
val
varsize
varsize
varsize
obj
type
size
IF
obj
expo
THEN
obj
exno
exno
INC
exno
END
obj
obj
next
END
Check
ORS
semicolon
missing
END
END
varsize
varsize
DIV
ptbase
pbsList
WHILE
ptbase
NIL
DO
IF
ptbase
type
base
form
ORB
Int
THEN
ORS
Mark
undefined
pointer
base
of
END
ptbase
ptbase
next
END
IF
sym
ORS
const
sym
ORS
var
THEN
ORS
Mark
declaration
in
bad
order
END
END
Declarations
PROCEDURE
ProcedureDecl
VAR
proc
ORB
Object
type
ORB
Type
procid
ORS
Ident
x
ORG
Item
locblksize
parblksize
L
LONGINT
int
BOOLEAN
BEGIN
ProcedureDecl
int
FALSE
ORS
Get
sym
IF
sym
ORS
times
THEN
ORS
Get
sym
int
TRUE
END
IF
sym
ORS
ident
THEN
ORS
CopyId
procid
ORS
Get
sym
ORB
NewObj
proc
ORS
id
ORB
Const
IF
int
THEN
parblksize
ELSE
parblksize
END
NEW
type
type
form
ORB
Proc
type
size
ORG
WordSize
proc
type
type
proc
val
proc
lev
level
CheckExport
proc
expo
IF
proc
expo
THEN
proc
exno
exno
INC
exno
END
ORB
OpenScope
INC
level
type
base
ORB
noType
ProcedureType
type
parblksize
formal
parameter
list
Check
ORS
semicolon
no
locblksize
parblksize
Declarations
locblksize
proc
val
ORG
Here
proc
type
dsc
ORB
topScope
next
IF
sym
ORS
procedure
THEN
L
ORG
FJump
L
REPEAT
ProcedureDecl
Check
ORS
semicolon
no
UNTIL
sym
ORS
procedure
ORG
FixOne
L
proc
val
ORG
Here
proc
type
dsc
ORB
topScope
next
END
ORG
Enter
parblksize
locblksize
int
IF
sym
ORS
begin
THEN
ORS
Get
sym
StatSequence
END
IF
sym
ORS
return
THEN
ORS
Get
sym
expression
x
IF
type
base
ORB
noType
THEN
ORS
Mark
this
is
not
a
function
ELSIF
CompTypes
type
base
x
type
FALSE
THEN
ORS
Mark
wrong
result
type
END
ELSIF
type
base
form
ORB
NoTyp
THEN
ORS
Mark
function
without
result
type
base
ORB
noType
END
ORG
Return
type
base
form
x
locblksize
int
ORB
CloseScope
DEC
level
Check
ORS
end
no
END
IF
sym
ORS
ident
THEN
IF
ORS
id
procid
THEN
ORS
Mark
no
match
END
ORS
Get
sym
ELSE
ORS
Mark
no
proc
id
END
END
END
ProcedureDecl
PROCEDURE
Module
VAR
key
LONGINT
impid
impid1
ORS
Ident
BEGIN
Texts
WriteString
W
compiling
ORS
Get
sym
IF
sym
ORS
module
THEN
ORS
Get
sym
IF
sym
ORS
times
THEN
version
Texts
Write
W
ORS
Get
sym
ELSE
version
END
ORB
Init
ORB
OpenScope
IF
sym
ORS
ident
THEN
ORS
CopyId
modid
ORS
Get
sym
Texts
WriteString
W
modid
Texts
Append
Oberon
Log
W
buf
ELSE
ORS
Mark
identifier
expected
END
Check
ORS
semicolon
no
level
dc
exno
key
IF
sym
ORS
import
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
impid
ORS
Get
sym
IF
sym
ORS
becomes
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
ORS
CopyId
impid1
ORS
Get
sym
ELSE
ORS
Mark
id
expected
END
ELSE
impid1
impid
END
ORB
Import
impid
impid1
IF
sym
ORS
comma
THEN
ORS
Get
sym
ELSIF
sym
ORS
ident
THEN
ORS
Mark
comma
missing
END
END
Check
ORS
semicolon
no
END
ORG
Open
version
Declarations
dc
ORG
SetDataSize
dc
DIV
WHILE
sym
ORS
procedure
DO
ProcedureDecl
Check
ORS
semicolon
no
END
ORG
Header
IF
sym
ORS
begin
THEN
ORS
Get
sym
StatSequence
END
Check
ORS
end
no
END
IF
sym
ORS
ident
THEN
IF
ORS
id
modid
THEN
ORS
Mark
no
match
END
ORS
Get
sym
ELSE
ORS
Mark
identifier
missing
END
IF
sym
ORS
period
THEN
ORS
Mark
period
missing
END
IF
ORS
errcnt
version
THEN
ORB
Export
modid
newSF
key
IF
newSF
THEN
Texts
WriteString
W
new
symbol
file
END
END
IF
ORS
errcnt
THEN
ORG
Close
modid
key
exno
Texts
WriteInt
W
ORG
pc
Texts
WriteInt
W
dc
Texts
WriteHex
W
key
ELSE
Texts
WriteLn
W
Texts
WriteString
W
compilation
FAILED
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
ORB
CloseScope
pbsList
NIL
ELSE
ORS
Mark
must
start
with
MODULE
END
END
Module
PROCEDURE
Option
VAR
S
Texts
Scanner
BEGIN
newSF
FALSE
IF
S
nextCh
THEN
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
S
s
s
THEN
newSF
TRUE
END
END
END
Option
PROCEDURE
Compile
VAR
beg
end
time
LONGINT
T
Texts
Text
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
THEN
IF
S
c
THEN
Option
S
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
ORS
Init
T
beg
Module
END
ELSIF
S
c
THEN
Option
S
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
S
s
NEW
T
Texts
Open
T
S
s
IF
T
len
THEN
ORS
Init
T
Module
END
END
END
END
ELSE
WHILE
S
class
Texts
Name
DO
NEW
T
Texts
Open
T
S
s
IF
T
len
THEN
Option
S
ORS
Init
T
Module
ELSE
Texts
WriteString
W
S
s
Texts
WriteString
W
not
found
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
IF
T
len
ORS
errcnt
THEN
Texts
Scan
S
ELSE
S
class
END
END
END
Oberon
Collect
END
Compile
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
OR
Compiler
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
NEW
dummy
dummy
class
ORB
Var
dummy
type
ORB
intType
expression
expression0
Type
Type0
FormalType
FormalType0
END
ORP
MODULE
ORS
NW
Scanner
in
Oberon
IMPORT
SYSTEM
Texts
Oberon
Oberon
Scanner
does
lexical
analysis
Input
is
Oberon
Text
output
is
sequence
of
symbols
i
e
identifiers
numbers
strings
and
special
symbols
Recognises
all
Oberon
keywords
and
skips
comments
The
keywords
are
recorded
in
a
table
Get
sym
delivers
next
symbol
from
input
text
with
Reader
R
Mark
msg
records
error
and
delivers
error
message
with
Writer
W
If
Get
delivers
ident
then
the
identifier
a
string
is
in
variable
id
if
int
or
char
in
ival
if
real
in
rval
and
if
string
in
str
and
slen
CONST
IdLen
NKW
nof
keywords
maxExp
stringBufSize
lexical
symbols
null
times
rdiv
div
mod
and
plus
minus
or
eql
neq
lss
leq
gtr
geq
in
is
arrow
period
char
int
real
false
true
nil
string
not
lparen
lbrak
lbrace
ident
if
while
repeat
case
for
comma
colon
becomes
upto
rparen
rbrak
rbrace
then
of
do
to
by
semicolon
end
bar
else
elsif
until
return
array
record
pointer
const
type
var
procedure
begin
import
module
eot
TYPE
Ident
ARRAY
IdLen
OF
CHAR
VAR
ival
slen
LONGINT
results
of
Get
rval
REAL
id
Ident
for
identifiers
str
ARRAY
stringBufSize
OF
CHAR
errcnt
INTEGER
ch
CHAR
last
character
read
errpos
LONGINT
R
Texts
Reader
W
Texts
Writer
k
INTEGER
KWX
ARRAY
OF
INTEGER
keyTab
ARRAY
NKW
OF
RECORD
sym
INTEGER
id
ARRAY
OF
CHAR
END
PROCEDURE
CopyId
VAR
ident
Ident
BEGIN
ident
id
END
CopyId
PROCEDURE
Pos
LONGINT
BEGIN
RETURN
Texts
Pos
R
END
Pos
PROCEDURE
Mark
msg
ARRAY
OF
CHAR
VAR
p
LONGINT
BEGIN
p
Pos
IF
p
errpos
errcnt
THEN
Texts
WriteLn
W
Texts
WriteString
W
pos
Texts
WriteInt
W
p
Texts
Write
W
Texts
WriteString
W
msg
Texts
Append
Oberon
Log
W
buf
END
INC
errcnt
errpos
p
END
Mark
PROCEDURE
Identifier
VAR
sym
INTEGER
VAR
i
k
INTEGER
BEGIN
i
REPEAT
IF
i
IdLen
THEN
id
i
ch
INC
i
END
Texts
Read
R
ch
UNTIL
ch
OR
ch
ch
A
OR
ch
Z
ch
a
OR
ch
z
id
i
0X
IF
i
THEN
k
KWX
i
search
for
keyword
WHILE
id
keyTab
k
id
k
KWX
i
DO
INC
k
END
IF
k
KWX
i
THEN
sym
keyTab
k
sym
ELSE
sym
ident
END
ELSE
sym
ident
END
END
Identifier
PROCEDURE
String
VAR
i
INTEGER
BEGIN
i
Texts
Read
R
ch
WHILE
R
eot
ch
22X
DO
IF
ch
THEN
IF
i
stringBufSize
THEN
str
i
ch
INC
i
ELSE
Mark
string
too
long
END
END
Texts
Read
R
ch
END
str
i
0X
INC
i
Texts
Read
R
ch
slen
i
END
String
PROCEDURE
HexString
VAR
i
m
n
INTEGER
BEGIN
i
Texts
Read
R
ch
WHILE
R
eot
ch
DO
WHILE
R
eot
ch
DO
Texts
Read
R
ch
END
skip
IF
ch
ch
THEN
m
ORD
ch
30H
ELSIF
A
ch
ch
F
THEN
m
ORD
ch
37H
ELSE
m
Mark
hexdig
expected
END
Texts
Read
R
ch
IF
ch
ch
THEN
n
ORD
ch
30H
ELSIF
A
ch
ch
F
THEN
n
ORD
ch
37H
ELSE
n
Mark
hexdig
expected
END
IF
i
stringBufSize
THEN
str
i
CHR
m
10H
n
INC
i
ELSE
Mark
string
too
long
END
Texts
Read
R
ch
END
Texts
Read
R
ch
slen
i
no
0X
appended
END
HexString
PROCEDURE
Ten
e
LONGINT
REAL
VAR
x
t
REAL
BEGIN
x
t
WHILE
e
DO
IF
ODD
e
THEN
x
t
x
END
t
t
t
e
e
DIV
END
RETURN
x
END
Ten
PROCEDURE
Number
VAR
sym
INTEGER
CONST
max
VAR
i
k
e
n
s
h
LONGINT
x
REAL
d
ARRAY
OF
INTEGER
negE
BOOLEAN
BEGIN
ival
i
n
k
REPEAT
IF
n
THEN
d
n
ORD
ch
30H
INC
n
ELSE
Mark
too
many
digits
n
END
Texts
Read
R
ch
UNTIL
ch
OR
ch
ch
A
OR
ch
F
IF
ch
H
OR
ch
R
OR
ch
X
THEN
hex
REPEAT
h
d
i
IF
h
THEN
h
h
END
k
k
10H
h
INC
i
no
overflow
check
UNTIL
i
n
IF
ch
X
THEN
sym
char
IF
k
100H
THEN
ival
k
ELSE
Mark
illegal
value
ival
END
ELSIF
ch
R
THEN
sym
real
rval
SYSTEM
VAL
REAL
k
ELSE
sym
int
ival
k
END
Texts
Read
R
ch
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
double
dot
ch
7FX
decimal
integer
REPEAT
IF
d
i
THEN
IF
k
max
d
i
DIV
THEN
k
k
d
i
ELSE
Mark
too
large
k
END
ELSE
Mark
bad
integer
END
INC
i
UNTIL
i
n
sym
int
ival
k
ELSE
real
number
x
e
REPEAT
integer
part
x
x
FLT
d
i
INC
i
UNTIL
i
n
WHILE
ch
ch
DO
fraction
x
x
FLT
ORD
ch
30H
DEC
e
Texts
Read
R
ch
END
IF
ch
E
OR
ch
D
THEN
scale
factor
Texts
Read
R
ch
s
IF
ch
THEN
negE
TRUE
Texts
Read
R
ch
ELSE
negE
FALSE
IF
ch
THEN
Texts
Read
R
ch
END
END
IF
ch
ch
THEN
REPEAT
s
s
ORD
ch
30H
Texts
Read
R
ch
UNTIL
ch
OR
ch
IF
negE
THEN
e
e
s
ELSE
e
e
s
END
ELSE
Mark
digit
END
END
IF
e
THEN
IF
e
maxExp
THEN
x
x
Ten
e
ELSE
x
END
ELSIF
e
THEN
IF
e
maxExp
THEN
x
Ten
e
x
ELSE
x
Mark
too
large
END
END
sym
real
rval
x
END
ELSE
decimal
integer
REPEAT
IF
d
i
THEN
IF
k
max
d
i
DIV
THEN
k
k
d
i
ELSE
Mark
too
large
k
END
ELSE
Mark
bad
integer
END
INC
i
UNTIL
i
n
sym
int
ival
k
END
END
Number
PROCEDURE
comment
BEGIN
Texts
Read
R
ch
REPEAT
WHILE
R
eot
ch
DO
IF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
comment
END
ELSE
Texts
Read
R
ch
END
END
WHILE
ch
DO
Texts
Read
R
ch
END
UNTIL
ch
OR
R
eot
IF
R
eot
THEN
Texts
Read
R
ch
ELSE
Mark
unterminated
comment
END
END
comment
PROCEDURE
Get
VAR
sym
INTEGER
BEGIN
REPEAT
WHILE
R
eot
ch
DO
Texts
Read
R
ch
END
IF
R
eot
THEN
sym
eot
ELSIF
ch
A
THEN
IF
ch
THEN
IF
ch
22X
THEN
String
sym
string
ELSIF
ch
THEN
Texts
Read
R
ch
sym
neq
ELSIF
ch
THEN
HexString
sym
string
ELSIF
ch
THEN
Texts
Read
R
ch
sym
and
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
sym
null
comment
ELSE
sym
lparen
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
rparen
ELSIF
ch
THEN
Texts
Read
R
ch
sym
times
ELSIF
ch
THEN
Texts
Read
R
ch
sym
plus
ELSIF
ch
THEN
Texts
Read
R
ch
sym
comma
ELSIF
ch
THEN
Texts
Read
R
ch
sym
minus
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
upto
ELSE
sym
period
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
rdiv
ELSE
Texts
Read
R
ch
sym
null
END
ELSIF
ch
THEN
Number
sym
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
becomes
ELSE
sym
colon
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
semicolon
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
leq
ELSE
sym
lss
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
eql
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
geq
ELSE
sym
gtr
END
ELSE
Texts
Read
R
ch
sym
null
END
ELSIF
ch
THEN
Identifier
sym
ELSIF
ch
a
THEN
IF
ch
THEN
sym
lbrak
ELSIF
ch
THEN
sym
rbrak
ELSIF
ch
THEN
sym
arrow
ELSE
sym
null
END
Texts
Read
R
ch
ELSIF
ch
THEN
Identifier
sym
ELSE
IF
ch
THEN
sym
lbrace
ELSIF
ch
THEN
sym
rbrace
ELSIF
ch
THEN
sym
bar
ELSIF
ch
THEN
sym
not
ELSIF
ch
7FX
THEN
sym
upto
ELSE
sym
null
END
Texts
Read
R
ch
END
UNTIL
sym
null
END
Get
PROCEDURE
Init
T
Texts
Text
pos
LONGINT
BEGIN
errpos
pos
errcnt
Texts
OpenReader
R
T
pos
Texts
Read
R
ch
END
Init
PROCEDURE
EnterKW
sym
INTEGER
name
ARRAY
OF
CHAR
BEGIN
keyTab
k
id
name
keyTab
k
sym
sym
INC
k
END
EnterKW
BEGIN
Texts
OpenWriter
W
k
KWX
KWX
EnterKW
if
IF
EnterKW
do
DO
EnterKW
of
OF
EnterKW
or
OR
EnterKW
to
TO
EnterKW
in
IN
EnterKW
is
IS
EnterKW
by
BY
KWX
k
EnterKW
end
END
EnterKW
nil
NIL
EnterKW
var
VAR
EnterKW
div
DIV
EnterKW
mod
MOD
EnterKW
for
FOR
KWX
k
EnterKW
else
ELSE
EnterKW
then
THEN
EnterKW
true
TRUE
EnterKW
type
TYPE
EnterKW
case
CASE
KWX
k
EnterKW
elsif
ELSIF
EnterKW
false
FALSE
EnterKW
array
ARRAY
EnterKW
begin
BEGIN
EnterKW
const
CONST
EnterKW
until
UNTIL
EnterKW
while
WHILE
KWX
k
EnterKW
record
RECORD
EnterKW
repeat
REPEAT
EnterKW
return
RETURN
EnterKW
import
IMPORT
EnterKW
module
MODULE
KWX
k
EnterKW
pointer
POINTER
KWX
k
KWX
k
EnterKW
procedure
PROCEDURE
KWX
k
END
ORS
MODULE
ORTool
NW
IMPORT
SYSTEM
Files
Texts
Oberon
ORB
VAR
W
Texts
Writer
Form
INTEGER
result
of
ReadType
mnemo0
mnemo1
ARRAY
OF
CHAR
mnemonics
PROCEDURE
Read
VAR
R
Files
Rider
VAR
n
INTEGER
VAR
b
BYTE
BEGIN
Files
ReadByte
R
b
IF
b
80H
THEN
n
b
ELSE
n
b
100H
END
END
Read
PROCEDURE
ReadType
VAR
R
Files
Rider
VAR
key
len
lev
size
off
INTEGER
ref
mno
class
form
readonly
INTEGER
name
modname
ARRAY
OF
CHAR
BEGIN
Read
R
ref
Texts
Write
W
Texts
Write
W
IF
ref
THEN
Texts
Write
W
Texts
WriteInt
W
ref
ELSE
Texts
WriteInt
W
ref
Read
R
form
Texts
WriteString
W
form
Texts
WriteInt
W
form
IF
form
ORB
Pointer
THEN
ReadType
R
ELSIF
form
ORB
Array
THEN
ReadType
R
Files
ReadNum
R
len
Files
ReadNum
R
size
Texts
WriteString
W
len
Texts
WriteInt
W
len
Texts
WriteString
W
size
Texts
WriteInt
W
size
ELSIF
form
ORB
Record
THEN
ReadType
R
base
type
Files
ReadNum
R
off
Texts
WriteString
W
exno
Texts
WriteInt
W
off
Files
ReadNum
R
off
Texts
WriteString
W
extlev
Texts
WriteInt
W
off
Files
ReadNum
R
size
Texts
WriteString
W
size
Texts
WriteInt
W
size
Texts
Write
W
Texts
Write
W
Read
R
class
WHILE
class
DO
fields
Files
ReadString
R
name
IF
name
0X
THEN
Texts
Write
W
Texts
WriteString
W
name
ReadType
R
ELSE
Texts
WriteString
W
END
Files
ReadNum
R
off
Texts
WriteInt
W
off
Read
R
class
END
Texts
Write
W
ELSIF
form
ORB
Proc
THEN
ReadType
R
Texts
Write
W
Read
R
class
WHILE
class
DO
Texts
WriteString
W
class
Texts
WriteInt
W
class
Read
R
readonly
IF
readonly
THEN
Texts
Write
W
END
ReadType
R
Read
R
class
END
Texts
Write
W
END
Files
ReadString
R
modname
IF
modname
0X
THEN
Files
ReadInt
R
key
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
modname
Texts
Write
W
Texts
WriteString
W
name
Texts
WriteHex
W
key
END
END
Form
form
Texts
Write
W
END
ReadType
PROCEDURE
DecSym
decode
symbol
file
VAR
class
typno
k
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
OR
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadInt
R
k
Files
ReadInt
R
k
Files
ReadString
R
name
Texts
WriteString
W
name
Texts
WriteHex
W
k
Read
R
class
Texts
WriteInt
W
class
sym
file
version
IF
class
ORB
versionkey
THEN
Texts
WriteLn
W
Read
R
class
WHILE
class
DO
Texts
WriteInt
W
class
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
ReadType
R
IF
class
ORB
Typ
THEN
Texts
Write
W
Read
R
class
WHILE
class
DO
pointer
base
fixup
Texts
WriteString
W
Texts
WriteInt
W
class
Read
R
class
END
Texts
Write
W
ELSIF
class
ORB
Const
OR
class
ORB
Var
THEN
Files
ReadNum
R
k
Texts
WriteInt
W
k
Reals
Strings
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Read
R
class
END
ELSE
Texts
WriteString
W
bad
symfile
version
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecSym
PROCEDURE
WriteReg
r
LONGINT
BEGIN
Texts
Write
W
IF
r
THEN
Texts
WriteString
W
R
Texts
WriteInt
W
r
MOD
10H
ELSIF
r
THEN
Texts
WriteString
W
MT
ELSIF
r
THEN
Texts
WriteString
W
SB
ELSIF
r
THEN
Texts
WriteString
W
SP
ELSE
Texts
WriteString
W
LNK
END
END
WriteReg
PROCEDURE
opcode
w
LONGINT
VAR
k
op
u
a
b
c
LONGINT
BEGIN
k
w
DIV
40000000H
MOD
a
w
DIV
1000000H
MOD
10H
b
w
DIV
100000H
MOD
10H
op
w
DIV
10000H
MOD
10H
u
w
DIV
20000000H
MOD
IF
k
THEN
Texts
WriteString
W
mnemo0
op
IF
u
THEN
Texts
Write
W
END
WriteReg
a
WriteReg
b
WriteReg
w
MOD
10H
ELSIF
k
THEN
Texts
WriteString
W
mnemo0
op
IF
u
THEN
Texts
Write
W
END
WriteReg
a
WriteReg
b
w
w
MOD
10000H
IF
w
8000H
THEN
w
w
10000H
END
Texts
WriteInt
W
w
ELSIF
k
THEN
LDR
STR
IF
u
THEN
Texts
WriteString
W
STR
ELSE
Texts
WriteString
W
LDR
END
WriteReg
a
WriteReg
b
w
w
MOD
100000H
IF
w
80000H
THEN
w
w
100000H
END
Texts
WriteInt
W
w
ELSIF
k
THEN
Branch
instr
Texts
Write
W
B
IF
ODD
w
DIV
10000000H
THEN
Texts
Write
W
L
END
Texts
WriteString
W
mnemo1
a
IF
u
THEN
WriteReg
w
MOD
10H
ELSE
w
w
MOD
100000H
IF
w
80000H
THEN
w
w
100000H
END
Texts
WriteInt
W
w
END
END
END
opcode
PROCEDURE
Sync
VAR
R
Files
Rider
VAR
ch
CHAR
BEGIN
Files
Read
R
ch
Texts
WriteString
W
Sync
Texts
Write
W
ch
Texts
WriteLn
W
END
Sync
PROCEDURE
Write
VAR
R
Files
Rider
x
INTEGER
BEGIN
Files
WriteByte
R
x
x
END
Write
PROCEDURE
DecObj
decode
object
file
VAR
class
i
n
key
size
fix
adr
data
len
INTEGER
ch
CHAR
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadString
R
name
Texts
WriteLn
W
Texts
WriteString
W
name
Files
ReadInt
R
key
Texts
WriteHex
W
key
Read
R
class
Texts
WriteInt
W
class
version
Files
ReadInt
R
size
Texts
WriteInt
W
size
Texts
WriteLn
W
Texts
WriteString
W
imports
Texts
WriteLn
W
Files
ReadString
R
name
WHILE
name
0X
DO
Texts
Write
W
9X
Texts
WriteString
W
name
Files
ReadInt
R
key
Texts
WriteHex
W
key
Texts
WriteLn
W
Files
ReadString
R
name
END
Sync
R
Texts
WriteString
W
type
descriptors
Texts
WriteLn
W
Files
ReadInt
R
n
n
n
DIV
i
WHILE
i
n
DO
Files
ReadInt
R
data
Texts
WriteHex
W
data
INC
i
END
Texts
WriteLn
W
Texts
WriteString
W
data
Files
ReadInt
R
data
Texts
WriteInt
W
data
Texts
WriteLn
W
Texts
WriteString
W
strings
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
Read
R
ch
Texts
Write
W
ch
INC
i
END
Texts
WriteLn
W
Texts
WriteString
W
code
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
ReadInt
R
data
Texts
WriteInt
W
i
Texts
Write
W
9X
Texts
WriteHex
W
data
Texts
Write
W
9X
opcode
data
Texts
WriteLn
W
INC
i
END
Sync
R
Texts
WriteString
W
commands
Texts
WriteLn
W
Files
ReadString
R
name
WHILE
name
0X
DO
Texts
Write
W
9X
Texts
WriteString
W
name
Files
ReadInt
R
adr
Texts
WriteInt
W
adr
Texts
WriteLn
W
Files
ReadString
R
name
END
Sync
R
Texts
WriteString
W
entries
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
ReadInt
R
adr
Texts
WriteInt
W
adr
INC
i
END
Texts
WriteLn
W
Sync
R
Texts
WriteString
W
pointer
refs
Texts
WriteLn
W
Files
ReadInt
R
adr
WHILE
adr
DO
Texts
WriteInt
W
adr
Files
ReadInt
R
adr
END
Texts
WriteLn
W
Sync
R
Files
ReadInt
R
data
Texts
WriteString
W
fixP
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
fixD
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
fixT
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
entry
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
Read
R
ch
IF
ch
O
THEN
Texts
WriteString
W
format
eror
Texts
WriteLn
W
END
Sync
R
ELSE
Texts
WriteString
W
not
found
Texts
WriteLn
W
END
Texts
Append
Oberon
Log
W
buf
END
END
DecObj
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
ORTool
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
mnemo0
MOV
mnemo0
LSL
mnemo0
ASR
mnemo0
ROR
mnemo0
AND
mnemo0
ANN
mnemo0
IOR
mnemo0
XOR
mnemo0
ADD
mnemo0
SUB
mnemo0
MUL
mnemo0
DIV
mnemo0
FAD
mnemo0
FSB
mnemo0
FML
mnemo0
FDV
mnemo1
MI
mnemo1
PL
mnemo1
EQ
mnemo1
NE
mnemo1
LS
mnemo1
HI
mnemo1
LT
mnemo1
GE
mnemo1
LE
mnemo1
GT
mnemo1
NO
END
ORTool
MODULE
Rectangles
NW
IMPORT
SYSTEM
Display
Files
Input
Texts
Oberon
Graphics
GraphicFrames
TYPE
Rectangle
POINTER
TO
RectDesc
RectDesc
RECORD
Graphics
ObjectDesc
lw
vers
INTEGER
END
VAR
method
Graphics
Method
tack
grey
INTEGER
PROCEDURE
New
VAR
r
Rectangle
BEGIN
NEW
r
r
do
method
Graphics
New
r
END
New
PROCEDURE
Copy
src
dst
Graphics
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Rectangle
lw
src
Rectangle
lw
dst
Rectangle
vers
src
Rectangle
vers
END
Copy
PROCEDURE
mark
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
GraphicFrames
ReplConst
f
col
x
y
END
mark
PROCEDURE
Draw
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
lw
col
INTEGER
f
GraphicFrames
Frame
PROCEDURE
draw
f
GraphicFrames
Frame
col
x
y
w
h
lw
INTEGER
BEGIN
GraphicFrames
ReplConst
f
col
x
y
w
lw
Display
replace
GraphicFrames
ReplConst
f
col
x
w
lw
y
lw
h
Display
replace
GraphicFrames
ReplConst
f
col
x
y
h
lw
w
lw
Display
replace
GraphicFrames
ReplConst
f
col
x
y
lw
h
Display
replace
END
draw
BEGIN
CASE
M
OF
GraphicFrames
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
lw
obj
Rectangle
lw
IF
x
f
X1
x
w
f
X
y
f
Y1
y
h
f
Y
THEN
IF
M
col
Display
black
THEN
col
obj
col
ELSE
col
M
col
END
IF
M
mode
THEN
draw
f
col
x
y
w
h
lw
IF
obj
selected
THEN
mark
f
Display
white
x
y
END
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
normal
selected
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
selected
normal
ELSIF
M
mode
THEN
draw
f
Display
black
x
y
w
h
lw
mark
f
Display
black
x
y
erase
END
END
END
END
Draw
PROCEDURE
Selectable
obj
Graphics
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
y
y
y
obj
y
END
Selectable
PROCEDURE
Change
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x0
y0
x1
y1
dx
dy
INTEGER
k
SET
BEGIN
CASE
M
OF
Graphics
WidMsg
obj
Rectangle
lw
M
w
Graphics
ColorMsg
obj
col
M
col
END
END
Change
PROCEDURE
Read
obj
Graphics
Object
VAR
R
Files
Rider
VAR
C
Graphics
Context
VAR
b
BYTE
len
INTEGER
BEGIN
Files
ReadByte
R
b
len
Files
ReadByte
R
b
obj
Rectangle
lw
b
Files
ReadByte
R
b
obj
Rectangle
vers
b
END
Read
PROCEDURE
Write
obj
Graphics
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Graphics
Context
BEGIN
Graphics
WriteObj
W
cno
obj
Files
WriteByte
W
Files
WriteByte
W
obj
Rectangle
lw
Files
WriteByte
W
obj
Rectangle
vers
END
Write
PROCEDURE
Print
obj
Graphics
Object
x
y
INTEGER
VAR
w
h
lw
s
INTEGER
BEGIN
INC
x
obj
x
INC
y
obj
y
w
obj
w
h
obj
h
lw
obj
Rectangle
lw
s
obj
Rectangle
vers
Printer
ReplConst
x
y
w
lw
Printer
ReplConst
x
w
lw
y
lw
h
Printer
ReplConst
x
y
h
lw
w
lw
Printer
ReplConst
x
y
lw
h
IF
s
THEN
Printer
ReplPattern
x
y
w
h
s
END
END
Print
PROCEDURE
Make
command
VAR
x0
x1
y0
y1
INTEGER
R
Rectangle
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
x1
G
mark
next
x
y1
G
mark
next
y
NEW
R
R
col
Oberon
CurCol
R
w
ABS
x1
x0
R
h
ABS
y1
y0
IF
x1
x0
THEN
x0
x1
END
IF
y1
y0
THEN
y0
y1
END
R
x
x0
G
x
R
y
y0
G
y
R
lw
Graphics
width
R
vers
R
do
method
Graphics
Add
G
graph
R
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
R
END
END
Make
BEGIN
NEW
method
method
module
Rectangles
method
allocator
New
method
new
New
method
copy
Copy
method
draw
Draw
method
selectable
Selectable
method
change
Change
method
read
Read
method
write
Write
method
print
Print
tack
SYSTEM
ADR
grey
SYSTEM
ADR
END
Rectangles
MODULE
SCC
NW
Ceres
nRF24L01
version
PR
IMPORT
SYSTEM
Kernel
CONST
swi
spiData
spiCtrl
netSelect
spiFast
netEnable
HdrSize
MaxPayload
SubPacket
Wait
SendTries
MaxPacket
HdrSize
MaxPayload
SubPacket
DIV
SubPacket
SubPacket
TYPE
Header
RECORD
valid
BOOLEAN
dadr
sadr
typ
BYTE
len
INTEGER
of
data
following
header
END
VAR
filter
BOOLEAN
Adr
BYTE
rcvd
INTEGER
rx
RECORD
hd
Header
dat
ARRAY
MaxPacket
HdrSize
OF
BYTE
END
PROCEDURE
SPICtrl
s
SET
BEGIN
SYSTEM
PUT
spiCtrl
s
IF
netEnable
IN
s
THEN
LED
55H
ELSE
LED
END
END
SPICtrl
PROCEDURE
SPI
n
INTEGER
BEGIN
send
rcv
into
shift
reg
one
byte
or
word
at
current
speed
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
wait
until
done
END
SPI
PROCEDURE
StartCmd
cmd
INTEGER
BEGIN
SPICtrl
netSelect
SPI
cmd
END
StartCmd
PROCEDURE
WriteReg1
reg
dat
INTEGER
disables
radio
BEGIN
StartCmd
reg
20H
SPI
dat
SPICtrl
W
REGISTER
END
WriteReg1
PROCEDURE
SubRcv
dst
INTEGER
VAR
i
dat
INTEGER
BEGIN
StartCmd
061H
R
RX
PAYLOAD
disables
radio
SPICtrl
netSelect
spiFast
FOR
i
TO
SubPacket
BY
DO
SPI
SYSTEM
GET
spiData
dat
SYSTEM
PUT
dst
i
dat
END
SPICtrl
WriteReg1
40H
done
STATUS
clear
RX
DR
SPICtrl
netEnable
enable
radio
END
SubRcv
PROCEDURE
SubSnd
src
INTEGER
VAR
timeout
BOOLEAN
VAR
i
dat
res
t1
try
INTEGER
x
status
BYTE
BEGIN
already
in
xmit
mode
StartCmd
0A0H
W
TX
PAYLOAD
SPICtrl
netSelect
spiFast
FOR
i
TO
SubPacket
BY
DO
SYSTEM
GET
src
i
dat
SPI
dat
END
SPICtrl
end
W
TX
PAYLOAD
command
try
SPICtrl
netEnable
netSelect
start
xmit
pulse
start
NOP
cmd
REPEAT
t1
Kernel
Time
Wait
REPEAT
wait
for
sent
or
retransmits
exceeded
SPI
0FFH
SYSTEM
GET
spiData
status
NOP
res
status
DIV
10H
MOD
SPICtrl
SPICtrl
netSelect
end
restart
NOP
cmd
end
10us
pulse
on
enable
UNTIL
res
IF
res
THEN
WriteReg1
20H
TX
DS
sent
ack
received
reset
it
ELSIF
res
THEN
WriteReg1
10H
INC
try
MAX
RT
retransmits
exceeded
reset
it
IF
try
SendTries
THEN
res
ELSE
REPEAT
UNTIL
Kernel
Time
t1
SPICtrl
netEnable
netSelect
start
xmit
pulse
start
NOP
cmd
again
END
END
UNTIL
res
timeout
res
END
SubSnd
PROCEDURE
Flush
BEGIN
StartCmd
0E1H
SPICtrl
StartCmd
0E2H
SPICtrl
FLUSH
TX
FLUSH
RX
END
Flush
PROCEDURE
ResetRcv
BEGIN
SYSTEM
PUT
SYSTEM
ADR
rx
rx
hd
len
rcvd
END
ResetRcv
PROCEDURE
Listen
b
BOOLEAN
BEGIN
WriteReg1
07EH
ORD
b
CONFIG
mask
ints
EN
CRC
byte
PWR
UP
PRX
PTX
WriteReg1
70H
STATUS
clear
ints
IF
b
THEN
SPICtrl
netEnable
END
turn
radio
on
END
Listen
PROCEDURE
Start
filt
BOOLEAN
VAR
n
INTEGER
BEGIN
filter
filt
Adr
SYSTEM
GET
swi
n
n
n
DIV
MOD
10H
WriteReg1
n
RF
CH
channel
WriteReg1
07H
RF
SETUP
1Mb
for
better
range
0dBm
WriteReg1
11H
SubPacket
RX
PW
P0
pipe
payload
width
Flush
Listen
TRUE
ResetRcv
END
Start
PROCEDURE
SendPacket
VAR
head
Header
dat
ARRAY
OF
BYTE
VAR
len
i
off
INTEGER
timeout
BOOLEAN
payload
ARRAY
SubPacket
OF
BYTE
BEGIN
let
any
receive
ack
finish
before
turning
radio
off
i
Kernel
Time
Wait
REPEAT
SPICtrl
netEnable
netSelect
SPI
0FFH
SPICtrl
netEnable
NOP
UNTIL
Kernel
Time
i
IF
Adr
THEN
Adr
i
MOD
100H
END
Listen
FALSE
head
sadr
Adr
head
valid
TRUE
SYSTEM
COPY
SYSTEM
ADR
head
SYSTEM
ADR
payload
HdrSize
DIV
i
HdrSize
off
len
head
len
WHILE
len
i
SubPacket
DO
payload
i
dat
off
INC
i
INC
off
DEC
len
END
WHILE
i
SubPacket
DO
payload
i
INC
i
END
SubSnd
SYSTEM
ADR
payload
timeout
WHILE
timeout
len
DO
i
send
the
rest
WHILE
len
i
SubPacket
DO
payload
i
dat
off
INC
i
INC
off
DEC
len
END
WHILE
i
SubPacket
DO
payload
i
INC
i
END
SubSnd
SYSTEM
ADR
payload
timeout
END
Listen
TRUE
END
SendPacket
PROCEDURE
Available
INTEGER
BEGIN
packet
already
rcvd
RETURN
rx
hd
len
rcvd
END
Available
PROCEDURE
Receive
VAR
x
BYTE
BEGIN
packet
already
rcvd
IF
rcvd
rx
hd
len
THEN
x
rx
dat
rcvd
INC
rcvd
ELSE
x
END
END
Receive
PROCEDURE
Rcvd
time
INTEGER
BOOLEAN
VAR
status
fifoStatus
BYTE
rcvd
BOOLEAN
BEGIN
time
time
Kernel
Time
REPEAT
SPICtrl
netEnable
netSelect
SPI
17H
R
REGISTER
FIFO
STATUS
SYSTEM
GET
spiData
status
SPI
SYSTEM
GET
spiData
fifoStatus
SPICtrl
netEnable
rcvd
ODD
status
DIV
40H
OR
ODD
fifoStatus
RX
DR
data
ready
or
RX
FIFO
not
empty
UNTIL
rcvd
OR
Kernel
Time
time
RETURN
rcvd
END
Rcvd
PROCEDURE
ReceiveHead
VAR
head
Header
actually
recv
whole
packet
VAR
adr
n
INTEGER
BEGIN
head
valid
FALSE
IF
Rcvd
THEN
ResetRcv
adr
SYSTEM
ADR
rx
SubRcv
adr
n
rx
hd
len
HdrSize
DIV
SubPacket
IF
rx
hd
len
MaxPayload
rx
hd
dadr
0FFH
OR
filter
OR
Adr
OR
rx
hd
dadr
Adr
THEN
WHILE
n
Rcvd
Wait
DO
INC
adr
SubPacket
SubRcv
adr
DEC
n
END
rx
hd
valid
n
ELSE
WHILE
Rcvd
Wait
DO
SubRcv
adr
END
ResetRcv
discard
packet
END
head
rx
hd
END
END
ReceiveHead
PROCEDURE
Skip
m
INTEGER
VAR
dmy
BYTE
BEGIN
WHILE
m
DO
Receive
dmy
DEC
m
END
END
Skip
PROCEDURE
Stop
BEGIN
SPICtrl
Flush
ResetRcv
END
Stop
BEGIN
Start
TRUE
END
SCC
MODULE
System
JG
NW
NW
IMPORT
SYSTEM
Kernel
FileDir
Files
Modules
Input
Display
Viewers
Fonts
Texts
Oberon
MenuViewers
TextFrames
CONST
StandardMenu
System
Close
System
Copy
System
Grow
Edit
Search
Edit
Store
LogMenu
Edit
Locate
Edit
Search
System
Copy
System
Grow
System
Clear
VAR
W
Texts
Writer
pat
ARRAY
OF
CHAR
PROCEDURE
GetArg
VAR
S
Texts
Scanner
VAR
T
Texts
Text
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
END
GetArg
PROCEDURE
EndLine
BEGIN
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
EndLine
Toolbox
for
system
control
PROCEDURE
SetUser
VAR
i
INTEGER
ch
CHAR
user
ARRAY
OF
CHAR
password
ARRAY
OF
CHAR
BEGIN
i
Input
Read
ch
WHILE
ch
i
DO
user
i
ch
INC
i
Input
Read
ch
END
user
i
0X
i
Input
Read
ch
WHILE
ch
i
DO
password
i
ch
INC
i
Input
Read
ch
END
password
i
0X
Oberon
SetUser
user
password
END
SetUser
PROCEDURE
SetFont
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Oberon
SetFont
Fonts
This
S
s
END
END
SetFont
PROCEDURE
SetColor
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
Oberon
SetColor
S
i
END
END
SetColor
PROCEDURE
SetOffset
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
Oberon
SetOffset
S
i
END
END
SetOffset
PROCEDURE
Date
VAR
S
Texts
Scanner
dt
hr
min
sec
yr
mo
day
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
set
clock
day
S
i
Texts
Scan
S
mo
S
i
Texts
Scan
S
yr
S
i
Texts
Scan
S
hr
S
i
Texts
Scan
S
min
S
i
Texts
Scan
S
sec
S
i
dt
yr
mo
day
hr
min
sec
Kernel
SetClock
dt
ELSE
read
clock
Texts
WriteString
W
System
Clock
dt
Oberon
Clock
Texts
WriteClock
W
dt
EndLine
END
END
Date
PROCEDURE
Collect
BEGIN
Oberon
Collect
END
Collect
Toolbox
for
standard
display
PROCEDURE
Open
open
viewer
in
system
track
VAR
X
Y
INTEGER
V
Viewers
Viewer
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Clear
clear
Log
VAR
T
Texts
Text
F
Display
Frame
buf
Texts
Buffer
BEGIN
F
Oberon
Par
frame
IF
F
NIL
F
next
IS
TextFrames
Frame
F
Oberon
Par
vwr
dsc
THEN
NEW
buf
Texts
OpenBuf
buf
T
F
next
TextFrames
Frame
text
Texts
Delete
T
T
len
buf
END
END
Clear
PROCEDURE
Close
VAR
V
Viewers
Viewer
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
V
Oberon
Par
vwr
ELSE
V
Oberon
MarkedViewer
END
Viewers
Close
V
END
Close
PROCEDURE
CloseTrack
VAR
V
Viewers
Viewer
BEGIN
V
Oberon
MarkedViewer
Viewers
CloseTrack
V
X
END
CloseTrack
PROCEDURE
Recall
VAR
V
Viewers
Viewer
M
Viewers
ViewerMsg
BEGIN
Viewers
Recall
V
IF
V
NIL
V
state
THEN
Viewers
Open
V
V
X
V
Y
V
H
M
id
Viewers
restore
V
handle
V
M
END
END
Recall
PROCEDURE
Copy
VAR
V
V1
Viewers
Viewer
M
Oberon
CopyMsg
N
Viewers
ViewerMsg
BEGIN
V
Oberon
Par
vwr
V
handle
V
M
V1
M
F
Viewers
Viewer
Viewers
Open
V1
V
X
V
Y
V
H
DIV
N
id
Viewers
restore
V1
handle
V1
N
END
Copy
PROCEDURE
Grow
VAR
V
V1
Viewers
Viewer
M
Oberon
CopyMsg
N
Viewers
ViewerMsg
DW
DH
INTEGER
BEGIN
V
Oberon
Par
vwr
DW
Oberon
DisplayWidth
V
X
DH
Oberon
DisplayHeight
V
X
IF
V
H
DH
Viewers
minH
THEN
Oberon
OpenTrack
V
X
V
W
ELSIF
V
W
DW
THEN
Oberon
OpenTrack
Oberon
UserTrack
V
X
DW
END
IF
V
H
DH
Viewers
minH
OR
V
W
DW
THEN
V
handle
V
M
V1
M
F
Viewers
Viewer
Viewers
Open
V1
V
X
DH
N
id
Viewers
restore
V1
handle
V1
N
END
END
Grow
Toolbox
for
module
management
PROCEDURE
Free1
VAR
S
Texts
Scanner
BEGIN
Texts
WriteString
W
S
s
Texts
WriteString
W
unloading
Modules
Free
S
s
IF
Modules
res
THEN
Texts
WriteString
W
failed
END
EndLine
END
Free1
PROCEDURE
Free
VAR
T
Texts
Text
beg
end
time
LONGINT
S
Texts
Scanner
BEGIN
Texts
WriteString
W
System
Free
EndLine
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Free1
S
END
END
ELSE
WHILE
S
class
Texts
Name
DO
Free1
S
Texts
Scan
S
END
END
Oberon
Collect
END
Free
PROCEDURE
FreeFonts
BEGIN
Texts
WriteString
W
System
FreeFonts
Fonts
Free
EndLine
END
FreeFonts
Toolbox
of
file
system
PROCEDURE
List
name
FileDir
FileName
adr
LONGINT
VAR
cont
BOOLEAN
VAR
i0
i
j0
j
INTEGER
hp
FileDir
FileHeader
BEGIN
i
WHILE
pat
i
pat
i
name
i
DO
INC
i
END
IF
pat
i
0X
name
i
0X
THEN
i0
i
j0
i
ELSIF
pat
i
THEN
i0
i
j0
i
WHILE
name
i0
0X
DO
i
i0
j
j0
WHILE
name
i
0X
name
i
pat
j
DO
INC
i
INC
j
END
IF
pat
j
0X
THEN
IF
name
i
0X
THEN
match
j0
j
ELSE
INC
i0
END
ELSIF
pat
j
THEN
i0
i
j0
j
ELSE
INC
i0
END
END
END
IF
name
i0
0X
pat
j0
0X
THEN
found
Texts
WriteString
W
name
IF
pat
j0
THEN
option
Kernel
GetSector
adr
hp
Texts
Write
W
9X
Texts
WriteClock
W
hp
date
Texts
WriteInt
W
hp
aleng
FileDir
SectorSize
hp
bleng
FileDir
HeaderSize
length
Texts
WriteHex
W
adr
END
Texts
WriteLn
W
END
END
List
PROCEDURE
Directory
VAR
X
Y
i
INTEGER
ch
CHAR
R
Texts
Reader
T
t
Texts
Text
V
Viewers
Viewer
beg
end
time
LONGINT
pre
ARRAY
OF
CHAR
BEGIN
Texts
OpenReader
R
Oberon
Par
text
Oberon
Par
pos
Texts
Read
R
ch
WHILE
ch
DO
Texts
Read
R
ch
END
IF
ch
OR
ch
0DX
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenReader
R
T
beg
Texts
Read
R
ch
WHILE
ch
DO
Texts
Read
R
ch
END
END
END
i
WHILE
ch
DO
pat
i
ch
INC
i
Texts
Read
R
ch
END
pat
i
0X
IF
ch
THEN
pat
i
END
directory
option
i
WHILE
pat
i
DO
pre
i
pat
i
INC
i
END
pre
i
0X
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
t
TextFrames
Text
V
MenuViewers
New
TextFrames
NewMenu
System
Directory
StandardMenu
TextFrames
NewText
t
TextFrames
menuH
X
Y
FileDir
Enumerate
pre
List
Texts
Append
t
W
buf
END
Directory
PROCEDURE
CopyFiles
VAR
f
g
Files
File
Rf
Rg
Files
Rider
ch
CHAR
name
ARRAY
OF
CHAR
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
CopyFiles
EndLine
WHILE
S
class
Texts
Name
DO
name
S
s
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteString
W
copying
Texts
Append
Oberon
Log
W
buf
f
Files
Old
name
IF
f
NIL
THEN
g
Files
New
S
s
Files
Set
Rf
f
Files
Set
Rg
g
Files
Read
Rf
ch
WHILE
Rf
eof
DO
Files
Write
Rg
ch
Files
Read
Rf
ch
END
Files
Register
g
ELSE
Texts
WriteString
W
failed
END
EndLine
END
END
END
Texts
Scan
S
END
END
CopyFiles
PROCEDURE
RenameFiles
VAR
res
INTEGER
name
ARRAY
OF
CHAR
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
RenameFiles
EndLine
WHILE
S
class
Texts
Name
DO
name
S
s
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteString
W
renaming
Files
Rename
name
S
s
res
IF
res
THEN
Texts
WriteString
W
failed
END
EndLine
END
END
END
Texts
Scan
S
END
END
RenameFiles
PROCEDURE
DeleteFiles
VAR
res
INTEGER
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
DeleteFiles
EndLine
WHILE
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
Texts
WriteString
W
deleting
Files
Delete
S
s
res
IF
res
THEN
Texts
WriteString
W
failed
END
EndLine
Texts
Scan
S
END
END
DeleteFiles
Toolbox
for
system
inspection
PROCEDURE
Watch
BEGIN
Texts
WriteString
W
System
Watch
Texts
WriteLn
W
Texts
WriteString
W
Modules
space
bytes
Texts
WriteInt
W
Modules
AllocPtr
Texts
WriteInt
W
Modules
AllocPtr
DIV
Kernel
heapOrg
Texts
Write
W
EndLine
Texts
WriteString
W
Heap
speace
Texts
WriteInt
W
Kernel
allocated
Texts
WriteInt
W
Kernel
allocated
DIV
Kernel
heapLim
Kernel
heapOrg
Texts
Write
W
EndLine
Texts
WriteString
W
Disk
sectors
Texts
WriteInt
W
Kernel
NofSectors
Texts
WriteInt
W
Kernel
NofSectors
DIV
10000H
Texts
Write
W
EndLine
Texts
WriteString
W
Tasks
Texts
WriteInt
W
Oberon
NofTasks
EndLine
END
Watch
PROCEDURE
ShowModules
VAR
T
Texts
Text
V
Viewers
Viewer
M
Modules
Module
X
Y
INTEGER
BEGIN
T
TextFrames
Text
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
System
ShowModules
StandardMenu
TextFrames
NewText
T
TextFrames
menuH
X
Y
M
Modules
root
WHILE
M
NIL
DO
IF
M
name
0X
THEN
Texts
WriteString
W
M
name
Texts
Write
W
9X
Texts
WriteHex
W
ORD
M
Texts
WriteHex
W
M
code
Texts
WriteInt
W
M
refcnt
ELSE
Texts
WriteString
W
END
Texts
WriteLn
W
M
M
next
END
Texts
Append
T
W
buf
END
ShowModules
PROCEDURE
ShowCommands
VAR
M
Modules
Module
comadr
LONGINT
ch
CHAR
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
X
Y
INTEGER
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Modules
Load
S
s
M
IF
M
NIL
THEN
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
T
TextFrames
Text
V
MenuViewers
New
TextFrames
NewMenu
System
Commands
StandardMenu
TextFrames
NewText
T
TextFrames
menuH
X
Y
comadr
M
cmd
SYSTEM
GET
comadr
ch
INC
comadr
WHILE
ch
0X
DO
Texts
WriteString
W
S
s
Texts
Write
W
REPEAT
Texts
Write
W
ch
SYSTEM
GET
comadr
ch
INC
comadr
UNTIL
ch
0X
WHILE
comadr
MOD
DO
INC
comadr
END
Texts
WriteLn
W
INC
comadr
SYSTEM
GET
comadr
ch
INC
comadr
END
Texts
Append
T
W
buf
END
END
END
ShowCommands
PROCEDURE
ShowFonts
VAR
fnt
Fonts
Font
BEGIN
Texts
WriteString
W
System
ShowFonts
Texts
WriteLn
W
fnt
Fonts
root
WHILE
fnt
NIL
DO
Texts
Write
W
9X
Texts
WriteString
W
fnt
name
Texts
WriteLn
W
fnt
fnt
next
END
Texts
Append
Oberon
Log
W
buf
END
ShowFonts
PROCEDURE
OpenViewers
VAR
logV
toolV
Viewers
Viewer
menu
main
Display
Frame
d
LONGINT
X
Y
INTEGER
BEGIN
d
Kernel
Clock
Texts
WriteString
W
Oberon
V5
NW
EndLine
Oberon
AllocateSystemViewer
X
Y
menu
TextFrames
NewMenu
System
Log
LogMenu
main
TextFrames
NewText
Oberon
Log
logV
MenuViewers
New
menu
main
TextFrames
menuH
X
Y
Oberon
AllocateSystemViewer
X
Y
menu
TextFrames
NewMenu
System
Tool
StandardMenu
main
TextFrames
NewText
TextFrames
Text
System
Tool
toolV
MenuViewers
New
menu
main
TextFrames
menuH
X
Y
END
OpenViewers
PROCEDURE
ExtendDisplay
VAR
V
Viewers
Viewer
X
Y
DX
DW
DH
INTEGER
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
DX
Viewers
curW
DW
Oberon
DisplayWidth
DX
DH
Oberon
DisplayHeight
DX
Oberon
OpenDisplay
DW
DIV
DW
DIV
DH
Oberon
AllocateSystemViewer
DX
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
ExtendDisplay
PROCEDURE
Trap
VAR
a
INTEGER
b
INTEGER
VAR
u
v
w
INTEGER
mod
Modules
Module
BEGIN
u
SYSTEM
REG
SYSTEM
GET
u
v
w
v
DIV
10H
MOD
10H
trap
number
IF
w
THEN
Kernel
New
a
b
ELSE
trap
Texts
WriteLn
W
Texts
WriteString
W
pos
Texts
WriteInt
W
v
DIV
100H
MOD
10000H
Texts
WriteString
W
TRAP
Texts
WriteInt
W
w
mod
Modules
root
WHILE
mod
NIL
u
mod
code
OR
u
mod
imp
DO
mod
mod
next
END
IF
mod
NIL
THEN
Texts
WriteString
W
in
Texts
WriteString
W
mod
name
END
Texts
WriteString
W
at
Texts
WriteHex
W
u
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Oberon
Reset
END
END
Trap
PROCEDURE
Abort
VAR
n
INTEGER
BEGIN
n
SYSTEM
REG
Texts
WriteString
W
ABORT
Texts
WriteHex
W
n
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Oberon
Reset
END
Abort
BEGIN
Texts
OpenWriter
W
Oberon
OpenLog
TextFrames
Text
OpenViewers
Kernel
Install
SYSTEM
ADR
Trap
20H
Kernel
Install
SYSTEM
ADR
Abort
END
System
MODULE
TextFrames
JG
NW
IMPORT
Modules
Input
Display
Viewers
Fonts
Texts
Oberon
MenuViewers
CONST
replace
insert
delete
unmark
message
id
BS
8X
TAB
9X
CR
0DX
DEL
7FX
TYPE
Line
POINTER
TO
LineDesc
LineDesc
RECORD
len
LONGINT
wid
INTEGER
eot
BOOLEAN
next
Line
END
Location
RECORD
org
pos
LONGINT
dx
x
y
INTEGER
lin
Line
END
Frame
POINTER
TO
FrameDesc
FrameDesc
RECORD
Display
FrameDesc
text
Texts
Text
org
LONGINT
col
INTEGER
lsp
INTEGER
left
right
top
bot
INTEGER
markH
INTEGER
time
LONGINT
hasCar
hasSel
hasMark
BOOLEAN
carloc
Location
selbeg
selend
Location
trailer
Line
END
UpdateMsg
RECORD
Display
FrameMsg
id
INTEGER
text
Texts
Text
beg
end
LONGINT
END
CopyOverMsg
RECORD
Display
FrameMsg
text
Texts
Text
beg
end
LONGINT
END
VAR
TBuf
DelBuf
Texts
Buffer
menuH
barW
left
right
top
bot
lsp
INTEGER
standard
sizes
asr
dsr
selH
markW
eolW
INTEGER
nextCh
CHAR
ScrollMarker
Oberon
Marker
W
KW
Texts
Writer
keyboard
writer
PROCEDURE
Min
i
j
INTEGER
INTEGER
BEGIN
IF
i
j
THEN
j
i
END
RETURN
j
END
Min
display
support
PROCEDURE
ReplConst
col
INTEGER
F
Frame
X
Y
W
H
INTEGER
mode
INTEGER
BEGIN
IF
X
W
F
X
F
W
THEN
Display
ReplConst
col
X
Y
W
H
mode
ELSIF
X
F
X
F
W
THEN
Display
ReplConst
col
X
Y
F
X
F
W
X
H
mode
END
END
ReplConst
PROCEDURE
FlipSM
X
Y
INTEGER
VAR
DW
DH
CL
INTEGER
BEGIN
DW
Display
Width
DH
Display
Height
CL
DW
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
updown
X
Y
Display
invert
END
FlipSM
PROCEDURE
UpdateMark
F
Frame
in
scroll
bar
VAR
oldH
INTEGER
BEGIN
oldH
F
markH
F
markH
F
org
F
H
DIV
F
text
len
IF
F
hasMark
F
left
barW
F
markH
oldH
THEN
Display
ReplConst
Display
white
F
X
F
Y
F
H
oldH
markW
Display
invert
Display
ReplConst
Display
white
F
X
F
Y
F
H
F
markH
markW
Display
invert
END
END
UpdateMark
PROCEDURE
SetChangeMark
F
Frame
on
BOOLEAN
in
corner
BEGIN
IF
F
H
menuH
THEN
IF
on
THEN
Display
CopyPattern
Display
white
Display
block
F
X
F
W
F
Y
F
H
Display
paint
ELSE
Display
ReplConst
F
col
F
X
F
W
F
Y
F
H
Display
replace
END
END
END
SetChangeMark
PROCEDURE
Width
VAR
R
Texts
Reader
len
LONGINT
INTEGER
VAR
patadr
pos
LONGINT
ox
dx
x
y
w
h
INTEGER
BEGIN
pos
ox
WHILE
pos
len
DO
Fonts
GetPat
R
fnt
nextCh
dx
x
y
w
h
patadr
ox
ox
dx
INC
pos
Texts
Read
R
nextCh
END
RETURN
ox
END
Width
PROCEDURE
DisplayLine
F
Frame
L
Line
VAR
R
Texts
Reader
X
Y
INTEGER
len
LONGINT
VAR
patadr
NX
dx
x
y
w
h
INTEGER
BEGIN
NX
F
X
F
W
WHILE
nextCh
CR
R
fnt
NIL
DO
Fonts
GetPat
R
fnt
nextCh
dx
x
y
w
h
patadr
IF
X
x
w
NX
h
THEN
Display
CopyPattern
R
col
patadr
X
x
Y
y
Display
invert
END
X
X
dx
INC
len
Texts
Read
R
nextCh
END
L
len
len
L
wid
X
eolW
F
X
F
left
L
eot
R
fnt
NIL
Texts
Read
R
nextCh
END
DisplayLine
PROCEDURE
Validate
T
Texts
Text
VAR
pos
LONGINT
VAR
R
Texts
Reader
BEGIN
IF
pos
T
len
THEN
pos
T
len
ELSIF
pos
THEN
DEC
pos
Texts
OpenReader
R
T
pos
REPEAT
Texts
Read
R
nextCh
INC
pos
UNTIL
R
eot
OR
nextCh
CR
ELSE
pos
END
END
Validate
PROCEDURE
Mark
F
Frame
on
BOOLEAN
BEGIN
IF
F
H
F
left
barW
F
hasMark
on
OR
F
hasMark
on
THEN
Display
ReplConst
Display
white
F
X
F
Y
F
H
F
markH
markW
Display
invert
END
F
hasMark
on
END
Mark
PROCEDURE
Restore
F
Frame
VAR
R
Texts
Reader
L
l
Line
curY
botY
INTEGER
BEGIN
Display
ReplConst
F
col
F
X
F
Y
F
W
F
H
Display
replace
IF
F
left
barW
THEN
Display
ReplConst
Display
white
F
X
barW
F
Y
F
H
Display
invert
END
Validate
F
text
F
org
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
F
org
Texts
Read
R
nextCh
L
F
trailer
curY
F
Y
F
H
F
top
asr
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
F
markH
F
org
F
H
DIV
F
text
len
END
Restore
PROCEDURE
Suspend
F
Frame
BEGIN
F
trailer
next
F
trailer
END
Suspend
PROCEDURE
Extend
F
Frame
newY
INTEGER
VAR
R
Texts
Reader
L
l
Line
org
LONGINT
curY
botY
INTEGER
BEGIN
Display
ReplConst
F
col
F
X
newY
F
W
F
Y
newY
Display
replace
IF
F
left
barW
THEN
Display
ReplConst
Display
white
F
X
barW
newY
F
Y
newY
Display
invert
END
botY
F
Y
F
bot
dsr
F
H
F
H
F
Y
newY
F
Y
newY
IF
F
trailer
next
F
trailer
THEN
Validate
F
text
F
org
END
L
F
trailer
org
F
org
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
org
org
L
len
curY
curY
lsp
END
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
F
markH
F
org
F
H
DIV
F
text
len
END
Extend
PROCEDURE
Reduce
F
Frame
newY
INTEGER
VAR
L
Line
curY
botY
INTEGER
BEGIN
F
H
F
H
F
Y
newY
F
Y
newY
botY
F
Y
F
bot
dsr
L
F
trailer
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
curY
curY
lsp
END
L
next
F
trailer
IF
curY
asr
F
Y
THEN
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
asr
F
Y
Display
replace
END
F
markH
F
org
F
H
DIV
F
text
len
Mark
F
TRUE
END
Reduce
PROCEDURE
Show
F
Frame
pos
LONGINT
VAR
R
Texts
Reader
L
L0
Line
org
LONGINT
curY
botY
Y0
INTEGER
BEGIN
IF
F
trailer
next
F
trailer
THEN
Validate
F
text
pos
IF
pos
F
org
THEN
Mark
F
FALSE
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
F
H
Display
replace
botY
F
Y
F
Y
F
Y
F
H
F
H
F
org
pos
F
trailer
next
F
trailer
Extend
F
botY
Mark
F
TRUE
ELSIF
pos
F
org
THEN
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
org
pos
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
org
pos
THEN
F
org
org
F
trailer
next
L
Y0
curY
WHILE
L
next
F
trailer
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
Display
CopyBlock
F
X
F
left
curY
dsr
F
W
F
left
Y0
asr
curY
dsr
F
X
F
left
curY
dsr
F
Y
F
H
F
top
asr
Y0
curY
curY
F
Y
F
H
F
top
asr
Y0
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
dsr
F
Y
Display
replace
botY
F
Y
F
bot
dsr
org
org
L
len
curY
curY
lsp
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
L0
DisplayLine
F
L0
R
F
X
F
left
curY
L
next
L0
L
L0
curY
curY
lsp
END
L
next
F
trailer
UpdateMark
F
ELSE
Mark
F
FALSE
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
F
H
Display
replace
botY
F
Y
F
Y
F
Y
F
H
F
H
F
org
pos
F
trailer
next
F
trailer
Extend
F
botY
Mark
F
TRUE
END
END
END
SetChangeMark
F
F
text
changed
END
Show
PROCEDURE
LocateLine
F
Frame
y
INTEGER
VAR
loc
Location
VAR
L
Line
org
LONGINT
cury
INTEGER
BEGIN
org
F
org
L
F
trailer
next
cury
F
H
F
top
asr
WHILE
L
next
F
trailer
cury
y
dsr
DO
org
org
L
len
L
L
next
cury
cury
lsp
END
loc
org
org
loc
lin
L
loc
y
cury
END
LocateLine
PROCEDURE
LocateString
F
Frame
x
y
INTEGER
VAR
loc
Location
VAR
R
Texts
Reader
patadr
bpos
pos
lim
LONGINT
bx
ex
ox
dx
u
v
w
h
INTEGER
BEGIN
LocateLine
F
y
loc
lim
loc
org
loc
lin
len
bpos
loc
org
bx
F
left
pos
loc
org
ox
F
left
Texts
OpenReader
R
F
text
loc
org
Texts
Read
R
nextCh
REPEAT
WHILE
pos
lim
nextCh
DO
scan
string
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
END
ex
ox
WHILE
pos
lim
nextCh
DO
scan
gap
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
END
IF
pos
lim
ox
x
THEN
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
bpos
pos
bx
ox
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
ELSE
pos
lim
END
UNTIL
pos
lim
loc
pos
bpos
loc
dx
ex
bx
loc
x
bx
END
LocateString
PROCEDURE
LocateChar
F
Frame
x
y
INTEGER
VAR
loc
Location
VAR
R
Texts
Reader
patadr
pos
lim
LONGINT
ox
dx
u
v
w
h
INTEGER
BEGIN
LocateLine
F
y
loc
lim
loc
org
loc
lin
len
pos
loc
org
ox
F
left
dx
eolW
Texts
OpenReader
R
F
text
loc
org
WHILE
pos
lim
DO
Texts
Read
R
nextCh
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
IF
ox
dx
x
THEN
INC
pos
ox
ox
dx
IF
pos
lim
THEN
dx
eolW
END
ELSE
lim
pos
END
END
loc
pos
pos
loc
dx
dx
loc
x
ox
END
LocateChar
PROCEDURE
LocatePos
F
Frame
pos
LONGINT
VAR
loc
Location
VAR
T
Texts
Text
R
Texts
Reader
L
Line
org
LONGINT
cury
INTEGER
BEGIN
T
F
text
org
F
org
L
F
trailer
next
cury
F
H
F
top
asr
IF
pos
org
THEN
pos
org
END
WHILE
L
next
F
trailer
pos
org
L
len
DO
org
org
L
len
L
L
next
cury
cury
lsp
END
IF
pos
org
L
len
THEN
pos
org
L
len
END
Texts
OpenReader
R
T
org
Texts
Read
R
nextCh
loc
org
org
loc
pos
pos
loc
lin
L
loc
x
F
left
Width
R
pos
org
loc
y
cury
END
LocatePos
PROCEDURE
Pos
F
Frame
X
Y
INTEGER
LONGINT
VAR
loc
Location
BEGIN
LocateChar
F
X
F
X
Y
F
Y
loc
RETURN
loc
pos
END
Pos
PROCEDURE
FlipCaret
F
Frame
BEGIN
IF
F
carloc
x
F
W
F
carloc
y
F
carloc
x
F
W
THEN
Display
CopyPattern
Display
white
Display
hook
F
X
F
carloc
x
F
Y
F
carloc
y
Display
invert
END
END
FlipCaret
PROCEDURE
SetCaret
F
Frame
pos
LONGINT
BEGIN
LocatePos
F
pos
F
carloc
FlipCaret
F
F
hasCar
TRUE
END
SetCaret
PROCEDURE
TrackCaret
F
Frame
X
Y
INTEGER
VAR
keysum
SET
VAR
loc
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateChar
F
X
F
X
Y
F
Y
F
carloc
FlipCaret
F
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateChar
F
X
F
X
Y
F
Y
loc
IF
loc
pos
F
carloc
pos
THEN
FlipCaret
F
F
carloc
loc
FlipCaret
F
END
UNTIL
keys
F
hasCar
TRUE
END
END
TrackCaret
PROCEDURE
RemoveCaret
F
Frame
BEGIN
IF
F
hasCar
THEN
FlipCaret
F
F
hasCar
FALSE
END
END
RemoveCaret
PROCEDURE
FlipSelection
F
Frame
VAR
beg
end
Location
VAR
L
Line
Y
INTEGER
BEGIN
L
beg
lin
Y
F
Y
beg
y
IF
L
end
lin
THEN
ReplConst
Display
white
F
F
X
beg
x
Y
end
x
beg
x
selH
Display
invert
ELSE
ReplConst
Display
white
F
F
X
beg
x
Y
F
left
L
wid
beg
x
selH
Display
invert
L
L
next
Y
Y
lsp
WHILE
L
end
lin
DO
ReplConst
Display
white
F
F
X
F
left
Y
L
wid
selH
Display
invert
L
L
next
Y
Y
lsp
END
ReplConst
Display
white
F
F
X
F
left
Y
end
x
F
left
selH
Display
invert
END
END
FlipSelection
PROCEDURE
SetSelection
F
Frame
beg
end
LONGINT
BEGIN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
END
LocatePos
F
beg
F
selbeg
LocatePos
F
end
F
selend
IF
F
selbeg
pos
F
selend
pos
THEN
FlipSelection
F
F
selbeg
F
selend
F
time
Oberon
Time
F
hasSel
TRUE
END
END
SetSelection
PROCEDURE
TrackSelection
F
Frame
X
Y
INTEGER
VAR
keysum
SET
VAR
loc
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
END
LocateChar
F
X
F
X
Y
F
Y
loc
IF
F
hasSel
loc
pos
F
selbeg
pos
F
selend
pos
F
selbeg
pos
THEN
LocateChar
F
F
left
Y
F
Y
F
selbeg
ELSE
F
selbeg
loc
END
INC
loc
pos
loc
x
loc
x
loc
dx
F
selend
loc
FlipSelection
F
F
selbeg
F
selend
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateChar
F
X
F
X
Y
F
Y
loc
IF
loc
pos
F
selbeg
pos
THEN
loc
F
selbeg
END
INC
loc
pos
loc
x
loc
x
loc
dx
IF
loc
pos
F
selend
pos
THEN
FlipSelection
F
loc
F
selend
F
selend
loc
ELSIF
loc
pos
F
selend
pos
THEN
FlipSelection
F
F
selend
loc
F
selend
loc
END
UNTIL
keys
F
time
Oberon
Time
F
hasSel
TRUE
END
END
TrackSelection
PROCEDURE
RemoveSelection
F
Frame
BEGIN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
F
hasSel
FALSE
END
END
RemoveSelection
PROCEDURE
TrackLine
F
Frame
X
Y
INTEGER
VAR
org
LONGINT
VAR
keysum
SET
VAR
old
new
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateLine
F
Y
F
Y
old
ReplConst
Display
white
F
F
X
F
left
F
Y
old
y
dsr
old
lin
wid
Display
invert
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouse
ScrollMarker
X
Y
LocateLine
F
Y
F
Y
new
IF
new
org
old
org
THEN
ReplConst
Display
white
F
F
X
F
left
F
Y
old
y
dsr
old
lin
wid
Display
invert
ReplConst
Display
white
F
F
X
F
left
F
Y
new
y
dsr
new
lin
wid
Display
invert
old
new
END
UNTIL
keys
ReplConst
Display
white
F
F
X
F
left
F
Y
new
y
dsr
new
lin
wid
Display
invert
org
new
org
ELSE
org
END
END
TrackLine
PROCEDURE
TrackWord
F
Frame
X
Y
INTEGER
VAR
pos
LONGINT
VAR
keysum
SET
VAR
old
new
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateString
F
X
F
X
Y
F
Y
old
ReplConst
Display
white
F
F
X
old
x
F
Y
old
y
dsr
old
dx
Display
invert
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateString
F
X
F
X
Y
F
Y
new
IF
new
pos
old
pos
THEN
ReplConst
Display
white
F
F
X
old
x
F
Y
old
y
dsr
old
dx
Display
invert
ReplConst
Display
white
F
F
X
new
x
F
Y
new
y
dsr
new
dx
Display
invert
old
new
END
UNTIL
keys
ReplConst
Display
white
F
F
X
new
x
F
Y
new
y
dsr
new
dx
Display
invert
pos
new
pos
ELSE
pos
END
END
TrackWord
PROCEDURE
Replace
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
Line
org
len
LONGINT
curY
wid
INTEGER
BEGIN
IF
end
F
org
THEN
IF
beg
F
org
THEN
beg
F
org
END
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
len
beg
org
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
curY
dsr
L
wid
wid
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
wid
curY
len
org
org
L
len
L
L
next
curY
curY
lsp
WHILE
L
F
trailer
org
end
DO
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
curY
org
org
L
len
L
L
next
curY
curY
lsp
END
END
END
UpdateMark
F
END
Replace
PROCEDURE
Insert
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
L0
l
Line
org
len
LONGINT
curY
botY
Y0
Y1
Y2
dY
wid
INTEGER
BEGIN
IF
beg
F
org
THEN
F
org
F
org
end
beg
ELSE
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
len
beg
org
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
curY
dsr
L
wid
wid
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
wid
curY
len
org
org
L
len
curY
curY
lsp
Y0
curY
L0
L
next
WHILE
org
end
curY
botY
DO
NEW
l
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
org
org
L
len
curY
curY
lsp
END
IF
L0
L
next
THEN
Y1
curY
L
next
L0
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
curY
curY
lsp
END
L
next
F
trailer
dY
Y0
Y1
IF
Y1
curY
dY
THEN
Display
CopyBlock
F
X
F
left
curY
dY
lsp
dsr
F
W
F
left
Y1
curY
dY
F
X
F
left
curY
lsp
dsr
Y2
Y1
dY
ELSE
Y2
curY
END
curY
Y1
L
L0
WHILE
curY
Y2
DO
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
curY
L
L
next
curY
curY
lsp
END
END
END
END
UpdateMark
F
END
Insert
PROCEDURE
Delete
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
L0
l
Line
org
org0
len
LONGINT
curY
botY
Y0
Y1
wid
INTEGER
BEGIN
IF
end
F
org
THEN
F
org
F
org
end
beg
ELSE
IF
beg
F
org
THEN
F
trailer
next
len
F
trailer
next
len
F
org
beg
F
org
beg
END
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
botY
F
Y
F
bot
dsr
org0
org
L0
L
Y0
curY
WHILE
L
F
trailer
org
end
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
Y1
curY
Texts
OpenReader
R
F
text
org0
Texts
Read
R
nextCh
len
beg
org0
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
Y0
dsr
L0
wid
wid
lsp
Display
replace
DisplayLine
F
L0
R
F
X
F
left
wid
Y0
len
Y0
Y0
lsp
IF
L
L0
next
THEN
L0
next
L
L
L0
org
org0
L0
len
WHILE
L
next
F
trailer
DO
L
L
next
org
org
L
len
curY
curY
lsp
END
Display
CopyBlock
F
X
F
left
curY
lsp
dsr
F
W
F
left
Y1
curY
F
X
F
left
curY
lsp
dsr
Y0
Y1
curY
curY
Y0
Y1
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
lsp
F
Y
dsr
Display
replace
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
END
END
END
UpdateMark
F
END
Delete
PROCEDURE
Recall
VAR
B
Texts
Buffer
BEGIN
B
TBuf
NEW
TBuf
Texts
OpenBuf
TBuf
END
Recall
message
handling
PROCEDURE
RemoveMarks
F
Frame
BEGIN
RemoveCaret
F
RemoveSelection
F
END
RemoveMarks
PROCEDURE
NotifyDisplay
T
Texts
Text
op
INTEGER
beg
end
LONGINT
VAR
M
UpdateMsg
BEGIN
M
id
op
M
text
T
M
beg
beg
M
end
end
Viewers
Broadcast
M
END
NotifyDisplay
PROCEDURE
Call
F
Frame
pos
LONGINT
new
BOOLEAN
VAR
S
Texts
Scanner
res
INTEGER
BEGIN
Texts
OpenScanner
S
F
text
pos
Texts
Scan
S
IF
S
class
Texts
Name
S
line
THEN
Oberon
SetPar
F
F
text
pos
S
len
Oberon
Call
S
s
res
IF
res
THEN
Texts
WriteString
W
Call
error
Texts
WriteString
W
Modules
importing
IF
res
THEN
Texts
WriteString
W
module
not
found
ELSIF
res
THEN
Texts
WriteString
W
bad
version
ELSIF
res
THEN
Texts
WriteString
W
imports
Texts
WriteString
W
Modules
imported
Texts
WriteString
W
with
bad
key
ELSIF
res
THEN
Texts
WriteString
W
corrupted
obj
file
ELSIF
res
THEN
Texts
WriteString
W
command
not
found
ELSIF
res
THEN
Texts
WriteString
W
insufficient
space
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
END
Call
PROCEDURE
Write
F
Frame
ch
CHAR
fnt
Fonts
Font
col
voff
INTEGER
VAR
buf
Texts
Buffer
BEGIN
F
hasCar
IF
ch
BS
THEN
backspace
IF
F
carloc
pos
F
org
THEN
Texts
Delete
F
text
F
carloc
pos
F
carloc
pos
DelBuf
SetCaret
F
F
carloc
pos
END
ELSIF
ch
3X
THEN
ctrl
c
copy
IF
F
hasSel
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Save
F
text
F
selbeg
pos
F
selend
pos
TBuf
END
ELSIF
ch
16X
THEN
ctrl
v
paste
NEW
buf
Texts
OpenBuf
buf
Texts
Copy
TBuf
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
TBuf
len
ELSIF
ch
18X
THEN
ctrl
x
cut
IF
F
hasSel
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Delete
F
text
F
selbeg
pos
F
selend
pos
TBuf
END
ELSIF
20X
ch
ch
DEL
OR
ch
CR
OR
ch
TAB
THEN
KW
fnt
fnt
KW
col
col
KW
voff
voff
Texts
Write
KW
ch
Texts
Insert
F
text
F
carloc
pos
KW
buf
SetCaret
F
F
carloc
pos
END
END
Write
PROCEDURE
Defocus
F
Frame
BEGIN
RemoveCaret
F
END
Defocus
PROCEDURE
Neutralize
F
Frame
BEGIN
RemoveMarks
F
END
Neutralize
PROCEDURE
Modify
F
Frame
id
dY
Y
H
INTEGER
BEGIN
Mark
F
FALSE
RemoveMarks
F
SetChangeMark
F
FALSE
IF
id
MenuViewers
extend
THEN
IF
dY
THEN
Display
CopyBlock
F
X
F
Y
F
W
F
H
F
X
F
Y
dY
F
Y
F
Y
dY
END
Extend
F
Y
ELSIF
id
MenuViewers
reduce
THEN
Reduce
F
Y
dY
IF
dY
THEN
Display
CopyBlock
F
X
F
Y
F
W
F
H
F
X
Y
F
Y
Y
END
END
IF
F
H
THEN
Mark
F
TRUE
SetChangeMark
F
F
text
changed
END
END
Modify
PROCEDURE
Open
F
Frame
H
Display
Handler
T
Texts
Text
org
LONGINT
col
left
right
top
bot
lsp
INTEGER
VAR
L
Line
BEGIN
NEW
L
L
len
L
wid
L
eot
FALSE
L
next
L
F
handle
H
F
text
T
F
org
org
F
trailer
L
F
left
left
F
right
right
F
top
top
F
bot
bot
F
lsp
lsp
F
col
col
F
hasMark
FALSE
F
hasCar
FALSE
F
hasSel
FALSE
END
Open
PROCEDURE
Copy
F
Frame
VAR
F1
Frame
BEGIN
NEW
F1
Open
F1
F
handle
F
text
F
org
F
col
F
left
F
right
F
top
F
bot
F
lsp
END
Copy
PROCEDURE
CopyOver
F
Frame
text
Texts
Text
beg
end
LONGINT
VAR
buf
Texts
Buffer
BEGIN
IF
F
hasCar
THEN
NEW
buf
Texts
OpenBuf
buf
Texts
Save
text
beg
end
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
end
beg
END
END
CopyOver
PROCEDURE
GetSelection
F
Frame
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
BEGIN
IF
F
hasSel
THEN
IF
F
text
text
THEN
IF
F
selbeg
pos
beg
THEN
beg
F
selbeg
pos
END
leftmost
IF
F
time
time
THEN
end
F
selend
pos
time
F
time
END
last
selected
ELSIF
F
time
time
THEN
text
F
text
beg
F
selbeg
pos
end
F
selend
pos
time
F
time
END
END
END
GetSelection
PROCEDURE
Update
F
Frame
VAR
M
UpdateMsg
BEGIN
F
text
M
text
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
IF
M
id
replace
THEN
Replace
F
M
beg
M
end
ELSIF
M
id
insert
THEN
Insert
F
M
beg
M
end
ELSIF
M
id
delete
THEN
Delete
F
M
beg
M
end
END
SetChangeMark
F
F
text
changed
END
Update
PROCEDURE
Edit
F
Frame
X
Y
INTEGER
Keys
SET
VAR
M
CopyOverMsg
text
Texts
Text
buf
Texts
Buffer
v
Viewers
Viewer
beg
end
time
pos
LONGINT
keysum
SET
fnt
Fonts
Font
col
voff
INTEGER
BEGIN
IF
X
F
X
Min
F
left
barW
THEN
scroll
bar
Oberon
DrawMouse
ScrollMarker
X
Y
keysum
Keys
IF
Keys
THEN
ML
scroll
up
TrackLine
F
X
Y
pos
keysum
IF
pos
keysum
THEN
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
pos
END
ELSIF
Keys
THEN
MM
keysum
Keys
REPEAT
Input
Mouse
Keys
X
Y
keysum
keysum
Keys
Oberon
DrawMouse
ScrollMarker
X
Y
UNTIL
Keys
IF
keysum
THEN
IF
IN
keysum
THEN
pos
ELSIF
IN
keysum
THEN
pos
F
text
len
ELSE
pos
F
Y
F
H
Y
F
text
len
DIV
F
H
END
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
pos
END
ELSIF
Keys
THEN
MR
scroll
down
TrackLine
F
X
Y
pos
keysum
IF
keysum
THEN
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
F
org
pos
END
END
ELSE
text
area
Oberon
DrawMouseArrow
X
Y
IF
IN
Keys
THEN
MR
select
TrackSelection
F
X
Y
keysum
IF
F
hasSel
THEN
IF
keysum
THEN
MR
ML
delete
text
Oberon
GetSelection
text
beg
end
time
Texts
Delete
text
beg
end
TBuf
Oberon
PassFocus
Viewers
This
F
X
F
Y
SetCaret
F
beg
ELSIF
keysum
THEN
MR
MM
copy
to
caret
Oberon
GetSelection
text
beg
end
time
M
text
text
M
beg
beg
M
end
end
Oberon
FocusViewer
handle
Oberon
FocusViewer
M
END
END
ELSIF
IN
Keys
THEN
MM
call
TrackWord
F
X
Y
pos
keysum
IF
pos
IN
keysum
THEN
Call
F
pos
IN
keysum
END
ELSIF
IN
Keys
THEN
ML
set
caret
Oberon
PassFocus
Viewers
This
F
X
F
Y
TrackCaret
F
X
Y
keysum
IF
keysum
THEN
ML
MM
copy
from
selection
to
caret
Oberon
GetSelection
text
beg
end
time
IF
time
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Save
text
beg
end
TBuf
Texts
Insert
F
text
F
carloc
pos
TBuf
SetSelection
F
F
carloc
pos
F
carloc
pos
end
beg
SetCaret
F
F
carloc
pos
end
beg
ELSIF
TBuf
NIL
THEN
NEW
buf
Texts
OpenBuf
buf
Texts
Copy
TBuf
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
buf
len
END
ELSIF
keysum
THEN
ML
MR
copy
looks
Oberon
GetSelection
text
beg
end
time
IF
time
THEN
Texts
Attributes
F
text
F
carloc
pos
fnt
col
voff
IF
fnt
NIL
THEN
Texts
ChangeLooks
text
beg
end
fnt
col
voff
END
END
END
END
END
END
Edit
PROCEDURE
Handle
F
Display
Frame
VAR
M
Display
FrameMsg
VAR
F1
Frame
buf
Texts
Buffer
BEGIN
CASE
F
OF
Frame
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
Edit
F
M
X
M
Y
M
keys
ELSIF
M
id
Oberon
consume
THEN
IF
F
hasCar
THEN
Write
F
M
ch
M
fnt
M
col
M
voff
END
END
Oberon
ControlMsg
IF
M
id
Oberon
defocus
THEN
Defocus
F
ELSIF
M
id
Oberon
neutralize
THEN
Neutralize
F
END
Oberon
SelectionMsg
GetSelection
F
M
text
M
beg
M
end
M
time
Oberon
CopyMsg
Copy
F
F1
M
F
F1
MenuViewers
ModifyMsg
Modify
F
M
id
M
dY
M
Y
M
H
CopyOverMsg
CopyOver
F
M
text
M
beg
M
end
UpdateMsg
IF
F
text
M
text
THEN
Update
F
M
END
END
END
END
Handle
creation
PROCEDURE
Menu
name
commands
ARRAY
OF
CHAR
Texts
Text
VAR
T
Texts
Text
BEGIN
NEW
T
T
notify
NotifyDisplay
Texts
Open
T
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
commands
Texts
Append
T
W
buf
RETURN
T
END
Menu
PROCEDURE
Text
name
ARRAY
OF
CHAR
Texts
Text
VAR
T
Texts
Text
BEGIN
NEW
T
T
notify
NotifyDisplay
Texts
Open
T
name
RETURN
T
END
Text
PROCEDURE
NewMenu
name
commands
ARRAY
OF
CHAR
Frame
VAR
F
Frame
T
Texts
Text
BEGIN
NEW
F
T
Menu
name
commands
Open
F
Handle
T
Display
white
left
DIV
lsp
RETURN
F
END
NewMenu
PROCEDURE
NewText
text
Texts
Text
pos
LONGINT
Frame
VAR
F
Frame
BEGIN
NEW
F
Open
F
Handle
text
pos
Display
black
left
right
top
bot
lsp
RETURN
F
END
NewText
BEGIN
NEW
TBuf
NEW
DelBuf
Texts
OpenBuf
TBuf
Texts
OpenBuf
DelBuf
lsp
Fonts
Default
height
menuH
lsp
barW
menuH
left
barW
lsp
DIV
right
lsp
DIV
top
lsp
DIV
bot
lsp
DIV
asr
Fonts
Default
maxY
dsr
Fonts
Default
minY
selH
lsp
markW
lsp
DIV
eolW
lsp
DIV
ScrollMarker
Fade
FlipSM
ScrollMarker
Draw
FlipSM
Texts
OpenWriter
W
Texts
OpenWriter
KW
END
TextFrames
MODULE
Texts
JG
NW
IMPORT
Files
Fonts
CONST
scanner
symbol
classes
Inval
invalid
symbol
Name
name
s
length
len
String
literal
string
s
length
len
Int
integer
i
decimal
or
hexadecimal
Real
real
number
x
Char
special
character
c
TextBlock
TextTag
offset
run
run
len
AsciiCode
run
fnt
name
col
voff
len
TAB
9X
CR
0DX
maxD
TextTag
0F1X
replace
insert
delete
unmark
op
codes
TYPE
Piece
POINTER
TO
PieceDesc
PieceDesc
RECORD
f
Files
File
off
len
LONGINT
fnt
Fonts
Font
col
voff
INTEGER
prev
next
Piece
END
Text
POINTER
TO
TextDesc
Notifier
PROCEDURE
T
Text
op
INTEGER
beg
end
LONGINT
TextDesc
RECORD
len
LONGINT
changed
BOOLEAN
notify
Notifier
trailer
Piece
pce
Piece
cache
org
LONGINT
cache
END
Reader
RECORD
eot
BOOLEAN
fnt
Fonts
Font
col
voff
INTEGER
ref
Piece
org
LONGINT
off
LONGINT
rider
Files
Rider
END
Scanner
RECORD
Reader
nextCh
CHAR
line
class
INTEGER
i
LONGINT
x
REAL
y
LONGREAL
c
CHAR
len
INTEGER
s
ARRAY
OF
CHAR
END
Buffer
POINTER
TO
BufDesc
BufDesc
RECORD
len
LONGINT
header
last
Piece
END
Writer
RECORD
buf
Buffer
fnt
Fonts
Font
col
voff
INTEGER
rider
Files
Rider
END
VAR
TrailerFile
Files
File
Filing
PROCEDURE
Trailer
Piece
VAR
Q
Piece
BEGIN
NEW
Q
Q
f
TrailerFile
Q
off
Q
len
Q
fnt
NIL
Q
col
Q
voff
RETURN
Q
END
Trailer
PROCEDURE
Load
VAR
R
Files
Rider
T
Text
VAR
Q
q
p
Piece
off
LONGINT
N
fno
INTEGER
bt
BYTE
f
Files
File
FName
ARRAY
OF
CHAR
Dict
ARRAY
OF
Fonts
Font
BEGIN
f
Files
Base
R
N
Q
Trailer
p
Q
Files
ReadInt
R
off
Files
ReadByte
R
bt
fno
bt
WHILE
fno
DO
IF
fno
N
THEN
Files
ReadString
R
FName
Dict
N
Fonts
This
FName
INC
N
END
NEW
q
q
fnt
Dict
fno
Files
ReadByte
R
bt
q
col
bt
Files
ReadByte
R
bt
q
voff
ASR
LSL
bt
Files
ReadInt
R
q
len
Files
ReadByte
R
bt
fno
bt
q
f
f
q
off
off
off
off
q
len
p
next
q
q
prev
p
p
q
END
p
next
Q
Q
prev
p
T
trailer
Q
Files
ReadInt
R
T
len
Files
Set
R
f
Files
Pos
R
T
len
END
Load
PROCEDURE
Open
T
Text
name
ARRAY
OF
CHAR
VAR
f
Files
File
R
Files
Rider
Q
q
Piece
tag
CHAR
len
LONGINT
BEGIN
f
Files
Old
name
IF
f
NIL
THEN
Files
Set
R
f
Files
Read
R
tag
IF
tag
TextTag
THEN
Load
R
T
ELSE
Ascii
file
len
Files
Length
f
Q
Trailer
NEW
q
q
fnt
Fonts
Default
q
col
q
voff
q
f
f
q
off
q
len
len
Q
next
q
q
prev
Q
q
next
Q
Q
prev
q
T
trailer
Q
T
len
len
END
ELSE
create
new
text
Q
Trailer
Q
next
Q
Q
prev
Q
T
trailer
Q
T
len
END
T
changed
FALSE
T
org
T
pce
T
trailer
init
cache
END
Open
PROCEDURE
Store
VAR
W
Files
Rider
T
Text
VAR
p
q
Piece
R
Files
Rider
off
rlen
pos
LONGINT
N
n
INTEGER
ch
CHAR
Dict
ARRAY
OF
CHAR
BEGIN
pos
Files
Pos
W
Files
WriteInt
W
place
holder
N
p
T
trailer
next
WHILE
p
T
trailer
DO
rlen
p
len
q
p
next
WHILE
q
T
trailer
q
fnt
p
fnt
q
col
p
col
q
voff
p
voff
DO
rlen
rlen
q
len
q
q
next
END
Dict
N
p
fnt
name
n
WHILE
Dict
n
p
fnt
name
DO
INC
n
END
Files
WriteByte
W
n
IF
n
N
THEN
Files
WriteString
W
p
fnt
name
INC
N
END
Files
WriteByte
W
p
col
Files
WriteByte
W
p
voff
Files
WriteInt
W
rlen
p
q
END
Files
WriteByte
W
Files
WriteInt
W
T
len
off
Files
Pos
W
p
T
trailer
next
WHILE
p
T
trailer
DO
rlen
p
len
Files
Set
R
p
f
p
off
WHILE
rlen
DO
Files
Read
R
ch
Files
Write
W
ch
DEC
rlen
END
p
p
next
END
Files
Set
W
Files
Base
W
pos
Files
WriteInt
W
off
fixup
T
changed
FALSE
IF
T
notify
NIL
THEN
T
notify
T
unmark
END
END
Store
PROCEDURE
Close
T
Text
name
ARRAY
OF
CHAR
VAR
f
Files
File
w
Files
Rider
BEGIN
f
Files
New
name
Files
Set
w
f
Files
Write
w
TextTag
Store
w
T
Files
Register
f
END
Close
Editing
PROCEDURE
OpenBuf
B
Buffer
BEGIN
NEW
B
header
null
piece
B
last
B
header
B
len
END
OpenBuf
PROCEDURE
FindPiece
T
Text
pos
LONGINT
VAR
org
LONGINT
VAR
pce
Piece
VAR
p
Piece
porg
LONGINT
BEGIN
p
T
pce
porg
T
org
IF
pos
porg
THEN
WHILE
pos
porg
p
len
DO
INC
porg
p
len
p
p
next
END
ELSE
p
p
prev
DEC
porg
p
len
WHILE
pos
porg
DO
p
p
prev
DEC
porg
p
len
END
END
T
pce
p
T
org
porg
update
cache
pce
p
org
porg
END
FindPiece
PROCEDURE
SplitPiece
p
Piece
off
LONGINT
VAR
pr
Piece
VAR
q
Piece
BEGIN
IF
off
THEN
NEW
q
q
fnt
p
fnt
q
col
p
col
q
voff
p
voff
q
len
p
len
off
q
f
p
f
q
off
p
off
off
p
len
off
q
next
p
next
p
next
q
q
prev
p
q
next
prev
q
pr
q
ELSE
pr
p
END
END
SplitPiece
PROCEDURE
Save
T
Text
beg
end
LONGINT
B
Buffer
VAR
p
q
qb
qe
Piece
org
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
org
p
NEW
qb
qb
p
qb
len
qb
len
beg
org
qb
off
qb
off
beg
org
qe
qb
WHILE
end
org
p
len
DO
org
org
p
len
p
p
next
NEW
q
q
p
qe
next
q
q
prev
qe
qe
q
END
qe
next
NIL
qe
len
qe
len
org
p
len
end
B
last
next
qb
qb
prev
B
last
B
last
qe
B
len
B
len
end
beg
END
Save
PROCEDURE
Copy
SB
DB
Buffer
VAR
Q
q
p
Piece
BEGIN
p
SB
header
Q
DB
last
WHILE
p
SB
last
DO
p
p
next
NEW
q
q
p
Q
next
q
q
prev
Q
Q
q
END
DB
last
Q
DB
len
DB
len
SB
len
END
Copy
PROCEDURE
Insert
T
Text
pos
LONGINT
B
Buffer
VAR
pl
pr
p
qb
qe
Piece
org
end
LONGINT
BEGIN
FindPiece
T
pos
org
p
SplitPiece
p
pos
org
pr
IF
T
org
org
THEN
T
org
org
p
prev
len
T
pce
p
prev
END
pl
pr
prev
qb
B
header
next
IF
qb
NIL
qb
f
pl
f
qb
off
pl
off
pl
len
qb
fnt
pl
fnt
qb
col
pl
col
qb
voff
pl
voff
THEN
pl
len
pl
len
qb
len
qb
qb
next
END
IF
qb
NIL
THEN
qe
B
last
qb
prev
pl
pl
next
qb
qe
next
pr
pr
prev
qe
END
T
len
T
len
B
len
end
pos
B
len
B
last
B
header
B
last
next
NIL
B
len
T
changed
TRUE
T
notify
T
insert
pos
end
END
Insert
PROCEDURE
Append
T
Text
B
Buffer
BEGIN
Insert
T
T
len
B
END
Append
PROCEDURE
Delete
T
Text
beg
end
LONGINT
B
Buffer
VAR
pb
pe
pbr
per
Piece
orgb
orge
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
orgb
pb
SplitPiece
pb
beg
orgb
pbr
FindPiece
T
end
orge
pe
SplitPiece
pe
end
orge
per
IF
T
org
orgb
THEN
adjust
cache
T
org
orgb
pb
prev
len
T
pce
pb
prev
END
B
header
next
pbr
B
last
per
prev
B
last
next
NIL
B
len
end
beg
per
prev
pbr
prev
pbr
prev
next
per
T
len
T
len
B
len
T
changed
TRUE
T
notify
T
delete
beg
end
END
Delete
PROCEDURE
ChangeLooks
T
Text
beg
end
LONGINT
sel
SET
fnt
Fonts
Font
col
voff
INTEGER
VAR
pb
pe
p
Piece
org
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
org
p
SplitPiece
p
beg
org
pb
FindPiece
T
end
org
p
SplitPiece
p
end
org
pe
p
pb
REPEAT
IF
IN
sel
THEN
p
fnt
fnt
END
IF
IN
sel
THEN
p
col
col
END
IF
IN
sel
THEN
p
voff
voff
END
p
p
next
UNTIL
p
pe
T
changed
TRUE
T
notify
T
replace
beg
end
END
ChangeLooks
PROCEDURE
Attributes
T
Text
pos
LONGINT
VAR
fnt
Fonts
Font
VAR
col
voff
INTEGER
VAR
p
Piece
org
LONGINT
BEGIN
FindPiece
T
pos
org
p
fnt
p
fnt
col
p
col
voff
p
voff
END
Attributes
Access
Readers
PROCEDURE
OpenReader
VAR
R
Reader
T
Text
pos
LONGINT
VAR
p
Piece
org
LONGINT
BEGIN
FindPiece
T
pos
org
p
R
ref
p
R
org
org
R
off
pos
org
Files
Set
R
rider
p
f
p
off
R
off
R
eot
FALSE
END
OpenReader
PROCEDURE
Read
VAR
R
Reader
VAR
ch
CHAR
BEGIN
Files
Read
R
rider
ch
R
fnt
R
ref
fnt
R
col
R
ref
col
R
voff
R
ref
voff
INC
R
off
IF
R
off
R
ref
len
THEN
IF
R
ref
f
TrailerFile
THEN
R
eot
TRUE
END
R
org
R
org
R
off
R
off
R
ref
R
ref
next
R
org
R
org
R
off
R
off
Files
Set
R
rider
R
ref
f
R
ref
off
END
END
Read
PROCEDURE
Pos
VAR
R
Reader
LONGINT
BEGIN
RETURN
R
org
R
off
END
Pos
Access
Scanners
NW
PROCEDURE
OpenScanner
VAR
S
Scanner
T
Text
pos
LONGINT
BEGIN
OpenReader
S
T
pos
S
line
S
nextCh
END
OpenScanner
floating
point
formats
x
m
e
bit
sign
bits
e
bits
m
x
m
e
bit
sign
bits
e
bits
m
PROCEDURE
Ten
n
INTEGER
REAL
VAR
t
p
REAL
BEGIN
t
p
compute
n
WHILE
n
DO
IF
ODD
n
THEN
t
p
t
END
p
p
p
n
n
DIV
END
RETURN
t
END
Ten
PROCEDURE
Scan
VAR
S
Scanner
CONST
maxExp
maxM
VAR
ch
term
CHAR
neg
negE
hex
BOOLEAN
i
j
h
d
e
n
s
INTEGER
k
LONGINT
x
REAL
BEGIN
ch
S
nextCh
i
WHILE
S
eot
ch
DO
IF
ch
CR
THEN
INC
S
line
END
Read
S
ch
END
IF
A
ch
ch
Z
OR
a
ch
ch
z
THEN
name
REPEAT
S
s
i
ch
INC
i
Read
S
ch
UNTIL
ch
ch
OR
ch
ch
A
OR
Z
ch
ch
a
OR
z
ch
OR
i
S
s
i
0X
S
len
i
S
class
Name
ELSIF
ch
22X
THEN
string
Read
S
ch
WHILE
ch
22X
ch
i
DO
S
s
i
ch
INC
i
Read
S
ch
END
S
s
i
0X
S
len
i
Read
S
ch
S
class
String
ELSE
hex
FALSE
IF
ch
THEN
neg
TRUE
Read
S
ch
ELSE
neg
FALSE
END
IF
ch
ch
THEN
number
n
ORD
ch
30H
h
n
Read
S
ch
WHILE
ch
ch
OR
A
ch
ch
F
DO
IF
ch
THEN
d
ORD
ch
30H
ELSE
d
ORD
ch
37H
hex
TRUE
END
n
n
d
h
10H
h
d
Read
S
ch
END
IF
ch
H
THEN
hex
integer
Read
S
ch
S
i
h
S
class
Int
neg
ELSIF
ch
THEN
real
number
Read
S
ch
x
e
j
WHILE
ch
ch
DO
fraction
h
n
ORD
ch
30H
IF
h
maxM
THEN
n
h
INC
j
END
Read
S
ch
END
IF
ch
E
THEN
scale
factor
s
Read
S
ch
IF
ch
THEN
negE
TRUE
Read
S
ch
ELSE
negE
FALSE
IF
ch
THEN
Read
S
ch
END
END
WHILE
ch
ch
DO
s
s
ORD
ch
30H
Read
S
ch
END
IF
negE
THEN
DEC
e
s
ELSE
INC
e
s
END
END
x
FLT
n
DEC
e
j
IF
e
THEN
IF
e
maxExp
THEN
x
x
Ten
e
ELSE
x
END
ELSIF
e
THEN
IF
e
maxExp
THEN
x
Ten
e
x
ELSE
x
END
END
IF
neg
THEN
S
x
x
ELSE
S
x
x
END
IF
hex
THEN
S
class
ELSE
S
class
Real
END
ELSE
decimal
integer
IF
neg
THEN
S
i
n
ELSE
S
i
n
END
IF
hex
THEN
S
class
Inval
ELSE
S
class
Int
END
END
ELSE
spectal
character
S
class
Char
IF
neg
THEN
S
c
ELSE
S
c
ch
Read
S
ch
END
END
END
S
nextCh
ch
END
Scan
Access
Writers
NW
PROCEDURE
OpenWriter
VAR
W
Writer
BEGIN
NEW
W
buf
OpenBuf
W
buf
W
fnt
Fonts
Default
W
col
W
voff
Files
Set
W
rider
Files
New
END
OpenWriter
PROCEDURE
SetFont
VAR
W
Writer
fnt
Fonts
Font
BEGIN
W
fnt
fnt
END
SetFont
PROCEDURE
SetColor
VAR
W
Writer
col
INTEGER
BEGIN
W
col
col
END
SetColor
PROCEDURE
SetOffset
VAR
W
Writer
voff
INTEGER
BEGIN
W
voff
voff
END
SetOffset
PROCEDURE
Write
VAR
W
Writer
ch
CHAR
VAR
p
Piece
BEGIN
IF
W
buf
last
fnt
W
fnt
OR
W
buf
last
col
W
col
OR
W
buf
last
voff
W
voff
THEN
NEW
p
p
f
Files
Base
W
rider
p
off
Files
Pos
W
rider
p
len
p
fnt
W
fnt
p
col
W
col
p
voff
W
voff
p
next
NIL
W
buf
last
next
p
p
prev
W
buf
last
W
buf
last
p
END
Files
Write
W
rider
ch
INC
W
buf
last
len
INC
W
buf
len
END
Write
PROCEDURE
WriteLn
VAR
W
Writer
BEGIN
Write
W
CR
END
WriteLn
PROCEDURE
WriteString
VAR
W
Writer
s
ARRAY
OF
CHAR
VAR
i
INTEGER
BEGIN
i
WHILE
s
i
DO
Write
W
s
i
INC
i
END
END
WriteString
PROCEDURE
WriteInt
VAR
W
Writer
x
n
LONGINT
VAR
i
INTEGER
x0
LONGINT
a
ARRAY
OF
CHAR
BEGIN
IF
ROR
x
THEN
WriteString
W
ELSE
i
IF
x
THEN
DEC
n
x0
x
ELSE
x0
x
END
REPEAT
a
i
CHR
x0
MOD
30H
x0
x0
DIV
INC
i
UNTIL
x0
WHILE
n
i
DO
Write
W
DEC
n
END
IF
x
THEN
Write
W
END
REPEAT
DEC
i
Write
W
a
i
UNTIL
i
END
END
WriteInt
PROCEDURE
WriteHex
VAR
W
Writer
x
LONGINT
VAR
i
INTEGER
y
LONGINT
a
ARRAY
OF
CHAR
BEGIN
i
Write
W
REPEAT
y
x
MOD
10H
IF
y
THEN
a
i
CHR
y
30H
ELSE
a
i
CHR
y
37H
END
x
x
DIV
10H
INC
i
UNTIL
i
REPEAT
DEC
i
Write
W
a
i
UNTIL
i
END
WriteHex
PROCEDURE
WriteReal
VAR
W
Writer
x
REAL
n
INTEGER
VAR
e
i
m
INTEGER
d
ARRAY
OF
CHAR
BEGIN
e
ASR
ORD
x
MOD
100H
binary
exponent
IF
e
THEN
WriteString
W
WHILE
n
DO
Write
W
DEC
n
END
ELSIF
e
THEN
WriteString
W
NaN
ELSE
Write
W
WHILE
n
DO
DEC
n
Write
W
END
n
digits
to
be
written
IF
x
THEN
Write
W
x
x
ELSE
Write
W
END
e
e
DIV
decimal
exponent
IF
e
THEN
x
x
Ten
e
ELSE
x
Ten
e
x
END
m
FLOOR
x
i
IF
m
THEN
INC
e
m
m
DIV
END
REPEAT
d
i
CHR
m
MOD
30H
m
m
DIV
INC
i
UNTIL
m
DEC
i
Write
W
d
i
Write
W
IF
i
n
THEN
n
ELSE
n
n
END
WHILE
i
n
DO
DEC
i
Write
W
d
i
END
Write
W
E
INC
e
IF
e
THEN
Write
W
e
e
ELSE
Write
W
END
Write
W
CHR
e
DIV
30H
Write
W
CHR
e
MOD
30H
END
END
WriteReal
PROCEDURE
WriteRealFix
VAR
W
Writer
x
REAL
n
k
INTEGER
VAR
i
m
INTEGER
neg
BOOLEAN
d
ARRAY
OF
CHAR
BEGIN
IF
x
THEN
WriteString
W
ELSE
IF
x
THEN
x
x
neg
TRUE
ELSE
neg
FALSE
END
IF
k
THEN
k
END
x
Ten
k
x
m
FLOOR
x
i
REPEAT
d
i
CHR
m
MOD
30H
m
m
DIV
INC
i
UNTIL
m
Write
W
WHILE
n
i
DO
Write
W
DEC
n
END
IF
neg
THEN
Write
W
DEC
n
ELSE
Write
W
END
WHILE
i
k
DO
DEC
i
Write
W
d
i
END
Write
W
WHILE
k
i
DO
DEC
k
Write
W
END
WHILE
i
DO
DEC
i
Write
W
d
i
END
END
END
WriteRealFix
PROCEDURE
WritePair
VAR
W
Writer
ch
CHAR
x
LONGINT
BEGIN
Write
W
ch
Write
W
CHR
x
DIV
30H
Write
W
CHR
x
MOD
30H
END
WritePair
PROCEDURE
WriteClock
VAR
W
Writer
d
LONGINT
BEGIN
WritePair
W
d
DIV
20000H
MOD
20H
day
WritePair
W
d
DIV
400000H
MOD
10H
month
WritePair
W
d
DIV
4000000H
MOD
40H
year
WritePair
W
d
DIV
1000H
MOD
20H
hour
WritePair
W
d
DIV
40H
MOD
40H
min
WritePair
W
d
MOD
40H
sec
END
WriteClock
BEGIN
TrailerFile
Files
New
END
Texts
MODULE
Viewers
JG
NW
IMPORT
Display
CONST
restore
modify
suspend
message
ids
inf
TYPE
Viewer
POINTER
TO
ViewerDesc
ViewerDesc
RECORD
Display
FrameDesc
state
INTEGER
END
state
displayed
state
filler
state
closed
state
suspended
ViewerMsg
RECORD
Display
FrameMsg
id
INTEGER
X
Y
W
H
INTEGER
state
INTEGER
END
Track
POINTER
TO
TrackDesc
TrackDesc
RECORD
ViewerDesc
under
Display
Frame
END
VAR
curW
minH
DH
INTEGER
FillerTrack
Track
FillerViewer
backup
Viewer
last
closed
viewer
PROCEDURE
Open
V
Viewer
X
Y
INTEGER
VAR
T
u
v
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
X
inf
THEN
IF
Y
DH
THEN
Y
DH
END
T
FillerTrack
next
WHILE
X
T
X
T
W
DO
T
T
next
END
u
T
dsc
v
u
next
WHILE
Y
v
Y
v
H
DO
u
v
v
u
next
END
IF
Y
v
Y
minH
THEN
Y
v
Y
minH
END
IF
v
next
Y
Y
v
Y
v
H
minH
THEN
V
X
T
X
V
W
T
W
V
Y
v
Y
V
H
v
H
M
id
suspend
M
state
v
handle
v
M
v
Viewer
state
V
next
v
next
u
next
V
V
state
ELSE
V
X
T
X
V
W
T
W
V
Y
v
Y
V
H
Y
v
Y
M
id
modify
M
Y
Y
M
H
v
Y
v
H
Y
v
handle
v
M
v
Y
M
Y
v
H
M
H
V
next
v
u
next
V
V
state
END
END
END
Open
PROCEDURE
Change
V
Viewer
Y
INTEGER
VAR
v
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
THEN
IF
Y
DH
THEN
Y
DH
END
v
V
next
IF
v
next
Y
Y
v
Y
v
H
minH
THEN
Y
v
Y
v
H
minH
END
IF
Y
V
Y
minH
THEN
M
id
modify
M
Y
Y
M
H
v
Y
v
H
Y
v
handle
v
M
v
Y
M
Y
v
H
M
H
V
H
Y
V
Y
END
END
END
Change
PROCEDURE
RestoreTrack
S
Display
Frame
VAR
T
t
v
Display
Frame
M
ViewerMsg
BEGIN
t
S
next
WHILE
t
next
S
DO
t
t
next
END
T
S
Track
under
WHILE
T
next
NIL
DO
T
T
next
END
t
next
S
Track
under
T
next
S
next
M
id
restore
REPEAT
t
t
next
v
t
dsc
REPEAT
v
v
next
v
handle
v
M
v
Viewer
state
v
Viewer
state
UNTIL
v
t
dsc
UNTIL
t
T
END
RestoreTrack
PROCEDURE
Close
V
Viewer
VAR
T
U
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
THEN
U
V
next
T
FillerTrack
REPEAT
T
T
next
UNTIL
V
X
T
X
T
W
IF
T
Track
under
NIL
OR
U
next
V
THEN
M
id
suspend
M
state
V
handle
V
M
V
state
backup
V
M
id
modify
M
Y
V
Y
M
H
V
H
U
H
U
handle
U
M
U
Y
M
Y
U
H
M
H
WHILE
U
next
V
DO
U
U
next
END
U
next
V
next
ELSE
close
track
M
id
suspend
M
state
V
handle
V
M
V
state
backup
V
U
handle
U
M
U
Viewer
state
RestoreTrack
T
END
END
END
Close
PROCEDURE
Recall
VAR
V
Viewer
BEGIN
V
backup
END
Recall
PROCEDURE
This
X
Y
INTEGER
Viewer
VAR
T
V
Display
Frame
BEGIN
IF
X
inf
Y
DH
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
V
T
dsc
REPEAT
V
V
next
UNTIL
Y
V
Y
V
H
ELSE
V
NIL
END
RETURN
V
Viewer
END
This
PROCEDURE
Next
V
Viewer
Viewer
BEGIN
RETURN
V
next
Viewer
END
Next
PROCEDURE
Locate
X
H
INTEGER
VAR
fil
bot
alt
max
Display
Frame
VAR
T
V
Display
Frame
BEGIN
IF
X
inf
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
fil
T
dsc
bot
fil
next
IF
bot
next
fil
THEN
alt
bot
next
V
alt
next
WHILE
V
fil
alt
H
H
DO
IF
V
H
alt
H
THEN
alt
V
END
V
V
next
END
ELSE
alt
bot
END
max
T
dsc
V
max
next
WHILE
V
fil
DO
IF
V
H
max
H
THEN
max
V
END
V
V
next
END
END
END
Locate
PROCEDURE
InitTrack
W
H
INTEGER
Filler
Viewer
VAR
S
Display
Frame
T
Track
BEGIN
IF
Filler
state
THEN
Filler
X
curW
Filler
W
W
Filler
Y
Filler
H
H
Filler
state
Filler
next
Filler
NEW
T
T
X
curW
T
W
W
T
Y
T
H
H
T
dsc
Filler
T
under
NIL
FillerViewer
X
curW
W
FillerViewer
W
inf
FillerViewer
X
FillerTrack
X
FillerViewer
X
FillerTrack
W
FillerViewer
W
S
FillerTrack
WHILE
S
next
FillerTrack
DO
S
S
next
END
S
next
T
T
next
FillerTrack
curW
curW
W
END
END
InitTrack
PROCEDURE
OpenTrack
X
W
INTEGER
Filler
Viewer
VAR
newT
Track
S
T
t
v
Display
Frame
M
ViewerMsg
v0
Viewer
BEGIN
IF
X
inf
Filler
state
THEN
S
FillerTrack
T
S
next
WHILE
X
T
X
T
W
DO
S
T
T
S
next
END
WHILE
X
W
T
X
T
W
DO
T
T
next
END
M
id
suspend
t
S
REPEAT
t
t
next
v
t
dsc
REPEAT
v
v
next
M
state
v
Viewer
state
v
handle
v
M
v
Viewer
state
M
state
UNTIL
v
t
dsc
UNTIL
t
T
Filler
X
S
next
X
Filler
W
T
X
T
W
S
next
X
Filler
Y
Filler
H
DH
Filler
state
Filler
next
Filler
NEW
newT
newT
X
Filler
X
newT
W
Filler
W
newT
Y
newT
H
DH
newT
dsc
Filler
newT
under
S
next
S
next
newT
newT
next
T
next
T
next
NIL
END
END
OpenTrack
PROCEDURE
CloseTrack
X
INTEGER
VAR
T
V
Display
Frame
M
ViewerMsg
BEGIN
IF
X
inf
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
IF
T
Track
under
NIL
THEN
M
id
suspend
M
state
V
T
dsc
REPEAT
V
V
next
V
handle
V
M
V
Viewer
state
UNTIL
V
T
dsc
RestoreTrack
T
END
END
END
CloseTrack
PROCEDURE
Broadcast
VAR
M
Display
FrameMsg
VAR
T
V
Display
Frame
BEGIN
T
FillerTrack
next
WHILE
T
FillerTrack
DO
V
T
dsc
REPEAT
V
V
next
V
handle
V
M
UNTIL
V
T
dsc
T
T
next
END
END
Broadcast
BEGIN
backup
NIL
curW
minH
DH
Display
Height
NEW
FillerViewer
FillerViewer
X
FillerViewer
W
inf
FillerViewer
Y
FillerViewer
H
DH
FillerViewer
next
FillerViewer
NEW
FillerTrack
FillerTrack
X
FillerTrack
W
inf
FillerTrack
Y
FillerTrack
H
DH
FillerTrack
dsc
FillerViewer
FillerTrack
next
FillerTrack
END
Viewers
MODULE
Curves
NW
IMPORT
Display
Files
Oberon
Graphics
GraphicFrames
TYPE
Curve
POINTER
TO
CurveDesc
CurveDesc
RECORD
Graphics
ObjectDesc
kind
lw
INTEGER
END
kind
up
line
down
line
circle
ellipse
VAR
method
Graphics
Method
PROCEDURE
Dot
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
IF
x
f
X
x
f
X1
y
f
Y
x
f
Y1
THEN
Display
Dot
col
x
y
Display
replace
END
END
Dot
PROCEDURE
mark
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
DEC
x
DEC
y
IF
x
f
X
x
f
X1
y
f
Y
y
f
Y1
THEN
IF
col
Display
black
THEN
Display
ReplConst
Display
black
x
y
Display
replace
ELSE
Display
CopyPattern
col
GraphicFrames
tack
x
y
Display
replace
END
END
END
mark
PROCEDURE
line
f
GraphicFrames
Frame
col
INTEGER
x
y
w
h
d
LONGINT
VAR
x1
y1
u
LONGINT
BEGIN
IF
h
w
THEN
x1
x
w
u
h
w
DIV
IF
d
THEN
INC
y
h
END
WHILE
x
x1
DO
Dot
f
col
x
y
INC
x
IF
u
THEN
INC
u
h
ELSE
INC
u
h
w
INC
y
d
END
END
ELSE
y1
y
h
u
w
h
DIV
IF
d
THEN
INC
x
w
END
WHILE
y
y1
DO
Dot
f
col
x
y
INC
y
IF
u
THEN
INC
u
w
ELSE
INC
u
w
h
INC
x
d
END
END
END
END
line
PROCEDURE
circle
f
GraphicFrames
Frame
col
INTEGER
x0
y0
r
LONGINT
VAR
x
y
u
LONGINT
BEGIN
u
r
x
r
y
WHILE
y
x
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
x
y0
y
IF
u
THEN
INC
u
y
ELSE
INC
u
y
x
DEC
x
END
INC
y
END
END
circle
PROCEDURE
ellipse
f
GraphicFrames
Frame
col
INTEGER
x0
y0
a
b
LONGINT
VAR
x
y
y1
aa
bb
d
g
h
LONGINT
BEGIN
aa
a
a
bb
b
b
h
aa
DIV
b
aa
bb
g
aa
DIV
b
aa
bb
x
y
b
WHILE
g
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
IF
h
THEN
d
x
bb
INC
g
d
ELSE
d
x
bb
y
aa
INC
g
d
aa
DEC
y
END
INC
h
d
INC
x
END
y1
y
h
bb
DIV
a
bb
aa
x
a
y
WHILE
y
y1
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
IF
h
THEN
INC
h
y
aa
ELSE
INC
h
y
aa
x
bb
DEC
x
END
INC
y
END
END
ellipse
PROCEDURE
New
VAR
c
Curve
BEGIN
NEW
c
c
do
method
Graphics
New
c
END
New
PROCEDURE
Copy
src
dst
Graphics
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Curve
kind
src
Curve
kind
dst
Curve
lw
src
Curve
lw
END
Copy
PROCEDURE
Draw
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
col
INTEGER
f
GraphicFrames
Frame
BEGIN
CASE
M
OF
GraphicFrames
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
M
col
Display
black
THEN
col
obj
col
ELSE
col
M
col
END
IF
x
f
X1
f
X
x
w
y
f
Y1
f
Y
y
h
THEN
IF
obj
Curve
kind
THEN
up
line
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
y
END
line
f
col
x
y
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
ELSIF
M
mode
THEN
mark
f
f
col
x
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
line
f
Display
black
x
y
w
h
END
ELSIF
obj
Curve
kind
THEN
down
line
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
y
h
END
line
f
col
x
y
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
h
ELSIF
M
mode
THEN
mark
f
f
col
x
y
h
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
h
line
f
Display
black
x
y
w
h
END
ELSIF
obj
Curve
kind
THEN
circle
w
w
DIV
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
w
y
END
circle
f
col
x
w
y
w
w
ELSIF
M
mode
THEN
mark
f
Display
white
x
w
y
ELSIF
M
mode
THEN
mark
f
f
col
x
w
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
w
y
circle
f
Display
black
x
w
y
w
w
END
ELSIF
obj
Curve
kind
THEN
ellipse
w
w
DIV
h
h
DIV
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
w
y
END
ellipse
f
col
x
w
y
h
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
w
y
ELSIF
M
mode
THEN
mark
f
f
col
x
w
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
w
y
ellipse
f
Display
black
x
w
y
h
w
h
END
END
END
END
END
Draw
PROCEDURE
Selectable
obj
Graphics
Object
x
y
INTEGER
BOOLEAN
VAR
xm
y0
w
h
INTEGER
res
BOOLEAN
BEGIN
IF
obj
Curve
kind
THEN
line
w
obj
w
h
obj
h
IF
obj
Curve
kind
THEN
y0
obj
y
h
h
h
ELSE
y0
obj
y
END
res
obj
x
x
x
obj
x
w
ABS
y
y0
w
x
obj
x
h
w
ELSE
circle
or
ellipse
xm
obj
w
DIV
obj
x
res
xm
x
x
xm
obj
y
y
y
obj
y
END
RETURN
res
END
Selectable
PROCEDURE
Change
obj
Graphics
Object
VAR
M
Graphics
Msg
BEGIN
IF
M
IS
Graphics
ColorMsg
THEN
obj
col
M
Graphics
ColorMsg
col
END
END
Change
PROCEDURE
Read
obj
Graphics
Object
VAR
R
Files
Rider
VAR
C
Graphics
Context
VAR
len
BYTE
BEGIN
Files
ReadByte
R
len
Files
ReadByte
R
len
obj
Curve
kind
len
Files
ReadByte
R
len
obj
Curve
lw
len
END
Read
PROCEDURE
Write
obj
Graphics
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Graphics
Context
BEGIN
Graphics
WriteObj
W
cno
obj
Files
WriteByte
W
Files
WriteByte
W
obj
Curve
kind
Files
WriteByte
W
obj
Curve
lw
END
Write
PROCEDURE
MakeLine
command
VAR
x0
x1
y0
y1
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
x1
G
mark
next
x
y1
G
mark
next
y
NEW
c
c
col
Oberon
CurCol
c
w
ABS
x1
x0
c
h
ABS
y1
y0
c
lw
Graphics
width
IF
x0
x1
THEN
c
x
x0
IF
y0
y1
THEN
c
kind
c
y
y0
ELSE
c
kind
c
y
y1
END
ELSE
c
x
x1
IF
y1
y0
THEN
c
kind
c
y
y1
ELSE
c
kind
c
y
y0
END
END
DEC
c
x
G
x
DEC
c
y
G
y
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
MakeLine
PROCEDURE
MakeCircle
command
VAR
x0
y0
r
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
r
ABS
G
mark
next
x
x0
IF
r
THEN
NEW
c
c
x
x0
r
G
x
c
y
y0
r
G
y
c
w
r
c
h
c
w
c
kind
c
col
Oberon
CurCol
c
lw
Graphics
width
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
END
MakeCircle
PROCEDURE
MakeEllipse
command
VAR
x0
y0
a
b
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
G
mark
next
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
a
ABS
G
mark
next
x
x0
b
ABS
G
mark
next
next
y
y0
IF
a
b
THEN
NEW
c
c
x
x0
a
G
x
c
y
y0
b
G
y
c
w
a
c
h
b
c
kind
c
col
Oberon
CurCol
c
lw
Graphics
width
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
END
MakeEllipse
BEGIN
NEW
method
method
module
Curves
method
allocator
New
method
new
New
method
copy
Copy
method
draw
Draw
method
selectable
Selectable
method
change
Change
method
read
Read
method
write
Write
END
Curves
MODULE
Display
NW
IMPORT
SYSTEM
CONST
black
white
black
background
replace
paint
invert
modes
base
0E7F00H
adr
of
x
pixel
monocolor
display
frame
TYPE
Frame
POINTER
TO
FrameDesc
FrameMsg
RECORD
END
Handler
PROCEDURE
F
Frame
VAR
M
FrameMsg
FrameDesc
RECORD
next
dsc
Frame
X
Y
W
H
INTEGER
handle
Handler
END
VAR
Base
Width
Height
INTEGER
arrow
star
hook
updown
block
cross
grey
INTEGER
a
pattern
is
an
array
of
bytes
the
first
is
its
width
the
second
its
height
the
rest
the
raster
PROCEDURE
Handle
F
Frame
VAR
M
FrameMsg
BEGIN
IF
F
NIL
F
handle
NIL
THEN
F
handle
F
M
END
END
Handle
raster
ops
PROCEDURE
Dot
col
x
y
mode
INTEGER
VAR
a
INTEGER
u
s
SET
BEGIN
a
base
x
DIV
y
s
x
MOD
SYSTEM
GET
a
u
IF
mode
paint
THEN
SYSTEM
PUT
a
u
s
ELSIF
mode
invert
THEN
SYSTEM
PUT
a
u
s
ELSE
mode
replace
IF
col
black
THEN
SYSTEM
PUT
a
u
s
ELSE
SYSTEM
PUT
a
u
s
END
END
END
Dot
PROCEDURE
ReplConst
col
x
y
w
h
mode
INTEGER
VAR
al
ar
a0
a1
INTEGER
left
right
mid
pix
pixl
pixr
SET
BEGIN
al
base
y
ar
x
w
DIV
al
al
x
DIV
al
IF
ar
al
THEN
mid
x
MOD
x
w
MOD
FOR
a1
al
TO
al
h
BY
DO
SYSTEM
GET
a1
pix
IF
mode
invert
THEN
SYSTEM
PUT
a1
pix
mid
ELSIF
mode
replace
col
black
THEN
erase
SYSTEM
PUT
a1
pix
mid
ELSE
mode
paint
OR
mode
replace
col
black
SYSTEM
PUT
a1
pix
mid
END
END
ELSIF
ar
al
THEN
left
x
MOD
right
x
w
MOD
FOR
a0
al
TO
al
h
BY
DO
SYSTEM
GET
a0
pixl
SYSTEM
GET
ar
pixr
IF
mode
invert
THEN
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
PUT
a1
pix
END
SYSTEM
PUT
ar
pixr
right
ELSIF
mode
replace
col
black
THEN
erase
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
PUT
a1
END
SYSTEM
PUT
ar
pixr
right
ELSE
mode
paint
OR
mode
replace
col
black
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
PUT
a1
END
SYSTEM
PUT
ar
pixr
right
END
INC
ar
END
END
END
ReplConst
PROCEDURE
CopyPattern
col
patadr
x
y
mode
INTEGER
only
for
modes
paint
invert
VAR
a
a0
pwd
INTEGER
w
h
pbt
BYTE
pix
SET
BEGIN
SYSTEM
GET
patadr
w
SYSTEM
GET
patadr
h
INC
patadr
a
base
x
DIV
y
FOR
a0
a
TO
a
h
BY
DO
build
pattern
line
w
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
100H
pwd
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
10000H
pwd
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
1000000H
pwd
END
END
END
SYSTEM
GET
a0
pix
IF
mode
invert
THEN
SYSTEM
PUT
a0
SYSTEM
VAL
SET
LSL
pwd
x
MOD
pix
ELSE
SYSTEM
PUT
a0
SYSTEM
VAL
SET
LSL
pwd
x
MOD
pix
END
IF
x
MOD
w
THEN
spill
over
SYSTEM
GET
a0
pix
IF
mode
invert
THEN
SYSTEM
PUT
a0
SYSTEM
VAL
SET
ASR
pwd
x
MOD
pix
ELSE
SYSTEM
PUT
a0
SYSTEM
VAL
SET
ASR
pwd
x
MOD
pix
END
END
END
END
CopyPattern
PROCEDURE
CopyBlock
sx
sy
w
h
dx
dy
mode
INTEGER
only
for
mode
replace
VAR
sa
da
sa0
sa1
d
len
INTEGER
u0
u1
u2
u3
v0
v1
v2
v3
n
INTEGER
end
step
INTEGER
src
dst
spill
SET
m0
m1
m2
m3
SET
BEGIN
u0
sx
DIV
u1
sx
MOD
u2
sx
w
DIV
u3
sx
w
MOD
v0
dx
DIV
v1
dx
MOD
v2
dx
w
DIV
v3
dx
w
MOD
sa
base
u0
sy
da
base
v0
dy
d
da
sa
n
u1
v1
displacement
in
words
and
bits
len
u2
u0
m0
v1
m2
v3
m3
m0
m2
IF
d
THEN
copy
up
scan
down
sa0
sa
h
end
sa
step
ELSE
copy
down
scan
up
sa0
sa
end
sa
h
step
END
WHILE
sa0
end
DO
IF
n
THEN
shift
right
m1
n
IF
v1
w
THEN
SYSTEM
GET
sa0
len
src
src
ROR
src
n
SYSTEM
GET
sa0
len
d
dst
SYSTEM
PUT
sa0
len
d
dst
m2
src
m2
spill
src
m1
FOR
sa1
sa0
len
TO
sa0
BY
DO
SYSTEM
GET
sa1
src
src
ROR
src
n
SYSTEM
PUT
sa1
d
spill
src
m1
spill
src
m1
END
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
SYSTEM
PUT
sa0
d
src
m0
dst
m0
ELSE
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
SYSTEM
PUT
sa0
d
src
m3
dst
m3
END
ELSE
shift
left
m1
n
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
IF
v1
w
THEN
SYSTEM
PUT
sa0
d
dst
m3
src
m3
ELSE
SYSTEM
PUT
sa0
d
dst
m0
src
m0
spill
src
m1
FOR
sa1
sa0
TO
sa0
len
BY
DO
SYSTEM
GET
sa1
src
src
ROR
src
n
SYSTEM
PUT
sa1
d
spill
src
m1
spill
src
m1
END
SYSTEM
GET
sa0
len
src
src
ROR
src
n
SYSTEM
GET
sa0
len
d
dst
SYSTEM
PUT
sa0
len
d
src
m2
dst
m2
END
END
INC
sa0
step
END
END
CopyBlock
PROCEDURE
ReplPattern
col
patadr
x
y
w
h
mode
INTEGER
pattern
width
fixed
pattern
starts
at
patadr
for
mode
invert
only
VAR
al
ar
a0
a1
INTEGER
pta0
pta1
INTEGER
pattern
addresses
ph
BYTE
left
right
mid
pix
pixl
pixr
ptw
SET
BEGIN
al
base
y
SYSTEM
GET
patadr
ph
pta0
patadr
pta1
ph
pta0
ar
x
w
DIV
al
al
x
DIV
al
IF
ar
al
THEN
mid
x
MOD
x
w
MOD
FOR
a1
al
TO
al
h
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
GET
pta0
ptw
SYSTEM
PUT
a1
pix
mid
pix
ptw
mid
INC
pta0
IF
pta0
pta1
THEN
pta0
patadr
END
END
ELSIF
ar
al
THEN
left
x
MOD
right
x
w
MOD
FOR
a0
al
TO
al
h
BY
DO
SYSTEM
GET
a0
pixl
SYSTEM
GET
pta0
ptw
SYSTEM
PUT
a0
pixl
left
pixl
ptw
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
PUT
a1
pix
ptw
END
SYSTEM
GET
ar
pixr
SYSTEM
PUT
ar
pixr
right
pixr
ptw
right
INC
pta0
INC
ar
IF
pta0
pta1
THEN
pta0
patadr
END
END
END
END
ReplPattern
BEGIN
Base
base
Width
Height
arrow
SYSTEM
ADR
0F0F
001C
000E
C101
E300
3F00
1F00
3F00
7F00
FF00
star
SYSTEM
ADR
0F0F
A002
C001
7F7F
C001
A002
hook
SYSTEM
ADR
0C0C
070F
C703
E701
F700
7F00
3F00
1F00
0F00
updown
SYSTEM
ADR
080E
183C
7EFF
FF7E3C18
block
SYSTEM
ADR
FFFF
C3C3
C3C3
FFFF
cross
SYSTEM
ADR
0F0F
grey
SYSTEM
ADR
AAAA
AAAA
END
Display
MODULE
Draw
NW
IMPORT
Files
Fonts
Viewers
Texts
Oberon
TextFrames
MenuViewers
Graphics
GraphicFrames
CONST
Menu
System
Close
System
Copy
System
Grow
Draw
Delete
Draw
Ticks
Draw
Restore
Draw
Store
VAR
W
Texts
Writer
Exported
commands
Open
Delete
SetWidth
ChangeColor
ChangeWidth
ChangeFont
Store
Print
Macro
Ticks
Restore
PROCEDURE
Open
VAR
X
Y
INTEGER
beg
end
t
LONGINT
G
Graphics
Graph
F
GraphicFrames
Frame
V
Viewers
Viewer
S
Texts
Scanner
text
Texts
Text
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
text
beg
end
t
IF
t
THEN
Texts
OpenScanner
S
text
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
THEN
NEW
G
Graphics
Open
G
S
s
NEW
F
GraphicFrames
Open
F
G
Oberon
AllocateUserViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
Menu
F
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Delete
VAR
F
GraphicFrames
Frame
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
F
Oberon
Par
vwr
dsc
next
GraphicFrames
Frame
GraphicFrames
Erase
F
Graphics
Delete
F
graph
END
END
Delete
PROCEDURE
GetArg
VAR
S
Texts
Scanner
VAR
T
Texts
Text
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
END
GetArg
PROCEDURE
SetWidth
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
S
i
S
i
THEN
Graphics
SetWidth
S
i
END
END
SetWidth
PROCEDURE
ChangeColor
VAR
S
Texts
Scanner
CM
Graphics
ColorMsg
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
CM
col
S
i
MOD
GraphicFrames
Change
GraphicFrames
Selected
CM
END
END
ChangeColor
PROCEDURE
ChangeWidth
VAR
S
Texts
Scanner
WM
Graphics
WidMsg
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
WM
w
S
i
GraphicFrames
Change
GraphicFrames
Selected
WM
END
END
ChangeWidth
PROCEDURE
ChangeFont
VAR
S
Texts
Scanner
FM
Graphics
FontMsg
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
FM
fnt
Fonts
This
S
s
IF
FM
fnt
NIL
THEN
GraphicFrames
Change
GraphicFrames
Selected
FM
END
END
END
ChangeFont
PROCEDURE
Redraw
Q
BOOLEAN
VAR
v
Viewers
Viewer
G
GraphicFrames
Frame
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
v
Oberon
Par
vwr
ELSE
v
Oberon
MarkedViewer
END
IF
v
NIL
v
dsc
NIL
v
dsc
next
IS
GraphicFrames
Frame
THEN
G
v
dsc
next
GraphicFrames
Frame
G
ticked
Q
OR
G
ticked
GraphicFrames
Restore
G
END
END
Redraw
PROCEDURE
Ticks
BEGIN
Redraw
FALSE
END
Ticks
PROCEDURE
Restore
BEGIN
Redraw
TRUE
END
Restore
PROCEDURE
Backup
VAR
name
ARRAY
OF
CHAR
VAR
res
i
INTEGER
ch
CHAR
bak
ARRAY
OF
CHAR
BEGIN
i
ch
name
WHILE
ch
0X
DO
bak
i
ch
INC
i
ch
name
i
END
IF
i
THEN
bak
i
bak
i
B
bak
i
a
bak
i
k
bak
i
0X
Files
Rename
name
bak
res
END
END
Backup
PROCEDURE
Store
VAR
S
Texts
Scanner
Menu
TextFrames
Frame
G
GraphicFrames
Frame
v
Viewers
Viewer
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
Menu
Oberon
Par
vwr
dsc
TextFrames
Frame
G
Menu
next
GraphicFrames
Frame
Texts
OpenScanner
S
Menu
text
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
S
s
Texts
WriteString
W
storing
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
GraphicFrames
Store
G
S
s
END
ELSE
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
v
Oberon
MarkedViewer
IF
v
dsc
NIL
v
dsc
next
IS
GraphicFrames
Frame
THEN
G
v
dsc
next
GraphicFrames
Frame
Texts
WriteString
W
S
s
Texts
WriteString
W
storing
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
GraphicFrames
Store
G
S
s
END
END
END
END
Store
PROCEDURE
Macro
VAR
S
Texts
Scanner
T
Texts
Text
time
beg
end
LONGINT
Lname
ARRAY
OF
CHAR
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Lname
S
s
Texts
Scan
S
IF
S
class
Texts
Name
THEN
GraphicFrames
Macro
Lname
S
s
END
END
END
Macro
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
Draw
NW
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
Draw
MODULE
Edit
JG
NW
IMPORT
Files
Fonts
Texts
Display
Viewers
Oberon
MenuViewers
TextFrames
CONST
CR
0DX
maxlen
StandardMenu
System
Close
System
Copy
System
Grow
Edit
Search
Edit
Store
VAR
W
Texts
Writer
time
LONGINT
M
INTEGER
pat
ARRAY
maxlen
OF
CHAR
d
ARRAY
OF
INTEGER
PROCEDURE
Max
i
j
LONGINT
LONGINT
VAR
m
LONGINT
BEGIN
IF
i
j
THEN
m
i
ELSE
m
j
END
RETURN
m
END
Max
PROCEDURE
Open
VAR
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
X
Y
INTEGER
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
OR
S
line
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
THEN
Oberon
AllocateUserViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Store
VAR
V
Viewers
Viewer
Text
TextFrames
Frame
T
Texts
Text
S
Texts
Scanner
f
Files
File
R
Files
Rider
beg
end
time
len
LONGINT
PROCEDURE
Backup
VAR
name
ARRAY
OF
CHAR
VAR
res
i
INTEGER
bak
ARRAY
OF
CHAR
BEGIN
i
WHILE
name
i
0X
DO
bak
i
name
i
INC
i
END
bak
i
bak
i
B
bak
i
a
bak
i
k
bak
i
0X
Files
Rename
name
bak
res
END
Backup
BEGIN
Texts
WriteString
W
Edit
Store
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
V
Oberon
Par
vwr
Texts
OpenScanner
S
V
dsc
TextFrames
Frame
text
ELSE
V
Oberon
MarkedViewer
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
END
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
Texts
WriteString
W
S
s
Texts
WriteInt
W
Text
text
len
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
Texts
Close
Text
text
S
s
END
END
Store
PROCEDURE
CopyLooks
VAR
T
Texts
Text
F
TextFrames
Frame
v
Viewers
Viewer
beg
end
time
LONGINT
fnt
Fonts
Font
col
voff
INTEGER
BEGIN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
v
Oberon
FocusViewer
IF
v
NIL
v
dsc
NIL
v
dsc
next
IS
TextFrames
Frame
THEN
F
v
dsc
next
TextFrames
Frame
Texts
Attributes
F
text
F
carloc
pos
fnt
col
voff
Texts
ChangeLooks
T
beg
end
fnt
col
voff
END
END
END
CopyLooks
PROCEDURE
ChangeFont
VAR
S
Texts
Scanner
T
Texts
Text
beg
end
LONGINT
BEGIN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
ChangeLooks
T
beg
end
Fonts
This
S
s
END
END
END
ChangeFont
PROCEDURE
ChangeColor
VAR
S
Texts
Scanner
T
Texts
Text
col
INTEGER
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
col
S
i
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
ChangeLooks
T
beg
end
NIL
col
END
END
END
ChangeColor
PROCEDURE
ChangeOffset
VAR
S
Texts
Scanner
T
Texts
Text
voff
INTEGER
ch
CHAR
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
voff
S
i
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
ChangeLooks
T
beg
end
NIL
voff
END
END
END
ChangeOffset
PROCEDURE
Search
uses
global
variables
M
pat
d
for
Boyer
Moore
search
VAR
Text
TextFrames
Frame
V
Viewers
Viewer
R
Texts
Reader
T
Texts
Text
pos
beg
end
prevTime
len
LONGINT
n
i
j
INTEGER
buf
ARRAY
OF
CHAR
PROCEDURE
Forward
n
INTEGER
VAR
R
Texts
Reader
VAR
buf
ARRAY
OF
CHAR
VAR
m
INTEGER
j
INTEGER
BEGIN
m
M
n
j
WHILE
j
m
DO
buf
j
buf
n
j
INC
j
END
WHILE
j
M
DO
Texts
Read
R
buf
j
INC
j
END
END
Forward
BEGIN
V
Oberon
Par
vwr
IF
Oberon
Par
frame
V
dsc
THEN
V
Oberon
FocusViewer
END
IF
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
prevTime
time
Oberon
GetSelection
T
beg
end
time
IF
time
prevTime
THEN
Texts
OpenReader
R
T
beg
i
pos
beg
REPEAT
Texts
Read
R
pat
i
INC
i
INC
pos
UNTIL
i
maxlen
OR
pos
end
M
i
j
WHILE
j
DO
d
j
M
INC
j
END
j
WHILE
j
M
DO
d
ORD
pat
j
M
j
INC
j
END
END
IF
Text
hasCar
THEN
pos
Text
carloc
pos
ELSE
pos
END
len
Text
text
len
Texts
OpenReader
R
Text
text
pos
Forward
M
R
buf
pos
pos
M
j
M
REPEAT
DEC
j
UNTIL
j
OR
buf
j
pat
j
WHILE
j
pos
len
DO
n
d
ORD
buf
M
Forward
n
R
buf
INC
pos
n
j
M
REPEAT
DEC
j
UNTIL
j
OR
buf
j
pat
j
END
IF
j
THEN
TextFrames
RemoveSelection
Text
TextFrames
RemoveCaret
Text
Oberon
RemoveMarks
Text
X
Text
Y
Text
W
Text
H
TextFrames
Show
Text
pos
Oberon
PassFocus
V
TextFrames
SetCaret
Text
pos
END
END
END
Search
PROCEDURE
Locate
VAR
Text
TextFrames
Frame
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
beg
end
time
LONGINT
BEGIN
V
Oberon
FocusViewer
IF
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
REPEAT
Texts
Scan
S
UNTIL
S
class
Texts
Int
skip
names
IF
S
class
Texts
Int
THEN
TextFrames
RemoveSelection
Text
TextFrames
RemoveCaret
Text
Oberon
RemoveMarks
Text
X
Text
Y
Text
W
Text
H
TextFrames
Show
Text
Max
S
i
Oberon
PassFocus
V
TextFrames
SetCaret
Text
S
i
END
END
END
END
Locate
PROCEDURE
Recall
VAR
Menu
Main
Display
Frame
buf
Texts
Buffer
V
Viewers
Viewer
pos
LONGINT
M
TextFrames
Frame
BEGIN
V
Oberon
FocusViewer
IF
V
NIL
V
IS
MenuViewers
Viewer
THEN
Menu
V
dsc
Main
V
dsc
next
IF
Main
IS
TextFrames
Frame
THEN
M
Main
TextFrames
Frame
IF
M
hasCar
THEN
TextFrames
Recall
buf
pos
M
carloc
pos
buf
len
Texts
Insert
M
text
M
carloc
pos
buf
TextFrames
SetCaret
M
pos
END
ELSIF
Menu
IS
TextFrames
Frame
THEN
M
Menu
TextFrames
Frame
IF
M
hasCar
THEN
TextFrames
Recall
buf
pos
M
carloc
pos
buf
len
Texts
Insert
M
text
M
carloc
pos
buf
TextFrames
SetCaret
M
pos
END
END
END
END
Recall
BEGIN
Texts
OpenWriter
W
END
Edit
MODULE
FileDir
NW
IMPORT
SYSTEM
Kernel
File
Directory
is
a
B
tree
with
its
root
page
at
DirRootAdr
Each
entry
contains
a
file
name
and
the
disk
address
of
the
file
s
head
sector
CONST
FnLength
SecTabSize
ExTabSize
SectorSize
IndexSize
SectorSize
DIV
HeaderSize
DirRootAdr
DirPgSize
N
DirPgSize
DIV
DirMark
9B1EA38DH
HeaderMark
9BA71D86H
FillerSize
TYPE
DiskAdr
INTEGER
FileName
ARRAY
FnLength
OF
CHAR
SectorTable
ARRAY
SecTabSize
OF
DiskAdr
ExtensionTable
ARRAY
ExTabSize
OF
DiskAdr
EntryHandler
PROCEDURE
name
FileName
sec
DiskAdr
VAR
continue
BOOLEAN
FileHeader
RECORD
first
page
of
each
file
on
disk
mark
INTEGER
name
FileName
aleng
bleng
date
INTEGER
ext
ExtensionTable
sec
SectorTable
fill
ARRAY
SectorSize
HeaderSize
OF
BYTE
END
FileHd
POINTER
TO
FileHeader
IndexSector
ARRAY
IndexSize
OF
DiskAdr
DataSector
ARRAY
SectorSize
OF
BYTE
DirEntry
B
tree
node
RECORD
name
FileName
adr
DiskAdr
sec
no
of
file
header
p
DiskAdr
sec
no
of
descendant
in
directory
END
DirPage
RECORD
mark
INTEGER
m
INTEGER
p0
DiskAdr
sec
no
of
left
descendant
in
directory
fill
ARRAY
FillerSize
OF
BYTE
e
ARRAY
DirPgSize
OF
DirEntry
END
Exported
procedures
Search
Insert
Delete
Enumerate
Init
PROCEDURE
Search
name
FileName
VAR
A
DiskAdr
VAR
i
L
R
INTEGER
dadr
DiskAdr
a
DirPage
BEGIN
dadr
DirRootAdr
A
REPEAT
Kernel
GetSector
dadr
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
a
m
name
a
e
R
name
THEN
A
a
e
R
adr
found
ELSIF
R
THEN
dadr
a
p0
ELSE
dadr
a
e
R
p
END
UNTIL
dadr
OR
A
END
Search
PROCEDURE
insert
name
FileName
dpg0
DiskAdr
VAR
h
BOOLEAN
VAR
v
DirEntry
fad
DiskAdr
h
tree
has
become
higher
and
v
is
ascending
element
VAR
ch
CHAR
i
j
L
R
INTEGER
dpg1
DiskAdr
u
DirEntry
a
DirPage
BEGIN
h
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
a
m
name
a
e
R
name
THEN
a
e
R
adr
fad
Kernel
PutSector
dpg0
a
replace
ELSE
not
on
this
page
IF
R
THEN
dpg1
a
p0
ELSE
dpg1
a
e
R
p
END
IF
dpg1
THEN
not
in
tree
insert
u
adr
fad
u
p
h
TRUE
j
REPEAT
ch
name
j
u
name
j
ch
INC
j
UNTIL
ch
0X
WHILE
j
FnLength
DO
u
name
j
0X
INC
j
END
ELSE
insert
name
dpg1
h
u
fad
END
IF
h
THEN
insert
u
to
the
left
of
e
R
IF
a
m
DirPgSize
THEN
h
FALSE
i
a
m
WHILE
i
R
DO
DEC
i
a
e
i
a
e
i
END
a
e
R
u
INC
a
m
ELSE
split
page
and
assign
the
middle
element
to
v
a
m
N
a
mark
DirMark
IF
R
N
THEN
insert
in
left
half
v
a
e
N
i
N
WHILE
i
R
DO
DEC
i
a
e
i
a
e
i
END
a
e
R
u
Kernel
PutSector
dpg0
a
Kernel
AllocSector
dpg0
dpg0
i
WHILE
i
N
DO
a
e
i
a
e
i
N
INC
i
END
ELSE
insert
in
right
half
Kernel
PutSector
dpg0
a
Kernel
AllocSector
dpg0
dpg0
DEC
R
N
i
IF
R
THEN
v
u
ELSE
v
a
e
N
WHILE
i
R
DO
a
e
i
a
e
N
i
INC
i
END
a
e
i
u
INC
i
END
WHILE
i
N
DO
a
e
i
a
e
N
i
INC
i
END
END
a
p0
v
p
v
p
dpg0
END
Kernel
PutSector
dpg0
a
END
END
END
insert
PROCEDURE
Insert
name
FileName
fad
DiskAdr
VAR
oldroot
DiskAdr
h
BOOLEAN
U
DirEntry
a
DirPage
BEGIN
h
FALSE
insert
name
DirRootAdr
h
U
fad
IF
h
THEN
root
overflow
Kernel
GetSector
DirRootAdr
a
ASSERT
a
mark
DirMark
Kernel
AllocSector
DirRootAdr
oldroot
Kernel
PutSector
oldroot
a
a
mark
DirMark
a
m
a
p0
oldroot
a
e
U
Kernel
PutSector
DirRootAdr
a
END
END
Insert
PROCEDURE
underflow
VAR
c
DirPage
ancestor
page
dpg0
DiskAdr
s
INTEGER
insertion
point
in
c
VAR
h
BOOLEAN
c
undersize
VAR
i
k
INTEGER
dpg1
DiskAdr
a
b
DirPage
a
underflowing
page
b
neighbouring
page
BEGIN
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
h
a
m
N
dpg0
c
e
s
p
IF
s
c
m
THEN
b
page
to
the
right
of
a
dpg1
c
e
s
p
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
k
b
m
N
DIV
k
no
of
items
available
on
page
b
a
e
N
c
e
s
a
e
N
p
b
p0
IF
k
THEN
move
k
items
from
b
to
a
one
to
c
i
WHILE
i
k
DO
a
e
i
N
b
e
i
INC
i
END
c
e
s
b
e
i
b
p0
c
e
s
p
c
e
s
p
dpg1
b
m
b
m
k
i
WHILE
i
b
m
DO
b
e
i
b
e
i
k
INC
i
END
Kernel
PutSector
dpg1
b
a
m
N
k
h
FALSE
ELSE
merge
pages
a
and
b
discard
b
i
WHILE
i
N
DO
a
e
i
N
b
e
i
INC
i
END
i
s
DEC
c
m
WHILE
i
c
m
DO
c
e
i
c
e
i
INC
i
END
a
m
N
h
c
m
N
END
Kernel
PutSector
dpg0
a
ELSE
b
page
to
the
left
of
a
DEC
s
IF
s
THEN
dpg1
c
p0
ELSE
dpg1
c
e
s
p
END
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
k
b
m
N
DIV
k
no
of
items
available
on
page
b
IF
k
THEN
i
N
WHILE
i
DO
DEC
i
a
e
i
k
a
e
i
END
i
k
a
e
i
c
e
s
a
e
i
p
a
p0
move
k
items
from
b
to
a
one
to
c
b
m
b
m
k
WHILE
i
DO
DEC
i
a
e
i
b
e
i
b
m
END
c
e
s
b
e
b
m
a
p0
c
e
s
p
c
e
s
p
dpg0
a
m
N
k
h
FALSE
Kernel
PutSector
dpg0
a
ELSE
merge
pages
a
and
b
discard
a
c
e
s
p
a
p0
b
e
N
c
e
s
i
WHILE
i
N
DO
b
e
i
N
a
e
i
INC
i
END
b
m
N
DEC
c
m
h
c
m
N
END
Kernel
PutSector
dpg1
b
END
END
underflow
PROCEDURE
delete
name
FileName
dpg0
DiskAdr
VAR
h
BOOLEAN
VAR
fad
DiskAdr
search
and
delete
entry
with
key
name
if
a
page
underflow
arises
balance
with
adjacent
page
or
merge
h
page
dpg0
is
undersize
VAR
i
L
R
INTEGER
dpg1
DiskAdr
a
DirPage
PROCEDURE
del
VAR
a
DirPage
R
INTEGER
dpg1
DiskAdr
VAR
h
BOOLEAN
VAR
dpg2
DiskAdr
global
a
R
b
DirPage
BEGIN
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
dpg2
b
e
b
m
p
IF
dpg2
THEN
del
a
R
dpg2
h
IF
h
THEN
underflow
b
dpg2
b
m
h
Kernel
PutSector
dpg1
b
END
ELSE
b
e
b
m
p
a
e
R
p
a
e
R
b
e
b
m
DEC
b
m
h
b
m
N
Kernel
PutSector
dpg1
b
END
END
del
BEGIN
h
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
THEN
dpg1
a
p0
ELSE
dpg1
a
e
R
p
END
IF
R
a
m
name
a
e
R
name
THEN
found
now
delete
fad
a
e
R
adr
IF
dpg1
THEN
a
is
a
leaf
page
DEC
a
m
h
a
m
N
i
R
WHILE
i
a
m
DO
a
e
i
a
e
i
INC
i
END
ELSE
del
a
R
dpg1
h
IF
h
THEN
underflow
a
dpg1
R
h
END
END
Kernel
PutSector
dpg0
a
ELSIF
dpg1
THEN
delete
name
dpg1
h
fad
IF
h
THEN
underflow
a
dpg1
R
h
Kernel
PutSector
dpg0
a
END
ELSE
not
in
tree
fad
END
END
delete
PROCEDURE
Delete
name
FileName
VAR
fad
DiskAdr
VAR
h
BOOLEAN
newroot
DiskAdr
a
DirPage
BEGIN
h
FALSE
delete
name
DirRootAdr
h
fad
IF
h
THEN
root
underflow
Kernel
GetSector
DirRootAdr
a
ASSERT
a
mark
DirMark
IF
a
m
a
p0
THEN
newroot
a
p0
Kernel
GetSector
newroot
a
ASSERT
a
mark
DirMark
Kernel
PutSector
DirRootAdr
a
discard
newroot
END
END
END
Delete
PROCEDURE
enumerate
prefix
ARRAY
OF
CHAR
dpg
DiskAdr
proc
EntryHandler
VAR
continue
BOOLEAN
VAR
i
j
INTEGER
pfx
nmx
CHAR
dpg1
DiskAdr
a
DirPage
BEGIN
Kernel
GetSector
dpg
a
ASSERT
a
mark
DirMark
i
WHILE
i
a
m
continue
DO
j
REPEAT
pfx
prefix
j
nmx
a
e
i
name
j
INC
j
UNTIL
nmx
pfx
OR
pfx
0X
IF
nmx
pfx
THEN
IF
i
THEN
dpg1
a
p0
ELSE
dpg1
a
e
i
p
END
IF
dpg1
THEN
enumerate
prefix
dpg1
proc
continue
END
IF
pfx
0X
THEN
IF
continue
THEN
proc
a
e
i
name
a
e
i
adr
continue
END
ELSE
continue
FALSE
END
END
INC
i
END
IF
continue
i
a
e
i
p
THEN
enumerate
prefix
a
e
i
p
proc
continue
END
END
enumerate
PROCEDURE
Enumerate
prefix
ARRAY
OF
CHAR
proc
EntryHandler
VAR
b
BOOLEAN
BEGIN
b
TRUE
enumerate
prefix
DirRootAdr
proc
b
END
Enumerate
initialization
PROCEDURE
Init
VAR
k
INTEGER
A
ARRAY
OF
DiskAdr
PROCEDURE
MarkSectors
VAR
A
ARRAY
OF
DiskAdr
k
INTEGER
VAR
L
R
i
j
n
INTEGER
x
DiskAdr
hd
FileHeader
B
IndexSector
PROCEDURE
sift
VAR
A
ARRAY
OF
DiskAdr
L
R
INTEGER
VAR
i
j
INTEGER
x
DiskAdr
BEGIN
j
L
x
A
j
REPEAT
i
j
j
j
IF
j
R
A
j
A
j
THEN
INC
j
END
IF
j
R
x
A
j
THEN
A
i
A
j
END
UNTIL
j
R
OR
x
A
j
A
i
x
END
sift
BEGIN
L
k
DIV
R
k
heapsort
WHILE
L
DO
DEC
L
sift
A
L
R
END
WHILE
R
DO
DEC
R
x
A
A
A
R
A
R
x
sift
A
L
R
END
WHILE
L
k
DO
Kernel
GetSector
A
L
hd
ASSERT
hd
mark
HeaderMark
IF
hd
aleng
SecTabSize
THEN
j
hd
aleng
REPEAT
DEC
j
Kernel
MarkSector
hd
sec
j
UNTIL
j
ELSE
j
SecTabSize
REPEAT
DEC
j
Kernel
MarkSector
hd
sec
j
UNTIL
j
n
hd
aleng
SecTabSize
DIV
i
WHILE
i
n
DO
Kernel
MarkSector
hd
ext
i
Kernel
GetSector
hd
ext
i
B
index
sector
IF
i
n
THEN
j
ELSE
j
hd
aleng
SecTabSize
MOD
END
REPEAT
DEC
j
Kernel
MarkSector
B
j
UNTIL
j
INC
i
END
END
INC
L
END
END
MarkSectors
PROCEDURE
TraverseDir
VAR
A
ARRAY
OF
DiskAdr
VAR
k
INTEGER
dpg
DiskAdr
VAR
i
INTEGER
a
DirPage
BEGIN
Kernel
GetSector
dpg
a
ASSERT
a
mark
DirMark
Kernel
MarkSector
dpg
i
WHILE
i
a
m
DO
A
k
a
e
i
adr
INC
k
INC
i
IF
k
THEN
MarkSectors
A
k
k
END
END
IF
a
p0
THEN
TraverseDir
A
k
a
p0
i
WHILE
i
a
m
DO
TraverseDir
A
k
a
e
i
p
INC
i
END
END
END
TraverseDir
BEGIN
k
TraverseDir
A
k
DirRootAdr
MarkSectors
A
k
END
Init
END
FileDir
MODULE
Files
NW
IMPORT
SYSTEM
Kernel
FileDir
A
file
consists
of
a
sequence
of
pages
The
first
page
contains
the
header
Part
of
the
header
is
the
page
table
an
array
of
disk
addresses
to
the
pages
A
file
is
referenced
through
riders
A
rider
indicates
a
current
position
and
refers
to
a
file
CONST
MaxBufs
HS
FileDir
HeaderSize
SS
FileDir
SectorSize
STS
FileDir
SecTabSize
XS
FileDir
IndexSize
TYPE
DiskAdr
INTEGER
File
POINTER
TO
FileDesc
Buffer
POINTER
TO
BufferRecord
Index
POINTER
TO
IndexRecord
Rider
RECORD
eof
BOOLEAN
res
INTEGER
file
File
apos
bpos
INTEGER
buf
Buffer
END
FileDesc
RECORD
next
INTEGER
list
of
files
invisible
to
the
GC
nofbufs
aleng
bleng
INTEGER
modH
registered
BOOLEAN
firstbuf
Buffer
sechint
DiskAdr
name
FileDir
FileName
date
INTEGER
ext
ARRAY
FileDir
ExTabSize
OF
Index
sec
FileDir
SectorTable
END
BufferRecord
RECORD
apos
lim
INTEGER
mod
BOOLEAN
next
Buffer
data
FileDir
DataSector
END
IndexRecord
RECORD
adr
DiskAdr
mod
BOOLEAN
sec
FileDir
IndexSector
END
aleng
SS
bleng
length
including
header
apos
SS
bpos
current
position
bpos
lim
SS
apos
aleng
PgTabSize
apos
aleng
lim
SS
OR
apos
aleng
VAR
root
INTEGER
File
list
of
open
files
PROCEDURE
Check
s
ARRAY
OF
CHAR
VAR
name
FileDir
FileName
VAR
res
INTEGER
VAR
i
INTEGER
ch
CHAR
BEGIN
ch
s
i
IF
ch
A
ch
Z
OR
ch
a
ch
z
THEN
REPEAT
name
i
ch
INC
i
ch
s
i
UNTIL
ch
ch
OR
ch
A
ch
Z
OR
ch
a
ch
z
OR
ch
OR
i
FileDir
FnLength
IF
i
FileDir
FnLength
THEN
res
ELSIF
ch
0X
THEN
res
WHILE
i
FileDir
FnLength
DO
name
i
0X
INC
i
END
ELSE
res
END
ELSIF
ch
0X
THEN
name
0X
res
ELSE
res
END
END
Check
PROCEDURE
Old
name
ARRAY
OF
CHAR
File
VAR
i
k
res
INTEGER
f
File
header
DiskAdr
buf
Buffer
F
FileDir
FileHd
namebuf
FileDir
FileName
inxpg
Index
BEGIN
f
NIL
Check
name
namebuf
res
IF
res
THEN
FileDir
Search
namebuf
header
IF
header
THEN
f
SYSTEM
VAL
File
root
WHILE
f
NIL
f
sec
header
DO
f
SYSTEM
VAL
File
f
next
END
IF
f
NIL
THEN
file
not
yet
present
NEW
buf
buf
apos
buf
next
buf
buf
mod
FALSE
F
SYSTEM
VAL
FileDir
FileHd
SYSTEM
ADR
buf
data
Kernel
GetSector
header
buf
data
ASSERT
F
mark
FileDir
HeaderMark
NEW
f
f
aleng
F
aleng
f
bleng
F
bleng
f
date
F
date
IF
f
aleng
THEN
buf
lim
f
bleng
ELSE
buf
lim
SS
END
f
firstbuf
buf
f
nofbufs
f
name
namebuf
f
registered
TRUE
f
sec
F
sec
k
f
aleng
XS
STS
DIV
XS
i
WHILE
i
k
DO
NEW
inxpg
inxpg
adr
F
ext
i
inxpg
mod
FALSE
Kernel
GetSector
inxpg
adr
inxpg
sec
f
ext
i
inxpg
INC
i
END
WHILE
i
FileDir
ExTabSize
DO
f
ext
i
NIL
INC
i
END
f
sechint
header
f
modH
FALSE
f
next
root
root
SYSTEM
VAL
INTEGER
f
END
END
END
RETURN
f
END
Old
PROCEDURE
New
name
ARRAY
OF
CHAR
File
VAR
i
res
INTEGER
f
File
buf
Buffer
F
FileDir
FileHd
namebuf
FileDir
FileName
BEGIN
f
NIL
Check
name
namebuf
res
IF
res
THEN
NEW
buf
buf
apos
buf
mod
TRUE
buf
lim
HS
buf
next
buf
F
SYSTEM
VAL
FileDir
FileHd
SYSTEM
ADR
buf
data
F
mark
FileDir
HeaderMark
F
aleng
F
bleng
HS
F
name
namebuf
F
date
Kernel
Clock
NEW
f
f
aleng
f
bleng
HS
f
modH
TRUE
f
registered
FALSE
f
date
F
date
f
firstbuf
buf
f
nofbufs
f
name
namebuf
f
sechint
i
REPEAT
f
ext
i
NIL
F
ext
i
INC
i
UNTIL
i
FileDir
ExTabSize
i
REPEAT
f
sec
i
F
sec
i
INC
i
UNTIL
i
STS
END
RETURN
f
END
New
PROCEDURE
UpdateHeader
f
File
VAR
F
FileDir
FileHeader
VAR
k
INTEGER
BEGIN
F
aleng
f
aleng
F
bleng
f
bleng
F
sec
f
sec
k
f
aleng
XS
STS
DIV
XS
WHILE
k
DO
DEC
k
F
ext
k
f
ext
k
adr
END
END
UpdateHeader
PROCEDURE
ReadBuf
f
File
buf
Buffer
pos
INTEGER
VAR
sec
DiskAdr
BEGIN
IF
pos
STS
THEN
sec
f
sec
pos
ELSE
sec
f
ext
pos
STS
DIV
XS
sec
pos
STS
MOD
XS
END
Kernel
GetSector
sec
buf
data
IF
pos
f
aleng
THEN
buf
lim
SS
ELSE
buf
lim
f
bleng
END
buf
apos
pos
buf
mod
FALSE
END
ReadBuf
PROCEDURE
WriteBuf
f
File
buf
Buffer
VAR
i
k
INTEGER
secadr
DiskAdr
inx
Index
BEGIN
IF
buf
apos
STS
THEN
secadr
f
sec
buf
apos
IF
secadr
THEN
Kernel
AllocSector
f
sechint
secadr
f
modH
TRUE
f
sec
buf
apos
secadr
f
sechint
secadr
END
IF
buf
apos
THEN
UpdateHeader
f
SYSTEM
VAL
FileDir
FileHeader
buf
data
f
modH
FALSE
END
ELSE
i
buf
apos
STS
DIV
XS
inx
f
ext
i
IF
inx
NIL
THEN
NEW
inx
inx
adr
inx
sec
f
ext
i
inx
f
modH
TRUE
END
k
buf
apos
STS
MOD
XS
secadr
inx
sec
k
IF
secadr
THEN
Kernel
AllocSector
f
sechint
secadr
f
modH
TRUE
inx
mod
TRUE
inx
sec
k
secadr
f
sechint
secadr
END
END
Kernel
PutSector
secadr
buf
data
buf
mod
FALSE
END
WriteBuf
PROCEDURE
Buf
f
File
pos
INTEGER
Buffer
VAR
buf
Buffer
BEGIN
buf
f
firstbuf
WHILE
buf
apos
pos
buf
next
f
firstbuf
DO
buf
buf
next
END
IF
buf
apos
pos
THEN
buf
NIL
END
RETURN
buf
END
Buf
PROCEDURE
GetBuf
f
File
pos
INTEGER
Buffer
VAR
buf
Buffer
BEGIN
buf
f
firstbuf
WHILE
buf
apos
pos
buf
next
f
firstbuf
DO
buf
buf
next
END
IF
buf
apos
pos
THEN
IF
f
nofbufs
MaxBufs
THEN
allocate
new
buffer
NEW
buf
buf
next
f
firstbuf
next
f
firstbuf
next
buf
INC
f
nofbufs
ELSE
reuse
a
buffer
f
firstbuf
buf
IF
buf
mod
THEN
WriteBuf
f
buf
END
END
IF
pos
f
aleng
THEN
ReadBuf
f
buf
pos
ELSE
buf
apos
pos
buf
lim
buf
mod
FALSE
END
END
RETURN
buf
END
GetBuf
PROCEDURE
Unbuffer
f
File
VAR
i
k
INTEGER
buf
Buffer
inx
Index
head
FileDir
FileHeader
BEGIN
buf
f
firstbuf
REPEAT
IF
buf
mod
THEN
WriteBuf
f
buf
END
buf
buf
next
UNTIL
buf
f
firstbuf
k
f
aleng
XS
STS
DIV
XS
i
WHILE
i
k
DO
inx
f
ext
i
INC
i
IF
inx
mod
THEN
IF
inx
adr
THEN
Kernel
AllocSector
f
sechint
inx
adr
f
sechint
inx
adr
f
modH
TRUE
END
Kernel
PutSector
inx
adr
inx
sec
inx
mod
FALSE
END
END
IF
f
modH
THEN
Kernel
GetSector
f
sec
head
UpdateHeader
f
head
Kernel
PutSector
f
sec
head
f
modH
FALSE
END
END
Unbuffer
PROCEDURE
Register
f
File
BEGIN
IF
f
NIL
f
name
0X
THEN
Unbuffer
f
IF
f
registered
THEN
FileDir
Insert
f
name
f
sec
f
registered
TRUE
f
next
root
root
SYSTEM
VAL
INTEGER
f
END
END
END
Register
PROCEDURE
Close
f
File
BEGIN
IF
f
NIL
THEN
Unbuffer
f
END
END
Close
PROCEDURE
Purge
f
File
VAR
a
i
j
k
INTEGER
ind
FileDir
IndexSector
BEGIN
IF
f
NIL
THEN
a
f
aleng
f
aleng
f
bleng
HS
IF
a
STS
THEN
i
a
ELSE
i
STS
DEC
a
i
j
a
MOD
XS
k
a
DIV
XS
WHILE
k
DO
Kernel
GetSector
f
ext
k
adr
ind
REPEAT
DEC
j
Kernel
FreeSector
ind
j
UNTIL
j
Kernel
FreeSector
f
ext
k
adr
j
XS
DEC
k
END
END
REPEAT
DEC
i
Kernel
FreeSector
f
sec
i
UNTIL
i
END
END
Purge
PROCEDURE
Delete
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
adr
DiskAdr
namebuf
FileDir
FileName
BEGIN
Check
name
namebuf
res
IF
res
THEN
FileDir
Delete
namebuf
adr
IF
adr
THEN
res
END
END
END
Delete
PROCEDURE
Rename
old
new
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
adr
DiskAdr
oldbuf
newbuf
FileDir
FileName
head
FileDir
FileHeader
BEGIN
Check
old
oldbuf
res
IF
res
THEN
Check
new
newbuf
res
IF
res
THEN
FileDir
Delete
oldbuf
adr
IF
adr
THEN
FileDir
Insert
newbuf
adr
Kernel
GetSector
adr
head
head
name
newbuf
Kernel
PutSector
adr
head
ELSE
res
END
END
END
END
Rename
PROCEDURE
Length
f
File
INTEGER
BEGIN
RETURN
f
aleng
SS
f
bleng
HS
END
Length
PROCEDURE
Date
f
File
INTEGER
BEGIN
RETURN
f
date
END
Date
Read
PROCEDURE
Set
VAR
r
Rider
f
File
pos
INTEGER
VAR
a
b
INTEGER
BEGIN
r
eof
FALSE
r
res
IF
f
NIL
THEN
IF
pos
THEN
a
b
HS
ELSIF
pos
f
aleng
SS
f
bleng
HS
THEN
a
pos
HS
DIV
SS
b
pos
HS
MOD
SS
ELSE
a
f
aleng
b
f
bleng
END
r
file
f
r
apos
a
r
bpos
b
r
buf
f
firstbuf
ELSE
r
file
NIL
END
END
Set
PROCEDURE
Pos
VAR
r
Rider
INTEGER
BEGIN
RETURN
r
apos
SS
r
bpos
HS
END
Pos
PROCEDURE
Base
VAR
r
Rider
File
BEGIN
RETURN
r
file
END
Base
PROCEDURE
ReadByte
VAR
r
Rider
VAR
x
BYTE
VAR
buf
Buffer
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
x
r
buf
data
r
bpos
INC
r
bpos
ELSIF
r
apos
r
file
aleng
THEN
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
buf
mod
THEN
WriteBuf
r
file
r
buf
END
ReadBuf
r
file
r
buf
r
apos
ELSE
r
buf
buf
END
x
r
buf
data
r
bpos
ELSE
x
r
eof
TRUE
END
END
ReadByte
PROCEDURE
ReadBytes
VAR
r
Rider
VAR
x
ARRAY
OF
BYTE
n
INTEGER
VAR
i
INTEGER
BEGIN
i
this
implementation
is
to
be
improved
WHILE
i
n
DO
ReadByte
r
x
i
INC
i
END
END
ReadBytes
PROCEDURE
Read
VAR
r
Rider
VAR
ch
CHAR
VAR
buf
Buffer
same
as
ReadByte
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
ch
CHR
r
buf
data
r
bpos
INC
r
bpos
ELSIF
r
apos
r
file
aleng
THEN
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
buf
mod
THEN
WriteBuf
r
file
r
buf
END
ReadBuf
r
file
r
buf
r
apos
ELSE
r
buf
buf
END
ch
CHR
r
buf
data
r
bpos
ELSE
ch
0X
r
eof
TRUE
END
END
Read
PROCEDURE
ReadInt
VAR
R
Rider
VAR
x
INTEGER
VAR
x0
x1
x2
x3
BYTE
BEGIN
ReadByte
R
x0
ReadByte
R
x1
ReadByte
R
x2
ReadByte
R
x3
x
x3
100H
x2
100H
x1
100H
x0
END
ReadInt
PROCEDURE
ReadSet
VAR
R
Rider
VAR
s
SET
VAR
n
INTEGER
BEGIN
ReadInt
R
SYSTEM
VAL
INTEGER
s
END
ReadSet
PROCEDURE
ReadReal
VAR
R
Rider
VAR
x
REAL
VAR
n
INTEGER
BEGIN
ReadInt
R
SYSTEM
VAL
INTEGER
x
END
ReadReal
PROCEDURE
ReadString
VAR
R
Rider
VAR
x
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
i
Read
R
ch
WHILE
ch
0X
DO
IF
i
LEN
x
THEN
x
i
ch
INC
i
END
Read
R
ch
END
x
i
0X
END
ReadString
PROCEDURE
ReadNum
VAR
R
Rider
VAR
x
INTEGER
VAR
n
y
INTEGER
b
BYTE
BEGIN
n
y
ReadByte
R
b
WHILE
b
80H
DO
y
ROR
y
b
80H
DEC
n
ReadByte
R
b
END
IF
n
THEN
x
ROR
y
b
MOD
10H
ELSE
x
ASR
ROR
y
b
n
END
END
ReadNum
Write
PROCEDURE
NewExt
f
File
VAR
i
k
INTEGER
ext
Index
BEGIN
k
f
aleng
STS
DIV
XS
NEW
ext
ext
adr
ext
mod
TRUE
f
ext
k
ext
i
XS
REPEAT
DEC
i
ext
sec
i
UNTIL
i
END
NewExt
PROCEDURE
WriteByte
VAR
r
Rider
x
BYTE
VAR
f
File
buf
Buffer
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
IF
r
bpos
SS
THEN
INC
r
buf
lim
INC
r
file
bleng
r
file
modH
TRUE
ELSE
f
r
file
WriteBuf
f
r
buf
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
apos
f
aleng
THEN
ReadBuf
f
r
buf
r
apos
ELSE
r
buf
apos
r
apos
r
buf
lim
f
aleng
f
aleng
f
bleng
f
modH
TRUE
IF
f
aleng
STS
MOD
XS
THEN
NewExt
f
END
END
ELSE
r
buf
buf
END
r
bpos
END
END
r
buf
data
r
bpos
x
INC
r
bpos
r
buf
mod
TRUE
END
WriteByte
PROCEDURE
WriteBytes
VAR
r
Rider
x
ARRAY
OF
BYTE
n
INTEGER
VAR
i
INTEGER
BEGIN
i
this
implementation
is
to
be
improed
WHILE
i
n
DO
WriteByte
r
x
i
INC
i
END
END
WriteBytes
PROCEDURE
Write
VAR
r
Rider
ch
CHAR
VAR
f
File
buf
Buffer
BEGIN
same
as
WriteByte
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
IF
r
bpos
SS
THEN
INC
r
buf
lim
INC
r
file
bleng
r
file
modH
TRUE
ELSE
f
r
file
WriteBuf
f
r
buf
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
apos
f
aleng
THEN
ReadBuf
f
r
buf
r
apos
ELSE
r
buf
apos
r
apos
r
buf
lim
f
aleng
f
aleng
f
bleng
f
modH
TRUE
IF
f
aleng
STS
MOD
XS
THEN
NewExt
f
END
END
ELSE
r
buf
buf
END
r
bpos
END
END
r
buf
data
r
bpos
ORD
ch
INC
r
bpos
r
buf
mod
TRUE
END
Write
PROCEDURE
WriteInt
VAR
R
Rider
x
INTEGER
BEGIN
WriteByte
R
x
MOD
100H
WriteByte
R
x
DIV
100H
MOD
100H
WriteByte
R
x
DIV
10000H
MOD
100H
WriteByte
R
x
DIV
1000000H
MOD
100H
END
WriteInt
PROCEDURE
WriteSet
VAR
R
Rider
s
SET
BEGIN
WriteInt
R
ORD
s
END
WriteSet
PROCEDURE
WriteReal
VAR
R
Rider
x
REAL
BEGIN
WriteInt
R
ORD
x
END
WriteReal
PROCEDURE
WriteString
VAR
R
Rider
x
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
i
REPEAT
ch
x
i
Write
R
ch
INC
i
UNTIL
ch
0X
END
WriteString
PROCEDURE
WriteNum
VAR
R
Rider
x
INTEGER
BEGIN
WHILE
x
40H
OR
x
40H
DO
WriteByte
R
x
MOD
80H
80H
x
ASR
x
END
WriteByte
R
x
MOD
80H
END
WriteNum
System
use
PROCEDURE
Init
BEGIN
root
Kernel
Init
FileDir
Init
END
Init
PROCEDURE
RestoreList
after
mark
phase
of
garbage
collection
VAR
f
f0
INTEGER
PROCEDURE
mark
f
INTEGER
INTEGER
VAR
m
INTEGER
BEGIN
IF
f
THEN
m
ELSE
SYSTEM
GET
f
m
END
RETURN
m
END
mark
BEGIN
field
next
has
offset
WHILE
mark
root
DO
SYSTEM
GET
root
root
END
f
root
WHILE
f
DO
f0
f
REPEAT
SYSTEM
GET
f0
f0
UNTIL
mark
f0
SYSTEM
PUT
f
f0
f
f0
END
END
RestoreList
END
Files
MODULE
Fonts
JG
PDR
NW
IMPORT
SYSTEM
Files
CONST
FontFileId
0DBH
TYPE
Font
POINTER
TO
FontDesc
FontDesc
RECORD
name
ARRAY
OF
CHAR
height
minX
maxX
minY
maxY
INTEGER
next
Font
T
ARRAY
OF
INTEGER
raster
ARRAY
OF
BYTE
END
LargeFontDesc
RECORD
FontDesc
ext
ARRAY
OF
BYTE
END
LargeFont
POINTER
TO
LargeFontDesc
raster
sizes
Syntax8
Syntax10
Syntax12
Syntax14
Syntax14b
Syntax16
Syntax20
Syntac24
Syntax24b
VAR
Default
root
Font
PROCEDURE
GetPat
fnt
Font
ch
CHAR
VAR
dx
x
y
w
h
patadr
INTEGER
VAR
pa
INTEGER
dxb
xb
yb
wb
hb
BYTE
BEGIN
pa
fnt
T
ORD
ch
MOD
80H
patadr
pa
SYSTEM
GET
pa
dxb
SYSTEM
GET
pa
xb
SYSTEM
GET
pa
yb
SYSTEM
GET
pa
wb
SYSTEM
GET
pa
hb
dx
dxb
x
xb
y
yb
w
wb
h
hb
IF
yb
THEN
y
yb
ELSE
y
yb
END
END
GetPat
PROCEDURE
This
name
ARRAY
OF
CHAR
Font
TYPE
RunRec
RECORD
beg
end
BYTE
END
BoxRec
RECORD
dx
x
y
w
h
BYTE
END
VAR
F
Font
LF
LargeFont
f
Files
File
R
Files
Rider
NofRuns
NofBoxes
BYTE
NofBytes
INTEGER
height
minX
maxX
minY
maxY
BYTE
i
j
k
m
n
INTEGER
a
a0
INTEGER
b
beg
end
BYTE
run
ARRAY
OF
RunRec
box
ARRAY
OF
BoxRec
PROCEDURE
RdInt16
VAR
R
Files
Rider
VAR
b0
BYTE
VAR
b1
BYTE
BEGIN
Files
ReadByte
R
b0
Files
ReadByte
R
b1
END
RdInt16
BEGIN
F
root
WHILE
F
NIL
name
F
name
DO
F
F
next
END
IF
F
NIL
THEN
f
Files
Old
name
IF
f
NIL
THEN
Files
Set
R
f
Files
ReadByte
R
b
IF
b
FontFileId
THEN
Files
ReadByte
R
b
abstraction
Files
ReadByte
R
b
family
Files
ReadByte
R
b
variant
NEW
F
F
name
name
RdInt16
R
height
RdInt16
R
minX
RdInt16
R
maxX
RdInt16
R
minY
RdInt16
R
maxY
RdInt16
R
NofRuns
NofBoxes
k
WHILE
k
NofRuns
DO
RdInt16
R
beg
run
k
beg
beg
RdInt16
R
end
run
k
end
end
NofBoxes
NofBoxes
end
beg
INC
k
END
NofBytes
j
WHILE
j
NofBoxes
DO
RdInt16
R
box
j
dx
RdInt16
R
box
j
x
RdInt16
R
box
j
y
RdInt16
R
box
j
w
RdInt16
R
box
j
h
NofBytes
NofBytes
box
j
w
DIV
box
j
h
INC
j
END
IF
NofBytes
THEN
NEW
F
ELSE
NEW
LF
F
LF
END
F
name
name
F
height
height
F
minX
minX
F
maxX
maxX
F
maxY
maxY
IF
minY
80H
THEN
F
minY
minY
100H
ELSE
F
minY
minY
END
a0
SYSTEM
ADR
F
raster
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
null
pattern
for
characters
not
in
a
run
INC
a0
a
a0
j
k
m
WHILE
k
NofRuns
DO
WHILE
m
run
k
beg
m
DO
F
T
m
a0
INC
m
END
WHILE
m
run
k
end
m
DO
F
T
m
a
SYSTEM
PUT
a
box
j
dx
SYSTEM
PUT
a
box
j
x
SYSTEM
PUT
a
box
j
y
SYSTEM
PUT
a
box
j
w
SYSTEM
PUT
a
box
j
h
INC
a
n
box
j
w
DIV
box
j
h
WHILE
n
DO
DEC
n
Files
ReadByte
R
b
SYSTEM
PUT
a
b
INC
a
END
INC
j
INC
m
END
INC
k
END
WHILE
m
DO
F
T
m
a0
INC
m
END
F
next
root
root
F
ELSE
bad
file
id
F
Default
END
ELSE
font
file
not
available
F
Default
END
END
RETURN
F
END
This
PROCEDURE
Free
remove
all
but
first
two
from
font
list
VAR
f
Font
BEGIN
f
root
next
IF
f
NIL
THEN
f
f
next
END
f
next
NIL
END
Free
BEGIN
root
NIL
Default
This
Oberon10
Scn
Fnt
END
Fonts
MODULE
GraphicFrames
NW
IMPORT
SYSTEM
Display
Viewers
Input
Fonts
Texts
Graphics
Oberon
MenuViewers
CONST
update
message
ids
drawobj
drawobjs
drawobjd
drawnorm
drawsel
drawdel
markW
TYPE
Frame
POINTER
TO
FrameDesc
Location
POINTER
TO
LocDesc
LocDesc
RECORD
x
y
INTEGER
next
Location
END
FrameDesc
RECORD
Display
FrameDesc
graph
Graphics
Graph
Xg
Yg
INTEGER
pos
rel
to
graph
origin
X1
Y1
INTEGER
right
and
upper
margins
x
y
col
INTEGER
x
X
Xg
y
Y
Yg
marked
ticked
BOOLEAN
mark
LocDesc
END
DrawMsg
RECORD
Graphics
Msg
f
Frame
x
y
col
mode
INTEGER
END
UpdateMsg
RECORD
Display
FrameMsg
id
INTEGER
graph
Graphics
Graph
obj
Graphics
Object
END
ChangedMsg
RECORD
Display
FrameMsg
f
Frame
graph
Graphics
Graph
mode
INTEGER
END
SelQuery
RECORD
Display
FrameMsg
f
Frame
time
LONGINT
END
FocusQuery
RECORD
Display
FrameMsg
f
Frame
END
PosQuery
RECORD
Display
FrameMsg
f
Frame
x
y
INTEGER
END
DispMsg
RECORD
Display
FrameMsg
x1
y1
w
INTEGER
pat
INTEGER
graph
Graphics
Graph
END
VAR
Crosshair
Oberon
Marker
tack
dotted
dotted1
INTEGER
patterns
newcap
Graphics
Caption
TBuf
Texts
Buffer
DW
DH
CL
INTEGER
W
Texts
Writer
Exported
procedures
Restore
Focus
Selected
This
Draw
DrawNorm
Erase
DrawObj
EraseObj
Change
Defocus
Deselect
Macro
Open
PROCEDURE
SetChangeMark
F
Frame
col
INTEGER
set
mark
in
corner
of
frame
BEGIN
IF
F
H
THEN
IF
col
THEN
Display
ReplConst
Display
black
F
X
F
W
F
Y
F
H
Display
replace
ELSE
Display
CopyPattern
Display
white
Display
block
F
X
F
W
F
Y
F
H
Display
paint
END
END
END
SetChangeMark
PROCEDURE
Restore
F
Frame
VAR
x
x0
y
INTEGER
M
DrawMsg
BEGIN
F
X1
F
X
F
W
F
Y1
F
Y
F
H
F
x
F
X
F
Xg
DIV
F
y
F
Y
F
Yg
DIV
F
marked
FALSE
F
mark
next
NIL
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Display
ReplConst
F
col
F
X
F
Y
F
W
F
H
IF
F
ticked
THEN
x0
F
X
DIV
y
F
Y
DIV
WHILE
y
F
Y1
DO
x
x0
WHILE
x
F
X1
DO
Display
Dot
Display
white
x
y
Display
replace
INC
x
END
INC
y
END
END
M
f
F
M
x
F
x
M
y
F
y
M
col
M
mode
Graphics
Draw
F
graph
M
IF
F
graph
changed
THEN
SetChangeMark
F
END
END
Restore
PROCEDURE
FlipCross
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
cross
X
Y
Display
invert
END
FlipCross
PROCEDURE
Focus
Frame
VAR
FQ
FocusQuery
BEGIN
FQ
f
NIL
Viewers
Broadcast
FQ
RETURN
FQ
f
END
Focus
PROCEDURE
Selected
Frame
VAR
SQ
SelQuery
BEGIN
SQ
f
NIL
SQ
time
Viewers
Broadcast
SQ
RETURN
SQ
f
END
Selected
PROCEDURE
This
x
y
INTEGER
Frame
VAR
PQ
PosQuery
BEGIN
PQ
f
NIL
PQ
x
x
PQ
y
y
Viewers
Broadcast
PQ
RETURN
PQ
f
END
This
PROCEDURE
Mark
F
Frame
mode
INTEGER
VAR
CM
ChangedMsg
BEGIN
CM
f
F
CM
graph
F
graph
CM
mode
mode
Viewers
Broadcast
CM
END
Mark
PROCEDURE
Draw
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawsel
UM
graph
F
graph
Viewers
Broadcast
UM
END
Draw
PROCEDURE
DrawNorm
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawnorm
UM
graph
F
graph
Viewers
Broadcast
UM
END
DrawNorm
PROCEDURE
Erase
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawdel
UM
graph
F
graph
Viewers
Broadcast
UM
Mark
F
END
Erase
PROCEDURE
DrawObj
F
Frame
obj
Graphics
Object
VAR
UM
UpdateMsg
BEGIN
UM
id
drawobj
UM
graph
F
graph
UM
obj
obj
Viewers
Broadcast
UM
END
DrawObj
PROCEDURE
EraseObj
F
Frame
obj
Graphics
Object
VAR
UM
UpdateMsg
BEGIN
UM
id
drawobjd
UM
graph
F
graph
UM
obj
obj
Viewers
Broadcast
UM
END
EraseObj
PROCEDURE
Change
F
Frame
VAR
msg
Graphics
Msg
BEGIN
IF
F
NIL
THEN
Erase
F
Graphics
Change
F
graph
msg
Draw
F
END
END
Change
PROCEDURE
FlipMark
x
y
INTEGER
BEGIN
Display
ReplConst
Display
white
x
y
Display
ReplConst
Display
white
x
y
END
FlipMark
PROCEDURE
Defocus
F
Frame
VAR
m
Location
BEGIN
newcap
NIL
IF
F
marked
THEN
FlipMark
F
mark
x
F
mark
y
m
F
mark
next
WHILE
m
NIL
DO
FlipMark
m
x
m
y
m
m
next
END
F
marked
FALSE
F
mark
next
NIL
END
END
Defocus
PROCEDURE
Deselect
F
Frame
VAR
UM
UpdateMsg
BEGIN
IF
F
NIL
THEN
UM
id
drawnorm
UM
graph
F
graph
Viewers
Broadcast
UM
Graphics
Deselect
F
graph
END
END
Deselect
PROCEDURE
Macro
Lname
Mname
ARRAY
OF
CHAR
VAR
x
y
INTEGER
F
Frame
mac
Graphics
Macro
mh
Graphics
MacHead
L
Graphics
Library
BEGIN
F
Focus
IF
F
NIL
THEN
x
F
mark
x
F
x
y
F
mark
y
F
y
Graphics
GetLib
Lname
FALSE
L
IF
L
NIL
THEN
mh
Graphics
ThisMac
L
Mname
IF
mh
NIL
THEN
Deselect
F
Defocus
F
NEW
mac
mac
x
x
mac
y
y
mac
w
mh
w
mac
h
mh
h
mac
mac
mh
mac
do
Graphics
MacMethod
mac
col
Oberon
CurCol
Graphics
Add
F
graph
mac
DrawObj
F
mac
Mark
F
END
ELSE
Texts
WriteString
W
Lname
Texts
WriteString
W
not
available
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
END
Macro
PROCEDURE
CaptionCopy
F
Frame
x1
y1
INTEGER
T
Texts
Text
beg
end
LONGINT
Graphics
Caption
VAR
ch
CHAR
dx
w
x2
y2
w1
h1
INTEGER
cap
Graphics
Caption
pat
INTEGER
R
Texts
Reader
BEGIN
Texts
Write
W
0DX
NEW
cap
cap
len
end
beg
cap
pos
Graphics
T
len
cap
do
Graphics
CapMethod
Texts
OpenReader
R
T
beg
Texts
Read
R
ch
W
fnt
R
fnt
W
col
R
col
w
cap
x
x1
F
x
cap
y
y1
F
y
R
fnt
minY
WHILE
beg
end
DO
Fonts
GetPat
R
fnt
ch
dx
x2
y2
w1
h1
pat
INC
w
dx
INC
beg
Texts
Write
W
ch
Texts
Read
R
ch
END
cap
w
w
cap
h
W
fnt
height
cap
col
W
col
Texts
Append
Graphics
T
W
buf
Graphics
Add
F
graph
cap
Mark
F
RETURN
cap
END
CaptionCopy
PROCEDURE
NewLine
F
Frame
G
Graphics
Graph
x
y
w
h
INTEGER
VAR
line
Graphics
Line
BEGIN
NEW
line
line
col
Oberon
CurCol
line
x
x
F
x
line
y
y
F
y
line
w
w
line
h
h
line
do
Graphics
LineMethod
Graphics
Add
G
line
Mark
F
END
NewLine
PROCEDURE
Edit
F
Frame
x0
y0
INTEGER
k0
SET
VAR
obj
Graphics
Object
x1
y1
w
h
t
INTEGER
beg
end
time
LONGINT
k1
k2
SET
mark
newmark
Location
T
Texts
Text
Fd
Frame
G
Graphics
Graph
BEGIN
k1
k0
G
F
graph
REPEAT
Input
Mouse
k2
x1
y1
k1
k1
k2
DEC
x1
x1
F
x
MOD
DEC
y1
y1
F
y
MOD
Oberon
DrawMouse
Crosshair
x1
y1
UNTIL
k2
Oberon
FadeMouse
IF
k0
THEN
left
key
w
ABS
x1
x0
h
ABS
y1
y0
IF
k1
THEN
IF
w
h
THEN
set
mark
IF
x1
markW
F
X
x1
markW
F
X1
y1
markW
F
Y
y1
markW
F
Y1
THEN
Defocus
F
Oberon
PassFocus
Viewers
This
F
X
F
Y
F
mark
x
x1
F
mark
y
y1
F
marked
TRUE
FlipMark
x1
y1
END
ELSE
draw
line
Deselect
F
IF
w
h
THEN
IF
y1
y0
THEN
y0
y1
END
NewLine
F
G
x0
y0
Graphics
width
h
ELSE
IF
x1
x0
THEN
x0
x1
END
NewLine
F
G
x0
y0
w
Graphics
width
END
Draw
F
END
ELSIF
k1
THEN
copy
text
selection
to
mark
Deselect
F
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
DrawObj
F
CaptionCopy
F
x1
y1
T
beg
end
Mark
F
END
ELSIF
k1
THEN
IF
F
marked
THEN
set
secondary
mark
NEW
newmark
newmark
x
x1
newmark
y
y1
newmark
next
NIL
FlipMark
x1
y1
mark
F
mark
next
IF
mark
NIL
THEN
F
mark
next
newmark
ELSE
WHILE
mark
next
NIL
DO
mark
mark
next
END
mark
next
newmark
END
END
END
ELSIF
k0
THEN
middle
key
IF
k1
THEN
move
IF
x0
x1
OR
y0
y1
THEN
Fd
This
x1
y1
Erase
F
IF
Fd
F
THEN
Graphics
Move
G
x1
x0
y1
y0
ELSIF
Fd
NIL
Fd
graph
G
THEN
Graphics
Move
G
x1
Fd
x
x0
F
x
DIV
y1
Fd
y
y0
F
y
DIV
END
Draw
F
Mark
F
END
ELSIF
k1
THEN
copy
Fd
This
x1
y1
IF
Fd
NIL
THEN
DrawNorm
F
IF
Fd
F
THEN
Graphics
Copy
G
G
x1
x0
y1
y0
ELSE
Deselect
Fd
Graphics
Copy
G
Fd
graph
x1
Fd
x
x0
F
x
DIV
y1
Fd
y
y0
F
y
DIV
END
Draw
Fd
Mark
F
END
ELSIF
k1
THEN
shift
graph
INC
F
Xg
x1
x0
INC
F
Yg
y1
y0
Restore
F
END
ELSIF
k0
THEN
right
key
select
newcap
NIL
IF
k1
THEN
Deselect
F
END
IF
ABS
x0
x1
ABS
y0
y1
THEN
obj
Graphics
ThisObj
G
x1
F
x
y1
F
y
IF
obj
NIL
THEN
Graphics
SelectObj
G
obj
DrawObj
F
obj
END
ELSE
IF
x1
x0
THEN
t
x0
x0
x1
x1
t
END
IF
y1
y0
THEN
t
y0
y0
y1
y1
t
END
Graphics
SelectArea
G
x0
F
x
y0
F
y
x1
F
x
y1
F
y
Draw
F
END
END
END
Edit
PROCEDURE
NewCaption
F
Frame
col
INTEGER
font
Fonts
Font
BEGIN
Texts
Write
W
0DX
NEW
newcap
newcap
x
F
mark
x
F
x
newcap
y
F
mark
y
F
y
font
minY
newcap
w
newcap
h
font
height
newcap
col
col
newcap
pos
Graphics
T
len
newcap
len
newcap
do
Graphics
CapMethod
Graphics
Add
F
graph
newcap
W
fnt
font
Mark
F
END
NewCaption
PROCEDURE
InsertChar
F
Frame
ch
CHAR
VAR
w1
h1
INTEGER
DM
DispMsg
BEGIN
DM
graph
F
graph
Fonts
GetPat
W
fnt
ch
DM
w
DM
x1
DM
y1
w1
h1
DM
pat
DEC
DM
y1
W
fnt
minY
IF
newcap
x
newcap
w
DM
w
F
x
F
X1
THEN
Viewers
Broadcast
DM
INC
newcap
w
DM
w
INC
newcap
len
Texts
Write
W
ch
END
Texts
Append
Graphics
T
W
buf
END
InsertChar
PROCEDURE
DeleteChar
F
Frame
VAR
w1
h1
INTEGER
ch
CHAR
pos
LONGINT
DM
DispMsg
R
Texts
Reader
BEGIN
DM
graph
F
graph
IF
newcap
len
THEN
pos
Graphics
T
len
Texts
OpenReader
R
Graphics
T
pos
backspace
Texts
Read
R
ch
IF
ch
THEN
Fonts
GetPat
R
fnt
ch
DM
w
DM
x1
DM
y1
w1
h1
DM
pat
DEC
newcap
w
DM
w
DEC
newcap
len
DEC
DM
y1
R
fnt
minY
Viewers
Broadcast
DM
Texts
Delete
Graphics
T
pos
pos
TBuf
END
END
END
DeleteChar
PROCEDURE
GetSelection
F
Frame
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
VAR
obj
Graphics
Object
BEGIN
obj
F
graph
sel
IF
obj
NIL
F
graph
time
time
THEN
CASE
obj
OF
Graphics
Caption
beg
obj
pos
end
obj
pos
obj
len
text
Graphics
T
time
F
graph
time
END
END
END
GetSelection
PROCEDURE
Handle
G
Display
Frame
VAR
M
Display
FrameMsg
VAR
x
y
h
INTEGER
DM
DispMsg
dM
DrawMsg
G1
Frame
BEGIN
CASE
G
OF
Frame
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
x
M
X
M
X
G
x
MOD
y
M
Y
M
Y
G
y
MOD
IF
M
keys
THEN
Edit
G
x
y
M
keys
ELSE
Oberon
DrawMouse
Crosshair
x
y
END
ELSIF
M
id
Oberon
consume
THEN
IF
M
ch
7FX
THEN
DEL
Erase
G
Graphics
Delete
G
graph
Mark
G
ELSIF
M
ch
20X
M
ch
7FX
THEN
IF
newcap
NIL
THEN
InsertChar
G
M
ch
Mark
G
ELSIF
G
marked
THEN
Defocus
G
Deselect
G
NewCaption
G
M
col
M
fnt
InsertChar
G
M
ch
END
ELSIF
M
ch
8X
newcap
NIL
THEN
DeleteChar
G
Mark
G
END
END
UpdateMsg
IF
M
graph
G
graph
THEN
dM
f
G
dM
x
G
x
dM
y
G
y
dM
col
IF
M
id
drawobj
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawobjs
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawobjd
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawsel
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
ELSIF
M
id
drawnorm
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
ELSIF
M
id
drawdel
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
END
END
ChangedMsg
IF
M
graph
G
graph
THEN
SetChangeMark
G
M
mode
END
SelQuery
IF
G
graph
sel
NIL
M
time
G
graph
time
THEN
M
f
G
Frame
M
time
G
graph
time
END
FocusQuery
IF
G
marked
THEN
M
f
G
END
PosQuery
IF
G
X
M
x
M
x
G
X1
G
Y
M
y
M
y
G
Y1
THEN
M
f
G
END
DispMsg
DM
M
x
G
x
newcap
x
newcap
w
y
G
y
newcap
y
IF
DM
graph
G
graph
x
G
X
x
DM
w
G
X1
y
G
Y
y
G
Y1
THEN
Display
CopyPattern
Oberon
CurCol
DM
pat
x
DM
x1
y
DM
y1
Display
ReplConst
Display
white
x
y
DM
w
newcap
h
END
Oberon
ControlMsg
IF
M
id
Oberon
neutralize
THEN
Oberon
RemoveMarks
G
X
G
Y
G
W
G
H
Defocus
G
DrawNorm
G
Graphics
Deselect
G
graph
ELSIF
M
id
Oberon
defocus
THEN
Defocus
G
END
Oberon
SelectionMsg
GetSelection
G
M
text
M
beg
M
end
M
time
Oberon
CopyMsg
Oberon
RemoveMarks
G
X
G
Y
G
W
G
H
Defocus
G
NEW
G1
G1
G
M
F
G1
MenuViewers
ModifyMsg
G
Y
M
Y
G
H
M
H
Restore
G
END
END
END
Handle
PROCEDURE
Store
F
Frame
name
ARRAY
OF
CHAR
BEGIN
Mark
F
Graphics
WriteFile
F
graph
name
END
Store
Draw
Methods
PROCEDURE
ReplConst
F
Frame
col
x
y
w
h
mode
INTEGER
BEGIN
IF
x
F
X
THEN
DEC
w
F
X
x
x
F
X
END
IF
x
w
F
X1
THEN
w
F
X1
x
END
IF
y
F
Y
THEN
DEC
h
F
Y
y
y
F
Y
END
IF
y
h
F
Y1
THEN
h
F
Y1
y
END
Display
ReplConst
col
x
y
w
h
mode
END
ReplConst
PROCEDURE
ReplPattern
F
Frame
col
patadr
x
y
w
h
mode
INTEGER
BEGIN
IF
x
F
X
THEN
DEC
w
F
X
x
x
F
X
END
IF
x
w
F
X1
THEN
w
F
X1
x
END
IF
y
F
Y
THEN
DEC
h
F
Y
y
y
F
Y
END
IF
y
h
F
Y1
THEN
h
F
Y1
y
END
Display
ReplPattern
col
patadr
x
y
w
h
mode
END
ReplPattern
PROCEDURE
DrawLine
obj
Graphics
Object
VAR
M
Graphics
Msg
M
mode
draw
according
to
state
normal
selected
selected
normal
erase
VAR
x
y
w
h
col
INTEGER
f
Frame
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
x
w
f
X
x
f
X1
y
h
f
Y
y
f
Y1
THEN
col
obj
col
IF
M
mode
obj
selected
OR
M
mode
THEN
ReplPattern
f
col
Display
grey
x
y
w
h
Display
replace
ELSIF
M
mode
IN
THEN
ReplConst
f
col
x
y
w
h
Display
replace
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
erase
END
END
END
END
DrawLine
PROCEDURE
DrawCaption
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
dx
x0
x1
y0
y1
w
h
w1
h1
col
INTEGER
f
Frame
ch
CHAR
pat
INTEGER
fnt
Fonts
Font
R
Texts
Reader
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
f
X
x
x
f
X1
f
Y
y
y
h
f
Y1
THEN
IF
x
w
f
X1
THEN
w
f
X1
x
END
Texts
OpenReader
R
Graphics
T
obj
Graphics
Caption
pos
Texts
Read
R
ch
IF
M
mode
THEN
IF
ch
THEN
fnt
R
fnt
x0
x
y0
y
fnt
minY
col
obj
col
REPEAT
Fonts
GetPat
fnt
ch
dx
x1
y1
w1
h1
pat
IF
x0
x1
w1
f
X1
THEN
Display
CopyPattern
col
pat
x0
x1
y0
y1
Display
paint
INC
x0
dx
Texts
Read
R
ch
ELSE
ch
0X
END
UNTIL
ch
IF
obj
selected
THEN
ReplConst
f
Display
white
x
y
w
h
Display
invert
END
END
ELSIF
M
mode
IN
THEN
ReplConst
f
Display
white
x
y
w
h
Display
invert
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
END
END
END
END
DrawCaption
PROCEDURE
DrawMacro
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
INTEGER
f
Frame
M1
DrawMsg
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
x
w
f
X
x
f
X1
y
h
f
Y
y
f
Y1
THEN
M1
x
x
M1
y
y
IF
M
mode
THEN
M1
f
f
M1
col
obj
col
M1
mode
Graphics
DrawMac
obj
Graphics
Macro
mac
M1
IF
obj
selected
THEN
ReplPattern
f
Display
white
dotted
x
y
w
h
Display
invert
END
ELSIF
M
mode
IN
THEN
ReplPattern
f
Display
white
dotted
x
y
w
h
Display
invert
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
END
END
END
END
DrawMacro
PROCEDURE
Open
G
Frame
graph
Graphics
Graph
BEGIN
G
graph
graph
G
Xg
G
Yg
G
x
G
X
G
y
G
Y
G
col
Display
black
G
marked
FALSE
G
mark
next
NIL
G
ticked
TRUE
G
handle
Handle
END
Open
BEGIN
DW
Display
Width
DH
Display
Height
CL
Texts
OpenWriter
W
tack
SYSTEM
ADR
dotted
SYSTEM
ADR
dotted1
SYSTEM
ADR
Crosshair
Fade
FlipCross
Crosshair
Draw
FlipCross
Graphics
InstallDrawMethods
DrawLine
DrawCaption
DrawMacro
END
GraphicFrames
MODULE
Graphics
NW
IMPORT
SYSTEM
Files
Modules
Fonts
Printer
Texts
Oberon
CONST
NameLen
GraphFileId
0FAX
LibFileId
0FBX
TYPE
Graph
POINTER
TO
GraphDesc
Object
POINTER
TO
ObjectDesc
Method
POINTER
TO
MethodDesc
Line
POINTER
TO
LineDesc
Caption
POINTER
TO
CaptionDesc
Macro
POINTER
TO
MacroDesc
ObjectDesc
RECORD
x
y
w
h
INTEGER
col
BYTE
selected
marked
BOOLEAN
do
Method
next
Object
END
Msg
RECORD
END
WidMsg
RECORD
Msg
w
INTEGER
END
ColorMsg
RECORD
Msg
col
INTEGER
END
FontMsg
RECORD
Msg
fnt
Fonts
Font
END
Name
ARRAY
NameLen
OF
CHAR
GraphDesc
RECORD
time
LONGINT
sel
first
Object
changed
BOOLEAN
END
MacHead
POINTER
TO
MacHeadDesc
MacExt
POINTER
TO
MacExtDesc
Library
POINTER
TO
LibraryDesc
MacHeadDesc
RECORD
name
Name
w
h
INTEGER
ext
MacExt
lib
Library
first
Object
next
MacHead
END
LibraryDesc
RECORD
name
Name
first
MacHead
next
Library
END
MacExtDesc
RECORD
END
Context
RECORD
nofonts
noflibs
nofclasses
INTEGER
font
ARRAY
OF
Fonts
Font
lib
ARRAY
OF
Library
class
ARRAY
OF
Modules
Command
END
MethodDesc
RECORD
module
allocator
Name
new
Modules
Command
copy
PROCEDURE
from
to
Object
draw
change
PROCEDURE
obj
Object
VAR
msg
Msg
selectable
PROCEDURE
obj
Object
x
y
INTEGER
BOOLEAN
read
PROCEDURE
obj
Object
VAR
R
Files
Rider
VAR
C
Context
write
PROCEDURE
obj
Object
cno
INTEGER
VAR
R
Files
Rider
VAR
C
Context
print
PROCEDURE
obj
Object
x
y
INTEGER
END
LineDesc
RECORD
ObjectDesc
unused
INTEGER
END
CaptionDesc
RECORD
ObjectDesc
pos
len
INTEGER
END
MacroDesc
RECORD
ObjectDesc
mac
MacHead
END
VAR
width
res
INTEGER
new
Object
T
Texts
Text
captions
LineMethod
CapMethod
MacMethod
Method
GetLib0
PROCEDURE
name
ARRAY
OF
CHAR
replace
BOOLEAN
VAR
Lib
Library
FirstLib
Library
W
TW
XW
Texts
Writer
PROCEDURE
New
obj
Object
BEGIN
new
obj
END
New
PROCEDURE
Add
G
Graph
obj
Object
BEGIN
obj
marked
FALSE
obj
selected
TRUE
obj
next
G
first
G
first
obj
G
sel
obj
G
time
Oberon
Time
G
changed
TRUE
END
Add
PROCEDURE
ThisObj
G
Graph
x
y
INTEGER
Object
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
obj
do
selectable
obj
x
y
DO
obj
obj
next
END
RETURN
obj
END
ThisObj
PROCEDURE
SelectObj
G
Graph
obj
Object
BEGIN
IF
obj
NIL
THEN
obj
selected
TRUE
G
sel
obj
G
time
Oberon
Time
END
END
SelectObj
PROCEDURE
SelectArea
G
Graph
x0
y0
x1
y1
INTEGER
VAR
obj
Object
t
INTEGER
BEGIN
obj
G
first
IF
x1
x0
THEN
t
x0
x0
x1
x1
t
END
IF
y1
y0
THEN
t
y0
y0
y1
y1
t
END
WHILE
obj
NIL
DO
IF
x0
obj
x
obj
x
obj
w
x1
y0
obj
y
obj
y
obj
h
y1
THEN
obj
selected
TRUE
G
sel
obj
END
obj
obj
next
END
IF
G
sel
NIL
THEN
G
time
Oberon
Time
END
END
SelectArea
PROCEDURE
Draw
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
obj
do
draw
obj
M
obj
obj
next
END
END
Draw
PROCEDURE
List
G
Graph
VAR
obj
Object
tag
INTEGER
BEGIN
obj
G
first
WHILE
obj
NIL
DO
Texts
Write
XW
9X
Texts
WriteHex
XW
ORD
obj
Texts
Write
XW
9X
Texts
WriteInt
XW
obj
x
Texts
WriteInt
XW
obj
y
Texts
WriteInt
XW
obj
w
Texts
WriteInt
XW
obj
h
Texts
Write
XW
SYSTEM
GET
ORD
obj
tag
Texts
WriteHex
XW
tag
SYSTEM
GET
ORD
obj
tag
Texts
WriteHex
XW
tag
Texts
WriteLn
XW
obj
obj
next
END
Texts
Append
Oberon
Log
XW
buf
END
List
procedures
operating
on
selection
PROCEDURE
Deselect
G
Graph
VAR
obj
Object
BEGIN
obj
G
first
G
sel
NIL
G
time
WHILE
obj
NIL
DO
obj
selected
FALSE
obj
obj
next
END
END
Deselect
PROCEDURE
DrawSel
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
draw
obj
M
END
obj
obj
next
END
END
DrawSel
PROCEDURE
Change
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
G
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
change
obj
M
END
obj
obj
next
END
END
Change
PROCEDURE
Move
G
Graph
dx
dy
INTEGER
VAR
obj
ob0
Object
x0
x1
y0
y1
INTEGER
BEGIN
obj
G
first
G
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
obj
IS
Caption
THEN
x0
obj
x
x1
obj
w
x0
y0
obj
y
y1
obj
h
y0
IF
dx
THEN
vertical
move
ob0
G
first
WHILE
ob0
NIL
DO
IF
ob0
selected
ob0
IS
Line
x0
ob0
x
ob0
x
x1
ob0
w
ob0
h
THEN
IF
y0
ob0
y
ob0
y
y1
THEN
INC
ob0
y
dy
DEC
ob0
h
dy
ob0
marked
TRUE
ELSIF
y0
ob0
y
ob0
h
ob0
y
ob0
h
y1
THEN
INC
ob0
h
dy
ob0
marked
TRUE
END
END
ob0
ob0
next
END
ELSIF
dy
THEN
horizontal
move
ob0
G
first
WHILE
ob0
NIL
DO
IF
ob0
selected
ob0
IS
Line
y0
ob0
y
ob0
y
y1
ob0
h
ob0
w
THEN
IF
x0
ob0
x
ob0
x
x1
THEN
INC
ob0
x
dx
DEC
ob0
w
dx
ob0
marked
TRUE
ELSIF
x0
ob0
x
ob0
w
ob0
x
ob0
w
x1
THEN
INC
ob0
w
dx
ob0
marked
TRUE
END
END
ob0
ob0
next
END
END
END
obj
obj
next
END
obj
G
first
now
move
WHILE
obj
NIL
DO
IF
obj
selected
THEN
INC
obj
x
dx
INC
obj
y
dy
END
obj
marked
FALSE
obj
obj
next
END
END
Move
PROCEDURE
Copy
Gs
Gd
Graph
dx
dy
INTEGER
VAR
obj
Object
BEGIN
obj
Gs
first
Gd
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
new
obj
do
copy
obj
new
INC
new
x
dx
INC
new
y
dy
obj
selected
FALSE
Add
Gd
new
END
obj
obj
next
END
new
NIL
END
Copy
PROCEDURE
Delete
G
Graph
VAR
obj
pred
Object
BEGIN
G
sel
NIL
G
changed
TRUE
obj
G
first
WHILE
obj
NIL
obj
selected
DO
obj
obj
next
END
G
first
obj
IF
obj
NIL
THEN
pred
obj
obj
obj
next
WHILE
obj
NIL
DO
IF
obj
selected
THEN
pred
next
obj
next
ELSE
pred
obj
END
obj
obj
next
END
END
END
Delete
Storing
PROCEDURE
WMsg
s0
s1
ARRAY
OF
CHAR
BEGIN
Texts
WriteString
W
s0
Texts
WriteString
W
s1
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
WMsg
PROCEDURE
InitContext
VAR
C
Context
BEGIN
C
nofonts
C
noflibs
C
nofclasses
C
class
LineMethod
new
C
class
CapMethod
new
C
class
MacMethod
new
END
InitContext
PROCEDURE
FontNo
VAR
W
Files
Rider
VAR
C
Context
fnt
Fonts
Font
INTEGER
VAR
fno
INTEGER
BEGIN
fno
WHILE
fno
C
nofonts
C
font
fno
fnt
DO
INC
fno
END
IF
fno
C
nofonts
THEN
Files
WriteByte
W
Files
WriteByte
W
Files
WriteByte
W
fno
Files
WriteString
W
fnt
name
C
font
fno
fnt
INC
C
nofonts
END
RETURN
fno
END
FontNo
PROCEDURE
StoreElems
VAR
W
Files
Rider
VAR
C
Context
obj
Object
VAR
cno
INTEGER
BEGIN
WHILE
obj
NIL
DO
cno
WHILE
cno
C
nofclasses
obj
do
new
C
class
cno
DO
INC
cno
END
IF
cno
C
nofclasses
THEN
Files
WriteByte
W
Files
WriteByte
W
Files
WriteByte
W
cno
Files
WriteString
W
obj
do
module
Files
WriteString
W
obj
do
allocator
C
class
cno
obj
do
new
INC
C
nofclasses
END
obj
do
write
obj
cno
W
C
obj
obj
next
END
Files
WriteByte
W
END
StoreElems
PROCEDURE
Store
G
Graph
VAR
W
Files
Rider
VAR
C
Context
BEGIN
InitContext
C
StoreElems
W
C
G
first
G
changed
FALSE
END
Store
PROCEDURE
WriteObj
VAR
W
Files
Rider
cno
INTEGER
obj
Object
BEGIN
Files
WriteByte
W
cno
Files
WriteInt
W
obj
y
10000H
obj
x
Files
WriteInt
W
obj
h
10000H
obj
w
Files
WriteByte
W
obj
col
END
WriteObj
PROCEDURE
WriteFile
G
Graph
name
ARRAY
OF
CHAR
VAR
F
Files
File
W
Files
Rider
C
Context
BEGIN
F
Files
New
name
Files
Set
W
F
Files
Write
W
GraphFileId
InitContext
C
StoreElems
W
C
G
first
Files
Register
F
END
WriteFile
PROCEDURE
Print
G
Graph
x0
y0
INTEGER
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
obj
do
print
obj
x0
y0
obj
obj
next
END
END
Print
Loading
PROCEDURE
GetClass
module
allocator
ARRAY
OF
CHAR
VAR
com
Modules
Command
VAR
mod
Modules
Module
BEGIN
Modules
Load
module
mod
IF
mod
NIL
THEN
com
Modules
ThisCommand
mod
allocator
IF
com
NIL
THEN
WMsg
allocator
unknown
END
ELSE
WMsg
module
not
available
com
NIL
END
END
GetClass
PROCEDURE
Font
VAR
R
Files
Rider
VAR
C
Context
Fonts
Font
VAR
fno
BYTE
BEGIN
Files
ReadByte
R
fno
RETURN
C
font
fno
END
Font
PROCEDURE
ReadObj
VAR
R
Files
Rider
obj
Object
VAR
xy
wh
INTEGER
dmy
BYTE
BEGIN
Files
ReadInt
R
xy
obj
y
xy
DIV
10000H
obj
x
xy
10000H
DIV
10000H
Files
ReadInt
R
wh
obj
h
wh
DIV
10000H
obj
w
wh
10000H
DIV
10000H
Files
ReadByte
R
obj
col
END
ReadObj
PROCEDURE
LoadElems
VAR
R
Files
Rider
VAR
C
Context
VAR
fobj
Object
VAR
cno
m
n
len
BYTE
pos
INTEGER
obj
Object
fnt
Fonts
Font
name
name1
ARRAY
OF
CHAR
BEGIN
obj
NIL
Files
ReadByte
R
cno
WHILE
R
eof
cno
DO
IF
cno
THEN
Files
ReadByte
R
m
Files
ReadByte
R
n
Files
ReadString
R
name
IF
m
THEN
fnt
Fonts
This
name
C
font
n
fnt
ELSIF
m
THEN
GetLib0
name
FALSE
C
lib
n
ELSIF
m
THEN
Files
ReadString
R
name1
GetClass
name
name1
C
class
n
END
ELSIF
C
class
cno
NIL
THEN
C
class
cno
ReadObj
R
new
new
selected
FALSE
new
marked
FALSE
new
next
obj
obj
new
new
do
read
new
R
C
ELSE
ReadObj
R
new
Files
ReadByte
R
len
pos
Files
Pos
R
Files
Set
R
Files
Base
R
pos
len
END
Files
ReadByte
R
cno
END
new
NIL
fobj
obj
END
LoadElems
PROCEDURE
Load
G
Graph
VAR
R
Files
Rider
VAR
C
Context
BEGIN
G
sel
NIL
InitContext
C
LoadElems
R
C
G
first
END
Load
PROCEDURE
Open
G
Graph
name
ARRAY
OF
CHAR
VAR
tag
CHAR
F
Files
File
R
Files
Rider
C
Context
BEGIN
G
first
NIL
G
sel
NIL
G
time
G
changed
FALSE
F
Files
Old
name
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
tag
IF
tag
GraphFileId
THEN
InitContext
C
LoadElems
R
C
G
first
res
ELSE
res
END
ELSE
res
END
END
Open
PROCEDURE
SetWidth
w
INTEGER
BEGIN
width
w
END
SetWidth
Macros
Libraries
PROCEDURE
GetLib
name
ARRAY
OF
CHAR
replace
BOOLEAN
VAR
Lib
Library
VAR
i
wh
INTEGER
ch
CHAR
L
Library
mh
MacHead
obj
Object
F
Files
File
R
Files
Rider
C
Context
Lname
Fname
ARRAY
OF
CHAR
BEGIN
L
FirstLib
i
WHILE
L
NIL
L
name
name
DO
L
L
next
END
IF
L
NIL
THEN
load
library
from
file
i
WHILE
name
i
0X
DO
Fname
i
name
i
INC
i
END
Fname
i
Fname
i
L
Fname
i
i
Fname
i
b
Fname
i
0X
F
Files
Old
Fname
IF
F
NIL
THEN
WMsg
loading
Fname
Files
Set
R
F
Files
Read
R
ch
IF
ch
LibFileId
THEN
IF
L
NIL
THEN
NEW
L
L
name
name
L
next
FirstLib
FirstLib
L
END
L
first
NIL
InitContext
C
LoadElems
R
C
obj
WHILE
obj
NIL
DO
NEW
mh
mh
first
obj
Files
ReadInt
R
wh
mh
h
wh
DIV
10000H
MOD
10000H
mh
w
wh
MOD
10000H
Files
ReadString
R
mh
name
mh
lib
L
mh
next
L
first
L
first
mh
LoadElems
R
C
obj
END
ELSE
L
NIL
END
ELSE
L
NIL
END
END
Lib
L
END
GetLib
PROCEDURE
NewLib
Lname
ARRAY
OF
CHAR
Library
VAR
L
Library
BEGIN
NEW
L
L
name
Lname
L
first
NIL
L
next
FirstLib
FirstLib
L
RETURN
L
END
NewLib
PROCEDURE
StoreLib
L
Library
Fname
ARRAY
OF
CHAR
VAR
i
INTEGER
mh
MacHead
F
Files
File
W
Files
Rider
C
Context
Gname
ARRAY
OF
CHAR
BEGIN
L
FirstLib
WHILE
L
NIL
L
name
Fname
DO
L
L
next
END
IF
L
NIL
THEN
i
WHILE
Fname
i
0X
DO
Gname
i
Fname
i
INC
i
END
Gname
i
Gname
i
L
Gname
i
i
Gname
i
b
Gname
i
0X
F
Files
New
Gname
Files
Set
W
F
Files
Write
W
LibFileId
InitContext
C
mh
L
first
WHILE
mh
NIL
DO
StoreElems
W
C
mh
first
Files
WriteInt
W
mh
h
10000H
mh
w
Files
WriteString
W
mh
name
mh
mh
next
END
Files
WriteByte
W
Files
Register
F
ELSE
Texts
WriteString
TW
Fname
Texts
WriteString
TW
not
found
Texts
WriteLn
TW
Texts
Append
Oberon
Log
TW
buf
END
END
StoreLib
PROCEDURE
RemoveLibraries
BEGIN
FirstLib
NIL
END
RemoveLibraries
PROCEDURE
ThisMac
L
Library
Mname
ARRAY
OF
CHAR
MacHead
VAR
mh
MacHead
BEGIN
mh
L
first
WHILE
mh
NIL
mh
name
Mname
DO
mh
mh
next
END
RETURN
mh
END
ThisMac
PROCEDURE
DrawMac
mh
MacHead
VAR
M
Msg
VAR
elem
Object
BEGIN
elem
mh
first
WHILE
elem
NIL
DO
elem
do
draw
elem
M
elem
elem
next
END
END
DrawMac
Procedures
for
designing
macros
PROCEDURE
OpenMac
mh
MacHead
G
Graph
x
y
INTEGER
VAR
obj
Object
BEGIN
obj
mh
first
WHILE
obj
NIL
DO
obj
do
new
obj
do
copy
obj
new
INC
new
x
x
INC
new
y
y
new
selected
TRUE
Add
G
new
obj
obj
next
END
new
NIL
END
OpenMac
PROCEDURE
MakeMac
G
Graph
VAR
head
MacHead
VAR
x0
y0
x1
y1
INTEGER
obj
last
Object
mh
MacHead
BEGIN
obj
G
first
last
NIL
x0
x1
y0
y1
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
new
obj
do
copy
obj
new
new
next
last
new
selected
FALSE
last
new
IF
obj
x
x0
THEN
x0
obj
x
END
IF
obj
x
obj
w
x1
THEN
x1
obj
x
obj
w
END
IF
obj
y
y0
THEN
y0
obj
y
END
IF
obj
y
obj
h
y1
THEN
y1
obj
y
obj
h
END
END
obj
obj
next
END
obj
last
WHILE
obj
NIL
DO
obj
x
obj
x
x0
obj
y
obj
y
y0
obj
obj
next
END
NEW
mh
mh
w
x1
x0
mh
h
y1
y0
mh
first
last
mh
ext
NIL
new
NIL
head
mh
END
MakeMac
PROCEDURE
InsertMac
mh
MacHead
L
Library
VAR
new
BOOLEAN
VAR
mh1
MacHead
BEGIN
mh
lib
L
mh1
L
first
WHILE
mh1
NIL
mh1
name
mh
name
DO
mh1
mh1
next
END
IF
mh1
NIL
THEN
new
TRUE
mh
next
L
first
L
first
mh
ELSE
new
FALSE
mh1
w
mh
w
mh1
h
mh
h
mh1
first
mh
first
END
END
InsertMac
Line
Methods
PROCEDURE
NewLine
VAR
line
Line
BEGIN
NEW
line
new
line
line
do
LineMethod
END
NewLine
PROCEDURE
CopyLine
src
dst
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
END
CopyLine
PROCEDURE
ChangeLine
obj
Object
VAR
M
Msg
BEGIN
CASE
M
OF
WidMsg
IF
obj
w
obj
h
THEN
IF
obj
w
THEN
obj
w
M
w
END
ELSIF
obj
h
THEN
obj
h
M
w
END
ColorMsg
obj
col
M
col
END
END
ChangeLine
PROCEDURE
LineSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
w
obj
y
y
y
obj
y
obj
h
END
LineSelectable
PROCEDURE
ReadLine
obj
Object
VAR
R
Files
Rider
VAR
C
Context
BEGIN
END
ReadLine
PROCEDURE
WriteLine
obj
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Context
BEGIN
WriteObj
W
cno
obj
END
WriteLine
PROCEDURE
PrintLine
obj
Object
x
y
INTEGER
VAR
w
h
INTEGER
BEGIN
w
obj
w
h
obj
h
IF
w
h
THEN
h
h
ELSE
w
w
END
Printer
ReplConst
obj
x
x
obj
y
y
w
h
END
PrintLine
Caption
Methods
PROCEDURE
NewCaption
VAR
cap
Caption
BEGIN
NEW
cap
new
cap
cap
do
CapMethod
END
NewCaption
PROCEDURE
CopyCaption
src
dst
Object
VAR
ch
CHAR
R
Texts
Reader
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Caption
pos
T
len
dst
Caption
len
src
Caption
len
Texts
Write
TW
0DX
Texts
OpenReader
R
T
src
Caption
pos
Texts
Read
R
ch
TW
fnt
R
fnt
WHILE
ch
0DX
DO
Texts
Write
TW
ch
Texts
Read
R
ch
END
Texts
Append
T
TW
buf
END
CopyCaption
PROCEDURE
ChangeCaption
obj
Object
VAR
M
Msg
VAR
dx
x1
dy
y1
w
w1
h1
len
INTEGER
pos
LONGINT
ch
CHAR
patadr
INTEGER
fnt
Fonts
Font
R
Texts
Reader
BEGIN
CASE
M
OF
FontMsg
fnt
M
FontMsg
fnt
w
len
pos
obj
Caption
pos
Texts
OpenReader
R
T
pos
Texts
Read
R
ch
dy
R
fnt
minY
WHILE
ch
0DX
DO
Fonts
GetPat
fnt
ch
dx
x1
y1
w1
h1
patadr
INC
w
dx
INC
len
Texts
Read
R
ch
END
INC
obj
y
fnt
minY
dy
obj
w
w
obj
h
fnt
height
Texts
ChangeLooks
T
pos
pos
len
fnt
ColorMsg
obj
col
M
ColorMsg
col
END
END
ChangeCaption
PROCEDURE
CaptionSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
w
obj
y
y
y
obj
y
obj
h
END
CaptionSelectable
PROCEDURE
ReadCaption
obj
Object
VAR
R
Files
Rider
VAR
C
Context
VAR
ch
CHAR
fno
BYTE
len
INTEGER
BEGIN
obj
Caption
pos
T
len
Texts
Write
TW
0DX
Files
ReadByte
R
fno
TW
fnt
C
font
fno
len
Files
Read
R
ch
WHILE
ch
0DX
DO
Texts
Write
TW
ch
INC
len
Files
Read
R
ch
END
obj
Caption
len
len
Texts
Append
T
TW
buf
END
ReadCaption
PROCEDURE
WriteCaption
obj
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Context
VAR
ch
CHAR
fno
BYTE
TR
Texts
Reader
BEGIN
IF
obj
Caption
len
THEN
Texts
OpenReader
TR
T
obj
Caption
pos
Texts
Read
TR
ch
fno
FontNo
W
C
TR
fnt
WriteObj
W
cno
obj
Files
WriteByte
W
fno
WHILE
ch
0DX
DO
Files
Write
W
ch
Texts
Read
TR
ch
END
Files
Write
W
0X
END
END
WriteCaption
PROCEDURE
PrintCaption
obj
Object
x
y
INTEGER
VAR
fnt
Fonts
Font
i
INTEGER
ch
CHAR
R
Texts
Reader
s
ARRAY
OF
CHAR
BEGIN
IF
obj
Caption
len
THEN
Texts
OpenReader
R
T
obj
Caption
pos
Texts
Read
R
ch
fnt
R
fnt
DEC
y
fnt
minY
i
WHILE
ch
DO
s
i
ch
INC
i
Texts
Read
R
ch
END
s
i
0X
IF
i
THEN
Printer
String
obj
x
x
obj
y
y
s
fnt
name
END
END
END
PrintCaption
Macro
Methods
PROCEDURE
NewMacro
VAR
mac
Macro
BEGIN
NEW
mac
new
mac
mac
do
MacMethod
END
NewMacro
PROCEDURE
CopyMacro
src
dst
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Macro
mac
src
Macro
mac
END
CopyMacro
PROCEDURE
ChangeMacro
obj
Object
VAR
M
Msg
BEGIN
CASE
M
OF
ColorMsg
obj
col
M
col
END
END
ChangeMacro
PROCEDURE
MacroSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
y
y
y
obj
y
END
MacroSelectable
PROCEDURE
ReadMacro
obj
Object
VAR
R
Files
Rider
VAR
C
Context
VAR
lno
BYTE
name
ARRAY
OF
CHAR
BEGIN
Files
ReadByte
R
lno
Files
ReadString
R
name
obj
Macro
mac
ThisMac
C
lib
lno
name
END
ReadMacro
PROCEDURE
WriteMacro
obj
Object
cno
INTEGER
VAR
W1
Files
Rider
VAR
C
Context
VAR
lno
INTEGER
BEGIN
lno
WHILE
lno
C
noflibs
obj
Macro
mac
lib
C
lib
lno
DO
INC
lno
END
IF
lno
C
noflibs
THEN
Files
WriteByte
W1
Files
WriteByte
W1
Files
WriteByte
W1
lno
Files
WriteString
W1
obj
Macro
mac
lib
name
C
lib
lno
obj
Macro
mac
lib
INC
C
noflibs
END
WriteObj
W1
cno
obj
Files
WriteByte
W1
lno
Files
WriteString
W1
obj
Macro
mac
name
END
WriteMacro
PROCEDURE
PrintMacro
obj
Object
x
y
INTEGER
VAR
elem
Object
mh
MacHead
BEGIN
mh
obj
Macro
mac
IF
mh
NIL
THEN
elem
mh
first
WHILE
elem
NIL
DO
elem
do
print
elem
obj
x
x
obj
y
y
elem
elem
next
END
END
END
PrintMacro
PROCEDURE
Notify
T
Texts
Text
op
INTEGER
beg
end
LONGINT
BEGIN
END
Notify
PROCEDURE
InstallDrawMethods
drawLine
drawCaption
drawMacro
PROCEDURE
obj
Object
VAR
msg
Msg
BEGIN
LineMethod
draw
drawLine
CapMethod
draw
drawCaption
MacMethod
draw
drawMacro
END
InstallDrawMethods
BEGIN
Texts
OpenWriter
W
Texts
OpenWriter
TW
Texts
OpenWriter
XW
width
GetLib0
GetLib
NEW
T
Texts
Open
T
T
notify
Notify
NEW
LineMethod
LineMethod
new
NewLine
LineMethod
copy
CopyLine
LineMethod
selectable
LineSelectable
LineMethod
change
ChangeLine
LineMethod
read
ReadLine
LineMethod
write
WriteLine
LineMethod
print
PrintLine
NEW
CapMethod
CapMethod
new
NewCaption
CapMethod
copy
CopyCaption
CapMethod
selectable
CaptionSelectable
CapMethod
change
ChangeCaption
CapMethod
read
ReadCaption
CapMethod
write
WriteCaption
CapMethod
print
PrintCaption
NEW
MacMethod
MacMethod
new
NewMacro
MacMethod
copy
CopyMacro
MacMethod
selectable
MacroSelectable
MacMethod
change
ChangeMacro
MacMethod
read
ReadMacro
MacMethod
write
WriteMacro
MacMethod
print
PrintMacro
END
Graphics
MODULE
GraphTool
NW
IMPORT
Files
Texts
Oberon
CONST
Context
Line
Caption
Macro
Rectangles
VAR
W
Texts
Writer
PROCEDURE
DecGraph
VAR
ch
CHAR
class
col
fno
cat
inx
libno
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0F8X
THEN
Files
ReadByte
R
class
WHILE
R
eof
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Files
Read
R
ch
Texts
WriteInt
W
col
Texts
Write
W
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Macro
THEN
Files
ReadByte
R
libno
Files
ReadString
R
name
Texts
WriteInt
W
libno
Texts
Write
W
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
file
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecGraph
PROCEDURE
DecGraph1
VAR
ch
CHAR
class
col
fno
len
lw
vers
cat
inx
libno
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0FAX
THEN
Files
ReadByte
R
class
WHILE
R
eof
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Texts
WriteInt
W
col
Texts
Write
W
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Macro
THEN
Files
ReadByte
R
libno
Files
ReadString
R
name
Texts
WriteInt
W
libno
Texts
Write
W
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
len
Texts
WriteInt
W
len
Files
ReadByte
R
lw
Texts
WriteInt
W
lw
Files
ReadByte
R
vers
Texts
WriteInt
W
vers
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
file
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecGraph1
PROCEDURE
DecLibrary1
VAR
ch
CHAR
class
col
fno
cat
inx
libno
len
lnw
vers
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
library1
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0FBX
THEN
Files
ReadByte
R
class
WHILE
class
R
eof
DO
WHILE
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Texts
WriteInt
W
col
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Texts
Write
W
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Texts
Write
W
Files
ReadByte
R
len
Texts
WriteInt
W
len
Files
ReadByte
R
lnw
Texts
WriteInt
W
lnw
Files
ReadByte
R
vers
Texts
WriteInt
W
vers
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
end
macro
Texts
WriteString
W
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
MOD
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
library
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecLibrary1
PROCEDURE
ConvertFontname
VAR
x
ARRAY
OF
CHAR
BEGIN
Syntax
Oberon
IF
x
S
x
y
x
n
x
t
x
a
x
x
THEN
x
O
x
b
x
e
x
r
x
o
x
n
END
END
ConvertFontname
PROCEDURE
ConvertLibrary
VAR
ch
CHAR
class
col
fno
cat
inx
libno
len
lnw
vers
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
G
Files
File
R
Q
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
convert
library
Texts
WriteString
W
S
s
F
Files
Old
S
s
IF
F
NIL
THEN
Texts
Scan
S
G
Files
New
S
s
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Files
Set
R
F
Files
Set
Q
G
Files
Read
R
ch
IF
ch
0FDX
THEN
Files
Write
Q
0FBX
Files
ReadByte
R
class
WHILE
class
R
eof
DO
WHILE
class
DO
Files
WriteByte
Q
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
WriteByte
Q
cat
Files
WriteByte
Q
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
font
ConvertFontname
name
END
Files
WriteString
Q
name
IF
cat
THEN
class
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
Files
WriteString
Q
name
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
ELSE
Files
ReadInt
R
xy
Files
WriteInt
Q
xy
Files
ReadInt
R
wh
Files
WriteInt
Q
wh
Files
ReadByte
R
col
Files
Read
R
ch
Files
WriteByte
Q
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Files
WriteByte
Q
fno
Files
ReadString
R
name
Files
WriteString
Q
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
len
Files
WriteByte
Q
len
Files
ReadByte
R
len
Files
ReadByte
R
lnw
Files
WriteByte
Q
lnw
Files
ReadByte
R
vers
Files
WriteByte
Q
vers
ELSE
Texts
WriteString
W
alien
class
Texts
WriteInt
W
class
END
END
Files
ReadByte
R
class
END
Files
WriteByte
Q
end
macro
Files
ReadInt
R
wh
Files
WriteInt
Q
wh
Files
ReadString
R
name
Files
WriteString
Q
name
Texts
WriteString
W
name
Texts
WriteInt
W
wh
MOD
10000H
Texts
WriteInt
W
wh
DIV
10000H
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
library
END
Files
Register
G
Texts
WriteString
W
done
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
ConvertLibrary
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
GraphTool
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
GraphTool
MODULE
Input
NW
Ceres
PDR
NW
Ceres
IMPORT
SYSTEM
CONST
msAdr
kbdAdr
VAR
kbdCode
BYTE
last
keyboard
code
read
Recd
Up
Shift
Ctrl
Ext
BOOLEAN
KTabAdr
INTEGER
keyboard
code
translation
table
MW
MH
MX
MY
INTEGER
mouse
limits
and
coords
MK
SET
mouse
keys
FIFO
implemented
in
hardware
because
every
read
must
be
handled
including
tracking
the
state
of
the
Shift
and
Ctrl
keys
PROCEDURE
Peek
BEGIN
IF
SYSTEM
BIT
msAdr
THEN
SYSTEM
GET
kbdAdr
kbdCode
IF
kbdCode
0F0H
THEN
Up
TRUE
ELSIF
kbdCode
0E0H
THEN
Ext
TRUE
ELSE
IF
kbdCode
12H
OR
kbdCode
59H
THEN
shift
Shift
Up
ELSIF
kbdCode
14H
THEN
ctrl
Ctrl
Up
ELSIF
Up
THEN
Recd
TRUE
real
key
going
down
END
Up
FALSE
Ext
FALSE
END
END
END
Peek
PROCEDURE
Available
INTEGER
BEGIN
Peek
RETURN
ORD
Recd
END
Available
PROCEDURE
Read
VAR
ch
CHAR
BEGIN
WHILE
Recd
DO
Peek
END
IF
Shift
OR
Ctrl
THEN
INC
kbdCode
80H
END
ctrl
implies
shift
ch
kbdTab
kbdCode
SYSTEM
GET
KTabAdr
kbdCode
ch
IF
Ctrl
THEN
ch
CHR
ORD
ch
MOD
20H
END
Recd
FALSE
END
Read
PROCEDURE
Mouse
VAR
keys
SET
VAR
x
y
INTEGER
VAR
w
INTEGER
BEGIN
SYSTEM
GET
msAdr
w
keys
SYSTEM
VAL
SET
w
DIV
1000000H
MOD
x
w
MOD
400H
y
w
DIV
1000H
MOD
400H
IF
y
MH
THEN
y
MH
END
END
Mouse
PROCEDURE
SetMouseLimits
w
h
INTEGER
BEGIN
MW
w
MH
h
END
SetMouseLimits
PROCEDURE
Init
BEGIN
Up
FALSE
Shift
FALSE
Ctrl
FALSE
Recd
FALSE
KTabAdr
SYSTEM
ADR
1A
7A
6E
6D
6A
2C
6B
6F
2E
2F
6C
3B
2D
5B
3D
0D
5D
5C
7F
1B
7E
5A
4E
5E
4D
4A
2A
3C
4B
4F
3E
3F
4C
3A
5F
7B
2B
0D
7D
7C
7F
1B
END
Init
BEGIN
Init
END
Input
MODULE
Kernel
NW
PR
IMPORT
SYSTEM
CONST
SectorLength
timer
spiData
spiCtrl
CARD0
SPIFAST
FSoffset
80000H
256MB
in
byte
blocks
mapsize
10000H
1K
sectors
64MB
TYPE
Sector
ARRAY
SectorLength
OF
BYTE
VAR
allocated
NofSectors
INTEGER
heapOrg
heapLim
INTEGER
stackOrg
stackSize
MemLim
INTEGER
clock
INTEGER
list0
list1
list2
list3
INTEGER
lists
of
free
blocks
of
size
n
bytes
data
INTEGER
SPI
data
in
sectorMap
ARRAY
mapsize
DIV
OF
SET
New
heap
allocation
PROCEDURE
GetBlock
VAR
p
LONGINT
len
LONGINT
len
is
multiple
of
VAR
q0
q1
q2
size
LONGINT
done
BOOLEAN
BEGIN
q0
q1
list0
done
FALSE
WHILE
done
q1
DO
SYSTEM
GET
q1
size
SYSTEM
GET
q1
q2
IF
size
len
THEN
no
fit
q0
q1
q1
q2
ELSIF
size
len
THEN
extract
p
done
TRUE
p
q1
IF
q0
THEN
SYSTEM
PUT
q0
q2
ELSE
list0
q2
END
ELSE
reduce
size
done
TRUE
p
q1
q1
q1
len
SYSTEM
PUT
q1
size
len
SYSTEM
PUT
q1
SYSTEM
PUT
q1
q2
IF
q0
THEN
SYSTEM
PUT
q0
q1
ELSE
list0
q1
END
END
END
IF
done
THEN
p
END
END
GetBlock
PROCEDURE
GetBlock128
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list1
THEN
p
list1
SYSTEM
GET
list1
list1
ELSE
GetBlock
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list1
list1
q
p
q
END
END
GetBlock128
PROCEDURE
GetBlock64
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list2
THEN
p
list2
SYSTEM
GET
list2
list2
ELSE
GetBlock128
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list2
list2
q
p
q
END
END
GetBlock64
PROCEDURE
GetBlock32
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list3
THEN
p
list3
SYSTEM
GET
list3
list3
ELSE
GetBlock64
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list3
list3
q
p
q
END
END
GetBlock32
PROCEDURE
New
VAR
ptr
LONGINT
tag
LONGINT
called
by
NEW
via
MT
ptr
and
tag
are
pointers
VAR
p
size
lim
LONGINT
BEGIN
SYSTEM
GET
tag
size
IF
size
THEN
GetBlock32
p
ELSIF
size
THEN
GetBlock64
p
ELSIF
size
THEN
GetBlock128
p
ELSE
GetBlock
p
size
DIV
END
IF
p
THEN
ptr
ELSE
ptr
p
SYSTEM
PUT
p
tag
lim
p
size
INC
p
INC
allocated
size
WHILE
p
lim
DO
SYSTEM
PUT
p
INC
p
END
END
END
New
Garbage
collector
PROCEDURE
Mark
pref
LONGINT
VAR
pvadr
offadr
offset
tag
p
q
r
LONGINT
BEGIN
SYSTEM
GET
pref
pvadr
pointers
heapOrg
considered
NIL
WHILE
pvadr
DO
SYSTEM
GET
pvadr
p
SYSTEM
GET
p
offadr
IF
p
heapOrg
offadr
THEN
q
p
mark
elements
in
data
structure
with
root
p
REPEAT
SYSTEM
GET
p
offadr
IF
offadr
THEN
SYSTEM
GET
p
tag
offadr
tag
ELSE
INC
offadr
END
SYSTEM
PUT
p
offadr
SYSTEM
GET
offadr
offset
IF
offset
THEN
down
SYSTEM
GET
p
offset
r
SYSTEM
GET
r
offadr
IF
r
heapOrg
offadr
THEN
SYSTEM
PUT
p
offset
q
q
p
p
r
END
ELSE
up
SYSTEM
GET
q
offadr
SYSTEM
GET
offadr
offset
IF
p
q
THEN
SYSTEM
GET
q
offset
r
SYSTEM
PUT
q
offset
p
p
q
q
r
END
END
UNTIL
p
q
offset
END
INC
pref
SYSTEM
GET
pref
pvadr
END
END
Mark
PROCEDURE
Scan
VAR
p
q
mark
tag
size
LONGINT
BEGIN
p
heapOrg
REPEAT
SYSTEM
GET
p
mark
q
p
WHILE
mark
DO
SYSTEM
GET
p
tag
SYSTEM
GET
tag
size
INC
p
size
SYSTEM
GET
p
mark
END
size
p
q
DEC
allocated
size
size
of
free
block
IF
size
THEN
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list3
list3
q
INC
q
DEC
size
END
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list2
list2
q
INC
q
DEC
size
END
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list1
list1
q
INC
q
DEC
size
END
IF
size
THEN
SYSTEM
PUT
q
size
SYSTEM
PUT
q
SYSTEM
PUT
q
list0
list0
q
INC
q
size
END
END
IF
mark
THEN
SYSTEM
GET
p
tag
SYSTEM
GET
tag
size
SYSTEM
PUT
p
INC
p
size
ELSE
free
SYSTEM
GET
p
size
INC
p
size
END
UNTIL
p
heapLim
END
Scan
Disk
storage
management
PROCEDURE
SPIIdle
n
INTEGER
send
n
FFs
slowly
with
no
card
selected
BEGIN
SYSTEM
PUT
spiCtrl
WHILE
n
DO
DEC
n
SYSTEM
PUT
spiData
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
END
END
SPIIdle
PROCEDURE
SPI
n
INTEGER
send
rcv
byte
slowly
with
card
selected
BEGIN
SYSTEM
PUT
spiCtrl
CARD0
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
END
SPI
PROCEDURE
SPICmd
n
arg
INTEGER
VAR
i
crc
INTEGER
BEGIN
send
cmd
REPEAT
SPIIdle
UNTIL
data
flush
while
unselected
REPEAT
SPI
UNTIL
data
flush
while
selected
IF
n
THEN
crc
ELSIF
n
THEN
crc
ELSE
crc
END
SPI
n
MOD
send
command
FOR
i
TO
BY
DO
SPI
ROR
arg
i
END
send
arg
SPI
crc
i
REPEAT
SPI
DEC
i
UNTIL
data
80H
OR
i
END
SPICmd
PROCEDURE
SDShift
VAR
n
INTEGER
VAR
data
INTEGER
BEGIN
SPICmd
CMD58
get
card
capacity
bit
SYSTEM
GET
spiData
data
SPI
IF
data
OR
SYSTEM
BIT
spiData
THEN
n
n
END
non
SDHC
card
SPI
SPI
SPIIdle
flush
response
END
SDShift
PROCEDURE
ReadSD
src
dst
INTEGER
VAR
i
INTEGER
BEGIN
SDShift
src
SPICmd
src
ASSERT
data
CMD17
read
one
block
i
wait
for
start
data
marker
REPEAT
SPI
INC
i
UNTIL
data
SYSTEM
PUT
spiCtrl
SPIFAST
CARD0
FOR
i
TO
BY
DO
SYSTEM
PUT
spiData
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
SYSTEM
PUT
dst
data
INC
dst
END
SPI
SPI
SPIIdle
may
be
a
checksum
deselect
card
END
ReadSD
PROCEDURE
WriteSD
dst
src
INTEGER
VAR
i
n
INTEGER
x
BYTE
BEGIN
SDShift
dst
SPICmd
dst
ASSERT
data
CMD24
write
one
block
SPI
write
start
data
marker
SYSTEM
PUT
spiCtrl
SPIFAST
CARD0
FOR
i
TO
BY
DO
SYSTEM
GET
src
n
INC
src
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
END
SPI
SPI
dummy
checksum
i
REPEAT
SPI
INC
i
UNTIL
data
MOD
OR
i
ASSERT
data
MOD
SPIIdle
deselect
card
END
WriteSD
PROCEDURE
InitSecMap
VAR
i
INTEGER
BEGIN
NofSectors
sectorMap
sectorMap
FOR
i
TO
mapsize
DIV
DO
sectorMap
i
END
END
InitSecMap
PROCEDURE
MarkSector
sec
INTEGER
BEGIN
sec
sec
DIV
ASSERT
SYSTEM
H
INCL
sectorMap
sec
DIV
sec
MOD
INC
NofSectors
END
MarkSector
PROCEDURE
FreeSector
sec
INTEGER
BEGIN
sec
sec
DIV
ASSERT
SYSTEM
H
EXCL
sectorMap
sec
DIV
sec
MOD
DEC
NofSectors
END
FreeSector
PROCEDURE
AllocSector
hint
INTEGER
VAR
sec
INTEGER
VAR
s
INTEGER
BEGIN
find
free
sector
starting
after
hint
hint
hint
DIV
ASSERT
SYSTEM
H
s
hint
REPEAT
INC
s
IF
s
mapsize
THEN
s
END
UNTIL
s
MOD
IN
sectorMap
s
DIV
INCL
sectorMap
s
DIV
s
MOD
INC
NofSectors
sec
s
END
AllocSector
PROCEDURE
GetSector
src
INTEGER
VAR
dst
Sector
BEGIN
src
src
DIV
ASSERT
SYSTEM
H
src
src
FSoffset
ReadSD
src
SYSTEM
ADR
dst
ReadSD
src
SYSTEM
ADR
dst
END
GetSector
PROCEDURE
PutSector
dst
INTEGER
VAR
src
Sector
BEGIN
dst
dst
DIV
ASSERT
SYSTEM
H
dst
dst
FSoffset
WriteSD
dst
SYSTEM
ADR
src
WriteSD
dst
SYSTEM
ADR
src
END
PutSector
Miscellaneous
procedures
PROCEDURE
Time
INTEGER
VAR
t
INTEGER
BEGIN
SYSTEM
GET
timer
t
RETURN
t
END
Time
PROCEDURE
Clock
INTEGER
BEGIN
RETURN
clock
END
Clock
PROCEDURE
SetClock
dt
INTEGER
BEGIN
clock
dt
END
SetClock
PROCEDURE
Install
Padr
at
INTEGER
BEGIN
SYSTEM
PUT
at
0E7000000H
Padr
at
DIV
END
Install
PROCEDURE
Trap
VAR
a
INTEGER
b
INTEGER
VAR
u
v
w
INTEGER
BEGIN
u
SYSTEM
REG
SYSTEM
GET
u
v
w
v
DIV
10H
MOD
10H
trap
number
IF
w
THEN
New
a
b
ELSE
stop
LED
w
REPEAT
UNTIL
FALSE
END
END
Trap
PROCEDURE
Init
BEGIN
Install
SYSTEM
ADR
Trap
20H
install
temporary
trap
SYSTEM
GET
MemLim
SYSTEM
GET
heapOrg
stackOrg
heapOrg
stackSize
8000H
heapLim
MemLim
list1
list2
list3
list0
heapOrg
SYSTEM
PUT
list0
heapLim
heapOrg
SYSTEM
PUT
list0
SYSTEM
PUT
list0
allocated
clock
InitSecMap
END
Init
END
Kernel
MODULE
MenuViewers
JG
NW
IMPORT
Input
Display
Viewers
Oberon
CONST
extend
reduce
FrameColor
Display
white
TYPE
Viewer
POINTER
TO
ViewerDesc
ViewerDesc
RECORD
Viewers
ViewerDesc
menuH
INTEGER
END
ModifyMsg
RECORD
Display
FrameMsg
id
INTEGER
dY
Y
H
INTEGER
END
PROCEDURE
Copy
V
Viewer
VAR
V1
Viewer
VAR
Menu
Main
Display
Frame
M
Oberon
CopyMsg
BEGIN
Menu
V
dsc
Main
V
dsc
next
NEW
V1
V1
V
V1
state
M
F
NIL
Menu
handle
Menu
M
V1
dsc
M
F
M
F
NIL
Main
handle
Main
M
V1
dsc
next
M
F
END
Copy
PROCEDURE
Draw
V
Viewers
Viewer
BEGIN
Display
ReplConst
FrameColor
V
X
V
Y
V
H
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
V
Y
V
H
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
W
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
H
V
W
Display
replace
END
Draw
PROCEDURE
Extend
V
Viewer
newY
INTEGER
VAR
dH
INTEGER
BEGIN
dH
V
Y
newY
IF
dH
THEN
Display
ReplConst
Display
black
V
X
newY
V
W
dH
Display
replace
Display
ReplConst
FrameColor
V
X
newY
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
newY
dH
Display
replace
Display
ReplConst
FrameColor
V
X
newY
V
W
Display
replace
END
END
Extend
PROCEDURE
Reduce
V
Viewer
newY
INTEGER
BEGIN
Display
ReplConst
FrameColor
V
X
newY
V
W
Display
replace
END
Reduce
PROCEDURE
Grow
V
Viewer
oldH
INTEGER
VAR
dH
INTEGER
BEGIN
dH
V
H
oldH
IF
dH
THEN
Display
ReplConst
FrameColor
V
X
V
Y
oldH
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
V
Y
oldH
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
H
V
W
Display
replace
END
END
Grow
PROCEDURE
Shrink
V
Viewer
newH
INTEGER
BEGIN
Display
ReplConst
FrameColor
V
X
V
Y
newH
V
W
Display
replace
END
Shrink
PROCEDURE
Adjust
F
Display
Frame
id
dY
Y
H
INTEGER
VAR
M
ModifyMsg
BEGIN
M
id
id
M
dY
dY
M
Y
Y
M
H
H
F
handle
F
M
F
Y
Y
F
H
H
END
Adjust
PROCEDURE
Restore
V
Viewer
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
Draw
V
Menu
X
V
X
Menu
Y
V
Y
V
H
Menu
W
V
W
Menu
H
Main
X
V
X
Main
Y
V
Y
V
H
V
menuH
Main
W
V
W
Main
H
IF
V
H
V
menuH
THEN
Adjust
Menu
extend
V
Y
V
H
V
menuH
V
menuH
Adjust
Main
extend
V
Y
V
H
V
menuH
ELSE
Adjust
Menu
extend
V
Y
V
H
END
END
Restore
PROCEDURE
Modify
V
Viewer
Y
H
INTEGER
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
IF
Y
V
Y
THEN
extend
Oberon
RemoveMarks
V
X
Y
V
W
V
Y
Y
Extend
V
Y
IF
H
V
menuH
THEN
Adjust
Menu
extend
Y
H
V
menuH
V
menuH
Adjust
Main
extend
Y
H
V
menuH
ELSE
Adjust
Menu
extend
Y
H
END
ELSIF
Y
V
Y
THEN
reduce
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
IF
H
V
menuH
THEN
Adjust
Main
reduce
Y
H
V
menuH
Adjust
Menu
reduce
Y
H
V
menuH
V
menuH
ELSE
Adjust
Main
reduce
Y
H
V
menuH
Adjust
Menu
reduce
Y
H
END
Reduce
V
Y
END
END
Modify
PROCEDURE
Change
V
Viewer
X
Y
INTEGER
Keys
SET
VAR
Menu
Main
Display
Frame
V1
Viewers
Viewer
keysum
SET
Y0
dY
H
INTEGER
BEGIN
Keys
Menu
V
dsc
Main
V
dsc
next
Oberon
DrawMouseArrow
X
Y
Display
ReplConst
Display
white
V
X
V
Y
V
H
V
dsc
H
V
W
V
dsc
H
Display
invert
Y0
Y
keysum
Keys
Input
Mouse
Keys
X
Y
WHILE
Keys
DO
keysum
keysum
Keys
Oberon
DrawMouseArrow
X
Y
Input
Mouse
Keys
X
Y
END
Display
ReplConst
Display
white
V
X
V
Y
V
H
V
dsc
H
V
W
V
dsc
H
Display
invert
IF
IN
keysum
THEN
IF
IN
keysum
THEN
V1
Viewers
This
X
Y
IF
V1
IS
Viewer
Y
V1
Y
V1
H
V1
Viewer
menuH
THEN
Y
V1
Y
V1
H
END
IF
Y
V1
Y
V
menuH
THEN
Y
V1
Y
V
menuH
END
Viewers
Close
V
Viewers
Open
V
X
Y
Restore
V
ELSE
IF
Y
Y0
THEN
extend
dY
Y
Y0
V1
Viewers
Next
V
IF
V1
state
THEN
CASE
V1
OF
Viewer
IF
V1
H
V1
menuH
THEN
dY
ELSIF
V1
H
V1
menuH
dY
THEN
dY
V1
H
V1
menuH
END
Viewers
Viewer
IF
V1
H
dY
THEN
dY
V1
H
END
END
ELSIF
V1
H
dY
THEN
dY
V1
H
END
Viewers
Change
V
V
Y
V
H
dY
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
Grow
V
V
H
dY
IF
V
H
V
menuH
THEN
Adjust
Menu
extend
dY
V
Y
V
H
V
menuH
V
menuH
Adjust
Main
extend
dY
V
Y
V
H
V
menuH
ELSE
V
H
Adjust
Menu
extend
dY
V
Y
V
H
Adjust
Main
extend
dY
V
Y
V
H
V
menuH
END
ELSIF
Y
Y0
THEN
reduce
dY
Y0
Y
IF
V
H
V
menuH
THEN
IF
V
H
V
menuH
dY
THEN
dY
V
H
V
menuH
END
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
H
V
H
dY
Adjust
Main
reduce
dY
V
Y
H
V
menuH
Adjust
Menu
reduce
dY
V
Y
H
V
menuH
V
menuH
Shrink
V
H
Viewers
Change
V
V
Y
H
END
END
END
END
END
Change
PROCEDURE
Suspend
V
Viewer
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
Adjust
Main
reduce
V
Y
V
H
V
menuH
Adjust
Menu
reduce
V
Y
V
H
END
Suspend
PROCEDURE
Handle
V
Display
Frame
VAR
M
Display
FrameMsg
VAR
X
Y
INTEGER
Menu
Main
Display
Frame
V1
Viewer
BEGIN
Menu
V
dsc
Main
V
dsc
next
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
X
M
X
Y
M
Y
IF
Y
V
Y
THEN
Oberon
DrawMouseArrow
X
Y
ELSIF
Y
V
Y
V
H
V
Viewer
menuH
THEN
Main
handle
Main
M
ELSIF
Y
V
Y
V
H
V
Viewer
menuH
THEN
Menu
handle
Menu
M
ELSIF
Y
V
Y
V
H
THEN
IF
IN
M
keys
THEN
Change
V
Viewer
X
Y
M
keys
ELSE
Menu
handle
Menu
M
END
ELSE
Oberon
DrawMouseArrow
X
Y
END
ELSE
Menu
handle
Menu
M
Main
handle
Main
M
END
Oberon
ControlMsg
IF
M
id
Oberon
mark
THEN
X
M
X
Y
M
Y
Oberon
DrawMouseArrow
X
Y
Oberon
DrawPointer
X
Y
ELSE
Menu
handle
Menu
M
Main
handle
Main
M
END
Oberon
CopyMsg
Copy
V
Viewer
V1
M
F
V1
Viewers
ViewerMsg
IF
M
id
Viewers
restore
THEN
Restore
V
Viewer
ELSIF
M
id
Viewers
modify
THEN
Modify
V
Viewer
M
Y
M
H
ELSIF
M
id
Viewers
suspend
THEN
Suspend
V
Viewer
END
Display
FrameMsg
Menu
handle
Menu
M
Main
handle
Main
M
END
END
Handle
PROCEDURE
New
Menu
Main
Display
Frame
menuH
X
Y
INTEGER
Viewer
VAR
V
Viewer
BEGIN
NEW
V
V
handle
Handle
V
dsc
Menu
V
dsc
next
Main
V
menuH
menuH
Viewers
Open
V
X
Y
Restore
V
RETURN
V
END
New
END
MenuViewers
MODULE
Modules
Link
and
load
on
RISC
NW
IMPORT
SYSTEM
Files
CONST
versionkey
1X
MT
DescSize
TYPE
Module
POINTER
TO
ModDesc
Command
PROCEDURE
ModuleName
ARRAY
OF
CHAR
ModDesc
RECORD
name
ModuleName
next
Module
key
num
size
refcnt
INTEGER
data
code
imp
cmd
ent
ptr
unused
INTEGER
addresses
END
VAR
root
M
Module
MTOrg
AllocPtr
res
INTEGER
importing
imported
ModuleName
limit
INTEGER
PROCEDURE
ThisFile
name
ARRAY
OF
CHAR
Files
File
VAR
i
INTEGER
filename
ModuleName
BEGIN
i
WHILE
name
i
0X
DO
filename
i
name
i
INC
i
END
filename
i
filename
i
r
filename
i
s
filename
i
c
filename
i
0X
RETURN
Files
Old
filename
END
ThisFile
PROCEDURE
error
n
INTEGER
name
ARRAY
OF
CHAR
BEGIN
res
n
importing
name
END
error
PROCEDURE
Check
s
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
ch
s
res
i
IF
ch
A
ch
Z
OR
ch
a
ch
z
THEN
REPEAT
ch
s
i
INC
i
UNTIL
ch
ch
OR
ch
A
ch
Z
OR
ch
a
ch
z
OR
ch
OR
i
IF
i
ch
0X
THEN
res
END
END
END
Check
PROCEDURE
Load
name
ARRAY
OF
CHAR
VAR
newmod
Module
search
module
in
list
if
not
found
load
module
res
already
present
or
loaded
res
file
not
available
res
key
conflict
res
bad
file
version
res
corrupted
file
res
no
space
VAR
mod
impmod
Module
i
n
key
impkey
mno
nofimps
size
INTEGER
p
u
v
w
INTEGER
addresses
ch
CHAR
body
Command
fixorgP
fixorgD
fixorgT
INTEGER
disp
adr
inst
pno
vno
dest
offset
INTEGER
name1
impname
ModuleName
F
Files
File
R
Files
Rider
import
ARRAY
OF
Module
BEGIN
mod
root
res
nofimps
WHILE
mod
NIL
name
mod
name
DO
mod
mod
next
END
IF
mod
NIL
THEN
load
Check
name
IF
res
THEN
F
ThisFile
name
ELSE
F
NIL
END
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadString
R
name1
Files
ReadInt
R
key
Files
Read
R
ch
Files
ReadInt
R
size
importing
name1
IF
ch
versionkey
THEN
Files
ReadString
R
impname
imports
WHILE
impname
0X
res
DO
Files
ReadInt
R
impkey
Load
impname
impmod
import
nofimps
impmod
importing
name1
IF
res
THEN
IF
impmod
key
impkey
THEN
INC
impmod
refcnt
INC
nofimps
ELSE
error
name1
imported
impname
END
END
Files
ReadString
R
impname
END
ELSE
error
name1
END
ELSE
error
name
END
IF
res
THEN
search
for
a
hole
in
the
list
allocate
and
link
INC
size
DescSize
mod
root
WHILE
mod
NIL
mod
name
0X
mod
size
size
DO
mod
mod
next
END
IF
mod
NIL
THEN
no
large
enough
hole
was
found
IF
AllocPtr
size
limit
THEN
allocate
p
AllocPtr
mod
SYSTEM
VAL
Module
p
AllocPtr
p
size
100H
DIV
20H
20H
mod
size
AllocPtr
p
mod
num
root
num
mod
next
root
root
mod
ELSE
error
name1
END
ELSE
fill
hole
p
SYSTEM
VAL
INTEGER
mod
END
END
IF
res
THEN
read
file
INC
p
DescSize
allocate
descriptor
mod
name
name
mod
key
key
mod
refcnt
mod
data
p
data
SYSTEM
PUT
mod
num
MTOrg
p
module
table
entry
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
type
descriptors
Files
ReadInt
R
n
WHILE
n
DO
SYSTEM
PUT
p
INC
p
DEC
n
END
variable
space
Files
ReadInt
R
n
WHILE
n
DO
Files
Read
R
ch
SYSTEM
PUT
p
ch
INC
p
DEC
n
END
strings
mod
code
p
program
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
program
code
mod
imp
p
copy
imports
i
WHILE
i
nofimps
DO
SYSTEM
PUT
p
import
i
INC
p
INC
i
END
mod
cmd
p
commands
Files
Read
R
ch
WHILE
ch
0X
DO
REPEAT
SYSTEM
PUT
p
ch
INC
p
Files
Read
R
ch
UNTIL
ch
0X
REPEAT
SYSTEM
PUT
p
0X
INC
p
UNTIL
p
MOD
Files
ReadInt
R
n
SYSTEM
PUT
p
n
INC
p
Files
Read
R
ch
END
REPEAT
SYSTEM
PUT
p
0X
INC
p
UNTIL
p
MOD
mod
ent
p
entries
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
mod
ptr
p
pointer
references
Files
ReadInt
R
w
WHILE
w
DO
SYSTEM
PUT
p
mod
data
w
INC
p
Files
ReadInt
R
w
END
SYSTEM
PUT
p
INC
p
Files
ReadInt
R
fixorgP
Files
ReadInt
R
fixorgD
Files
ReadInt
R
fixorgT
Files
ReadInt
R
w
body
SYSTEM
VAL
Command
mod
code
w
Files
Read
R
ch
IF
ch
O
THEN
corrupted
file
mod
NIL
error
name
END
END
IF
res
THEN
fixup
of
BL
adr
mod
code
fixorgP
WHILE
adr
mod
code
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
100000H
MOD
10H
pno
inst
DIV
1000H
MOD
100H
disp
inst
MOD
1000H
SYSTEM
GET
mod
imp
mno
impmod
SYSTEM
GET
impmod
ent
pno
dest
dest
dest
impmod
code
offset
dest
adr
DIV
SYSTEM
PUT
adr
offset
MOD
1000000H
0F7000000H
adr
adr
disp
END
fixup
of
LDR
STR
ADD
adr
mod
code
fixorgD
WHILE
adr
mod
code
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
100000H
MOD
10H
disp
inst
MOD
1000H
IF
mno
THEN
global
SYSTEM
PUT
adr
inst
DIV
1000000H
10H
MT
100000H
mod
num
ELSE
import
SYSTEM
GET
mod
imp
mno
impmod
v
impmod
num
SYSTEM
PUT
adr
inst
DIV
1000000H
10H
MT
100000H
v
SYSTEM
GET
adr
inst
vno
inst
MOD
100H
SYSTEM
GET
impmod
ent
vno
offset
IF
ODD
inst
DIV
100H
THEN
offset
offset
impmod
code
impmod
data
END
SYSTEM
PUT
adr
inst
DIV
10000H
10000H
offset
END
adr
adr
disp
END
fixup
of
type
descriptors
adr
mod
data
fixorgT
WHILE
adr
mod
data
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
1000000H
MOD
10H
vno
inst
DIV
1000H
MOD
1000H
disp
inst
MOD
1000H
IF
mno
THEN
global
inst
mod
data
vno
ELSE
import
SYSTEM
GET
mod
imp
mno
impmod
SYSTEM
GET
impmod
ent
vno
offset
inst
impmod
data
offset
END
SYSTEM
PUT
adr
inst
adr
adr
disp
END
body
initialize
module
ELSIF
res
THEN
importing
name
WHILE
nofimps
DO
DEC
nofimps
DEC
import
nofimps
refcnt
END
END
END
newmod
mod
END
Load
PROCEDURE
ThisCommand
mod
Module
name
ARRAY
OF
CHAR
Command
VAR
k
adr
w
INTEGER
ch
CHAR
s
ARRAY
OF
CHAR
BEGIN
res
w
IF
mod
NIL
THEN
adr
mod
cmd
SYSTEM
GET
adr
ch
WHILE
ch
0X
res
DO
k
read
command
name
REPEAT
s
k
ch
INC
k
INC
adr
SYSTEM
GET
adr
ch
UNTIL
ch
0X
s
k
0X
REPEAT
INC
adr
UNTIL
adr
MOD
SYSTEM
GET
adr
k
INC
adr
IF
s
name
THEN
res
w
mod
code
k
ELSE
SYSTEM
GET
adr
ch
END
END
END
RETURN
SYSTEM
VAL
Command
w
END
ThisCommand
PROCEDURE
Free
name
ARRAY
OF
CHAR
VAR
mod
imp
Module
p
q
INTEGER
BEGIN
mod
root
res
WHILE
mod
NIL
mod
name
name
DO
mod
mod
next
END
IF
mod
NIL
THEN
IF
mod
refcnt
THEN
mod
name
0X
p
mod
imp
q
mod
cmd
WHILE
p
q
DO
SYSTEM
GET
p
imp
DEC
imp
refcnt
INC
p
END
ELSE
res
END
END
END
Free
PROCEDURE
Init
BEGIN
Files
Init
MTOrg
SYSTEM
REG
MT
SYSTEM
GET
AllocPtr
SYSTEM
GET
root
SYSTEM
GET
limit
DEC
limit
8000H
END
Init
BEGIN
Init
Load
Oberon
M
LED
res
REPEAT
UNTIL
FALSE
only
if
load
fails
END
Modules
MODULE
Net
NW
PR
IMPORT
SYSTEM
SCC
Files
Viewers
Texts
TextFrames
MenuViewers
Oberon
CONST
PakSize
T0
T1
timeouts
T0
T1
timeouts
ACK
10H
NAK
25H
NPR
26H
acknowledgements
NRQ
34H
NRS
35H
name
request
response
SND
41H
REC
42H
MSG
44H
TRQ
46H
TIM
47H
time
requests
VAR
W
Texts
Writer
Server
Oberon
Task
head0
head1
SCC
Header
partner
ARRAY
OF
CHAR
dmy
ARRAY
OF
BYTE
protected
BOOLEAN
write
protection
PROCEDURE
SetPartner
name
ARRAY
OF
CHAR
BEGIN
head0
dadr
head1
sadr
partner
name
END
SetPartner
PROCEDURE
Send
t
BYTE
L
INTEGER
data
ARRAY
OF
BYTE
BEGIN
head0
typ
t
head0
len
L
SCC
SendPacket
head0
data
END
Send
PROCEDURE
ReceiveHead
timeout
LONGINT
VAR
time
LONGINT
BEGIN
time
Oberon
Time
timeout
REPEAT
SCC
ReceiveHead
head1
IF
head1
valid
head1
sadr
head0
dadr
THEN
SCC
Skip
head1
len
head1
valid
FALSE
END
IF
head1
valid
Oberon
Time
time
THEN
head1
typ
0FFH
END
UNTIL
head1
valid
OR
head1
typ
0FFH
END
ReceiveHead
PROCEDURE
FindPartner
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
time
LONGINT
k
INTEGER
Id
ARRAY
OF
CHAR
IdB
ARRAY
OF
BYTE
BEGIN
SCC
Skip
SCC
Available
res
k
WHILE
k
name
k
0X
DO
Id
k
name
k
IdB
k
ORD
Id
k
INC
k
END
Id
k
0X
IdB
k
also
terminate
IdB
IF
Id
partner
THEN
head0
dadr
0FFH
Send
NRQ
k
IdB
time
Oberon
Time
T1
REPEAT
SCC
ReceiveHead
head1
IF
head1
valid
THEN
IF
head1
typ
NRS
THEN
SetPartner
Id
ELSE
SCC
Skip
head1
len
head1
valid
FALSE
END
ELSIF
Oberon
Time
time
THEN
res
partner
0X
END
UNTIL
head1
valid
OR
res
END
END
FindPartner
PROCEDURE
AppendS
s
ARRAY
OF
CHAR
VAR
d
ARRAY
OF
BYTE
VAR
k
INTEGER
VAR
i
INTEGER
ch
CHAR
BEGIN
i
REPEAT
ch
s
i
d
k
ORD
ch
INC
i
INC
k
UNTIL
ch
0X
END
AppendS
PROCEDURE
AppendW
s
LONGINT
VAR
d
ARRAY
OF
BYTE
n
INTEGER
VAR
k
INTEGER
VAR
i
INTEGER
BEGIN
i
REPEAT
d
k
s
MOD
100H
s
s
DIV
100H
INC
i
INC
k
UNTIL
i
n
END
AppendW
PROCEDURE
PickS
VAR
s
ARRAY
OF
CHAR
VAR
i
INTEGER
x
BYTE
BEGIN
i
REPEAT
SCC
Receive
x
s
i
CHR
x
INC
i
UNTIL
x
END
PickS
PROCEDURE
PickQ
VAR
w
LONGINT
VAR
x0
x1
x2
x3
BYTE
BEGIN
SCC
Receive
x0
SCC
Receive
x1
SCC
Receive
x2
SCC
Receive
x3
w
x0
100H
x1
100H
x2
100H
x3
END
PickQ
PROCEDURE
SendData
F
Files
File
VAR
k
seqno
INTEGER
x
BYTE
len
LONGINT
R
Files
Rider
buf
ARRAY
PakSize
OF
BYTE
BEGIN
Files
Set
R
F
len
seqno
REPEAT
k
REPEAT
Files
ReadByte
R
x
IF
R
eof
THEN
buf
k
x
INC
k
END
UNTIL
R
eof
OR
k
PakSize
REPEAT
Send
seqno
k
buf
ReceiveHead
T1
UNTIL
head1
typ
seqno
ACK
seqno
seqno
MOD
len
len
k
IF
head1
typ
seqno
ACK
THEN
Texts
WriteString
W
failed
k
END
UNTIL
k
PakSize
Texts
WriteInt
W
len
END
SendData
PROCEDURE
ReceiveData
F
Files
File
VAR
done
BOOLEAN
VAR
k
retry
seqno
INTEGER
x
BYTE
len
LONGINT
R
Files
Rider
BEGIN
Files
Set
R
F
seqno
len
retry
k
PakSize
REPEAT
IF
head1
typ
seqno
THEN
seqno
seqno
MOD
len
len
head1
len
retry
Send
seqno
ACK
dmy
k
WHILE
k
head1
len
DO
SCC
Receive
x
Files
WriteByte
R
x
INC
k
END
IF
k
PakSize
THEN
done
TRUE
END
ELSE
DEC
retry
IF
retry
THEN
Texts
WriteString
W
failed
done
FALSE
k
END
Send
seqno
ACK
dmy
END
ReceiveHead
T0
UNTIL
k
PakSize
Texts
WriteInt
W
len
END
ReceiveData
PROCEDURE
reply
msg
INTEGER
BEGIN
IF
msg
THEN
Texts
WriteString
W
no
link
ELSIF
msg
THEN
Texts
WriteString
W
no
permission
ELSIF
msg
THEN
Texts
WriteString
W
not
done
ELSIF
msg
THEN
Texts
WriteString
W
not
found
ELSIF
msg
THEN
Texts
WriteString
W
no
response
ELSIF
msg
THEN
Texts
WriteString
W
time
set
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
reply
PROCEDURE
Serve
VAR
i
INTEGER
done
BOOLEAN
x
BYTE
F
Files
File
pw
clock
newclock
LONGINT
Id
ARRAY
OF
CHAR
IdB
ARRAY
OF
BYTE
FileName
ARRAY
OF
CHAR
BEGIN
SCC
ReceiveHead
head1
IF
head1
valid
THEN
IF
head1
typ
SND
THEN
PickS
Id
PickQ
pw
PickS
FileName
Texts
WriteString
W
Id
Texts
Write
W
Texts
WriteString
W
FileName
F
Files
Old
FileName
IF
F
NIL
THEN
Texts
WriteString
W
sending
SetPartner
Id
Texts
Append
Oberon
Log
W
buf
SendData
F
ELSE
Send
NAK
dmy
Texts
Write
W
END
reply
ELSIF
head1
typ
REC
THEN
PickS
Id
PickQ
pw
PickS
FileName
IF
protected
THEN
Texts
WriteString
W
Id
Texts
Write
W
Texts
WriteString
W
FileName
F
Files
New
FileName
IF
F
NIL
THEN
Texts
WriteString
W
receiving
SetPartner
Id
Texts
Append
Oberon
Log
W
buf
Send
ACK
dmy
ReceiveHead
T0
ReceiveData
F
done
IF
done
THEN
Files
Register
F
END
ELSE
Send
NAK
dmy
Texts
Write
W
END
reply
ELSE
Send
NPR
dmy
END
ELSIF
head1
typ
MSG
THEN
i
WHILE
i
head1
len
DO
SCC
Receive
x
Texts
Write
W
CHR
x
INC
i
END
Send
ACK
dmy
reply
ELSIF
head1
typ
TRQ
THEN
i
AppendW
Oberon
Clock
IdB
i
Send
TIM
IdB
ELSIF
head1
typ
TIM
THEN
PickQ
newclock
PickS
Id
PickQ
pw
clock
Oberon
Clock
IF
protected
Id
0X
ABS
pw
clock
THEN
Oberon
SetClock
newclock
Texts
WriteString
W
Id
Texts
WriteString
W
changed
System
Date
Texts
WriteClock
W
newclock
reply
END
ELSIF
head1
typ
NRQ
THEN
i
REPEAT
SCC
Receive
x
Id
i
CHR
x
INC
i
IF
i
THEN
Id
0X
x
END
UNTIL
x
WHILE
i
head1
len
DO
SCC
Receive
x
INC
i
END
IF
Id
Oberon
User
THEN
SetPartner
Id
Send
NRS
dmy
END
ELSE
SCC
Skip
head1
len
END
END
END
Serve
PROCEDURE
GetPar1
VAR
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
END
GetPar1
PROCEDURE
GetPar
VAR
S
Texts
Scanner
VAR
end
LONGINT
VAR
T
Texts
Text
beg
tm
LONGINT
BEGIN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
tm
IF
tm
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
ELSE
end
Oberon
Par
text
len
END
END
GetPar
PROCEDURE
SendFiles
VAR
k
INTEGER
end
LONGINT
S
Texts
Scanner
F
Files
File
buf
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
k
IF
k
THEN
GetPar
S
end
WHILE
Texts
Pos
S
end
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
k
AppendS
Oberon
User
buf
k
AppendW
Oberon
Password
buf
k
AppendS
S
s
buf
k
IF
S
nextCh
THEN
prefix
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
THEN
buf
k
ORD
AppendS
S
s
buf
k
Texts
Write
W
Texts
WriteString
W
S
s
END
END
F
Files
Old
S
s
IF
F
NIL
THEN
Send
REC
k
buf
ReceiveHead
T0
IF
head1
typ
ACK
THEN
Texts
WriteString
W
sending
Texts
Append
Oberon
Log
W
buf
SendData
F
reply
ELSIF
head1
typ
NPR
THEN
reply
end
ELSIF
head1
typ
NAK
THEN
reply
end
ELSE
reply
end
END
ELSE
reply
END
Texts
Scan
S
END
ELSE
reply
END
END
END
SendFiles
PROCEDURE
ReceiveFiles
VAR
k
INTEGER
done
BOOLEAN
end
LONGINT
S
Texts
Scanner
F
Files
File
buf
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
k
IF
k
THEN
GetPar
S
end
WHILE
Texts
Pos
S
end
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
k
AppendS
Oberon
User
buf
k
AppendW
Oberon
Password
buf
k
AppendS
S
s
buf
k
IF
S
nextCh
THEN
prefix
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
THEN
buf
k
ORD
AppendS
S
s
buf
k
Texts
Write
W
Texts
WriteString
W
S
s
END
END
Send
SND
k
buf
Texts
WriteString
W
receiving
Texts
Append
Oberon
Log
W
buf
ReceiveHead
T1
IF
head1
typ
THEN
F
Files
New
S
s
IF
F
NIL
THEN
ReceiveData
F
done
IF
done
THEN
Files
Register
F
reply
ELSE
end
END
ELSE
reply
Send
NAK
dmy
END
ELSIF
head1
typ
NAK
THEN
reply
ELSIF
head1
typ
NPR
THEN
reply
end
ELSE
reply
end
END
Texts
Scan
S
END
ELSE
reply
END
END
END
ReceiveFiles
PROCEDURE
SendMsg
VAR
i
INTEGER
ch
CHAR
S
Texts
Scanner
msg
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
i
IF
i
THEN
Texts
Read
S
ch
WHILE
ch
i
DO
msg
i
ORD
ch
INC
i
Texts
Read
S
ch
END
Send
MSG
i
msg
ReceiveHead
T0
IF
head1
typ
ACK
THEN
reply
END
ELSE
reply
END
END
END
SendMsg
PROCEDURE
GetTime
VAR
dt
res
INTEGER
S
Texts
Scanner
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
res
IF
res
THEN
Send
TRQ
dmy
ReceiveHead
T1
IF
head1
typ
TIM
THEN
PickQ
dt
Oberon
SetClock
dt
reply
END
ELSE
reply
END
END
END
GetTime
PROCEDURE
StartServer
BEGIN
protected
TRUE
partner
0X
SCC
Start
TRUE
Oberon
Remove
Server
Oberon
Install
Server
Texts
WriteString
W
Server
started
as
Texts
WriteString
W
Oberon
User
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
StartServer
PROCEDURE
Unprotect
BEGIN
protected
FALSE
END
Unprotect
PROCEDURE
WProtect
BEGIN
protected
TRUE
END
WProtect
PROCEDURE
Reset
BEGIN
SCC
Start
TRUE
END
Reset
PROCEDURE
StopServer
BEGIN
Oberon
Remove
Server
Texts
WriteString
W
Server
stopped
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
StopServer
PROCEDURE
SCCStatus
BEGIN
Texts
WriteString
W
SCC
Available
Texts
WriteInt
W
SCC
Available
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
SCCStatus
BEGIN
Texts
OpenWriter
W
Server
Oberon
NewTask
Serve
END
Net
MODULE
Oberon
JG
NW
IMPORT
SYSTEM
Kernel
Files
Modules
Input
Display
Viewers
Fonts
Texts
CONST
message
ids
consume
track
defocus
neutralize
mark
off
idle
active
task
states
BasicCycle
ESC
1BX
SETSTAR
1AX
TYPE
Painter
PROCEDURE
x
y
INTEGER
Marker
RECORD
Fade
Draw
Painter
END
Cursor
RECORD
marker
Marker
on
BOOLEAN
X
Y
INTEGER
END
InputMsg
RECORD
Display
FrameMsg
id
INTEGER
keys
SET
X
Y
INTEGER
ch
CHAR
fnt
Fonts
Font
col
voff
INTEGER
END
SelectionMsg
RECORD
Display
FrameMsg
time
LONGINT
text
Texts
Text
beg
end
LONGINT
END
ControlMsg
RECORD
Display
FrameMsg
id
X
Y
INTEGER
END
CopyMsg
RECORD
Display
FrameMsg
F
Display
Frame
END
Task
POINTER
TO
TaskDesc
Handler
PROCEDURE
TaskDesc
RECORD
state
nextTime
period
INTEGER
next
Task
handle
Handler
END
VAR
User
ARRAY
OF
CHAR
Password
LONGINT
Arrow
Star
Marker
Mouse
Pointer
Cursor
FocusViewer
Viewers
Viewer
Log
Texts
Text
Par
RECORD
vwr
Viewers
Viewer
frame
Display
Frame
text
Texts
Text
pos
LONGINT
END
CurFnt
Fonts
Font
CurCol
CurOff
INTEGER
NofTasks
INTEGER
CurTask
Task
DW
DH
CL
INTEGER
ActCnt
INTEGER
action
count
for
GC
Mod
Modules
Module
user
identification
PROCEDURE
Code
VAR
s
ARRAY
OF
CHAR
LONGINT
VAR
i
INTEGER
a
b
c
LONGINT
BEGIN
a
b
i
WHILE
s
i
0X
DO
c
b
b
a
a
c
MOD
ORD
s
i
INC
i
END
IF
b
THEN
b
b
END
RETURN
b
a
END
Code
PROCEDURE
SetUser
VAR
user
password
ARRAY
OF
CHAR
BEGIN
User
user
Password
Code
password
END
SetUser
PROCEDURE
Clock
LONGINT
BEGIN
RETURN
Kernel
Clock
END
Clock
PROCEDURE
SetClock
d
LONGINT
BEGIN
Kernel
SetClock
d
END
SetClock
PROCEDURE
Time
LONGINT
BEGIN
RETURN
Kernel
Time
END
Time
cursor
handling
PROCEDURE
FlipArrow
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
arrow
X
Y
Display
invert
END
FlipArrow
PROCEDURE
FlipStar
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
star
X
Y
Display
invert
END
FlipStar
PROCEDURE
OpenCursor
VAR
c
Cursor
BEGIN
c
on
FALSE
c
X
c
Y
END
OpenCursor
PROCEDURE
FadeCursor
VAR
c
Cursor
BEGIN
IF
c
on
THEN
c
marker
Fade
c
X
c
Y
c
on
FALSE
END
END
FadeCursor
PROCEDURE
DrawCursor
VAR
c
Cursor
m
Marker
x
y
INTEGER
BEGIN
IF
c
on
x
c
X
OR
y
c
Y
OR
m
Draw
c
marker
Draw
THEN
c
marker
Fade
c
X
c
Y
c
on
FALSE
END
IF
c
on
THEN
m
Draw
x
y
c
marker
m
c
X
x
c
Y
y
c
on
TRUE
END
END
DrawCursor
PROCEDURE
DrawMouse
m
Marker
x
y
INTEGER
BEGIN
DrawCursor
Mouse
m
x
y
END
DrawMouse
PROCEDURE
DrawMouseArrow
x
y
INTEGER
BEGIN
DrawCursor
Mouse
Arrow
x
y
END
DrawMouseArrow
PROCEDURE
FadeMouse
BEGIN
FadeCursor
Mouse
END
FadeMouse
PROCEDURE
DrawPointer
x
y
INTEGER
BEGIN
DrawCursor
Pointer
Star
x
y
END
DrawPointer
display
management
PROCEDURE
RemoveMarks
X
Y
W
H
INTEGER
BEGIN
IF
Mouse
X
X
Mouse
X
X
W
Mouse
Y
Y
Mouse
Y
Y
H
THEN
FadeCursor
Mouse
END
IF
Pointer
X
X
Pointer
X
X
W
Pointer
Y
Y
Pointer
Y
Y
H
THEN
FadeCursor
Pointer
END
END
RemoveMarks
PROCEDURE
HandleFiller
V
Display
Frame
VAR
M
Display
FrameMsg
BEGIN
CASE
M
OF
InputMsg
IF
M
id
track
THEN
DrawCursor
Mouse
Arrow
M
X
M
Y
END
ControlMsg
IF
M
id
mark
THEN
DrawCursor
Pointer
Star
M
X
M
Y
END
Viewers
ViewerMsg
IF
M
id
Viewers
restore
V
W
V
H
THEN
RemoveMarks
V
X
V
Y
V
W
V
H
Display
ReplConst
Display
black
V
X
V
Y
V
W
V
H
Display
replace
ELSIF
M
id
Viewers
modify
M
Y
V
Y
THEN
RemoveMarks
V
X
M
Y
V
W
V
Y
M
Y
Display
ReplConst
Display
black
V
X
M
Y
V
W
V
Y
M
Y
Display
replace
END
END
END
HandleFiller
PROCEDURE
OpenDisplay
UW
SW
H
INTEGER
VAR
Filler
Viewers
Viewer
BEGIN
Input
SetMouseLimits
Viewers
curW
UW
SW
H
Display
ReplConst
Display
black
Viewers
curW
UW
SW
H
Display
replace
NEW
Filler
Filler
handle
HandleFiller
Viewers
InitTrack
UW
H
Filler
init
user
track
NEW
Filler
Filler
handle
HandleFiller
Viewers
InitTrack
SW
H
Filler
init
system
track
END
OpenDisplay
PROCEDURE
DisplayWidth
X
INTEGER
INTEGER
BEGIN
RETURN
DW
END
DisplayWidth
PROCEDURE
DisplayHeight
X
INTEGER
INTEGER
BEGIN
RETURN
DH
END
DisplayHeight
PROCEDURE
OpenTrack
X
W
INTEGER
VAR
Filler
Viewers
Viewer
BEGIN
NEW
Filler
Filler
handle
HandleFiller
Viewers
OpenTrack
X
W
Filler
END
OpenTrack
PROCEDURE
UserTrack
X
INTEGER
INTEGER
BEGIN
RETURN
X
DIV
DW
DW
END
UserTrack
PROCEDURE
SystemTrack
X
INTEGER
INTEGER
BEGIN
RETURN
X
DIV
DW
DW
DW
DIV
END
SystemTrack
PROCEDURE
UY
X
INTEGER
INTEGER
VAR
h
INTEGER
fil
bot
alt
max
Display
Frame
BEGIN
Viewers
Locate
X
fil
bot
alt
max
IF
fil
H
DH
DIV
THEN
h
DH
ELSE
h
max
Y
max
H
DIV
END
RETURN
h
END
UY
PROCEDURE
AllocateUserViewer
DX
INTEGER
VAR
X
Y
INTEGER
BEGIN
IF
Pointer
on
THEN
X
Pointer
X
Y
Pointer
Y
ELSE
X
DX
DIV
DW
DW
Y
UY
X
END
END
AllocateUserViewer
PROCEDURE
SY
X
INTEGER
INTEGER
VAR
H0
H1
H2
H3
y
INTEGER
fil
bot
alt
max
Display
Frame
BEGIN
H3
DH
DH
DIV
H2
H3
H3
DIV
H1
DH
DIV
H0
DH
DIV
Viewers
Locate
X
DH
fil
bot
alt
max
IF
fil
H
DH
DIV
THEN
y
DH
ELSIF
max
H
DH
H0
THEN
y
max
Y
H3
ELSIF
max
H
H3
H0
THEN
y
max
Y
H2
ELSIF
max
H
H2
H0
THEN
y
max
Y
H1
ELSIF
max
bot
THEN
y
max
Y
max
H
DIV
ELSIF
bot
H
H1
THEN
y
bot
H
DIV
ELSE
y
alt
Y
alt
H
DIV
END
RETURN
y
END
SY
PROCEDURE
AllocateSystemViewer
DX
INTEGER
VAR
X
Y
INTEGER
BEGIN
IF
Pointer
on
THEN
X
Pointer
X
Y
Pointer
Y
ELSE
X
DX
DIV
DW
DW
DW
DIV
Y
SY
X
END
END
AllocateSystemViewer
PROCEDURE
MarkedViewer
Viewers
Viewer
BEGIN
RETURN
Viewers
This
Pointer
X
Pointer
Y
END
MarkedViewer
PROCEDURE
PassFocus
V
Viewers
Viewer
VAR
M
ControlMsg
BEGIN
M
id
defocus
FocusViewer
handle
FocusViewer
M
FocusViewer
V
END
PassFocus
PROCEDURE
OpenLog
T
Texts
Text
BEGIN
Log
T
END
OpenLog
command
interpretation
PROCEDURE
SetPar
F
Display
Frame
T
Texts
Text
pos
LONGINT
BEGIN
Par
vwr
Viewers
This
F
X
F
Y
Par
frame
F
Par
text
T
Par
pos
pos
END
SetPar
PROCEDURE
Call
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
mod
Modules
Module
P
Modules
Command
i
j
INTEGER
ch
CHAR
Mname
Cname
ARRAY
OF
CHAR
BEGIN
i
ch
name
WHILE
ch
ch
0X
DO
Mname
i
ch
INC
i
ch
name
i
END
IF
ch
THEN
Mname
i
0X
INC
i
Modules
Load
Mname
mod
res
Modules
res
IF
Modules
res
THEN
j
ch
name
i
INC
i
WHILE
ch
0X
DO
Cname
j
ch
INC
j
ch
name
i
INC
i
END
Cname
j
0X
P
Modules
ThisCommand
mod
Cname
res
Modules
res
IF
Modules
res
THEN
P
END
END
ELSE
res
END
END
Call
PROCEDURE
GetSelection
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
VAR
M
SelectionMsg
BEGIN
M
time
Viewers
Broadcast
M
time
M
time
IF
time
THEN
text
M
text
beg
M
beg
end
M
end
END
END
GetSelection
PROCEDURE
GC
VAR
mod
Modules
Module
BEGIN
IF
ActCnt
OR
Kernel
allocated
Kernel
heapLim
Kernel
heapOrg
10000H
THEN
mod
Modules
root
LED
21H
WHILE
mod
NIL
DO
IF
mod
name
0X
THEN
Kernel
Mark
mod
ptr
END
mod
mod
next
END
LED
23H
Files
RestoreList
LED
27H
Kernel
Scan
LED
20H
ActCnt
BasicCycle
END
END
GC
PROCEDURE
NewTask
h
Handler
period
INTEGER
Task
VAR
t
Task
BEGIN
NEW
t
t
state
off
t
next
t
t
handle
h
t
period
period
RETURN
t
END
NewTask
PROCEDURE
Install
T
Task
BEGIN
IF
T
state
off
THEN
T
next
CurTask
next
CurTask
next
T
T
state
idle
T
nextTime
INC
NofTasks
END
END
Install
PROCEDURE
Remove
T
Task
VAR
t
Task
BEGIN
IF
T
state
off
THEN
t
T
WHILE
t
next
T
DO
t
t
next
END
t
next
T
next
T
state
off
T
next
NIL
CurTask
t
DEC
NofTasks
END
END
Remove
PROCEDURE
Collect
count
INTEGER
BEGIN
ActCnt
count
END
Collect
PROCEDURE
SetFont
fnt
Fonts
Font
BEGIN
CurFnt
fnt
END
SetFont
PROCEDURE
SetColor
col
INTEGER
BEGIN
CurCol
col
END
SetColor
PROCEDURE
SetOffset
voff
INTEGER
BEGIN
CurOff
voff
END
SetOffset
PROCEDURE
Loop
VAR
V
Viewers
Viewer
M
InputMsg
N
ControlMsg
prevX
prevY
X
Y
t
INTEGER
keys
SET
ch
CHAR
BEGIN
REPEAT
Input
Mouse
keys
X
Y
IF
Input
Available
THEN
Input
Read
ch
IF
ch
ESC
THEN
N
id
neutralize
Viewers
Broadcast
N
FadeCursor
Pointer
LED
ELSIF
ch
SETSTAR
THEN
N
id
mark
N
X
X
N
Y
Y
V
Viewers
This
X
Y
V
handle
V
N
ELSE
M
id
consume
M
ch
ch
M
fnt
CurFnt
M
col
CurCol
M
voff
CurOff
FocusViewer
handle
FocusViewer
M
DEC
ActCnt
END
ELSIF
keys
THEN
M
id
track
M
X
X
M
Y
Y
M
keys
keys
REPEAT
V
Viewers
This
M
X
M
Y
V
handle
V
M
Input
Mouse
M
keys
M
X
M
Y
UNTIL
M
keys
DEC
ActCnt
ELSE
IF
X
prevX
OR
Y
prevY
OR
Mouse
on
THEN
M
id
track
M
X
X
IF
Y
Display
Height
THEN
Y
Display
Height
END
M
Y
Y
M
keys
keys
V
Viewers
This
X
Y
V
handle
V
M
prevX
X
prevY
Y
END
CurTask
CurTask
next
t
Kernel
Time
IF
t
CurTask
nextTime
THEN
CurTask
nextTime
t
CurTask
period
CurTask
state
active
CurTask
handle
CurTask
state
idle
END
END
UNTIL
FALSE
END
Loop
PROCEDURE
Reset
BEGIN
IF
CurTask
state
active
THEN
Remove
CurTask
END
SYSTEM
LDREG
Kernel
stackOrg
reset
stack
pointer
Loop
END
Reset
BEGIN
User
0X
Arrow
Fade
FlipArrow
Arrow
Draw
FlipArrow
Star
Fade
FlipStar
Star
Draw
FlipStar
OpenCursor
Mouse
OpenCursor
Pointer
DW
Display
Width
DH
Display
Height
CL
DW
OpenDisplay
DW
DIV
DW
DIV
DH
FocusViewer
Viewers
This
CurFnt
Fonts
Default
CurCol
Display
white
CurOff
ActCnt
CurTask
NewTask
GC
Install
CurTask
Modules
Load
System
Mod
Mod
NIL
Loop
END
Oberon
MODULE
ORB
NW
in
Oberon
IMPORT
Files
ORS
Definition
of
data
types
Object
and
Type
which
together
form
the
data
structure
called
symbol
table
Contains
procedures
for
creation
of
Objects
and
for
search
NewObj
this
thisimport
thisfield
and
OpenScope
CloseScope
Handling
of
import
and
export
i
e
reading
and
writing
of
symbol
files
is
done
by
procedures
Import
and
Export
This
module
contains
the
list
of
standard
identifiers
with
which
the
symbol
table
universe
and
that
of
the
pseudo
module
SYSTEM
are
initialized
CONST
versionkey
maxTypTab
class
values
Head
Const
Var
Par
Fld
Typ
SProc
SFunc
Mod
form
values
Byte
Bool
Char
Int
Real
Set
Pointer
NilTyp
NoTyp
Proc
String
Array
Record
TYPE
Object
POINTER
TO
ObjDesc
Module
POINTER
TO
ModDesc
Type
POINTER
TO
TypeDesc
ObjDesc
RECORD
class
exno
BYTE
expo
rdo
BOOLEAN
exported
read
only
lev
INTEGER
next
dsc
Object
type
Type
name
ORS
Ident
val
LONGINT
END
ModDesc
RECORD
ObjDesc
orgname
ORS
Ident
END
TypeDesc
RECORD
form
ref
mno
INTEGER
ref
is
only
used
for
import
export
nofpar
INTEGER
for
procedures
extension
level
for
records
len
LONGINT
for
arrays
len
open
array
for
records
adr
of
descriptor
dsc
typobj
Object
base
Type
for
arrays
records
pointers
size
LONGINT
in
bytes
always
multiple
of
except
for
Byte
Bool
and
Char
END
Object
classes
and
the
meaning
of
val
class
val
Var
address
Par
address
Const
value
Fld
offset
Typ
type
descriptor
TD
address
SProc
inline
code
number
SFunc
inline
code
number
Mod
key
Type
forms
and
the
meaning
of
dsc
and
base
form
dsc
base
Pointer
type
of
dereferenced
object
Proc
params
result
type
Array
type
of
elements
Record
fields
extension
VAR
topScope
universe
system
Object
byteType
boolType
charType
Type
intType
realType
setType
nilType
noType
strType
Type
nofmod
Ref
INTEGER
typtab
ARRAY
maxTypTab
OF
Type
PROCEDURE
NewObj
VAR
obj
Object
id
ORS
Ident
class
INTEGER
insert
new
Object
with
name
id
VAR
new
x
Object
BEGIN
x
topScope
WHILE
x
next
NIL
x
next
name
id
DO
x
x
next
END
IF
x
next
NIL
THEN
NEW
new
new
name
id
new
class
class
new
next
NIL
new
rdo
FALSE
new
dsc
NIL
x
next
new
obj
new
ELSE
obj
x
next
ORS
Mark
mult
def
END
END
NewObj
PROCEDURE
thisObj
Object
VAR
s
x
Object
BEGIN
s
topScope
REPEAT
x
s
next
WHILE
x
NIL
x
name
ORS
id
DO
x
x
next
END
s
s
dsc
UNTIL
x
NIL
OR
s
NIL
RETURN
x
END
thisObj
PROCEDURE
thisimport
mod
Object
Object
VAR
obj
Object
BEGIN
IF
mod
rdo
THEN
IF
mod
name
0X
THEN
obj
mod
dsc
WHILE
obj
NIL
obj
name
ORS
id
DO
obj
obj
next
END
ELSE
obj
NIL
END
ELSE
obj
NIL
END
RETURN
obj
END
thisimport
PROCEDURE
thisfield
rec
Type
Object
VAR
fld
Object
BEGIN
fld
rec
dsc
WHILE
fld
NIL
fld
name
ORS
id
DO
fld
fld
next
END
RETURN
fld
END
thisfield
PROCEDURE
OpenScope
VAR
s
Object
BEGIN
NEW
s
s
class
Head
s
dsc
topScope
s
next
NIL
topScope
s
END
OpenScope
PROCEDURE
CloseScope
BEGIN
topScope
topScope
dsc
END
CloseScope
Import
PROCEDURE
MakeFileName
VAR
FName
ORS
Ident
name
ext
ARRAY
OF
CHAR
VAR
i
j
INTEGER
BEGIN
i
j
assume
name
suffix
less
than
characters
WHILE
i
ORS
IdLen
name
i
0X
DO
FName
i
name
i
INC
i
END
REPEAT
FName
i
ext
j
INC
i
INC
j
UNTIL
ext
j
0X
FName
i
0X
END
MakeFileName
PROCEDURE
ThisModule
name
orgname
ORS
Ident
non
BOOLEAN
key
LONGINT
Object
VAR
mod
Module
obj
obj1
Object
BEGIN
obj1
topScope
obj
obj1
next
search
for
module
WHILE
obj
NIL
obj
name
name
DO
obj1
obj
obj
obj1
next
END
IF
obj
NIL
THEN
insert
new
module
NEW
mod
mod
class
Mod
mod
rdo
FALSE
mod
name
name
mod
orgname
orgname
mod
val
key
mod
lev
nofmod
INC
nofmod
mod
type
noType
mod
dsc
NIL
mod
next
NIL
obj1
next
mod
obj
mod
ELSE
module
already
present
IF
non
THEN
ORS
Mark
invalid
import
order
END
END
RETURN
obj
END
ThisModule
PROCEDURE
Read
VAR
R
Files
Rider
VAR
x
INTEGER
VAR
b
BYTE
BEGIN
Files
ReadByte
R
b
IF
b
80H
THEN
x
b
ELSE
x
b
100H
END
END
Read
PROCEDURE
InType
VAR
R
Files
Rider
thismod
Object
VAR
T
Type
VAR
key
LONGINT
ref
class
form
np
readonly
INTEGER
fld
par
obj
mod
Object
t
Type
name
modname
ORS
Ident
BEGIN
Read
R
ref
IF
ref
THEN
T
typtab
ref
already
read
ELSE
NEW
t
T
t
typtab
ref
t
t
mno
thismod
lev
Read
R
form
t
form
form
IF
form
Pointer
THEN
InType
R
thismod
t
base
t
size
ELSIF
form
Array
THEN
InType
R
thismod
t
base
Files
ReadNum
R
t
len
Files
ReadNum
R
t
size
ELSIF
form
Record
THEN
InType
R
thismod
t
base
IF
t
base
form
NoTyp
THEN
t
base
NIL
obj
NIL
ELSE
obj
t
base
dsc
END
Files
ReadNum
R
t
len
TD
adr
exno
Files
ReadNum
R
t
nofpar
ext
level
Files
ReadNum
R
t
size
Read
R
class
WHILE
class
DO
fields
NEW
fld
fld
class
class
Files
ReadString
R
fld
name
IF
fld
name
0X
THEN
fld
expo
TRUE
InType
R
thismod
fld
type
ELSE
fld
expo
FALSE
fld
type
nilType
END
Files
ReadNum
R
fld
val
fld
next
obj
obj
fld
Read
R
class
END
t
dsc
obj
ELSIF
form
Proc
THEN
InType
R
thismod
t
base
obj
NIL
np
Read
R
class
WHILE
class
DO
parameters
NEW
par
par
class
class
Read
R
readonly
par
rdo
readonly
InType
R
thismod
par
type
par
next
obj
obj
par
INC
np
Read
R
class
END
t
dsc
obj
t
nofpar
np
t
size
END
Files
ReadString
R
modname
IF
modname
0X
THEN
re
import
Files
ReadInt
R
key
Files
ReadString
R
name
mod
ThisModule
modname
modname
FALSE
key
obj
mod
dsc
search
type
WHILE
obj
NIL
obj
name
name
DO
obj
obj
next
END
IF
obj
NIL
THEN
T
obj
type
type
object
found
in
object
list
of
mod
ELSE
insert
new
type
object
in
object
list
of
mod
NEW
obj
obj
name
name
obj
class
Typ
obj
next
mod
dsc
mod
dsc
obj
obj
type
t
t
mno
mod
lev
t
typobj
obj
T
t
END
typtab
ref
T
END
END
END
InType
PROCEDURE
Import
VAR
modid
modid1
ORS
Ident
VAR
key
LONGINT
class
k
INTEGER
obj
Object
t
Type
thismod
Object
modname
fname
ORS
Ident
F
Files
File
R
Files
Rider
BEGIN
IF
modid1
SYSTEM
THEN
thismod
ThisModule
modid
modid1
TRUE
key
DEC
nofmod
thismod
lev
thismod
dsc
system
thismod
rdo
TRUE
ELSE
MakeFileName
fname
modid1
smb
F
Files
Old
fname
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadInt
R
key
Files
ReadInt
R
key
Files
ReadString
R
modname
thismod
ThisModule
modid
modid1
TRUE
key
thismod
rdo
TRUE
Read
R
class
version
key
IF
class
versionkey
THEN
ORS
Mark
wrong
version
END
Read
R
class
WHILE
class
DO
NEW
obj
obj
class
class
Files
ReadString
R
obj
name
InType
R
thismod
obj
type
obj
lev
thismod
lev
IF
class
Typ
THEN
t
obj
type
t
typobj
obj
Read
R
k
fixup
bases
of
previously
declared
pointer
types
WHILE
k
DO
typtab
k
base
t
Read
R
k
END
ELSE
IF
class
Const
THEN
IF
obj
type
form
Real
THEN
Files
ReadInt
R
obj
val
ELSE
Files
ReadNum
R
obj
val
END
ELSIF
class
Var
THEN
Files
ReadNum
R
obj
val
obj
rdo
TRUE
END
END
obj
next
thismod
dsc
thismod
dsc
obj
Read
R
class
END
ELSE
ORS
Mark
import
not
available
END
END
END
Import
Export
PROCEDURE
Write
VAR
R
Files
Rider
x
INTEGER
BEGIN
Files
WriteByte
R
x
END
Write
PROCEDURE
OutType
VAR
R
Files
Rider
t
Type
VAR
obj
mod
fld
Object
PROCEDURE
OutPar
VAR
R
Files
Rider
par
Object
n
INTEGER
VAR
cl
INTEGER
BEGIN
IF
n
THEN
OutPar
R
par
next
n
cl
par
class
Write
R
cl
IF
par
rdo
THEN
Write
R
ELSE
Write
R
END
OutType
R
par
type
END
END
OutPar
PROCEDURE
FindHiddenPointers
VAR
R
Files
Rider
typ
Type
offset
LONGINT
VAR
fld
Object
i
n
LONGINT
BEGIN
IF
typ
form
Pointer
OR
typ
form
NilTyp
THEN
Write
R
Fld
Write
R
Files
WriteNum
R
offset
ELSIF
typ
form
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindHiddenPointers
R
fld
type
fld
val
offset
fld
fld
next
END
ELSIF
typ
form
Array
THEN
i
n
typ
len
WHILE
i
n
DO
FindHiddenPointers
R
typ
base
typ
base
size
i
offset
INC
i
END
END
END
FindHiddenPointers
BEGIN
IF
t
ref
THEN
type
was
already
output
Write
R
t
ref
ELSE
obj
t
typobj
IF
obj
NIL
THEN
Write
R
Ref
t
ref
Ref
INC
Ref
ELSE
anonymous
Write
R
END
Write
R
t
form
IF
t
form
Pointer
THEN
OutType
R
t
base
ELSIF
t
form
Array
THEN
OutType
R
t
base
Files
WriteNum
R
t
len
Files
WriteNum
R
t
size
ELSIF
t
form
Record
THEN
IF
t
base
NIL
THEN
OutType
R
t
base
ELSE
OutType
R
noType
END
IF
obj
NIL
THEN
Files
WriteNum
R
obj
exno
ELSE
Write
R
END
Files
WriteNum
R
t
nofpar
Files
WriteNum
R
t
size
fld
t
dsc
WHILE
fld
NIL
DO
fields
IF
fld
expo
THEN
Write
R
Fld
Files
WriteString
R
fld
name
OutType
R
fld
type
Files
WriteNum
R
fld
val
offset
ELSE
FindHiddenPointers
R
fld
type
fld
val
END
fld
fld
next
END
Write
R
ELSIF
t
form
Proc
THEN
OutType
R
t
base
OutPar
R
t
dsc
t
nofpar
Write
R
END
IF
t
mno
obj
NIL
THEN
re
export
output
name
mod
topScope
next
WHILE
mod
NIL
mod
lev
t
mno
DO
mod
mod
next
END
IF
mod
NIL
THEN
Files
WriteString
R
mod
Module
orgname
Files
WriteInt
R
mod
val
Files
WriteString
R
obj
name
ELSE
ORS
Mark
re
export
not
found
Write
R
END
ELSE
Write
R
END
END
END
OutType
PROCEDURE
Export
VAR
modid
ORS
Ident
VAR
newSF
BOOLEAN
VAR
key
LONGINT
VAR
x
sum
oldkey
LONGINT
obj
obj0
Object
filename
ORS
Ident
F
F1
Files
File
R
R1
Files
Rider
BEGIN
Ref
Record
MakeFileName
filename
modid
smb
F
Files
New
filename
Files
Set
R
F
Files
WriteInt
R
placeholder
Files
WriteInt
R
placeholder
for
key
to
be
inserted
at
the
end
Files
WriteString
R
modid
Write
R
versionkey
obj
topScope
next
WHILE
obj
NIL
DO
IF
obj
expo
THEN
Write
R
obj
class
Files
WriteString
R
obj
name
OutType
R
obj
type
IF
obj
class
Typ
THEN
IF
obj
type
form
Record
THEN
obj0
topScope
next
check
whether
this
is
base
of
previously
declared
pointer
types
WHILE
obj0
obj
DO
IF
obj0
type
form
Pointer
obj0
type
base
obj
type
obj0
type
ref
THEN
Write
R
obj0
type
ref
END
obj0
obj0
next
END
END
Write
R
ELSIF
obj
class
Const
THEN
IF
obj
type
form
Proc
THEN
Files
WriteNum
R
obj
exno
ELSIF
obj
type
form
Real
THEN
Files
WriteInt
R
obj
val
ELSE
Files
WriteNum
R
obj
val
END
ELSIF
obj
class
Var
THEN
Files
WriteNum
R
obj
exno
END
END
obj
obj
next
END
REPEAT
Write
R
UNTIL
Files
Length
F
MOD
FOR
Ref
Record
TO
maxTypTab
DO
typtab
Ref
NIL
END
Files
Set
R
F
sum
Files
ReadInt
R
x
compute
key
checksum
WHILE
R
eof
DO
sum
sum
x
Files
ReadInt
R
x
END
F1
Files
Old
filename
sum
is
new
key
IF
F1
NIL
THEN
Files
Set
R1
F1
Files
ReadInt
R1
oldkey
ELSE
oldkey
sum
END
IF
sum
oldkey
THEN
IF
newSF
OR
F1
NIL
THEN
key
sum
newSF
TRUE
Files
Set
R
F
Files
WriteInt
R
sum
Files
Register
F
insert
checksum
ELSE
ORS
Mark
new
symbol
file
inhibited
END
ELSE
newSF
FALSE
key
sum
END
END
Export
PROCEDURE
Init
BEGIN
topScope
universe
nofmod
END
Init
PROCEDURE
type
ref
form
INTEGER
size
LONGINT
Type
VAR
tp
Type
BEGIN
NEW
tp
tp
form
form
tp
size
size
tp
ref
ref
tp
base
NIL
typtab
ref
tp
RETURN
tp
END
type
PROCEDURE
enter
name
ARRAY
OF
CHAR
cl
INTEGER
type
Type
n
LONGINT
VAR
obj
Object
BEGIN
NEW
obj
obj
name
name
obj
class
cl
obj
type
type
obj
val
n
obj
dsc
NIL
IF
cl
Typ
THEN
type
typobj
obj
END
obj
next
system
system
obj
END
enter
BEGIN
byteType
type
Byte
Int
boolType
type
Bool
Bool
charType
type
Char
Char
intType
type
Int
Int
realType
type
Real
Real
setType
type
Set
Set
nilType
type
NilTyp
NilTyp
noType
type
NoTyp
NoTyp
strType
type
String
String
initialize
universe
with
data
types
and
in
line
procedures
LONGINT
is
synonym
to
INTEGER
LONGREAL
to
REAL
LED
ADC
SBC
LDPSR
LDREG
REG
COND
are
not
in
language
definition
system
NIL
n
procno
nofpar
enter
UML
SFunc
intType
functions
enter
SBC
SFunc
intType
enter
ADC
SFunc
intType
enter
ROR
SFunc
intType
enter
ASR
SFunc
intType
enter
LSL
SFunc
intType
enter
LEN
SFunc
intType
enter
CHR
SFunc
charType
enter
ORD
SFunc
intType
enter
FLT
SFunc
realType
enter
FLOOR
SFunc
intType
enter
ODD
SFunc
boolType
enter
ABS
SFunc
intType
enter
LED
SProc
noType
procedures
enter
UNPK
SProc
noType
enter
PACK
SProc
noType
enter
NEW
SProc
noType
enter
ASSERT
SProc
noType
enter
EXCL
SProc
noType
enter
INCL
SProc
noType
enter
DEC
SProc
noType
enter
INC
SProc
noType
enter
SET
Typ
setType
types
enter
BOOLEAN
Typ
boolType
enter
BYTE
Typ
byteType
enter
CHAR
Typ
charType
enter
LONGREAL
Typ
realType
enter
REAL
Typ
realType
enter
LONGINT
Typ
intType
enter
INTEGER
Typ
intType
topScope
NIL
OpenScope
topScope
next
system
universe
topScope
system
NIL
initialize
unsafe
pseudo
module
SYSTEM
enter
H
SFunc
intType
functions
enter
COND
SFunc
boolType
enter
SIZE
SFunc
intType
enter
ADR
SFunc
intType
enter
VAL
SFunc
intType
enter
REG
SFunc
intType
enter
BIT
SFunc
boolType
enter
LDREG
SProc
noType
procedures
enter
LDPSR
SProc
noType
enter
COPY
SProc
noType
enter
PUT
SProc
noType
enter
GET
SProc
noType
END
ORB
MODULE
ORG
N
Wirth
Oberon
compiler
code
generator
for
RISC
IMPORT
SYSTEM
Files
ORS
ORB
Code
generator
for
Oberon
compiler
for
RISC
processor
Procedural
interface
to
Parser
OSAP
result
in
array
code
Procedure
Close
writes
code
files
CONST
WordSize
StkOrg0
VarOrg0
for
RISC
only
MT
SP
LNK
dedicated
registers
maxCode
maxStrx
maxTD
C24
1000000H
Reg
RegI
Cond
internal
item
modes
frequently
used
opcodes
U
2000H
V
1000H
Mov
Lsl
Asr
Ror
And
Ann
Ior
Xor
Add
Sub
Cmp
Mul
Div
Fad
Fsb
Fml
Fdv
Ldr
Str
BR
BLR
BC
BL
MI
PL
EQ
NE
LT
GE
LE
GT
TYPE
Item
RECORD
mode
INTEGER
type
ORB
Type
a
b
r
LONGINT
rdo
BOOLEAN
read
only
END
Item
forms
and
meaning
of
fields
mode
r
a
b
Const
value
proc
adr
immediate
value
Var
base
off
direct
adr
Par
off0
off1
indirect
adr
Reg
regno
RegI
regno
off
Cond
cond
Fchain
Tchain
VAR
pc
varsize
LONGINT
program
counter
data
index
tdx
strx
LONGINT
entry
LONGINT
main
entry
point
RH
LONGINT
available
registers
R
R
H
frame
LONGINT
frame
offset
changed
in
SaveRegs
and
RestoreRegs
fixorgP
fixorgD
fixorgT
LONGINT
origins
of
lists
of
locations
to
be
fixed
up
by
loader
check
BOOLEAN
emit
run
time
checks
version
INTEGER
RISC
RISC
relmap
ARRAY
OF
INTEGER
condition
codes
for
relations
code
ARRAY
maxCode
OF
LONGINT
data
ARRAY
maxTD
OF
LONGINT
type
descriptors
str
ARRAY
maxStrx
OF
CHAR
instruction
assemblers
according
to
formats
PROCEDURE
Put0
op
a
b
c
LONGINT
BEGIN
emit
format
instruction
code
pc
a
10H
b
10H
op
10000H
c
INC
pc
END
Put0
PROCEDURE
Put1
op
a
b
im
LONGINT
BEGIN
emit
format
instruction
10000H
im
10000H
IF
im
THEN
INC
op
V
END
code
pc
a
40H
10H
b
10H
op
10000H
im
MOD
10000H
INC
pc
END
Put1
PROCEDURE
Put1a
op
a
b
im
LONGINT
BEGIN
same
as
Put1
but
with
range
test
10000H
im
10000H
IF
im
10000H
im
0FFFFH
THEN
Put1
op
a
b
im
ELSE
Put1
Mov
U
RH
im
DIV
10000H
IF
im
MOD
10000H
THEN
Put1
Ior
RH
RH
im
MOD
10000H
END
Put0
op
a
b
RH
END
END
Put1a
PROCEDURE
Put2
op
a
b
off
LONGINT
BEGIN
emit
load
store
instruction
code
pc
op
10H
a
10H
b
100000H
off
MOD
100000H
INC
pc
END
Put2
PROCEDURE
Put3
op
cond
off
LONGINT
BEGIN
emit
branch
instruction
code
pc
op
10H
cond
1000000H
off
MOD
1000000H
INC
pc
END
Put3
PROCEDURE
incR
BEGIN
IF
RH
MT
THEN
INC
RH
ELSE
ORS
Mark
register
stack
overflow
END
END
incR
PROCEDURE
CheckRegs
BEGIN
IF
RH
THEN
ORS
Mark
Reg
Stack
RH
END
IF
pc
maxCode
THEN
ORS
Mark
program
too
long
END
IF
frame
THEN
ORS
Mark
frame
error
frame
END
END
CheckRegs
PROCEDURE
SetCC
VAR
x
Item
n
LONGINT
BEGIN
x
mode
Cond
x
a
x
b
x
r
n
END
SetCC
PROCEDURE
Trap
cond
num
LONGINT
BEGIN
Put3
BLR
cond
ORS
Pos
100H
num
10H
MT
END
Trap
handling
of
forward
reference
fixups
of
branch
addresses
and
constant
tables
PROCEDURE
negated
cond
LONGINT
LONGINT
BEGIN
IF
cond
THEN
cond
cond
ELSE
cond
cond
END
RETURN
cond
END
negated
PROCEDURE
fix
at
with
LONGINT
BEGIN
code
at
code
at
DIV
C24
C24
with
MOD
C24
END
fix
PROCEDURE
FixOne
at
LONGINT
BEGIN
fix
at
pc
at
END
FixOne
PROCEDURE
FixLink
L
LONGINT
VAR
L1
LONGINT
BEGIN
WHILE
L
DO
L1
code
L
MOD
40000H
fix
L
pc
L
L
L1
END
END
FixLink
PROCEDURE
FixLinkWith
L0
dst
LONGINT
VAR
L1
LONGINT
BEGIN
WHILE
L0
DO
L1
code
L0
MOD
C24
code
L0
code
L0
DIV
C24
C24
dst
L0
MOD
C24
L0
L1
END
END
FixLinkWith
PROCEDURE
merged
L0
L1
LONGINT
LONGINT
VAR
L2
L3
LONGINT
BEGIN
IF
L0
THEN
L3
L0
REPEAT
L2
L3
L3
code
L2
MOD
40000H
UNTIL
L3
code
L2
code
L2
L1
L1
L0
END
RETURN
L1
END
merged
loading
of
operands
and
addresses
into
registers
PROCEDURE
GetSB
base
LONGINT
BEGIN
IF
version
THEN
Put1
Mov
RH
VarOrg0
ELSE
Put2
Ldr
RH
base
pc
fixorgD
fixorgD
pc
END
END
GetSB
PROCEDURE
NilCheck
BEGIN
IF
check
THEN
Trap
EQ
END
END
NilCheck
PROCEDURE
load
VAR
x
Item
VAR
op
LONGINT
BEGIN
IF
x
type
size
THEN
op
Ldr
ELSE
op
Ldr
END
IF
x
mode
Reg
THEN
IF
x
mode
ORB
Const
THEN
IF
x
type
form
ORB
Proc
THEN
IF
x
r
THEN
ORS
Mark
not
allowed
ELSIF
x
r
THEN
Put3
BL
Put1a
Sub
RH
LNK
pc
x
a
ELSE
GetSB
x
r
Put1
Add
RH
RH
x
a
100H
mark
as
progbase
relative
END
ELSIF
x
a
0FFFFH
x
a
10000H
THEN
Put1
Mov
RH
x
a
ELSE
Put1
Mov
U
RH
x
a
DIV
10000H
MOD
10000H
IF
x
a
MOD
10000H
THEN
Put1
Ior
RH
RH
x
a
MOD
10000H
END
END
x
r
RH
incR
ELSIF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
op
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put2
op
RH
RH
x
a
END
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
op
RH
RH
x
b
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
Put2
op
x
r
x
r
x
a
ELSIF
x
mode
Cond
THEN
Put3
BC
negated
x
r
FixLink
x
b
Put1
Mov
RH
Put3
BC
FixLink
x
a
Put1
Mov
RH
x
r
RH
incR
END
x
mode
Reg
END
END
load
PROCEDURE
loadAdr
VAR
x
Item
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put1a
Add
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put1a
Add
RH
RH
x
a
END
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
IF
x
b
THEN
Put1a
Add
RH
RH
x
b
END
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
IF
x
a
THEN
Put1a
Add
x
r
x
r
x
a
END
ELSE
ORS
Mark
address
error
END
x
mode
Reg
END
loadAdr
PROCEDURE
loadCond
VAR
x
Item
BEGIN
IF
x
type
form
ORB
Bool
THEN
IF
x
mode
ORB
Const
THEN
x
r
x
a
ELSE
load
x
IF
code
pc
DIV
40000000H
THEN
Put1
Cmp
x
r
x
r
END
x
r
NE
DEC
RH
END
x
mode
Cond
x
a
x
b
ELSE
ORS
Mark
not
Boolean
END
END
loadCond
PROCEDURE
loadTypTagAdr
T
ORB
Type
VAR
x
Item
BEGIN
x
mode
ORB
Var
x
a
T
len
x
r
T
mno
loadAdr
x
END
loadTypTagAdr
PROCEDURE
loadStringAdr
VAR
x
Item
BEGIN
GetSB
Put1a
Add
RH
RH
varsize
x
a
x
mode
Reg
x
r
RH
incR
END
loadStringAdr
Items
Conversion
from
constants
or
from
Objects
on
the
Heap
to
Items
on
the
Stack
PROCEDURE
MakeConstItem
VAR
x
Item
typ
ORB
Type
val
LONGINT
BEGIN
x
mode
ORB
Const
x
type
typ
x
a
val
END
MakeConstItem
PROCEDURE
MakeRealItem
VAR
x
Item
val
REAL
BEGIN
x
mode
ORB
Const
x
type
ORB
realType
x
a
SYSTEM
VAL
LONGINT
val
END
MakeRealItem
PROCEDURE
MakeStringItem
VAR
x
Item
len
LONGINT
copies
string
from
ORS
buffer
to
ORG
string
array
VAR
i
LONGINT
BEGIN
x
mode
ORB
Const
x
type
ORB
strType
x
a
strx
x
b
len
i
IF
strx
len
maxStrx
THEN
WHILE
len
DO
str
strx
ORS
str
i
INC
strx
INC
i
DEC
len
END
WHILE
strx
MOD
DO
str
strx
0X
INC
strx
END
ELSE
ORS
Mark
too
many
strings
END
END
MakeStringItem
PROCEDURE
MakeItem
VAR
x
Item
y
ORB
Object
curlev
LONGINT
BEGIN
x
mode
y
class
x
type
y
type
x
a
y
val
x
rdo
y
rdo
IF
y
class
ORB
Par
THEN
x
b
ELSIF
y
class
ORB
Const
y
type
form
ORB
String
THEN
x
b
y
lev
len
ELSE
x
r
y
lev
END
IF
y
lev
y
lev
curlev
y
class
ORB
Const
THEN
ORS
Mark
not
accessible
END
END
MakeItem
Code
generation
for
Selectors
Variables
Constants
PROCEDURE
Field
VAR
x
Item
y
ORB
Object
x
x
y
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
x
a
x
a
y
val
ELSE
loadAdr
x
x
mode
RegI
x
a
y
val
END
ELSIF
x
mode
RegI
THEN
x
a
x
a
y
val
ELSIF
x
mode
ORB
Par
THEN
x
b
x
b
y
val
END
END
Field
PROCEDURE
Index
VAR
x
y
Item
x
x
y
VAR
s
lim
LONGINT
BEGIN
s
x
type
base
size
lim
x
type
len
IF
y
mode
ORB
Const
lim
THEN
IF
y
a
OR
y
a
lim
THEN
ORS
Mark
bad
index
END
IF
x
mode
IN
ORB
Var
RegI
THEN
x
a
y
a
s
x
a
ELSIF
x
mode
ORB
Par
THEN
x
b
y
a
s
x
b
END
ELSE
load
y
IF
check
THEN
check
array
bounds
IF
lim
THEN
Put1a
Cmp
RH
y
r
lim
ELSE
open
array
IF
x
mode
IN
ORB
Var
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put0
Cmp
RH
y
r
RH
ELSE
ORS
Mark
error
in
Index
END
END
Trap
BCC
END
IF
s
THEN
Put1
Lsl
y
r
y
r
ELSIF
s
THEN
Put1a
Mul
y
r
y
r
s
END
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
Put0
Add
y
r
SP
y
r
INC
x
a
frame
ELSE
GetSB
x
r
IF
x
r
THEN
Put0
Add
y
r
RH
y
r
ELSE
Put1a
Add
RH
RH
x
a
Put0
Add
y
r
RH
y
r
x
a
END
END
x
r
y
r
x
mode
RegI
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put0
Add
y
r
RH
y
r
x
mode
RegI
x
r
y
r
x
a
x
b
ELSIF
x
mode
RegI
THEN
Put0
Add
x
r
x
r
y
r
DEC
RH
END
END
END
Index
PROCEDURE
DeRef
VAR
x
Item
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
Ldr
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put2
Ldr
RH
RH
x
a
END
NilCheck
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
Ldr
RH
RH
x
b
NilCheck
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
Put2
Ldr
x
r
x
r
x
a
NilCheck
ELSIF
x
mode
Reg
THEN
ORS
Mark
bad
mode
in
DeRef
END
x
mode
RegI
x
a
x
b
END
DeRef
PROCEDURE
Q
T
ORB
Type
VAR
dcw
LONGINT
BEGIN
one
entry
of
type
descriptor
extension
table
IF
T
base
NIL
THEN
Q
T
base
dcw
data
dcw
T
mno
1000H
T
len
1000H
dcw
fixorgT
fixorgT
dcw
INC
dcw
END
END
Q
PROCEDURE
FindPtrFlds
typ
ORB
Type
off
LONGINT
VAR
dcw
LONGINT
VAR
fld
ORB
Object
i
s
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
data
dcw
off
INC
dcw
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindPtrFlds
fld
type
fld
val
off
dcw
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
s
typ
base
size
FOR
i
TO
typ
len
DO
FindPtrFlds
typ
base
i
s
off
dcw
END
END
END
FindPtrFlds
PROCEDURE
BuildTD
T
ORB
Type
VAR
dc
LONGINT
VAR
dcw
k
s
LONGINT
dcw
word
address
BEGIN
dcw
dc
DIV
s
T
size
convert
size
for
heap
allocation
IF
s
THEN
s
ELSIF
s
THEN
s
ELSIF
s
THEN
s
ELSE
s
s
DIV
END
T
len
dc
data
dcw
s
INC
dcw
len
used
as
address
k
T
nofpar
extension
level
IF
k
THEN
ORS
Mark
ext
level
too
large
ELSE
Q
T
dcw
WHILE
k
DO
data
dcw
INC
dcw
INC
k
END
END
FindPtrFlds
T
dcw
data
dcw
INC
dcw
tdx
dcw
dc
dcw
IF
tdx
maxTD
THEN
ORS
Mark
too
many
record
types
tdx
END
END
BuildTD
PROCEDURE
TypeTest
VAR
x
Item
T
ORB
Type
varpar
isguard
BOOLEAN
VAR
pc0
LONGINT
BEGIN
fetch
tag
into
RH
IF
varpar
THEN
Put2
Ldr
RH
SP
x
a
frame
ELSE
load
x
pc0
pc
Put3
BC
EQ
NIL
belongs
to
every
pointer
type
Put2
Ldr
RH
x
r
END
Put2
Ldr
RH
RH
T
nofpar
incR
loadTypTagAdr
T
tag
of
T
Put0
Cmp
RH
RH
RH
DEC
RH
IF
varpar
THEN
fix
pc0
pc
pc0
END
IF
isguard
THEN
IF
check
THEN
Trap
NE
END
ELSE
SetCC
x
EQ
IF
varpar
THEN
DEC
RH
END
END
END
TypeTest
Code
generation
for
Boolean
operators
PROCEDURE
Not
VAR
x
Item
x
x
VAR
t
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
x
r
negated
x
r
t
x
a
x
a
x
b
x
b
t
END
Not
PROCEDURE
And1
VAR
x
Item
x
x
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
x
a
x
a
pc
FixLink
x
b
x
b
END
And1
PROCEDURE
And2
VAR
x
y
Item
BEGIN
IF
y
mode
Cond
THEN
loadCond
y
END
x
a
merged
y
a
x
a
x
b
y
b
x
r
y
r
END
And2
PROCEDURE
Or1
VAR
x
Item
x
x
OR
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
x
r
x
b
x
b
pc
FixLink
x
a
x
a
END
Or1
PROCEDURE
Or2
VAR
x
y
Item
BEGIN
IF
y
mode
Cond
THEN
loadCond
y
END
x
a
y
a
x
b
merged
y
b
x
b
x
r
y
r
END
Or2
Code
generation
for
arithmetic
operators
PROCEDURE
Neg
VAR
x
Item
x
x
BEGIN
IF
x
type
form
ORB
Int
THEN
IF
x
mode
ORB
Const
THEN
x
a
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Sub
x
r
RH
x
r
END
ELSIF
x
type
form
ORB
Real
THEN
IF
x
mode
ORB
Const
THEN
x
a
x
a
7FFFFFFFH
ELSE
load
x
Put1
Mov
RH
Put0
Fsb
x
r
RH
x
r
END
ELSE
form
Set
IF
x
mode
ORB
Const
THEN
x
a
x
a
ELSE
load
x
Put1
Xor
x
r
x
r
END
END
END
Neg
PROCEDURE
AddOp
op
LONGINT
VAR
x
y
Item
x
x
y
BEGIN
IF
op
ORS
plus
THEN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
y
a
THEN
Put1a
Add
x
r
x
r
y
a
END
ELSE
load
x
load
y
Put0
Add
RH
x
r
y
r
DEC
RH
x
r
RH
END
ELSE
op
ORS
minus
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
y
a
THEN
Put1a
Sub
x
r
x
r
y
a
END
ELSE
load
x
load
y
Put0
Sub
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
END
AddOp
PROCEDURE
log2
m
LONGINT
VAR
e
LONGINT
LONGINT
BEGIN
e
WHILE
ODD
m
DO
m
m
DIV
INC
e
END
RETURN
m
END
log2
PROCEDURE
MulOp
VAR
x
y
Item
x
x
y
VAR
e
LONGINT
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
Put1
Lsl
x
r
x
r
e
ELSIF
y
mode
ORB
Const
THEN
load
x
Put1a
Mul
x
r
x
r
y
a
ELSIF
x
mode
ORB
Const
x
a
log2
x
a
e
THEN
load
y
Put1
Lsl
y
r
y
r
e
x
mode
Reg
x
r
y
r
ELSIF
x
mode
ORB
Const
THEN
load
y
Put1a
Mul
y
r
y
r
x
a
x
mode
Reg
x
r
y
r
ELSE
load
x
load
y
Put0
Mul
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
MulOp
PROCEDURE
DivOp
op
LONGINT
VAR
x
y
Item
x
x
op
y
VAR
e
LONGINT
BEGIN
IF
op
ORS
div
THEN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
y
a
THEN
x
a
x
a
DIV
y
a
ELSE
ORS
Mark
bad
divisor
END
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
Put1
Asr
x
r
x
r
e
ELSIF
y
mode
ORB
Const
THEN
IF
y
a
THEN
load
x
Put1a
Div
x
r
x
r
y
a
ELSE
ORS
Mark
bad
divisor
END
ELSE
load
y
IF
check
THEN
Trap
LE
END
load
x
Put0
Div
RH
x
r
y
r
DEC
RH
x
r
RH
END
ELSE
op
ORS
mod
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
y
a
THEN
x
a
x
a
MOD
y
a
ELSE
ORS
Mark
bad
modulus
END
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
IF
e
THEN
Put1
And
x
r
x
r
y
a
ELSE
Put1
Lsl
x
r
x
r
e
Put1
Ror
x
r
x
r
e
END
ELSIF
y
mode
ORB
Const
THEN
IF
y
a
THEN
load
x
Put1a
Div
x
r
x
r
y
a
Put0
Mov
U
x
r
ELSE
ORS
Mark
bad
modulus
END
ELSE
load
y
IF
check
THEN
Trap
LE
END
load
x
Put0
Div
RH
x
r
y
r
Put0
Mov
U
RH
DEC
RH
x
r
RH
END
END
END
DivOp
Code
generation
for
REAL
operators
PROCEDURE
RealOp
op
INTEGER
VAR
x
y
Item
x
x
op
y
BEGIN
load
x
load
y
IF
op
ORS
plus
THEN
Put0
Fad
RH
x
r
y
r
ELSIF
op
ORS
minus
THEN
Put0
Fsb
RH
x
r
y
r
ELSIF
op
ORS
times
THEN
Put0
Fml
RH
x
r
y
r
ELSIF
op
ORS
rdiv
THEN
Put0
Fdv
RH
x
r
y
r
END
DEC
RH
x
r
RH
END
RealOp
Code
generation
for
set
operators
PROCEDURE
Singleton
VAR
x
Item
x
x
BEGIN
IF
x
mode
ORB
Const
THEN
x
a
LSL
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Lsl
x
r
RH
x
r
END
END
Singleton
PROCEDURE
Set
VAR
x
y
Item
x
x
y
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
x
a
y
a
THEN
x
a
LSL
y
a
LSL
x
a
ELSE
x
a
END
ELSE
IF
x
mode
ORB
Const
x
a
THEN
x
a
LSL
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Lsl
x
r
RH
x
r
END
IF
y
mode
ORB
Const
y
a
THEN
Put1
Mov
RH
LSL
y
a
y
mode
Reg
y
r
RH
incR
ELSE
load
y
Put1
Mov
RH
Put0
Lsl
y
r
RH
y
r
END
IF
x
mode
ORB
Const
THEN
IF
x
a
THEN
Put1
Xor
y
r
y
r
Put1a
And
RH
y
r
x
a
END
x
mode
Reg
x
r
RH
ELSE
DEC
RH
Put0
Ann
RH
x
r
y
r
END
END
END
Set
PROCEDURE
In
VAR
x
y
Item
x
x
IN
y
BEGIN
load
y
IF
x
mode
ORB
Const
THEN
Put1
Ror
y
r
y
r
x
a
MOD
20H
DEC
RH
ELSE
load
x
Put1
Add
x
r
x
r
Put0
Ror
y
r
y
r
x
r
DEC
RH
END
SetCC
x
MI
END
In
PROCEDURE
SetOp
op
LONGINT
VAR
x
y
Item
x
x
op
y
VAR
xset
yset
SET
x
type
form
Set
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
xset
SYSTEM
VAL
SET
x
a
yset
SYSTEM
VAL
SET
y
a
IF
op
ORS
plus
THEN
xset
xset
yset
ELSIF
op
ORS
minus
THEN
xset
xset
yset
ELSIF
op
ORS
times
THEN
xset
xset
yset
ELSIF
op
ORS
rdiv
THEN
xset
xset
yset
END
x
a
SYSTEM
VAL
LONGINT
xset
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
op
ORS
plus
THEN
Put1a
Ior
x
r
x
r
y
a
ELSIF
op
ORS
minus
THEN
Put1a
Ann
x
r
x
r
y
a
ELSIF
op
ORS
times
THEN
Put1a
And
x
r
x
r
y
a
ELSIF
op
ORS
rdiv
THEN
Put1a
Xor
x
r
x
r
y
a
END
ELSE
load
x
load
y
IF
op
ORS
plus
THEN
Put0
Ior
RH
x
r
y
r
ELSIF
op
ORS
minus
THEN
Put0
Ann
RH
x
r
y
r
ELSIF
op
ORS
times
THEN
Put0
And
RH
x
r
y
r
ELSIF
op
ORS
rdiv
THEN
Put0
Xor
RH
x
r
y
r
END
DEC
RH
x
r
RH
END
END
SetOp
Code
generation
for
relations
PROCEDURE
IntRelation
op
INTEGER
VAR
x
y
Item
x
x
y
BEGIN
IF
y
mode
ORB
Const
y
type
form
ORB
Proc
THEN
load
x
IF
y
a
OR
op
IN
ORS
eql
ORS
neq
OR
code
pc
DIV
40000000H
THEN
Put1a
Cmp
x
r
x
r
y
a
END
DEC
RH
ELSE
IF
x
mode
Cond
OR
y
mode
Cond
THEN
ORS
Mark
not
implemented
END
load
x
load
y
Put0
Cmp
x
r
x
r
y
r
DEC
RH
END
SetCC
x
relmap
op
ORS
eql
END
IntRelation
PROCEDURE
RealRelation
op
INTEGER
VAR
x
y
Item
x
x
y
BEGIN
load
x
IF
y
mode
ORB
Const
y
a
THEN
DEC
RH
ELSE
load
y
Put0
Fsb
x
r
x
r
y
r
DEC
RH
END
SetCC
x
relmap
op
ORS
eql
END
RealRelation
PROCEDURE
StringRelation
op
INTEGER
VAR
x
y
Item
x
x
y
x
y
are
char
arrays
or
strings
BEGIN
IF
x
type
form
ORB
String
THEN
loadStringAdr
x
ELSE
loadAdr
x
END
IF
y
type
form
ORB
String
THEN
loadStringAdr
y
ELSE
loadAdr
y
END
Put2
Ldr
RH
x
r
Put1
Add
x
r
x
r
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put0
Cmp
RH
RH
RH
Put3
BC
NE
Put1
Cmp
RH
RH
Put3
BC
NE
DEC
RH
SetCC
x
relmap
op
ORS
eql
END
StringRelation
Code
generation
of
Assignments
PROCEDURE
StrToChar
VAR
x
Item
BEGIN
x
type
ORB
charType
DEC
strx
x
a
ORD
str
x
a
END
StrToChar
PROCEDURE
Store
VAR
x
y
Item
x
y
VAR
op
LONGINT
BEGIN
load
y
IF
x
type
size
THEN
op
Str
ELSE
op
Str
END
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
op
y
r
SP
x
a
frame
ELSE
GetSB
x
r
Put2
op
y
r
RH
x
a
END
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
op
y
r
RH
x
b
ELSIF
x
mode
RegI
THEN
Put2
op
y
r
x
r
x
a
DEC
RH
ELSE
ORS
Mark
bad
mode
in
Store
END
DEC
RH
END
Store
PROCEDURE
StoreStruct
VAR
x
y
Item
x
y
frame
VAR
s
pc0
LONGINT
BEGIN
IF
y
type
size
THEN
loadAdr
x
loadAdr
y
IF
x
type
form
ORB
Array
x
type
len
THEN
IF
y
type
len
THEN
IF
x
type
size
y
type
size
THEN
Put1a
Mov
RH
y
type
size
DIV
ELSE
ORS
Mark
different
length
size
not
implemented
END
ELSE
y
open
array
Put2
Ldr
RH
SP
y
a
s
y
type
base
size
element
size
pc0
pc
Put3
BC
EQ
IF
s
THEN
Put1
Add
RH
RH
Put1
Asr
RH
RH
ELSIF
s
THEN
Put1a
Mul
RH
RH
s
DIV
END
IF
check
THEN
Put1a
Mov
RH
x
type
size
DIV
Put0
Cmp
RH
RH
RH
Trap
GT
END
fix
pc0
pc
pc0
END
ELSIF
x
type
form
ORB
Record
THEN
Put1a
Mov
RH
x
type
size
DIV
ELSE
ORS
Mark
inadmissible
assignment
END
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put2
Str
RH
x
r
Put1
Add
x
r
x
r
Put1
Sub
RH
RH
Put3
BC
NE
END
RH
END
StoreStruct
PROCEDURE
CopyString
VAR
x
y
Item
x
y
VAR
len
LONGINT
BEGIN
loadAdr
x
len
x
type
len
IF
len
THEN
IF
len
y
b
THEN
ORS
Mark
string
too
long
END
ELSIF
check
THEN
Put2
Ldr
RH
SP
x
a
open
array
len
frame
Put1
Cmp
RH
RH
y
b
Trap
LT
END
loadStringAdr
y
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put2
Str
RH
x
r
Put1
Add
x
r
x
r
Put1
Asr
RH
RH
Put3
BC
NE
RH
END
CopyString
Code
generation
for
parameters
PROCEDURE
OpenArrayParam
VAR
x
Item
BEGIN
loadAdr
x
IF
x
type
len
THEN
Put1a
Mov
RH
x
type
len
ELSE
Put2
Ldr
RH
SP
x
a
frame
END
incR
END
OpenArrayParam
PROCEDURE
VarParam
VAR
x
Item
ftype
ORB
Type
VAR
xmd
INTEGER
BEGIN
xmd
x
mode
loadAdr
x
IF
ftype
form
ORB
Array
ftype
len
THEN
open
array
IF
x
type
len
THEN
Put1a
Mov
RH
x
type
len
ELSE
Put2
Ldr
RH
SP
x
a
frame
END
incR
ELSIF
ftype
form
ORB
Record
THEN
IF
xmd
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
incR
ELSE
loadTypTagAdr
x
type
END
END
END
VarParam
PROCEDURE
ValueParam
VAR
x
Item
BEGIN
load
x
END
ValueParam
PROCEDURE
StringParam
VAR
x
Item
BEGIN
loadStringAdr
x
Put1
Mov
RH
x
b
incR
len
END
StringParam
For
Statements
PROCEDURE
For0
VAR
x
y
Item
BEGIN
load
y
END
For0
PROCEDURE
For1
VAR
x
y
z
w
Item
VAR
L
LONGINT
BEGIN
IF
z
mode
ORB
Const
THEN
Put1a
Cmp
RH
y
r
z
a
ELSE
load
z
Put0
Cmp
RH
y
r
z
r
DEC
RH
END
L
pc
IF
w
a
THEN
Put3
BC
GT
ELSIF
w
a
THEN
Put3
BC
LT
ELSE
ORS
Mark
zero
increment
Put3
BC
MI
END
Store
x
y
END
For1
PROCEDURE
For2
VAR
x
y
w
Item
BEGIN
load
x
DEC
RH
Put1a
Add
x
r
x
r
w
a
END
For2
Branches
procedure
calls
procedure
prolog
and
epilog
PROCEDURE
Here
LONGINT
BEGIN
RETURN
pc
END
Here
PROCEDURE
FJump
VAR
L
LONGINT
BEGIN
Put3
BC
L
L
pc
END
FJump
PROCEDURE
CFJump
VAR
x
Item
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
x
a
FixLink
x
b
x
a
pc
END
CFJump
PROCEDURE
BJump
L
LONGINT
BEGIN
Put3
BC
L
pc
END
BJump
PROCEDURE
CBJump
VAR
x
Item
L
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
L
pc
FixLink
x
b
FixLinkWith
x
a
L
END
CBJump
PROCEDURE
Fixup
VAR
x
Item
BEGIN
FixLink
x
a
END
Fixup
PROCEDURE
SaveRegs
r
LONGINT
R
r
VAR
r0
LONGINT
BEGIN
r
r0
Put1
Sub
SP
SP
r
INC
frame
r
REPEAT
Put2
Str
r0
SP
r
r0
INC
r0
UNTIL
r0
r
END
SaveRegs
PROCEDURE
RestoreRegs
r
LONGINT
R
r
VAR
r0
LONGINT
BEGIN
r
r0
r
REPEAT
DEC
r0
Put2
Ldr
r0
SP
r
r0
UNTIL
r0
Put1
Add
SP
SP
r
DEC
frame
r
END
RestoreRegs
PROCEDURE
PrepCall
VAR
x
Item
VAR
r
LONGINT
BEGIN
x
type
form
ORB
Proc
IF
x
mode
ORB
Par
THEN
load
x
END
r
RH
IF
RH
THEN
SaveRegs
RH
RH
END
END
PrepCall
PROCEDURE
Call
VAR
x
Item
r
LONGINT
BEGIN
x
type
form
ORB
Proc
IF
x
mode
ORB
Const
THEN
IF
x
r
THEN
Put3
BL
x
a
DIV
pc
ELSE
imported
IF
pc
fixorgP
1000H
THEN
Put3
BL
x
r
100H
x
a
1000H
pc
fixorgP
fixorgP
pc
ELSE
ORS
Mark
fixup
impossible
END
END
ELSE
IF
x
mode
ORB
Par
THEN
load
x
DEC
RH
ELSE
Put2
Ldr
RH
SP
Put1
Add
SP
SP
DEC
r
DEC
frame
END
IF
check
THEN
Trap
EQ
END
Put3
BLR
RH
END
IF
x
type
base
form
ORB
NoTyp
THEN
procedure
RH
ELSE
function
IF
r
THEN
Put0
Mov
r
RestoreRegs
r
END
x
mode
Reg
x
r
r
RH
r
END
END
Call
PROCEDURE
Enter
parblksize
locblksize
LONGINT
int
BOOLEAN
VAR
a
r
LONGINT
BEGIN
frame
IF
int
THEN
procedure
prolog
IF
locblksize
10000H
THEN
ORS
Mark
too
many
locals
END
a
r
Put1
Sub
SP
SP
locblksize
Put2
Str
LNK
SP
WHILE
a
parblksize
DO
Put2
Str
r
SP
a
INC
r
INC
a
END
ELSE
interrupt
procedure
Put1
Sub
SP
SP
locblksize
Put2
Str
SP
Put2
Str
SP
Put2
Str
SP
R0
R1
R2
saved
on
stack
END
END
Enter
PROCEDURE
Return
form
INTEGER
VAR
x
Item
size
LONGINT
int
BOOLEAN
BEGIN
IF
form
ORB
NoTyp
THEN
load
x
END
IF
int
THEN
procedure
epilog
Put2
Ldr
LNK
SP
Put1
Add
SP
SP
size
Put3
BR
LNK
ELSE
interrupt
return
restore
R2
R1
R0
Put2
Ldr
SP
Put2
Ldr
SP
Put2
Ldr
SP
Put1
Add
SP
SP
size
Put3
BR
10H
RTI
END
RH
END
Return
In
line
code
procedures
PROCEDURE
Increment
upordown
LONGINT
VAR
x
y
Item
VAR
op
zr
v
LONGINT
BEGIN
frame
IF
upordown
THEN
op
Add
ELSE
op
Sub
END
IF
x
type
ORB
byteType
THEN
v
ELSE
v
END
IF
y
type
form
ORB
NoTyp
THEN
y
mode
ORB
Const
y
a
END
IF
x
mode
ORB
Var
x
r
THEN
zr
RH
Put2
Ldr
v
zr
SP
x
a
incR
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
y
a
ELSE
load
y
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
v
zr
SP
x
a
DEC
RH
ELSE
loadAdr
x
zr
RH
Put2
Ldr
v
RH
x
r
incR
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
y
a
ELSE
load
y
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
v
zr
x
r
DEC
RH
END
END
Increment
PROCEDURE
Include
inorex
LONGINT
VAR
x
y
Item
VAR
op
zr
LONGINT
BEGIN
loadAdr
x
zr
RH
Put2
Ldr
RH
x
r
incR
IF
inorex
THEN
op
Ior
ELSE
op
Ann
END
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
LSL
y
a
ELSE
load
y
Put1
Mov
RH
Put0
Lsl
y
r
RH
y
r
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
zr
x
r
DEC
RH
END
Include
PROCEDURE
Assert
VAR
x
Item
VAR
cond
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
IF
x
a
THEN
cond
negated
x
r
ELSE
Put3
BC
x
r
x
b
FixLink
x
a
x
b
pc
cond
END
Trap
cond
FixLink
x
b
END
Assert
PROCEDURE
New
VAR
x
Item
BEGIN
loadAdr
x
loadTypTagAdr
x
type
base
Trap
RH
END
New
PROCEDURE
Pack
VAR
x
y
Item
VAR
z
Item
BEGIN
z
x
load
x
load
y
Put1
Lsl
y
r
y
r
Put0
Add
x
r
x
r
y
r
DEC
RH
Store
z
x
END
Pack
PROCEDURE
Unpk
VAR
x
y
Item
VAR
z
e0
Item
BEGIN
z
x
load
x
e0
mode
Reg
e0
r
RH
e0
type
ORB
intType
Put1
Asr
RH
x
r
Put1
Sub
RH
RH
Store
y
e0
incR
Put1
Lsl
RH
RH
Put0
Sub
x
r
x
r
RH
Store
z
x
END
Unpk
PROCEDURE
Led
VAR
x
Item
BEGIN
load
x
Put1
Mov
RH
Put2
Str
x
r
RH
DEC
RH
END
Led
PROCEDURE
Get
VAR
x
y
Item
BEGIN
load
x
x
type
y
type
x
mode
RegI
x
a
Store
y
x
END
Get
PROCEDURE
Put
VAR
x
y
Item
BEGIN
load
x
x
type
y
type
x
mode
RegI
x
a
Store
x
y
END
Put
PROCEDURE
Copy
VAR
x
y
z
Item
BEGIN
load
x
load
y
IF
z
mode
ORB
Const
THEN
IF
z
a
THEN
load
z
ELSE
ORS
Mark
bad
count
END
ELSE
load
z
IF
check
THEN
Trap
LT
END
Put3
BC
EQ
END
Put2
Ldr
RH
x
r
Put1
Add
x
r
x
r
Put2
Str
RH
y
r
Put1
Add
y
r
y
r
Put1
Sub
z
r
z
r
Put3
BC
NE
DEC
RH
END
Copy
PROCEDURE
LDPSR
VAR
x
Item
BEGIN
x
mode
Const
Put3
x
a
20H
END
LDPSR
PROCEDURE
LDREG
VAR
x
y
Item
BEGIN
IF
y
mode
ORB
Const
THEN
Put1a
Mov
x
a
y
a
ELSE
load
y
Put0
Mov
x
a
y
r
DEC
RH
END
END
LDREG
In
line
code
functions
PROCEDURE
Abs
VAR
x
Item
BEGIN
IF
x
mode
ORB
Const
THEN
x
a
ABS
x
a
ELSE
load
x
IF
x
type
form
ORB
Real
THEN
Put1
Lsl
x
r
x
r
Put1
Ror
x
r
x
r
ELSE
Put1
Cmp
x
r
x
r
Put3
BC
GE
Put1
Mov
RH
Put0
Sub
x
r
RH
x
r
END
END
END
Abs
PROCEDURE
Odd
VAR
x
Item
BEGIN
load
x
Put1
And
x
r
x
r
SetCC
x
NE
DEC
RH
END
Odd
PROCEDURE
Floor
VAR
x
Item
BEGIN
load
x
Put1
Mov
U
RH
4B00H
Put0
Fad
V
x
r
x
r
RH
END
Floor
PROCEDURE
Float
VAR
x
Item
BEGIN
load
x
Put1
Mov
U
RH
4B00H
Put0
Fad
U
x
r
x
r
RH
END
Float
PROCEDURE
Ord
VAR
x
Item
BEGIN
IF
x
mode
IN
ORB
Var
ORB
Par
RegI
Cond
THEN
load
x
END
END
Ord
PROCEDURE
Len
VAR
x
Item
BEGIN
IF
x
type
len
THEN
IF
x
mode
RegI
THEN
DEC
RH
END
x
mode
ORB
Const
x
a
x
type
len
ELSE
open
array
Put2
Ldr
RH
SP
x
a
frame
x
mode
Reg
x
r
RH
incR
END
END
Len
PROCEDURE
Shift
fct
LONGINT
VAR
x
y
Item
VAR
op
LONGINT
BEGIN
load
x
IF
fct
THEN
op
Lsl
ELSIF
fct
THEN
op
Asr
ELSE
op
Ror
END
IF
y
mode
ORB
Const
THEN
Put1
op
x
r
x
r
y
a
MOD
20H
ELSE
load
y
Put0
op
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
Shift
PROCEDURE
ADC
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Add
2000H
x
r
x
r
y
r
DEC
RH
END
ADC
PROCEDURE
SBC
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Sub
2000H
x
r
x
r
y
r
DEC
RH
END
SBC
PROCEDURE
UML
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Mul
2000H
x
r
x
r
y
r
DEC
RH
END
UML
PROCEDURE
Bit
VAR
x
y
Item
BEGIN
load
x
Put2
Ldr
x
r
x
r
IF
y
mode
ORB
Const
THEN
Put1
Ror
x
r
x
r
y
a
DEC
RH
ELSE
load
y
Put1
Add
y
r
y
r
Put0
Ror
x
r
x
r
y
r
DEC
RH
END
SetCC
x
MI
END
Bit
PROCEDURE
Register
VAR
x
Item
BEGIN
x
mode
Const
Put0
Mov
RH
x
a
MOD
10H
x
mode
Reg
x
r
RH
incR
END
Register
PROCEDURE
H
VAR
x
Item
BEGIN
x
mode
Const
Put0
Mov
U
x
a
MOD
V
RH
x
mode
Reg
x
r
RH
incR
END
H
PROCEDURE
Adr
VAR
x
Item
BEGIN
IF
x
mode
IN
ORB
Var
ORB
Par
RegI
THEN
loadAdr
x
ELSIF
x
mode
ORB
Const
x
type
form
ORB
Proc
THEN
load
x
ELSIF
x
mode
ORB
Const
x
type
form
ORB
String
THEN
loadStringAdr
x
ELSE
ORS
Mark
not
addressable
END
END
Adr
PROCEDURE
Condition
VAR
x
Item
BEGIN
x
mode
Const
SetCC
x
x
a
END
Condition
PROCEDURE
Open
v
INTEGER
BEGIN
pc
tdx
strx
RH
fixorgP
fixorgD
fixorgT
check
v
version
v
IF
v
THEN
pc
REPEAT
code
pc
INC
pc
UNTIL
pc
END
END
Open
PROCEDURE
SetDataSize
dc
LONGINT
BEGIN
varsize
dc
END
SetDataSize
PROCEDURE
Header
BEGIN
entry
pc
IF
version
THEN
code
0E7000000H
pc
Put1a
Mov
SP
StkOrg0
RISC
ELSE
Put1
Sub
SP
SP
Put2
Str
LNK
SP
END
END
Header
PROCEDURE
NofPtrs
typ
ORB
Type
LONGINT
VAR
fld
ORB
Object
n
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
n
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
n
WHILE
fld
NIL
DO
n
NofPtrs
fld
type
n
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
n
NofPtrs
typ
base
typ
len
ELSE
n
END
RETURN
n
END
NofPtrs
PROCEDURE
FindPtrs
VAR
R
Files
Rider
typ
ORB
Type
adr
LONGINT
VAR
fld
ORB
Object
i
s
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
Files
WriteInt
R
adr
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindPtrs
R
fld
type
fld
val
adr
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
s
typ
base
size
FOR
i
TO
typ
len
DO
FindPtrs
R
typ
base
i
s
adr
END
END
END
FindPtrs
PROCEDURE
Close
VAR
modid
ORS
Ident
key
nofent
LONGINT
VAR
obj
ORB
Object
i
comsize
nofimps
nofptrs
size
LONGINT
name
ORS
Ident
F
Files
File
R
Files
Rider
BEGIN
exit
code
IF
version
THEN
Put1
Mov
Put3
BR
RISC
ELSE
Put2
Ldr
LNK
SP
Put1
Add
SP
SP
Put3
BR
LNK
END
obj
ORB
topScope
next
nofimps
comsize
nofptrs
WHILE
obj
NIL
DO
IF
obj
class
ORB
Mod
obj
dsc
ORB
system
THEN
INC
nofimps
count
imports
ELSIF
obj
exno
obj
class
ORB
Const
obj
type
form
ORB
Proc
obj
type
nofpar
obj
type
base
ORB
noType
THEN
i
count
commands
WHILE
obj
name
i
0X
DO
INC
i
END
i
i
DIV
INC
comsize
i
ELSIF
obj
class
ORB
Var
THEN
INC
nofptrs
NofPtrs
obj
type
count
pointers
END
obj
obj
next
END
size
varsize
strx
comsize
pc
nofimps
nofent
nofptrs
varsize
includes
type
descriptors
ORB
MakeFileName
name
modid
rsc
write
code
file
F
Files
New
name
Files
Set
R
F
Files
WriteString
R
modid
Files
WriteInt
R
key
Files
Write
R
CHR
version
Files
WriteInt
R
size
obj
ORB
topScope
next
WHILE
obj
NIL
obj
class
ORB
Mod
DO
imports
IF
obj
dsc
ORB
system
THEN
Files
WriteString
R
obj
ORB
Module
orgname
Files
WriteInt
R
obj
val
END
obj
obj
next
END
Files
Write
R
0X
Files
WriteInt
R
tdx
i
WHILE
i
tdx
DO
Files
WriteInt
R
data
i
INC
i
END
type
descriptors
Files
WriteInt
R
varsize
tdx
data
Files
WriteInt
R
strx
FOR
i
TO
strx
DO
Files
Write
R
str
i
END
strings
Files
WriteInt
R
pc
code
len
FOR
i
TO
pc
DO
Files
WriteInt
R
code
i
END
program
obj
ORB
topScope
next
WHILE
obj
NIL
DO
commands
IF
obj
exno
obj
class
ORB
Const
obj
type
form
ORB
Proc
obj
type
nofpar
obj
type
base
ORB
noType
THEN
Files
WriteString
R
obj
name
Files
WriteInt
R
obj
val
END
obj
obj
next
END
Files
Write
R
0X
Files
WriteInt
R
nofent
Files
WriteInt
R
entry
obj
ORB
topScope
next
WHILE
obj
NIL
DO
entries
IF
obj
exno
THEN
IF
obj
class
ORB
Const
obj
type
form
ORB
Proc
OR
obj
class
ORB
Var
THEN
Files
WriteInt
R
obj
val
ELSIF
obj
class
ORB
Typ
THEN
IF
obj
type
form
ORB
Record
THEN
Files
WriteInt
R
obj
type
len
MOD
10000H
ELSIF
obj
type
form
ORB
Pointer
obj
type
base
typobj
NIL
OR
obj
type
base
typobj
exno
THEN
Files
WriteInt
R
obj
type
base
len
MOD
10000H
END
END
END
obj
obj
next
END
obj
ORB
topScope
next
WHILE
obj
NIL
DO
pointer
variables
IF
obj
class
ORB
Var
THEN
FindPtrs
R
obj
type
obj
val
END
obj
obj
next
END
Files
WriteInt
R
Files
WriteInt
R
fixorgP
Files
WriteInt
R
fixorgD
Files
WriteInt
R
fixorgT
Files
WriteInt
R
entry
Files
Write
R
O
Files
Register
F
END
Close
BEGIN
relmap
relmap
relmap
relmap
relmap
relmap
END
ORG
MODULE
ORP
N
Wirth
Oberon
compiler
for
RISC
in
Oberon
IMPORT
Texts
Oberon
ORS
ORB
ORG
Author
Niklaus
Wirth
Parser
of
Oberon
RISC
compiler
Uses
Scanner
ORS
to
obtain
symbols
tokens
ORB
for
definition
of
data
structures
and
for
handling
import
and
export
and
ORG
to
produce
binary
code
ORP
performs
type
checking
and
data
allocation
Parser
is
target
independent
except
for
part
of
the
handling
of
allocations
TYPE
PtrBase
POINTER
TO
PtrBaseDesc
PtrBaseDesc
RECORD
list
of
names
of
pointer
base
types
name
ORS
Ident
type
ORB
Type
next
PtrBase
END
VAR
sym
INTEGER
last
symbol
read
dc
LONGINT
data
counter
level
exno
version
INTEGER
newSF
BOOLEAN
option
flag
expression
PROCEDURE
VAR
x
ORG
Item
to
avoid
forward
reference
Type
PROCEDURE
VAR
type
ORB
Type
FormalType
PROCEDURE
VAR
typ
ORB
Type
dim
INTEGER
modid
ORS
Ident
pbsList
PtrBase
list
of
names
of
pointer
base
types
dummy
ORB
Object
W
Texts
Writer
PROCEDURE
Check
s
INTEGER
msg
ARRAY
OF
CHAR
BEGIN
IF
sym
s
THEN
ORS
Get
sym
ELSE
ORS
Mark
msg
END
END
Check
PROCEDURE
qualident
VAR
obj
ORB
Object
BEGIN
obj
ORB
thisObj
ORS
Get
sym
IF
obj
NIL
THEN
ORS
Mark
undef
obj
dummy
END
IF
sym
ORS
period
obj
class
ORB
Mod
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
obj
ORB
thisimport
obj
ORS
Get
sym
IF
obj
NIL
THEN
ORS
Mark
undef
obj
dummy
END
ELSE
ORS
Mark
identifier
expected
obj
dummy
END
END
END
qualident
PROCEDURE
CheckBool
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Bool
THEN
ORS
Mark
not
Boolean
x
type
ORB
boolType
END
END
CheckBool
PROCEDURE
CheckInt
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Int
THEN
ORS
Mark
not
Integer
x
type
ORB
intType
END
END
CheckInt
PROCEDURE
CheckReal
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Real
THEN
ORS
Mark
not
Real
x
type
ORB
realType
END
END
CheckReal
PROCEDURE
CheckSet
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Set
THEN
ORS
Mark
not
Set
x
type
ORB
setType
END
END
CheckSet
PROCEDURE
CheckSetVal
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Int
THEN
ORS
Mark
not
Int
x
type
ORB
setType
ELSIF
x
mode
ORB
Const
THEN
IF
x
a
OR
x
a
THEN
ORS
Mark
invalid
set
END
END
END
CheckSetVal
PROCEDURE
CheckConst
VAR
x
ORG
Item
BEGIN
IF
x
mode
ORB
Const
THEN
ORS
Mark
not
a
constant
x
mode
ORB
Const
END
END
CheckConst
PROCEDURE
CheckReadOnly
VAR
x
ORG
Item
BEGIN
IF
x
rdo
THEN
ORS
Mark
read
only
END
END
CheckReadOnly
PROCEDURE
CheckExport
VAR
expo
BOOLEAN
BEGIN
IF
sym
ORS
times
THEN
expo
TRUE
ORS
Get
sym
IF
level
THEN
ORS
Mark
remove
asterisk
END
ELSE
expo
FALSE
END
END
CheckExport
PROCEDURE
IsExtension
t0
t1
ORB
Type
BOOLEAN
BEGIN
t1
is
an
extension
of
t0
RETURN
t0
t1
OR
t1
NIL
IsExtension
t0
t1
base
END
IsExtension
expressions
PROCEDURE
TypeTest
VAR
x
ORG
Item
T
ORB
Type
guard
BOOLEAN
VAR
xt
ORB
Type
BEGIN
xt
x
type
IF
T
form
xt
form
T
form
ORB
Pointer
OR
T
form
ORB
Record
x
mode
ORB
Par
THEN
WHILE
xt
T
xt
NIL
DO
xt
xt
base
END
IF
xt
T
THEN
xt
x
type
IF
xt
form
ORB
Pointer
THEN
IF
IsExtension
xt
base
T
base
THEN
ORG
TypeTest
x
T
base
FALSE
guard
x
type
T
ELSE
ORS
Mark
not
an
extension
END
ELSIF
xt
form
ORB
Record
x
mode
ORB
Par
THEN
IF
IsExtension
xt
T
THEN
ORG
TypeTest
x
T
TRUE
guard
x
type
T
ELSE
ORS
Mark
not
an
extension
END
ELSE
ORS
Mark
incompatible
types
END
ELSIF
guard
THEN
ORG
MakeConstItem
x
ORB
boolType
END
ELSE
ORS
Mark
type
mismatch
END
IF
guard
THEN
x
type
ORB
boolType
END
END
TypeTest
PROCEDURE
selector
VAR
x
ORG
Item
VAR
y
ORG
Item
obj
ORB
Object
BEGIN
WHILE
sym
ORS
lbrak
OR
sym
ORS
period
OR
sym
ORS
arrow
OR
sym
ORS
lparen
x
type
form
IN
ORB
Record
ORB
Pointer
DO
IF
sym
ORS
lbrak
THEN
REPEAT
ORS
Get
sym
expression
y
IF
x
type
form
ORB
Array
THEN
CheckInt
y
ORG
Index
x
y
x
type
x
type
base
ELSE
ORS
Mark
not
an
array
END
UNTIL
sym
ORS
comma
Check
ORS
rbrak
no
ELSIF
sym
ORS
period
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
IF
x
type
form
ORB
Pointer
THEN
ORG
DeRef
x
x
type
x
type
base
END
IF
x
type
form
ORB
Record
THEN
obj
ORB
thisfield
x
type
ORS
Get
sym
IF
obj
NIL
THEN
ORG
Field
x
obj
x
type
obj
type
ELSE
ORS
Mark
undef
END
ELSE
ORS
Mark
not
a
record
END
ELSE
ORS
Mark
ident
END
ELSIF
sym
ORS
arrow
THEN
ORS
Get
sym
IF
x
type
form
ORB
Pointer
THEN
ORG
DeRef
x
x
type
x
type
base
ELSE
ORS
Mark
not
a
pointer
END
ELSIF
sym
ORS
lparen
x
type
form
IN
ORB
Record
ORB
Pointer
THEN
type
guard
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
TypeTest
x
obj
type
TRUE
ELSE
ORS
Mark
guard
type
expected
END
ELSE
ORS
Mark
not
an
identifier
END
Check
ORS
rparen
missing
END
END
END
selector
PROCEDURE
EqualSignatures
t0
t1
ORB
Type
BOOLEAN
VAR
p0
p1
ORB
Object
com
BOOLEAN
BEGIN
com
TRUE
IF
t0
base
t1
base
t0
nofpar
t1
nofpar
THEN
p0
t0
dsc
p1
t1
dsc
WHILE
p0
NIL
DO
IF
p0
class
p1
class
p0
rdo
p1
rdo
p0
type
p1
type
OR
p0
type
form
ORB
Array
p1
type
form
ORB
Array
p0
type
len
p1
type
len
p0
type
base
p1
type
base
OR
p0
type
form
ORB
Proc
p1
type
form
ORB
Proc
EqualSignatures
p0
type
p1
type
THEN
p0
p0
next
p1
p1
next
ELSE
p0
NIL
com
FALSE
END
END
ELSE
com
FALSE
END
RETURN
com
END
EqualSignatures
PROCEDURE
CompTypes
t0
t1
ORB
Type
varpar
BOOLEAN
BOOLEAN
BEGIN
check
for
assignment
compatibility
RETURN
t0
t1
openarray
assignment
disallowed
in
ORG
OR
t0
form
ORB
Array
t1
form
ORB
Array
t0
base
t1
base
t0
len
t1
len
OR
t0
form
ORB
Record
t1
form
ORB
Record
IsExtension
t0
t1
OR
varpar
t0
form
ORB
Pointer
t1
form
ORB
Pointer
IsExtension
t0
base
t1
base
OR
t0
form
ORB
Proc
t1
form
ORB
Proc
EqualSignatures
t0
t1
OR
t0
form
IN
ORB
Pointer
ORB
Proc
t1
form
ORB
NilTyp
END
CompTypes
PROCEDURE
Parameter
par
ORB
Object
VAR
x
ORG
Item
varpar
BOOLEAN
BEGIN
expression
x
IF
par
NIL
THEN
varpar
par
class
ORB
Par
IF
CompTypes
par
type
x
type
varpar
THEN
IF
varpar
THEN
ORG
ValueParam
x
ELSE
par
class
Par
IF
par
rdo
THEN
CheckReadOnly
x
END
ORG
VarParam
x
par
type
END
ELSIF
x
type
form
ORB
Array
par
type
form
ORB
Array
x
type
base
par
type
base
par
type
len
THEN
IF
par
rdo
THEN
CheckReadOnly
x
END
ORG
OpenArrayParam
x
ELSIF
x
type
form
ORB
String
varpar
par
rdo
par
type
form
ORB
Array
par
type
base
form
ORB
Char
par
type
len
THEN
ORG
StringParam
x
ELSIF
varpar
par
type
form
ORB
Int
x
type
form
ORB
Int
THEN
ORG
ValueParam
x
BYTE
ELSIF
x
type
form
ORB
String
x
b
par
class
ORB
Var
par
type
form
ORB
Char
THEN
ORG
StrToChar
x
ORG
ValueParam
x
ELSIF
par
type
form
ORB
Array
par
type
base
ORB
byteType
par
type
len
par
type
size
x
type
size
THEN
ORG
VarParam
x
par
type
ELSE
ORS
Mark
incompatible
parameters
END
END
END
Parameter
PROCEDURE
ParamList
VAR
x
ORG
Item
VAR
n
INTEGER
par
ORB
Object
BEGIN
par
x
type
dsc
n
IF
sym
ORS
rparen
THEN
Parameter
par
n
WHILE
sym
ORS
comma
DO
Check
sym
comma
IF
par
NIL
THEN
par
par
next
END
INC
n
Parameter
par
END
Check
ORS
rparen
missing
ELSE
ORS
Get
sym
END
IF
n
x
type
nofpar
THEN
ORS
Mark
too
few
params
ELSIF
n
x
type
nofpar
THEN
ORS
Mark
too
many
params
END
END
ParamList
PROCEDURE
StandFunc
VAR
x
ORG
Item
fct
LONGINT
restyp
ORB
Type
VAR
y
ORG
Item
n
npar
LONGINT
BEGIN
Check
ORS
lparen
no
npar
fct
MOD
fct
fct
DIV
expression
x
n
WHILE
sym
ORS
comma
DO
ORS
Get
sym
expression
y
INC
n
END
Check
ORS
rparen
no
IF
n
npar
THEN
IF
fct
THEN
ABS
IF
x
type
form
IN
ORB
Int
ORB
Real
THEN
ORG
Abs
x
restyp
x
type
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
ODD
CheckInt
x
ORG
Odd
x
ELSIF
fct
THEN
FLOOR
CheckReal
x
ORG
Floor
x
ELSIF
fct
THEN
FLT
CheckInt
x
ORG
Float
x
ELSIF
fct
THEN
ORD
IF
x
type
form
ORB
Proc
THEN
ORG
Ord
x
ELSIF
x
type
form
ORB
String
x
b
THEN
ORG
StrToChar
x
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
CHR
CheckInt
x
ORG
Ord
x
ELSIF
fct
THEN
LEN
IF
x
type
form
ORB
Array
THEN
ORG
Len
x
ELSE
ORS
Mark
not
an
array
END
ELSIF
fct
IN
THEN
LSL
ASR
ROR
CheckInt
y
IF
x
type
form
IN
ORB
Int
ORB
Set
THEN
ORG
Shift
fct
x
y
restyp
x
type
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
ADC
ORG
ADC
x
y
ELSIF
fct
THEN
SBC
ORG
SBC
x
y
ELSIF
fct
THEN
UML
ORG
UML
x
y
ELSIF
fct
THEN
BIT
CheckInt
x
CheckInt
y
ORG
Bit
x
y
ELSIF
fct
THEN
REG
CheckConst
x
CheckInt
x
ORG
Register
x
ELSIF
fct
THEN
VAL
IF
x
mode
ORB
Typ
x
type
size
y
type
size
THEN
restyp
x
type
x
y
ELSE
ORS
Mark
casting
not
allowed
END
ELSIF
fct
THEN
ADR
ORG
Adr
x
ELSIF
fct
THEN
SIZE
IF
x
mode
ORB
Typ
THEN
ORG
MakeConstItem
x
ORB
intType
x
type
size
ELSE
ORS
Mark
must
be
a
type
END
ELSIF
fct
THEN
COND
CheckConst
x
CheckInt
x
ORG
Condition
x
ELSIF
fct
THEN
H
CheckConst
x
CheckInt
x
ORG
H
x
END
x
type
restyp
ELSE
ORS
Mark
wrong
nof
params
END
END
StandFunc
PROCEDURE
element
VAR
x
ORG
Item
VAR
y
ORG
Item
BEGIN
expression
x
CheckSetVal
x
IF
sym
ORS
upto
THEN
ORS
Get
sym
expression
y
CheckSetVal
y
ORG
Set
x
y
ELSE
ORG
Singleton
x
END
x
type
ORB
setType
END
element
PROCEDURE
set
VAR
x
ORG
Item
VAR
y
ORG
Item
BEGIN
IF
sym
ORS
if
THEN
IF
sym
ORS
rbrace
THEN
ORS
Mark
missing
END
ORG
MakeConstItem
x
ORB
setType
empty
set
ELSE
element
x
WHILE
sym
ORS
rparen
OR
sym
ORS
rbrace
DO
IF
sym
ORS
comma
THEN
ORS
Get
sym
ELSIF
sym
ORS
rbrace
THEN
ORS
Mark
missing
comma
END
element
y
ORG
SetOp
ORS
plus
x
y
END
END
END
set
PROCEDURE
factor
VAR
x
ORG
Item
VAR
obj
ORB
Object
rx
LONGINT
BEGIN
sync
IF
sym
ORS
char
OR
sym
ORS
ident
THEN
ORS
Mark
expression
expected
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
char
sym
ORS
for
OR
sym
ORS
then
END
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
SFunc
THEN
StandFunc
x
obj
val
obj
type
ELSE
ORG
MakeItem
x
obj
level
selector
x
IF
sym
ORS
lparen
THEN
ORS
Get
sym
IF
x
type
form
ORB
Proc
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ParamList
x
ORG
Call
x
rx
x
type
x
type
base
ELSE
ORS
Mark
not
a
function
ParamList
x
END
END
END
ELSIF
sym
ORS
int
THEN
ORG
MakeConstItem
x
ORB
intType
ORS
ival
ORS
Get
sym
ELSIF
sym
ORS
real
THEN
ORG
MakeRealItem
x
ORS
rval
ORS
Get
sym
ELSIF
sym
ORS
char
THEN
ORG
MakeConstItem
x
ORB
charType
ORS
ival
ORS
Get
sym
ELSIF
sym
ORS
nil
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
nilType
ELSIF
sym
ORS
string
THEN
ORG
MakeStringItem
x
ORS
slen
ORS
Get
sym
ELSIF
sym
ORS
lparen
THEN
ORS
Get
sym
expression
x
Check
ORS
rparen
no
ELSIF
sym
ORS
lbrace
THEN
ORS
Get
sym
set
x
Check
ORS
rbrace
no
ELSIF
sym
ORS
not
THEN
ORS
Get
sym
factor
x
CheckBool
x
ORG
Not
x
ELSIF
sym
ORS
false
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
boolType
ELSIF
sym
ORS
true
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
boolType
ELSE
ORS
Mark
not
a
factor
ORG
MakeConstItem
x
ORB
intType
END
END
factor
PROCEDURE
term
VAR
x
ORG
Item
VAR
y
ORG
Item
op
f
INTEGER
BEGIN
factor
x
f
x
type
form
WHILE
sym
ORS
times
sym
ORS
and
DO
op
sym
ORS
Get
sym
IF
op
ORS
times
THEN
IF
f
ORB
Int
THEN
factor
y
CheckInt
y
ORG
MulOp
x
y
ELSIF
f
ORB
Real
THEN
factor
y
CheckReal
y
ORG
RealOp
op
x
y
ELSIF
f
ORB
Set
THEN
factor
y
CheckSet
y
ORG
SetOp
op
x
y
ELSE
ORS
Mark
bad
type
END
ELSIF
op
ORS
div
OR
op
ORS
mod
THEN
CheckInt
x
factor
y
CheckInt
y
ORG
DivOp
op
x
y
ELSIF
op
ORS
rdiv
THEN
IF
f
ORB
Real
THEN
factor
y
CheckReal
y
ORG
RealOp
op
x
y
ELSIF
f
ORB
Set
THEN
factor
y
CheckSet
y
ORG
SetOp
op
x
y
ELSE
ORS
Mark
bad
type
END
ELSE
op
and
CheckBool
x
ORG
And1
x
factor
y
CheckBool
y
ORG
And2
x
y
END
END
END
term
PROCEDURE
SimpleExpression
VAR
x
ORG
Item
VAR
y
ORG
Item
op
INTEGER
BEGIN
IF
sym
ORS
minus
THEN
ORS
Get
sym
term
x
IF
x
type
form
IN
ORB
Int
ORB
Real
ORB
Set
THEN
ORG
Neg
x
ELSE
CheckInt
x
END
ELSIF
sym
ORS
plus
THEN
ORS
Get
sym
term
x
ELSE
term
x
END
WHILE
sym
ORS
plus
sym
ORS
or
DO
op
sym
ORS
Get
sym
IF
op
ORS
or
THEN
ORG
Or1
x
CheckBool
x
term
y
CheckBool
y
ORG
Or2
x
y
ELSIF
x
type
form
ORB
Int
THEN
term
y
CheckInt
y
ORG
AddOp
op
x
y
ELSIF
x
type
form
ORB
Real
THEN
term
y
CheckReal
y
ORG
RealOp
op
x
y
ELSE
CheckSet
x
term
y
CheckSet
y
ORG
SetOp
op
x
y
END
END
END
SimpleExpression
PROCEDURE
expression0
VAR
x
ORG
Item
VAR
y
ORG
Item
obj
ORB
Object
rel
xf
yf
INTEGER
BEGIN
SimpleExpression
x
IF
sym
ORS
eql
sym
ORS
geq
THEN
rel
sym
ORS
Get
sym
SimpleExpression
y
xf
x
type
form
yf
y
type
form
IF
x
type
y
type
THEN
IF
xf
IN
ORB
Char
ORB
Int
THEN
ORG
IntRelation
rel
x
y
ELSIF
xf
ORB
Real
THEN
ORG
RealRelation
rel
x
y
ELSIF
xf
IN
ORB
Set
ORB
Pointer
ORB
Proc
ORB
NilTyp
ORB
Bool
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Array
x
type
base
form
ORB
Char
OR
xf
ORB
String
THEN
ORG
StringRelation
rel
x
y
ELSE
ORS
Mark
illegal
comparison
END
ELSIF
xf
IN
ORB
Pointer
ORB
Proc
yf
ORB
NilTyp
OR
yf
IN
ORB
Pointer
ORB
Proc
xf
ORB
NilTyp
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Pointer
yf
ORB
Pointer
IsExtension
x
type
base
y
type
base
OR
IsExtension
y
type
base
x
type
base
OR
xf
ORB
Proc
yf
ORB
Proc
EqualSignatures
x
type
y
type
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Array
x
type
base
form
ORB
Char
yf
ORB
String
OR
yf
ORB
Array
y
type
base
form
ORB
Char
OR
yf
ORB
Array
y
type
base
form
ORB
Char
xf
ORB
String
THEN
ORG
StringRelation
rel
x
y
ELSIF
xf
ORB
Char
yf
ORB
String
y
b
THEN
ORG
StrToChar
y
ORG
IntRelation
rel
x
y
ELSIF
yf
ORB
Char
xf
ORB
String
x
b
THEN
ORG
StrToChar
x
ORG
IntRelation
rel
x
y
ELSIF
xf
ORB
Int
yf
ORB
Int
THEN
ORG
IntRelation
rel
x
y
BYTE
ELSE
ORS
Mark
illegal
comparison
END
x
type
ORB
boolType
ELSIF
sym
ORS
in
THEN
ORS
Get
sym
CheckInt
x
SimpleExpression
y
CheckSet
y
ORG
In
x
y
x
type
ORB
boolType
ELSIF
sym
ORS
is
THEN
ORS
Get
sym
qualident
obj
TypeTest
x
obj
type
FALSE
x
type
ORB
boolType
END
END
expression0
statements
PROCEDURE
StandProc
pno
LONGINT
VAR
nap
npar
LONGINT
nof
actual
formal
parameters
x
y
z
ORG
Item
BEGIN
Check
ORS
lparen
no
npar
pno
MOD
pno
pno
DIV
expression
x
nap
IF
sym
ORS
comma
THEN
ORS
Get
sym
expression
y
nap
z
type
ORB
noType
WHILE
sym
ORS
comma
DO
ORS
Get
sym
expression
z
INC
nap
END
ELSE
y
type
ORB
noType
END
Check
ORS
rparen
no
IF
npar
nap
OR
pno
IN
THEN
IF
pno
IN
THEN
INC
DEC
CheckInt
x
CheckReadOnly
x
IF
y
type
ORB
noType
THEN
CheckInt
y
END
ORG
Increment
pno
x
y
ELSIF
pno
IN
THEN
INCL
EXCL
CheckSet
x
CheckReadOnly
x
CheckInt
y
ORG
Include
pno
x
y
ELSIF
pno
THEN
CheckBool
x
ORG
Assert
x
ELSIF
pno
THEN
NEW
CheckReadOnly
x
IF
x
type
form
ORB
Pointer
x
type
base
form
ORB
Record
THEN
ORG
New
x
ELSE
ORS
Mark
not
a
pointer
to
record
END
ELSIF
pno
THEN
CheckReal
x
CheckInt
y
CheckReadOnly
x
ORG
Pack
x
y
ELSIF
pno
THEN
CheckReal
x
CheckInt
y
CheckReadOnly
x
ORG
Unpk
x
y
ELSIF
pno
THEN
IF
x
type
form
ORB
Set
THEN
ORG
Led
x
ELSE
ORS
Mark
bad
type
END
ELSIF
pno
THEN
CheckInt
x
ORG
Get
x
y
ELSIF
pno
THEN
CheckInt
x
ORG
Put
x
y
ELSIF
pno
THEN
CheckInt
x
CheckInt
y
CheckInt
z
ORG
Copy
x
y
z
ELSIF
pno
THEN
CheckConst
x
CheckInt
x
ORG
LDPSR
x
ELSIF
pno
THEN
CheckInt
x
ORG
LDREG
x
y
END
ELSE
ORS
Mark
wrong
nof
parameters
END
END
StandProc
PROCEDURE
StatSequence
VAR
obj
ORB
Object
orgtype
ORB
Type
original
type
of
case
var
x
y
z
w
ORG
Item
L0
L1
rx
LONGINT
PROCEDURE
TypeCase
obj
ORB
Object
VAR
x
ORG
Item
VAR
typobj
ORB
Object
BEGIN
IF
sym
ORS
ident
THEN
qualident
typobj
ORG
MakeItem
x
obj
level
IF
typobj
class
ORB
Typ
THEN
ORS
Mark
not
a
type
END
TypeTest
x
typobj
type
FALSE
obj
type
typobj
type
ORG
CFJump
x
Check
ORS
colon
expected
StatSequence
ELSE
ORG
CFJump
x
ORS
Mark
type
id
expected
END
END
TypeCase
PROCEDURE
SkipCase
BEGIN
WHILE
sym
ORS
colon
DO
ORS
Get
sym
END
ORS
Get
sym
StatSequence
END
SkipCase
BEGIN
StatSequence
REPEAT
sync
obj
NIL
IF
sym
ORS
ident
sym
ORS
for
OR
sym
ORS
semicolon
THEN
ORS
Mark
statement
expected
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
ident
END
IF
sym
ORS
ident
THEN
qualident
obj
ORG
MakeItem
x
obj
level
IF
x
mode
ORB
SProc
THEN
StandProc
obj
val
ELSE
selector
x
IF
sym
ORS
becomes
THEN
assignment
ORS
Get
sym
CheckReadOnly
x
expression
y
IF
CompTypes
x
type
y
type
FALSE
THEN
IF
x
type
form
ORB
Pointer
OR
x
type
form
ORB
Proc
THEN
ORG
Store
x
y
ELSE
ORG
StoreStruct
x
y
END
ELSIF
x
type
form
ORB
Array
y
type
form
ORB
Array
x
type
base
y
type
base
y
type
len
THEN
ORG
StoreStruct
x
y
ELSIF
x
type
form
ORB
Array
x
type
base
form
ORB
Char
y
type
form
ORB
String
THEN
ORG
CopyString
x
y
ELSIF
x
type
form
ORB
Int
y
type
form
ORB
Int
THEN
ORG
Store
x
y
BYTE
ELSIF
x
type
form
ORB
Char
y
type
form
ORB
String
y
b
THEN
ORG
StrToChar
y
ORG
Store
x
y
ELSE
ORS
Mark
illegal
assignment
END
ELSIF
sym
ORS
eql
THEN
ORS
Mark
should
be
ORS
Get
sym
expression
y
ELSIF
sym
ORS
lparen
THEN
procedure
call
ORS
Get
sym
IF
x
type
form
ORB
Proc
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ParamList
x
ORG
Call
x
rx
ELSE
ORS
Mark
not
a
procedure
ParamList
x
END
ELSIF
x
type
form
ORB
Proc
THEN
procedure
call
without
parameters
IF
x
type
nofpar
THEN
ORS
Mark
missing
parameters
END
IF
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ORG
Call
x
rx
ELSE
ORS
Mark
not
a
procedure
END
ELSIF
x
mode
ORB
Typ
THEN
ORS
Mark
illegal
assignment
ELSE
ORS
Mark
not
a
procedure
END
END
ELSIF
sym
ORS
if
THEN
ORS
Get
sym
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
then
no
THEN
StatSequence
L0
WHILE
sym
ORS
elsif
DO
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
then
no
THEN
StatSequence
END
IF
sym
ORS
else
THEN
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
StatSequence
ELSE
ORG
Fixup
x
END
ORG
FixLink
L0
Check
ORS
end
no
END
ELSIF
sym
ORS
while
THEN
ORS
Get
sym
L0
ORG
Here
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
do
no
DO
StatSequence
ORG
BJump
L0
WHILE
sym
ORS
elsif
DO
ORS
Get
sym
ORG
Fixup
x
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
do
no
DO
StatSequence
ORG
BJump
L0
END
ORG
Fixup
x
Check
ORS
end
no
END
ELSIF
sym
ORS
repeat
THEN
ORS
Get
sym
L0
ORG
Here
StatSequence
IF
sym
ORS
until
THEN
ORS
Get
sym
expression
x
CheckBool
x
ORG
CBJump
x
L0
ELSE
ORS
Mark
missing
UNTIL
END
ELSIF
sym
ORS
for
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
ORG
MakeItem
x
obj
level
CheckInt
x
CheckReadOnly
x
IF
sym
ORS
becomes
THEN
ORS
Get
sym
expression
y
CheckInt
y
ORG
For0
x
y
L0
ORG
Here
Check
ORS
to
no
TO
expression
z
CheckInt
z
obj
rdo
TRUE
IF
sym
ORS
by
THEN
ORS
Get
sym
expression
w
CheckConst
w
CheckInt
w
ELSE
ORG
MakeConstItem
w
ORB
intType
END
Check
ORS
do
no
DO
ORG
For1
x
y
z
w
L1
StatSequence
Check
ORS
end
no
END
ORG
For2
x
y
w
ORG
BJump
L0
ORG
FixLink
L1
obj
rdo
FALSE
ELSE
ORS
Mark
expected
END
ELSE
ORS
Mark
identifier
expected
END
ELSIF
sym
ORS
case
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
orgtype
obj
type
IF
orgtype
form
ORB
Pointer
OR
orgtype
form
ORB
Record
obj
class
ORB
Par
THEN
Check
ORS
of
OF
expected
TypeCase
obj
x
L0
WHILE
sym
ORS
bar
DO
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
obj
type
orgtype
TypeCase
obj
x
END
ORG
Fixup
x
ORG
FixLink
L0
obj
type
orgtype
ELSE
ORS
Mark
numeric
case
not
implemented
Check
ORS
of
OF
expected
SkipCase
WHILE
sym
ORS
bar
DO
SkipCase
END
END
ELSE
ORS
Mark
ident
expected
END
Check
ORS
end
no
END
END
ORG
CheckRegs
IF
sym
ORS
semicolon
THEN
ORS
Get
sym
ELSIF
sym
ORS
semicolon
THEN
ORS
Mark
missing
semicolon
END
UNTIL
sym
ORS
semicolon
END
StatSequence
Types
and
declarations
PROCEDURE
IdentList
class
INTEGER
VAR
first
ORB
Object
VAR
obj
ORB
Object
BEGIN
IF
sym
ORS
ident
THEN
ORB
NewObj
first
ORS
id
class
ORS
Get
sym
CheckExport
first
expo
WHILE
sym
ORS
comma
DO
ORS
Get
sym
IF
sym
ORS
ident
THEN
ORB
NewObj
obj
ORS
id
class
ORS
Get
sym
CheckExport
obj
expo
ELSE
ORS
Mark
ident
END
END
IF
sym
ORS
colon
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
ELSE
first
NIL
END
END
IdentList
PROCEDURE
ArrayType
VAR
type
ORB
Type
VAR
x
ORG
Item
typ
ORB
Type
len
LONGINT
BEGIN
NEW
typ
typ
form
ORB
NoTyp
expression
x
IF
x
mode
ORB
Const
x
type
form
ORB
Int
x
a
THEN
len
x
a
ELSE
len
ORS
Mark
not
a
valid
length
END
IF
sym
ORS
of
THEN
ORS
Get
sym
Type
typ
base
IF
typ
base
form
ORB
Array
typ
base
len
THEN
ORS
Mark
dyn
array
not
allowed
END
ELSIF
sym
ORS
comma
THEN
ORS
Get
sym
ArrayType
typ
base
ELSE
ORS
Mark
missing
OF
typ
base
ORB
intType
END
typ
size
len
typ
base
size
DIV
typ
form
ORB
Array
typ
len
len
type
typ
END
ArrayType
PROCEDURE
RecordType
VAR
type
ORB
Type
VAR
obj
obj0
new
bot
base
ORB
Object
typ
tp
ORB
Type
offset
off
n
LONGINT
BEGIN
NEW
typ
typ
form
ORB
NoTyp
typ
base
NIL
typ
mno
level
typ
nofpar
offset
bot
NIL
IF
sym
ORS
lparen
THEN
ORS
Get
sym
record
extension
IF
level
THEN
ORS
Mark
extension
of
local
types
not
implemented
END
IF
sym
ORS
ident
THEN
qualident
base
IF
base
class
ORB
Typ
THEN
IF
base
type
form
ORB
Record
THEN
typ
base
base
type
ELSE
typ
base
ORB
intType
ORS
Mark
invalid
extension
END
typ
nofpar
typ
base
nofpar
nofpar
here
abused
for
extension
level
bot
typ
base
dsc
offset
typ
base
size
ELSE
ORS
Mark
type
expected
END
ELSE
ORS
Mark
ident
expected
END
Check
ORS
rparen
no
END
WHILE
sym
ORS
ident
DO
fields
n
obj
bot
WHILE
sym
ORS
ident
DO
obj0
obj
WHILE
obj0
NIL
obj0
name
ORS
id
DO
obj0
obj0
next
END
IF
obj0
NIL
THEN
ORS
Mark
mult
def
END
NEW
new
ORS
CopyId
new
name
new
class
ORB
Fld
new
next
obj
obj
new
INC
n
ORS
Get
sym
CheckExport
new
expo
IF
sym
ORS
comma
sym
ORS
colon
THEN
ORS
Mark
comma
expected
ELSIF
sym
ORS
comma
THEN
ORS
Get
sym
END
END
Check
ORS
colon
colon
expected
Type
tp
IF
tp
form
ORB
Array
tp
len
THEN
ORS
Mark
dyn
array
not
allowed
END
IF
tp
size
THEN
offset
offset
DIV
END
offset
offset
n
tp
size
off
offset
obj0
obj
WHILE
obj0
bot
DO
obj0
type
tp
obj0
lev
off
off
tp
size
obj0
val
off
obj0
obj0
next
END
bot
obj
IF
sym
ORS
semicolon
THEN
ORS
Get
sym
ELSIF
sym
ORS
end
THEN
ORS
Mark
or
END
END
END
typ
form
ORB
Record
typ
dsc
bot
typ
size
offset
DIV
type
typ
END
RecordType
PROCEDURE
FPSection
VAR
adr
LONGINT
VAR
nofpar
INTEGER
VAR
obj
first
ORB
Object
tp
ORB
Type
parsize
LONGINT
cl
INTEGER
rdo
BOOLEAN
BEGIN
IF
sym
ORS
var
THEN
ORS
Get
sym
cl
ORB
Par
ELSE
cl
ORB
Var
END
IdentList
cl
first
FormalType
tp
rdo
FALSE
IF
cl
ORB
Var
tp
form
ORB
Array
THEN
cl
ORB
Par
rdo
TRUE
END
IF
tp
form
ORB
Array
tp
len
OR
tp
form
ORB
Record
THEN
parsize
ORG
WordSize
open
array
or
record
needs
second
word
for
length
or
type
tag
ELSE
parsize
ORG
WordSize
END
obj
first
WHILE
obj
NIL
DO
INC
nofpar
obj
class
cl
obj
type
tp
obj
rdo
rdo
obj
lev
level
obj
val
adr
adr
adr
parsize
obj
obj
next
END
IF
adr
THEN
ORS
Mark
too
many
parameters
END
END
FPSection
PROCEDURE
ProcedureType
ptype
ORB
Type
VAR
parblksize
LONGINT
VAR
obj
ORB
Object
size
LONGINT
nofpar
INTEGER
BEGIN
ptype
base
ORB
noType
size
parblksize
nofpar
ptype
dsc
NIL
IF
sym
ORS
lparen
THEN
ORS
Get
sym
IF
sym
ORS
rparen
THEN
ORS
Get
sym
ELSE
FPSection
size
nofpar
WHILE
sym
ORS
semicolon
DO
ORS
Get
sym
FPSection
size
nofpar
END
Check
ORS
rparen
no
END
IF
sym
ORS
colon
THEN
function
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
ptype
base
obj
type
IF
obj
class
ORB
Typ
obj
type
form
IN
ORB
Byte
ORB
Pointer
ORB
Proc
THEN
ORS
Mark
illegal
function
type
END
ELSE
ORS
Mark
type
identifier
expected
END
END
END
ptype
nofpar
nofpar
parblksize
size
END
ProcedureType
PROCEDURE
FormalType0
VAR
typ
ORB
Type
dim
INTEGER
VAR
obj
ORB
Object
dmy
LONGINT
BEGIN
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
typ
obj
type
ELSE
ORS
Mark
not
a
type
typ
ORB
intType
END
ELSIF
sym
ORS
array
THEN
ORS
Get
sym
Check
ORS
of
OF
IF
dim
THEN
ORS
Mark
multi
dimensional
open
arrays
not
implemented
END
NEW
typ
typ
form
ORB
Array
typ
len
typ
size
ORG
WordSize
FormalType
typ
base
dim
ELSIF
sym
ORS
procedure
THEN
ORS
Get
sym
ORB
OpenScope
NEW
typ
typ
form
ORB
Proc
typ
size
ORG
WordSize
dmy
ProcedureType
typ
dmy
typ
dsc
ORB
topScope
next
ORB
CloseScope
ELSE
ORS
Mark
identifier
expected
typ
ORB
noType
END
END
FormalType0
PROCEDURE
CheckRecLevel
lev
INTEGER
BEGIN
IF
lev
THEN
ORS
Mark
ptr
base
must
be
global
END
END
CheckRecLevel
PROCEDURE
Type0
VAR
type
ORB
Type
VAR
dmy
LONGINT
obj
ORB
Object
ptbase
PtrBase
BEGIN
type
ORB
intType
sync
IF
sym
ORS
ident
sym
ORS
array
THEN
ORS
Mark
not
a
type
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
ident
OR
sym
ORS
array
END
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
IF
obj
type
NIL
obj
type
form
ORB
NoTyp
THEN
type
obj
type
END
ELSE
ORS
Mark
not
a
type
or
undefined
END
ELSIF
sym
ORS
array
THEN
ORS
Get
sym
ArrayType
type
ELSIF
sym
ORS
record
THEN
ORS
Get
sym
RecordType
type
Check
ORS
end
no
END
ELSIF
sym
ORS
pointer
THEN
ORS
Get
sym
Check
ORS
to
no
TO
NEW
type
type
form
ORB
Pointer
type
size
ORG
WordSize
type
base
ORB
intType
IF
sym
ORS
ident
THEN
obj
ORB
thisObj
IF
obj
NIL
THEN
IF
obj
class
ORB
Typ
obj
type
form
IN
ORB
Record
ORB
NoTyp
THEN
CheckRecLevel
obj
lev
type
base
obj
type
ELSIF
obj
class
ORB
Mod
THEN
ORS
Mark
external
base
type
not
implemented
ELSE
ORS
Mark
no
valid
base
type
END
ELSE
CheckRecLevel
level
enter
into
list
of
forward
references
to
be
fixed
in
Declarations
NEW
ptbase
ORS
CopyId
ptbase
name
ptbase
type
type
ptbase
next
pbsList
pbsList
ptbase
END
ORS
Get
sym
ELSE
Type
type
base
IF
type
base
form
ORB
Record
OR
type
base
typobj
NIL
THEN
ORS
Mark
must
point
to
named
record
END
CheckRecLevel
level
END
ELSIF
sym
ORS
procedure
THEN
ORS
Get
sym
ORB
OpenScope
NEW
type
type
form
ORB
Proc
type
size
ORG
WordSize
dmy
ProcedureType
type
dmy
type
dsc
ORB
topScope
next
ORB
CloseScope
ELSE
ORS
Mark
illegal
type
END
END
Type0
PROCEDURE
Declarations
VAR
varsize
LONGINT
VAR
obj
first
ORB
Object
x
ORG
Item
tp
ORB
Type
ptbase
PtrBase
expo
BOOLEAN
id
ORS
Ident
BEGIN
sync
pbsList
NIL
IF
sym
ORS
const
sym
ORS
end
sym
ORS
return
THEN
ORS
Mark
declaration
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
const
OR
sym
ORS
end
OR
sym
ORS
return
END
IF
sym
ORS
const
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
id
ORS
Get
sym
CheckExport
expo
IF
sym
ORS
eql
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
expression
x
IF
x
type
form
ORB
String
x
b
THEN
ORG
StrToChar
x
END
ORB
NewObj
obj
id
ORB
Const
obj
expo
expo
IF
x
mode
ORB
Const
THEN
obj
val
x
a
obj
lev
x
b
obj
type
x
type
ELSE
ORS
Mark
expression
not
constant
obj
type
ORB
intType
END
Check
ORS
semicolon
missing
END
END
IF
sym
ORS
type
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
id
ORS
Get
sym
CheckExport
expo
IF
sym
ORS
eql
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
Type
tp
ORB
NewObj
obj
id
ORB
Typ
obj
type
tp
obj
expo
expo
obj
lev
level
IF
tp
typobj
NIL
THEN
tp
typobj
obj
END
IF
expo
obj
type
form
ORB
Record
THEN
obj
exno
exno
INC
exno
ELSE
obj
exno
END
IF
tp
form
ORB
Record
THEN
ptbase
pbsList
check
whether
this
is
base
of
a
pointer
type
search
and
fixup
WHILE
ptbase
NIL
DO
IF
obj
name
ptbase
name
THEN
ptbase
type
base
obj
type
END
ptbase
ptbase
next
END
IF
level
THEN
ORG
BuildTD
tp
dc
END
type
descriptor
len
used
as
its
address
END
Check
ORS
semicolon
missing
END
END
IF
sym
ORS
var
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
IdentList
ORB
Var
first
Type
tp
obj
first
WHILE
obj
NIL
DO
obj
type
tp
obj
lev
level
IF
tp
size
THEN
varsize
varsize
DIV
align
END
obj
val
varsize
varsize
varsize
obj
type
size
IF
obj
expo
THEN
obj
exno
exno
INC
exno
END
obj
obj
next
END
Check
ORS
semicolon
missing
END
END
varsize
varsize
DIV
ptbase
pbsList
WHILE
ptbase
NIL
DO
IF
ptbase
type
base
form
ORB
Int
THEN
ORS
Mark
undefined
pointer
base
of
END
ptbase
ptbase
next
END
IF
sym
ORS
const
sym
ORS
var
THEN
ORS
Mark
declaration
in
bad
order
END
END
Declarations
PROCEDURE
ProcedureDecl
VAR
proc
ORB
Object
type
ORB
Type
procid
ORS
Ident
x
ORG
Item
locblksize
parblksize
L
LONGINT
int
BOOLEAN
BEGIN
ProcedureDecl
int
FALSE
ORS
Get
sym
IF
sym
ORS
times
THEN
ORS
Get
sym
int
TRUE
END
IF
sym
ORS
ident
THEN
ORS
CopyId
procid
ORS
Get
sym
ORB
NewObj
proc
ORS
id
ORB
Const
IF
int
THEN
parblksize
ELSE
parblksize
END
NEW
type
type
form
ORB
Proc
type
size
ORG
WordSize
proc
type
type
proc
val
proc
lev
level
CheckExport
proc
expo
IF
proc
expo
THEN
proc
exno
exno
INC
exno
END
ORB
OpenScope
INC
level
type
base
ORB
noType
ProcedureType
type
parblksize
formal
parameter
list
Check
ORS
semicolon
no
locblksize
parblksize
Declarations
locblksize
proc
val
ORG
Here
proc
type
dsc
ORB
topScope
next
IF
sym
ORS
procedure
THEN
L
ORG
FJump
L
REPEAT
ProcedureDecl
Check
ORS
semicolon
no
UNTIL
sym
ORS
procedure
ORG
FixOne
L
proc
val
ORG
Here
proc
type
dsc
ORB
topScope
next
END
ORG
Enter
parblksize
locblksize
int
IF
sym
ORS
begin
THEN
ORS
Get
sym
StatSequence
END
IF
sym
ORS
return
THEN
ORS
Get
sym
expression
x
IF
type
base
ORB
noType
THEN
ORS
Mark
this
is
not
a
function
ELSIF
CompTypes
type
base
x
type
FALSE
THEN
ORS
Mark
wrong
result
type
END
ELSIF
type
base
form
ORB
NoTyp
THEN
ORS
Mark
function
without
result
type
base
ORB
noType
END
ORG
Return
type
base
form
x
locblksize
int
ORB
CloseScope
DEC
level
Check
ORS
end
no
END
IF
sym
ORS
ident
THEN
IF
ORS
id
procid
THEN
ORS
Mark
no
match
END
ORS
Get
sym
ELSE
ORS
Mark
no
proc
id
END
END
END
ProcedureDecl
PROCEDURE
Module
VAR
key
LONGINT
impid
impid1
ORS
Ident
BEGIN
Texts
WriteString
W
compiling
ORS
Get
sym
IF
sym
ORS
module
THEN
ORS
Get
sym
IF
sym
ORS
times
THEN
version
Texts
Write
W
ORS
Get
sym
ELSE
version
END
ORB
Init
ORB
OpenScope
IF
sym
ORS
ident
THEN
ORS
CopyId
modid
ORS
Get
sym
Texts
WriteString
W
modid
Texts
Append
Oberon
Log
W
buf
ELSE
ORS
Mark
identifier
expected
END
Check
ORS
semicolon
no
level
dc
exno
key
IF
sym
ORS
import
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
impid
ORS
Get
sym
IF
sym
ORS
becomes
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
ORS
CopyId
impid1
ORS
Get
sym
ELSE
ORS
Mark
id
expected
END
ELSE
impid1
impid
END
ORB
Import
impid
impid1
IF
sym
ORS
comma
THEN
ORS
Get
sym
ELSIF
sym
ORS
ident
THEN
ORS
Mark
comma
missing
END
END
Check
ORS
semicolon
no
END
ORG
Open
version
Declarations
dc
ORG
SetDataSize
dc
DIV
WHILE
sym
ORS
procedure
DO
ProcedureDecl
Check
ORS
semicolon
no
END
ORG
Header
IF
sym
ORS
begin
THEN
ORS
Get
sym
StatSequence
END
Check
ORS
end
no
END
IF
sym
ORS
ident
THEN
IF
ORS
id
modid
THEN
ORS
Mark
no
match
END
ORS
Get
sym
ELSE
ORS
Mark
identifier
missing
END
IF
sym
ORS
period
THEN
ORS
Mark
period
missing
END
IF
ORS
errcnt
version
THEN
ORB
Export
modid
newSF
key
IF
newSF
THEN
Texts
WriteString
W
new
symbol
file
END
END
IF
ORS
errcnt
THEN
ORG
Close
modid
key
exno
Texts
WriteInt
W
ORG
pc
Texts
WriteInt
W
dc
Texts
WriteHex
W
key
ELSE
Texts
WriteLn
W
Texts
WriteString
W
compilation
FAILED
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
ORB
CloseScope
pbsList
NIL
ELSE
ORS
Mark
must
start
with
MODULE
END
END
Module
PROCEDURE
Option
VAR
S
Texts
Scanner
BEGIN
newSF
FALSE
IF
S
nextCh
THEN
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
S
s
s
THEN
newSF
TRUE
END
END
END
Option
PROCEDURE
Compile
VAR
beg
end
time
LONGINT
T
Texts
Text
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
THEN
IF
S
c
THEN
Option
S
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
ORS
Init
T
beg
Module
END
ELSIF
S
c
THEN
Option
S
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
S
s
NEW
T
Texts
Open
T
S
s
IF
T
len
THEN
ORS
Init
T
Module
END
END
END
END
ELSE
WHILE
S
class
Texts
Name
DO
NEW
T
Texts
Open
T
S
s
IF
T
len
THEN
Option
S
ORS
Init
T
Module
ELSE
Texts
WriteString
W
S
s
Texts
WriteString
W
not
found
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
IF
T
len
ORS
errcnt
THEN
Texts
Scan
S
ELSE
S
class
END
END
END
Oberon
Collect
END
Compile
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
OR
Compiler
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
NEW
dummy
dummy
class
ORB
Var
dummy
type
ORB
intType
expression
expression0
Type
Type0
FormalType
FormalType0
END
ORP
MODULE
ORS
NW
Scanner
in
Oberon
IMPORT
SYSTEM
Texts
Oberon
Oberon
Scanner
does
lexical
analysis
Input
is
Oberon
Text
output
is
sequence
of
symbols
i
e
identifiers
numbers
strings
and
special
symbols
Recognises
all
Oberon
keywords
and
skips
comments
The
keywords
are
recorded
in
a
table
Get
sym
delivers
next
symbol
from
input
text
with
Reader
R
Mark
msg
records
error
and
delivers
error
message
with
Writer
W
If
Get
delivers
ident
then
the
identifier
a
string
is
in
variable
id
if
int
or
char
in
ival
if
real
in
rval
and
if
string
in
str
and
slen
CONST
IdLen
NKW
nof
keywords
maxExp
stringBufSize
lexical
symbols
null
times
rdiv
div
mod
and
plus
minus
or
eql
neq
lss
leq
gtr
geq
in
is
arrow
period
char
int
real
false
true
nil
string
not
lparen
lbrak
lbrace
ident
if
while
repeat
case
for
comma
colon
becomes
upto
rparen
rbrak
rbrace
then
of
do
to
by
semicolon
end
bar
else
elsif
until
return
array
record
pointer
const
type
var
procedure
begin
import
module
eot
TYPE
Ident
ARRAY
IdLen
OF
CHAR
VAR
ival
slen
LONGINT
results
of
Get
rval
REAL
id
Ident
for
identifiers
str
ARRAY
stringBufSize
OF
CHAR
errcnt
INTEGER
ch
CHAR
last
character
read
errpos
LONGINT
R
Texts
Reader
W
Texts
Writer
k
INTEGER
KWX
ARRAY
OF
INTEGER
keyTab
ARRAY
NKW
OF
RECORD
sym
INTEGER
id
ARRAY
OF
CHAR
END
PROCEDURE
CopyId
VAR
ident
Ident
BEGIN
ident
id
END
CopyId
PROCEDURE
Pos
LONGINT
BEGIN
RETURN
Texts
Pos
R
END
Pos
PROCEDURE
Mark
msg
ARRAY
OF
CHAR
VAR
p
LONGINT
BEGIN
p
Pos
IF
p
errpos
errcnt
THEN
Texts
WriteLn
W
Texts
WriteString
W
pos
Texts
WriteInt
W
p
Texts
Write
W
Texts
WriteString
W
msg
Texts
Append
Oberon
Log
W
buf
END
INC
errcnt
errpos
p
END
Mark
PROCEDURE
Identifier
VAR
sym
INTEGER
VAR
i
k
INTEGER
BEGIN
i
REPEAT
IF
i
IdLen
THEN
id
i
ch
INC
i
END
Texts
Read
R
ch
UNTIL
ch
OR
ch
ch
A
OR
ch
Z
ch
a
OR
ch
z
id
i
0X
IF
i
THEN
k
KWX
i
search
for
keyword
WHILE
id
keyTab
k
id
k
KWX
i
DO
INC
k
END
IF
k
KWX
i
THEN
sym
keyTab
k
sym
ELSE
sym
ident
END
ELSE
sym
ident
END
END
Identifier
PROCEDURE
String
VAR
i
INTEGER
BEGIN
i
Texts
Read
R
ch
WHILE
R
eot
ch
22X
DO
IF
ch
THEN
IF
i
stringBufSize
THEN
str
i
ch
INC
i
ELSE
Mark
string
too
long
END
END
Texts
Read
R
ch
END
str
i
0X
INC
i
Texts
Read
R
ch
slen
i
END
String
PROCEDURE
HexString
VAR
i
m
n
INTEGER
BEGIN
i
Texts
Read
R
ch
WHILE
R
eot
ch
DO
WHILE
R
eot
ch
DO
Texts
Read
R
ch
END
skip
IF
ch
ch
THEN
m
ORD
ch
30H
ELSIF
A
ch
ch
F
THEN
m
ORD
ch
37H
ELSE
m
Mark
hexdig
expected
END
Texts
Read
R
ch
IF
ch
ch
THEN
n
ORD
ch
30H
ELSIF
A
ch
ch
F
THEN
n
ORD
ch
37H
ELSE
n
Mark
hexdig
expected
END
IF
i
stringBufSize
THEN
str
i
CHR
m
10H
n
INC
i
ELSE
Mark
string
too
long
END
Texts
Read
R
ch
END
Texts
Read
R
ch
slen
i
no
0X
appended
END
HexString
PROCEDURE
Ten
e
LONGINT
REAL
VAR
x
t
REAL
BEGIN
x
t
WHILE
e
DO
IF
ODD
e
THEN
x
t
x
END
t
t
t
e
e
DIV
END
RETURN
x
END
Ten
PROCEDURE
Number
VAR
sym
INTEGER
CONST
max
VAR
i
k
e
n
s
h
LONGINT
x
REAL
d
ARRAY
OF
INTEGER
negE
BOOLEAN
BEGIN
ival
i
n
k
REPEAT
IF
n
THEN
d
n
ORD
ch
30H
INC
n
ELSE
Mark
too
many
digits
n
END
Texts
Read
R
ch
UNTIL
ch
OR
ch
ch
A
OR
ch
F
IF
ch
H
OR
ch
R
OR
ch
X
THEN
hex
REPEAT
h
d
i
IF
h
THEN
h
h
END
k
k
10H
h
INC
i
no
overflow
check
UNTIL
i
n
IF
ch
X
THEN
sym
char
IF
k
100H
THEN
ival
k
ELSE
Mark
illegal
value
ival
END
ELSIF
ch
R
THEN
sym
real
rval
SYSTEM
VAL
REAL
k
ELSE
sym
int
ival
k
END
Texts
Read
R
ch
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
double
dot
ch
7FX
decimal
integer
REPEAT
IF
d
i
THEN
IF
k
max
d
i
DIV
THEN
k
k
d
i
ELSE
Mark
too
large
k
END
ELSE
Mark
bad
integer
END
INC
i
UNTIL
i
n
sym
int
ival
k
ELSE
real
number
x
e
REPEAT
integer
part
x
x
FLT
d
i
INC
i
UNTIL
i
n
WHILE
ch
ch
DO
fraction
x
x
FLT
ORD
ch
30H
DEC
e
Texts
Read
R
ch
END
IF
ch
E
OR
ch
D
THEN
scale
factor
Texts
Read
R
ch
s
IF
ch
THEN
negE
TRUE
Texts
Read
R
ch
ELSE
negE
FALSE
IF
ch
THEN
Texts
Read
R
ch
END
END
IF
ch
ch
THEN
REPEAT
s
s
ORD
ch
30H
Texts
Read
R
ch
UNTIL
ch
OR
ch
IF
negE
THEN
e
e
s
ELSE
e
e
s
END
ELSE
Mark
digit
END
END
IF
e
THEN
IF
e
maxExp
THEN
x
x
Ten
e
ELSE
x
END
ELSIF
e
THEN
IF
e
maxExp
THEN
x
Ten
e
x
ELSE
x
Mark
too
large
END
END
sym
real
rval
x
END
ELSE
decimal
integer
REPEAT
IF
d
i
THEN
IF
k
max
d
i
DIV
THEN
k
k
d
i
ELSE
Mark
too
large
k
END
ELSE
Mark
bad
integer
END
INC
i
UNTIL
i
n
sym
int
ival
k
END
END
Number
PROCEDURE
comment
BEGIN
Texts
Read
R
ch
REPEAT
WHILE
R
eot
ch
DO
IF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
comment
END
ELSE
Texts
Read
R
ch
END
END
WHILE
ch
DO
Texts
Read
R
ch
END
UNTIL
ch
OR
R
eot
IF
R
eot
THEN
Texts
Read
R
ch
ELSE
Mark
unterminated
comment
END
END
comment
PROCEDURE
Get
VAR
sym
INTEGER
BEGIN
REPEAT
WHILE
R
eot
ch
DO
Texts
Read
R
ch
END
IF
R
eot
THEN
sym
eot
ELSIF
ch
A
THEN
IF
ch
THEN
IF
ch
22X
THEN
String
sym
string
ELSIF
ch
THEN
Texts
Read
R
ch
sym
neq
ELSIF
ch
THEN
HexString
sym
string
ELSIF
ch
THEN
Texts
Read
R
ch
sym
and
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
sym
null
comment
ELSE
sym
lparen
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
rparen
ELSIF
ch
THEN
Texts
Read
R
ch
sym
times
ELSIF
ch
THEN
Texts
Read
R
ch
sym
plus
ELSIF
ch
THEN
Texts
Read
R
ch
sym
comma
ELSIF
ch
THEN
Texts
Read
R
ch
sym
minus
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
upto
ELSE
sym
period
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
rdiv
ELSE
Texts
Read
R
ch
sym
null
END
ELSIF
ch
THEN
Number
sym
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
becomes
ELSE
sym
colon
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
semicolon
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
leq
ELSE
sym
lss
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
eql
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
geq
ELSE
sym
gtr
END
ELSE
Texts
Read
R
ch
sym
null
END
ELSIF
ch
THEN
Identifier
sym
ELSIF
ch
a
THEN
IF
ch
THEN
sym
lbrak
ELSIF
ch
THEN
sym
rbrak
ELSIF
ch
THEN
sym
arrow
ELSE
sym
null
END
Texts
Read
R
ch
ELSIF
ch
THEN
Identifier
sym
ELSE
IF
ch
THEN
sym
lbrace
ELSIF
ch
THEN
sym
rbrace
ELSIF
ch
THEN
sym
bar
ELSIF
ch
THEN
sym
not
ELSIF
ch
7FX
THEN
sym
upto
ELSE
sym
null
END
Texts
Read
R
ch
END
UNTIL
sym
null
END
Get
PROCEDURE
Init
T
Texts
Text
pos
LONGINT
BEGIN
errpos
pos
errcnt
Texts
OpenReader
R
T
pos
Texts
Read
R
ch
END
Init
PROCEDURE
EnterKW
sym
INTEGER
name
ARRAY
OF
CHAR
BEGIN
keyTab
k
id
name
keyTab
k
sym
sym
INC
k
END
EnterKW
BEGIN
Texts
OpenWriter
W
k
KWX
KWX
EnterKW
if
IF
EnterKW
do
DO
EnterKW
of
OF
EnterKW
or
OR
EnterKW
to
TO
EnterKW
in
IN
EnterKW
is
IS
EnterKW
by
BY
KWX
k
EnterKW
end
END
EnterKW
nil
NIL
EnterKW
var
VAR
EnterKW
div
DIV
EnterKW
mod
MOD
EnterKW
for
FOR
KWX
k
EnterKW
else
ELSE
EnterKW
then
THEN
EnterKW
true
TRUE
EnterKW
type
TYPE
EnterKW
case
CASE
KWX
k
EnterKW
elsif
ELSIF
EnterKW
false
FALSE
EnterKW
array
ARRAY
EnterKW
begin
BEGIN
EnterKW
const
CONST
EnterKW
until
UNTIL
EnterKW
while
WHILE
KWX
k
EnterKW
record
RECORD
EnterKW
repeat
REPEAT
EnterKW
return
RETURN
EnterKW
import
IMPORT
EnterKW
module
MODULE
KWX
k
EnterKW
pointer
POINTER
KWX
k
KWX
k
EnterKW
procedure
PROCEDURE
KWX
k
END
ORS
MODULE
ORTool
NW
IMPORT
SYSTEM
Files
Texts
Oberon
ORB
VAR
W
Texts
Writer
Form
INTEGER
result
of
ReadType
mnemo0
mnemo1
ARRAY
OF
CHAR
mnemonics
PROCEDURE
Read
VAR
R
Files
Rider
VAR
n
INTEGER
VAR
b
BYTE
BEGIN
Files
ReadByte
R
b
IF
b
80H
THEN
n
b
ELSE
n
b
100H
END
END
Read
PROCEDURE
ReadType
VAR
R
Files
Rider
VAR
key
len
lev
size
off
INTEGER
ref
mno
class
form
readonly
INTEGER
name
modname
ARRAY
OF
CHAR
BEGIN
Read
R
ref
Texts
Write
W
Texts
Write
W
IF
ref
THEN
Texts
Write
W
Texts
WriteInt
W
ref
ELSE
Texts
WriteInt
W
ref
Read
R
form
Texts
WriteString
W
form
Texts
WriteInt
W
form
IF
form
ORB
Pointer
THEN
ReadType
R
ELSIF
form
ORB
Array
THEN
ReadType
R
Files
ReadNum
R
len
Files
ReadNum
R
size
Texts
WriteString
W
len
Texts
WriteInt
W
len
Texts
WriteString
W
size
Texts
WriteInt
W
size
ELSIF
form
ORB
Record
THEN
ReadType
R
base
type
Files
ReadNum
R
off
Texts
WriteString
W
exno
Texts
WriteInt
W
off
Files
ReadNum
R
off
Texts
WriteString
W
extlev
Texts
WriteInt
W
off
Files
ReadNum
R
size
Texts
WriteString
W
size
Texts
WriteInt
W
size
Texts
Write
W
Texts
Write
W
Read
R
class
WHILE
class
DO
fields
Files
ReadString
R
name
IF
name
0X
THEN
Texts
Write
W
Texts
WriteString
W
name
ReadType
R
ELSE
Texts
WriteString
W
END
Files
ReadNum
R
off
Texts
WriteInt
W
off
Read
R
class
END
Texts
Write
W
ELSIF
form
ORB
Proc
THEN
ReadType
R
Texts
Write
W
Read
R
class
WHILE
class
DO
Texts
WriteString
W
class
Texts
WriteInt
W
class
Read
R
readonly
IF
readonly
THEN
Texts
Write
W
END
ReadType
R
Read
R
class
END
Texts
Write
W
END
Files
ReadString
R
modname
IF
modname
0X
THEN
Files
ReadInt
R
key
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
modname
Texts
Write
W
Texts
WriteString
W
name
Texts
WriteHex
W
key
END
END
Form
form
Texts
Write
W
END
ReadType
PROCEDURE
DecSym
decode
symbol
file
VAR
class
typno
k
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
OR
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadInt
R
k
Files
ReadInt
R
k
Files
ReadString
R
name
Texts
WriteString
W
name
Texts
WriteHex
W
k
Read
R
class
Texts
WriteInt
W
class
sym
file
version
IF
class
ORB
versionkey
THEN
Texts
WriteLn
W
Read
R
class
WHILE
class
DO
Texts
WriteInt
W
class
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
ReadType
R
IF
class
ORB
Typ
THEN
Texts
Write
W
Read
R
class
WHILE
class
DO
pointer
base
fixup
Texts
WriteString
W
Texts
WriteInt
W
class
Read
R
class
END
Texts
Write
W
ELSIF
class
ORB
Const
OR
class
ORB
Var
THEN
Files
ReadNum
R
k
Texts
WriteInt
W
k
Reals
Strings
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Read
R
class
END
ELSE
Texts
WriteString
W
bad
symfile
version
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecSym
PROCEDURE
WriteReg
r
LONGINT
BEGIN
Texts
Write
W
IF
r
THEN
Texts
WriteString
W
R
Texts
WriteInt
W
r
MOD
10H
ELSIF
r
THEN
Texts
WriteString
W
MT
ELSIF
r
THEN
Texts
WriteString
W
SB
ELSIF
r
THEN
Texts
WriteString
W
SP
ELSE
Texts
WriteString
W
LNK
END
END
WriteReg
PROCEDURE
opcode
w
LONGINT
VAR
k
op
u
a
b
c
LONGINT
BEGIN
k
w
DIV
40000000H
MOD
a
w
DIV
1000000H
MOD
10H
b
w
DIV
100000H
MOD
10H
op
w
DIV
10000H
MOD
10H
u
w
DIV
20000000H
MOD
IF
k
THEN
Texts
WriteString
W
mnemo0
op
IF
u
THEN
Texts
Write
W
END
WriteReg
a
WriteReg
b
WriteReg
w
MOD
10H
ELSIF
k
THEN
Texts
WriteString
W
mnemo0
op
IF
u
THEN
Texts
Write
W
END
WriteReg
a
WriteReg
b
w
w
MOD
10000H
IF
w
8000H
THEN
w
w
10000H
END
Texts
WriteInt
W
w
ELSIF
k
THEN
LDR
STR
IF
u
THEN
Texts
WriteString
W
STR
ELSE
Texts
WriteString
W
LDR
END
WriteReg
a
WriteReg
b
w
w
MOD
100000H
IF
w
80000H
THEN
w
w
100000H
END
Texts
WriteInt
W
w
ELSIF
k
THEN
Branch
instr
Texts
Write
W
B
IF
ODD
w
DIV
10000000H
THEN
Texts
Write
W
L
END
Texts
WriteString
W
mnemo1
a
IF
u
THEN
WriteReg
w
MOD
10H
ELSE
w
w
MOD
100000H
IF
w
80000H
THEN
w
w
100000H
END
Texts
WriteInt
W
w
END
END
END
opcode
PROCEDURE
Sync
VAR
R
Files
Rider
VAR
ch
CHAR
BEGIN
Files
Read
R
ch
Texts
WriteString
W
Sync
Texts
Write
W
ch
Texts
WriteLn
W
END
Sync
PROCEDURE
Write
VAR
R
Files
Rider
x
INTEGER
BEGIN
Files
WriteByte
R
x
x
END
Write
PROCEDURE
DecObj
decode
object
file
VAR
class
i
n
key
size
fix
adr
data
len
INTEGER
ch
CHAR
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadString
R
name
Texts
WriteLn
W
Texts
WriteString
W
name
Files
ReadInt
R
key
Texts
WriteHex
W
key
Read
R
class
Texts
WriteInt
W
class
version
Files
ReadInt
R
size
Texts
WriteInt
W
size
Texts
WriteLn
W
Texts
WriteString
W
imports
Texts
WriteLn
W
Files
ReadString
R
name
WHILE
name
0X
DO
Texts
Write
W
9X
Texts
WriteString
W
name
Files
ReadInt
R
key
Texts
WriteHex
W
key
Texts
WriteLn
W
Files
ReadString
R
name
END
Sync
R
Texts
WriteString
W
type
descriptors
Texts
WriteLn
W
Files
ReadInt
R
n
n
n
DIV
i
WHILE
i
n
DO
Files
ReadInt
R
data
Texts
WriteHex
W
data
INC
i
END
Texts
WriteLn
W
Texts
WriteString
W
data
Files
ReadInt
R
data
Texts
WriteInt
W
data
Texts
WriteLn
W
Texts
WriteString
W
strings
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
Read
R
ch
Texts
Write
W
ch
INC
i
END
Texts
WriteLn
W
Texts
WriteString
W
code
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
ReadInt
R
data
Texts
WriteInt
W
i
Texts
Write
W
9X
Texts
WriteHex
W
data
Texts
Write
W
9X
opcode
data
Texts
WriteLn
W
INC
i
END
Sync
R
Texts
WriteString
W
commands
Texts
WriteLn
W
Files
ReadString
R
name
WHILE
name
0X
DO
Texts
Write
W
9X
Texts
WriteString
W
name
Files
ReadInt
R
adr
Texts
WriteInt
W
adr
Texts
WriteLn
W
Files
ReadString
R
name
END
Sync
R
Texts
WriteString
W
entries
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
ReadInt
R
adr
Texts
WriteInt
W
adr
INC
i
END
Texts
WriteLn
W
Sync
R
Texts
WriteString
W
pointer
refs
Texts
WriteLn
W
Files
ReadInt
R
adr
WHILE
adr
DO
Texts
WriteInt
W
adr
Files
ReadInt
R
adr
END
Texts
WriteLn
W
Sync
R
Files
ReadInt
R
data
Texts
WriteString
W
fixP
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
fixD
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
fixT
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
entry
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
Read
R
ch
IF
ch
O
THEN
Texts
WriteString
W
format
eror
Texts
WriteLn
W
END
Sync
R
ELSE
Texts
WriteString
W
not
found
Texts
WriteLn
W
END
Texts
Append
Oberon
Log
W
buf
END
END
DecObj
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
ORTool
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
mnemo0
MOV
mnemo0
LSL
mnemo0
ASR
mnemo0
ROR
mnemo0
AND
mnemo0
ANN
mnemo0
IOR
mnemo0
XOR
mnemo0
ADD
mnemo0
SUB
mnemo0
MUL
mnemo0
DIV
mnemo0
FAD
mnemo0
FSB
mnemo0
FML
mnemo0
FDV
mnemo1
MI
mnemo1
PL
mnemo1
EQ
mnemo1
NE
mnemo1
LS
mnemo1
HI
mnemo1
LT
mnemo1
GE
mnemo1
LE
mnemo1
GT
mnemo1
NO
END
ORTool
MODULE
Rectangles
NW
IMPORT
SYSTEM
Display
Files
Input
Texts
Oberon
Graphics
GraphicFrames
TYPE
Rectangle
POINTER
TO
RectDesc
RectDesc
RECORD
Graphics
ObjectDesc
lw
vers
INTEGER
END
VAR
method
Graphics
Method
tack
grey
INTEGER
PROCEDURE
New
VAR
r
Rectangle
BEGIN
NEW
r
r
do
method
Graphics
New
r
END
New
PROCEDURE
Copy
src
dst
Graphics
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Rectangle
lw
src
Rectangle
lw
dst
Rectangle
vers
src
Rectangle
vers
END
Copy
PROCEDURE
mark
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
GraphicFrames
ReplConst
f
col
x
y
END
mark
PROCEDURE
Draw
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
lw
col
INTEGER
f
GraphicFrames
Frame
PROCEDURE
draw
f
GraphicFrames
Frame
col
x
y
w
h
lw
INTEGER
BEGIN
GraphicFrames
ReplConst
f
col
x
y
w
lw
Display
replace
GraphicFrames
ReplConst
f
col
x
w
lw
y
lw
h
Display
replace
GraphicFrames
ReplConst
f
col
x
y
h
lw
w
lw
Display
replace
GraphicFrames
ReplConst
f
col
x
y
lw
h
Display
replace
END
draw
BEGIN
CASE
M
OF
GraphicFrames
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
lw
obj
Rectangle
lw
IF
x
f
X1
x
w
f
X
y
f
Y1
y
h
f
Y
THEN
IF
M
col
Display
black
THEN
col
obj
col
ELSE
col
M
col
END
IF
M
mode
THEN
draw
f
col
x
y
w
h
lw
IF
obj
selected
THEN
mark
f
Display
white
x
y
END
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
normal
selected
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
selected
normal
ELSIF
M
mode
THEN
draw
f
Display
black
x
y
w
h
lw
mark
f
Display
black
x
y
erase
END
END
END
END
Draw
PROCEDURE
Selectable
obj
Graphics
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
y
y
y
obj
y
END
Selectable
PROCEDURE
Change
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x0
y0
x1
y1
dx
dy
INTEGER
k
SET
BEGIN
CASE
M
OF
Graphics
WidMsg
obj
Rectangle
lw
M
w
Graphics
ColorMsg
obj
col
M
col
END
END
Change
PROCEDURE
Read
obj
Graphics
Object
VAR
R
Files
Rider
VAR
C
Graphics
Context
VAR
b
BYTE
len
INTEGER
BEGIN
Files
ReadByte
R
b
len
Files
ReadByte
R
b
obj
Rectangle
lw
b
Files
ReadByte
R
b
obj
Rectangle
vers
b
END
Read
PROCEDURE
Write
obj
Graphics
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Graphics
Context
BEGIN
Graphics
WriteObj
W
cno
obj
Files
WriteByte
W
Files
WriteByte
W
obj
Rectangle
lw
Files
WriteByte
W
obj
Rectangle
vers
END
Write
PROCEDURE
Print
obj
Graphics
Object
x
y
INTEGER
VAR
w
h
lw
s
INTEGER
BEGIN
INC
x
obj
x
INC
y
obj
y
w
obj
w
h
obj
h
lw
obj
Rectangle
lw
s
obj
Rectangle
vers
Printer
ReplConst
x
y
w
lw
Printer
ReplConst
x
w
lw
y
lw
h
Printer
ReplConst
x
y
h
lw
w
lw
Printer
ReplConst
x
y
lw
h
IF
s
THEN
Printer
ReplPattern
x
y
w
h
s
END
END
Print
PROCEDURE
Make
command
VAR
x0
x1
y0
y1
INTEGER
R
Rectangle
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
x1
G
mark
next
x
y1
G
mark
next
y
NEW
R
R
col
Oberon
CurCol
R
w
ABS
x1
x0
R
h
ABS
y1
y0
IF
x1
x0
THEN
x0
x1
END
IF
y1
y0
THEN
y0
y1
END
R
x
x0
G
x
R
y
y0
G
y
R
lw
Graphics
width
R
vers
R
do
method
Graphics
Add
G
graph
R
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
R
END
END
Make
BEGIN
NEW
method
method
module
Rectangles
method
allocator
New
method
new
New
method
copy
Copy
method
draw
Draw
method
selectable
Selectable
method
change
Change
method
read
Read
method
write
Write
method
print
Print
tack
SYSTEM
ADR
grey
SYSTEM
ADR
END
Rectangles
MODULE
SCC
NW
Ceres
nRF24L01
version
PR
IMPORT
SYSTEM
Kernel
CONST
swi
spiData
spiCtrl
netSelect
spiFast
netEnable
HdrSize
MaxPayload
SubPacket
Wait
SendTries
MaxPacket
HdrSize
MaxPayload
SubPacket
DIV
SubPacket
SubPacket
TYPE
Header
RECORD
valid
BOOLEAN
dadr
sadr
typ
BYTE
len
INTEGER
of
data
following
header
END
VAR
filter
BOOLEAN
Adr
BYTE
rcvd
INTEGER
rx
RECORD
hd
Header
dat
ARRAY
MaxPacket
HdrSize
OF
BYTE
END
PROCEDURE
SPICtrl
s
SET
BEGIN
SYSTEM
PUT
spiCtrl
s
IF
netEnable
IN
s
THEN
LED
55H
ELSE
LED
END
END
SPICtrl
PROCEDURE
SPI
n
INTEGER
BEGIN
send
rcv
into
shift
reg
one
byte
or
word
at
current
speed
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
wait
until
done
END
SPI
PROCEDURE
StartCmd
cmd
INTEGER
BEGIN
SPICtrl
netSelect
SPI
cmd
END
StartCmd
PROCEDURE
WriteReg1
reg
dat
INTEGER
disables
radio
BEGIN
StartCmd
reg
20H
SPI
dat
SPICtrl
W
REGISTER
END
WriteReg1
PROCEDURE
SubRcv
dst
INTEGER
VAR
i
dat
INTEGER
BEGIN
StartCmd
061H
R
RX
PAYLOAD
disables
radio
SPICtrl
netSelect
spiFast
FOR
i
TO
SubPacket
BY
DO
SPI
SYSTEM
GET
spiData
dat
SYSTEM
PUT
dst
i
dat
END
SPICtrl
WriteReg1
40H
done
STATUS
clear
RX
DR
SPICtrl
netEnable
enable
radio
END
SubRcv
PROCEDURE
SubSnd
src
INTEGER
VAR
timeout
BOOLEAN
VAR
i
dat
res
t1
try
INTEGER
x
status
BYTE
BEGIN
already
in
xmit
mode
StartCmd
0A0H
W
TX
PAYLOAD
SPICtrl
netSelect
spiFast
FOR
i
TO
SubPacket
BY
DO
SYSTEM
GET
src
i
dat
SPI
dat
END
SPICtrl
end
W
TX
PAYLOAD
command
try
SPICtrl
netEnable
netSelect
start
xmit
pulse
start
NOP
cmd
REPEAT
t1
Kernel
Time
Wait
REPEAT
wait
for
sent
or
retransmits
exceeded
SPI
0FFH
SYSTEM
GET
spiData
status
NOP
res
status
DIV
10H
MOD
SPICtrl
SPICtrl
netSelect
end
restart
NOP
cmd
end
10us
pulse
on
enable
UNTIL
res
IF
res
THEN
WriteReg1
20H
TX
DS
sent
ack
received
reset
it
ELSIF
res
THEN
WriteReg1
10H
INC
try
MAX
RT
retransmits
exceeded
reset
it
IF
try
SendTries
THEN
res
ELSE
REPEAT
UNTIL
Kernel
Time
t1
SPICtrl
netEnable
netSelect
start
xmit
pulse
start
NOP
cmd
again
END
END
UNTIL
res
timeout
res
END
SubSnd
PROCEDURE
Flush
BEGIN
StartCmd
0E1H
SPICtrl
StartCmd
0E2H
SPICtrl
FLUSH
TX
FLUSH
RX
END
Flush
PROCEDURE
ResetRcv
BEGIN
SYSTEM
PUT
SYSTEM
ADR
rx
rx
hd
len
rcvd
END
ResetRcv
PROCEDURE
Listen
b
BOOLEAN
BEGIN
WriteReg1
07EH
ORD
b
CONFIG
mask
ints
EN
CRC
byte
PWR
UP
PRX
PTX
WriteReg1
70H
STATUS
clear
ints
IF
b
THEN
SPICtrl
netEnable
END
turn
radio
on
END
Listen
PROCEDURE
Start
filt
BOOLEAN
VAR
n
INTEGER
BEGIN
filter
filt
Adr
SYSTEM
GET
swi
n
n
n
DIV
MOD
10H
WriteReg1
n
RF
CH
channel
WriteReg1
07H
RF
SETUP
1Mb
for
better
range
0dBm
WriteReg1
11H
SubPacket
RX
PW
P0
pipe
payload
width
Flush
Listen
TRUE
ResetRcv
END
Start
PROCEDURE
SendPacket
VAR
head
Header
dat
ARRAY
OF
BYTE
VAR
len
i
off
INTEGER
timeout
BOOLEAN
payload
ARRAY
SubPacket
OF
BYTE
BEGIN
let
any
receive
ack
finish
before
turning
radio
off
i
Kernel
Time
Wait
REPEAT
SPICtrl
netEnable
netSelect
SPI
0FFH
SPICtrl
netEnable
NOP
UNTIL
Kernel
Time
i
IF
Adr
THEN
Adr
i
MOD
100H
END
Listen
FALSE
head
sadr
Adr
head
valid
TRUE
SYSTEM
COPY
SYSTEM
ADR
head
SYSTEM
ADR
payload
HdrSize
DIV
i
HdrSize
off
len
head
len
WHILE
len
i
SubPacket
DO
payload
i
dat
off
INC
i
INC
off
DEC
len
END
WHILE
i
SubPacket
DO
payload
i
INC
i
END
SubSnd
SYSTEM
ADR
payload
timeout
WHILE
timeout
len
DO
i
send
the
rest
WHILE
len
i
SubPacket
DO
payload
i
dat
off
INC
i
INC
off
DEC
len
END
WHILE
i
SubPacket
DO
payload
i
INC
i
END
SubSnd
SYSTEM
ADR
payload
timeout
END
Listen
TRUE
END
SendPacket
PROCEDURE
Available
INTEGER
BEGIN
packet
already
rcvd
RETURN
rx
hd
len
rcvd
END
Available
PROCEDURE
Receive
VAR
x
BYTE
BEGIN
packet
already
rcvd
IF
rcvd
rx
hd
len
THEN
x
rx
dat
rcvd
INC
rcvd
ELSE
x
END
END
Receive
PROCEDURE
Rcvd
time
INTEGER
BOOLEAN
VAR
status
fifoStatus
BYTE
rcvd
BOOLEAN
BEGIN
time
time
Kernel
Time
REPEAT
SPICtrl
netEnable
netSelect
SPI
17H
R
REGISTER
FIFO
STATUS
SYSTEM
GET
spiData
status
SPI
SYSTEM
GET
spiData
fifoStatus
SPICtrl
netEnable
rcvd
ODD
status
DIV
40H
OR
ODD
fifoStatus
RX
DR
data
ready
or
RX
FIFO
not
empty
UNTIL
rcvd
OR
Kernel
Time
time
RETURN
rcvd
END
Rcvd
PROCEDURE
ReceiveHead
VAR
head
Header
actually
recv
whole
packet
VAR
adr
n
INTEGER
BEGIN
head
valid
FALSE
IF
Rcvd
THEN
ResetRcv
adr
SYSTEM
ADR
rx
SubRcv
adr
n
rx
hd
len
HdrSize
DIV
SubPacket
IF
rx
hd
len
MaxPayload
rx
hd
dadr
0FFH
OR
filter
OR
Adr
OR
rx
hd
dadr
Adr
THEN
WHILE
n
Rcvd
Wait
DO
INC
adr
SubPacket
SubRcv
adr
DEC
n
END
rx
hd
valid
n
ELSE
WHILE
Rcvd
Wait
DO
SubRcv
adr
END
ResetRcv
discard
packet
END
head
rx
hd
END
END
ReceiveHead
PROCEDURE
Skip
m
INTEGER
VAR
dmy
BYTE
BEGIN
WHILE
m
DO
Receive
dmy
DEC
m
END
END
Skip
PROCEDURE
Stop
BEGIN
SPICtrl
Flush
ResetRcv
END
Stop
BEGIN
Start
TRUE
END
SCC
MODULE
System
JG
NW
NW
IMPORT
SYSTEM
Kernel
FileDir
Files
Modules
Input
Display
Viewers
Fonts
Texts
Oberon
MenuViewers
TextFrames
CONST
StandardMenu
System
Close
System
Copy
System
Grow
Edit
Search
Edit
Store
LogMenu
Edit
Locate
Edit
Search
System
Copy
System
Grow
System
Clear
VAR
W
Texts
Writer
pat
ARRAY
OF
CHAR
PROCEDURE
GetArg
VAR
S
Texts
Scanner
VAR
T
Texts
Text
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
END
GetArg
PROCEDURE
EndLine
BEGIN
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
EndLine
Toolbox
for
system
control
PROCEDURE
SetUser
VAR
i
INTEGER
ch
CHAR
user
ARRAY
OF
CHAR
password
ARRAY
OF
CHAR
BEGIN
i
Input
Read
ch
WHILE
ch
i
DO
user
i
ch
INC
i
Input
Read
ch
END
user
i
0X
i
Input
Read
ch
WHILE
ch
i
DO
password
i
ch
INC
i
Input
Read
ch
END
password
i
0X
Oberon
SetUser
user
password
END
SetUser
PROCEDURE
SetFont
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Oberon
SetFont
Fonts
This
S
s
END
END
SetFont
PROCEDURE
SetColor
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
Oberon
SetColor
S
i
END
END
SetColor
PROCEDURE
SetOffset
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
Oberon
SetOffset
S
i
END
END
SetOffset
PROCEDURE
Date
VAR
S
Texts
Scanner
dt
hr
min
sec
yr
mo
day
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
set
clock
day
S
i
Texts
Scan
S
mo
S
i
Texts
Scan
S
yr
S
i
Texts
Scan
S
hr
S
i
Texts
Scan
S
min
S
i
Texts
Scan
S
sec
S
i
dt
yr
mo
day
hr
min
sec
Kernel
SetClock
dt
ELSE
read
clock
Texts
WriteString
W
System
Clock
dt
Oberon
Clock
Texts
WriteClock
W
dt
EndLine
END
END
Date
PROCEDURE
Collect
BEGIN
Oberon
Collect
END
Collect
Toolbox
for
standard
display
PROCEDURE
Open
open
viewer
in
system
track
VAR
X
Y
INTEGER
V
Viewers
Viewer
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Clear
clear
Log
VAR
T
Texts
Text
F
Display
Frame
buf
Texts
Buffer
BEGIN
F
Oberon
Par
frame
IF
F
NIL
F
next
IS
TextFrames
Frame
F
Oberon
Par
vwr
dsc
THEN
NEW
buf
Texts
OpenBuf
buf
T
F
next
TextFrames
Frame
text
Texts
Delete
T
T
len
buf
END
END
Clear
PROCEDURE
Close
VAR
V
Viewers
Viewer
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
V
Oberon
Par
vwr
ELSE
V
Oberon
MarkedViewer
END
Viewers
Close
V
END
Close
PROCEDURE
CloseTrack
VAR
V
Viewers
Viewer
BEGIN
V
Oberon
MarkedViewer
Viewers
CloseTrack
V
X
END
CloseTrack
PROCEDURE
Recall
VAR
V
Viewers
Viewer
M
Viewers
ViewerMsg
BEGIN
Viewers
Recall
V
IF
V
NIL
V
state
THEN
Viewers
Open
V
V
X
V
Y
V
H
M
id
Viewers
restore
V
handle
V
M
END
END
Recall
PROCEDURE
Copy
VAR
V
V1
Viewers
Viewer
M
Oberon
CopyMsg
N
Viewers
ViewerMsg
BEGIN
V
Oberon
Par
vwr
V
handle
V
M
V1
M
F
Viewers
Viewer
Viewers
Open
V1
V
X
V
Y
V
H
DIV
N
id
Viewers
restore
V1
handle
V1
N
END
Copy
PROCEDURE
Grow
VAR
V
V1
Viewers
Viewer
M
Oberon
CopyMsg
N
Viewers
ViewerMsg
DW
DH
INTEGER
BEGIN
V
Oberon
Par
vwr
DW
Oberon
DisplayWidth
V
X
DH
Oberon
DisplayHeight
V
X
IF
V
H
DH
Viewers
minH
THEN
Oberon
OpenTrack
V
X
V
W
ELSIF
V
W
DW
THEN
Oberon
OpenTrack
Oberon
UserTrack
V
X
DW
END
IF
V
H
DH
Viewers
minH
OR
V
W
DW
THEN
V
handle
V
M
V1
M
F
Viewers
Viewer
Viewers
Open
V1
V
X
DH
N
id
Viewers
restore
V1
handle
V1
N
END
END
Grow
Toolbox
for
module
management
PROCEDURE
Free1
VAR
S
Texts
Scanner
BEGIN
Texts
WriteString
W
S
s
Texts
WriteString
W
unloading
Modules
Free
S
s
IF
Modules
res
THEN
Texts
WriteString
W
failed
END
EndLine
END
Free1
PROCEDURE
Free
VAR
T
Texts
Text
beg
end
time
LONGINT
S
Texts
Scanner
BEGIN
Texts
WriteString
W
System
Free
EndLine
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Free1
S
END
END
ELSE
WHILE
S
class
Texts
Name
DO
Free1
S
Texts
Scan
S
END
END
Oberon
Collect
END
Free
PROCEDURE
FreeFonts
BEGIN
Texts
WriteString
W
System
FreeFonts
Fonts
Free
EndLine
END
FreeFonts
Toolbox
of
file
system
PROCEDURE
List
name
FileDir
FileName
adr
LONGINT
VAR
cont
BOOLEAN
VAR
i0
i
j0
j
INTEGER
hp
FileDir
FileHeader
BEGIN
i
WHILE
pat
i
pat
i
name
i
DO
INC
i
END
IF
pat
i
0X
name
i
0X
THEN
i0
i
j0
i
ELSIF
pat
i
THEN
i0
i
j0
i
WHILE
name
i0
0X
DO
i
i0
j
j0
WHILE
name
i
0X
name
i
pat
j
DO
INC
i
INC
j
END
IF
pat
j
0X
THEN
IF
name
i
0X
THEN
match
j0
j
ELSE
INC
i0
END
ELSIF
pat
j
THEN
i0
i
j0
j
ELSE
INC
i0
END
END
END
IF
name
i0
0X
pat
j0
0X
THEN
found
Texts
WriteString
W
name
IF
pat
j0
THEN
option
Kernel
GetSector
adr
hp
Texts
Write
W
9X
Texts
WriteClock
W
hp
date
Texts
WriteInt
W
hp
aleng
FileDir
SectorSize
hp
bleng
FileDir
HeaderSize
length
Texts
WriteHex
W
adr
END
Texts
WriteLn
W
END
END
List
PROCEDURE
Directory
VAR
X
Y
i
INTEGER
ch
CHAR
R
Texts
Reader
T
t
Texts
Text
V
Viewers
Viewer
beg
end
time
LONGINT
pre
ARRAY
OF
CHAR
BEGIN
Texts
OpenReader
R
Oberon
Par
text
Oberon
Par
pos
Texts
Read
R
ch
WHILE
ch
DO
Texts
Read
R
ch
END
IF
ch
OR
ch
0DX
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenReader
R
T
beg
Texts
Read
R
ch
WHILE
ch
DO
Texts
Read
R
ch
END
END
END
i
WHILE
ch
DO
pat
i
ch
INC
i
Texts
Read
R
ch
END
pat
i
0X
IF
ch
THEN
pat
i
END
directory
option
i
WHILE
pat
i
DO
pre
i
pat
i
INC
i
END
pre
i
0X
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
t
TextFrames
Text
V
MenuViewers
New
TextFrames
NewMenu
System
Directory
StandardMenu
TextFrames
NewText
t
TextFrames
menuH
X
Y
FileDir
Enumerate
pre
List
Texts
Append
t
W
buf
END
Directory
PROCEDURE
CopyFiles
VAR
f
g
Files
File
Rf
Rg
Files
Rider
ch
CHAR
name
ARRAY
OF
CHAR
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
CopyFiles
EndLine
WHILE
S
class
Texts
Name
DO
name
S
s
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteString
W
copying
Texts
Append
Oberon
Log
W
buf
f
Files
Old
name
IF
f
NIL
THEN
g
Files
New
S
s
Files
Set
Rf
f
Files
Set
Rg
g
Files
Read
Rf
ch
WHILE
Rf
eof
DO
Files
Write
Rg
ch
Files
Read
Rf
ch
END
Files
Register
g
ELSE
Texts
WriteString
W
failed
END
EndLine
END
END
END
Texts
Scan
S
END
END
CopyFiles
PROCEDURE
RenameFiles
VAR
res
INTEGER
name
ARRAY
OF
CHAR
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
RenameFiles
EndLine
WHILE
S
class
Texts
Name
DO
name
S
s
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteString
W
renaming
Files
Rename
name
S
s
res
IF
res
THEN
Texts
WriteString
W
failed
END
EndLine
END
END
END
Texts
Scan
S
END
END
RenameFiles
PROCEDURE
DeleteFiles
VAR
res
INTEGER
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
DeleteFiles
EndLine
WHILE
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
Texts
WriteString
W
deleting
Files
Delete
S
s
res
IF
res
THEN
Texts
WriteString
W
failed
END
EndLine
Texts
Scan
S
END
END
DeleteFiles
Toolbox
for
system
inspection
PROCEDURE
Watch
BEGIN
Texts
WriteString
W
System
Watch
Texts
WriteLn
W
Texts
WriteString
W
Modules
space
bytes
Texts
WriteInt
W
Modules
AllocPtr
Texts
WriteInt
W
Modules
AllocPtr
DIV
Kernel
heapOrg
Texts
Write
W
EndLine
Texts
WriteString
W
Heap
speace
Texts
WriteInt
W
Kernel
allocated
Texts
WriteInt
W
Kernel
allocated
DIV
Kernel
heapLim
Kernel
heapOrg
Texts
Write
W
EndLine
Texts
WriteString
W
Disk
sectors
Texts
WriteInt
W
Kernel
NofSectors
Texts
WriteInt
W
Kernel
NofSectors
DIV
10000H
Texts
Write
W
EndLine
Texts
WriteString
W
Tasks
Texts
WriteInt
W
Oberon
NofTasks
EndLine
END
Watch
PROCEDURE
ShowModules
VAR
T
Texts
Text
V
Viewers
Viewer
M
Modules
Module
X
Y
INTEGER
BEGIN
T
TextFrames
Text
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
System
ShowModules
StandardMenu
TextFrames
NewText
T
TextFrames
menuH
X
Y
M
Modules
root
WHILE
M
NIL
DO
IF
M
name
0X
THEN
Texts
WriteString
W
M
name
Texts
Write
W
9X
Texts
WriteHex
W
ORD
M
Texts
WriteHex
W
M
code
Texts
WriteInt
W
M
refcnt
ELSE
Texts
WriteString
W
END
Texts
WriteLn
W
M
M
next
END
Texts
Append
T
W
buf
END
ShowModules
PROCEDURE
ShowCommands
VAR
M
Modules
Module
comadr
LONGINT
ch
CHAR
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
X
Y
INTEGER
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Modules
Load
S
s
M
IF
M
NIL
THEN
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
T
TextFrames
Text
V
MenuViewers
New
TextFrames
NewMenu
System
Commands
StandardMenu
TextFrames
NewText
T
TextFrames
menuH
X
Y
comadr
M
cmd
SYSTEM
GET
comadr
ch
INC
comadr
WHILE
ch
0X
DO
Texts
WriteString
W
S
s
Texts
Write
W
REPEAT
Texts
Write
W
ch
SYSTEM
GET
comadr
ch
INC
comadr
UNTIL
ch
0X
WHILE
comadr
MOD
DO
INC
comadr
END
Texts
WriteLn
W
INC
comadr
SYSTEM
GET
comadr
ch
INC
comadr
END
Texts
Append
T
W
buf
END
END
END
ShowCommands
PROCEDURE
ShowFonts
VAR
fnt
Fonts
Font
BEGIN
Texts
WriteString
W
System
ShowFonts
Texts
WriteLn
W
fnt
Fonts
root
WHILE
fnt
NIL
DO
Texts
Write
W
9X
Texts
WriteString
W
fnt
name
Texts
WriteLn
W
fnt
fnt
next
END
Texts
Append
Oberon
Log
W
buf
END
ShowFonts
PROCEDURE
OpenViewers
VAR
logV
toolV
Viewers
Viewer
menu
main
Display
Frame
d
LONGINT
X
Y
INTEGER
BEGIN
d
Kernel
Clock
Texts
WriteString
W
Oberon
V5
NW
EndLine
Oberon
AllocateSystemViewer
X
Y
menu
TextFrames
NewMenu
System
Log
LogMenu
main
TextFrames
NewText
Oberon
Log
logV
MenuViewers
New
menu
main
TextFrames
menuH
X
Y
Oberon
AllocateSystemViewer
X
Y
menu
TextFrames
NewMenu
System
Tool
StandardMenu
main
TextFrames
NewText
TextFrames
Text
System
Tool
toolV
MenuViewers
New
menu
main
TextFrames
menuH
X
Y
END
OpenViewers
PROCEDURE
ExtendDisplay
VAR
V
Viewers
Viewer
X
Y
DX
DW
DH
INTEGER
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
DX
Viewers
curW
DW
Oberon
DisplayWidth
DX
DH
Oberon
DisplayHeight
DX
Oberon
OpenDisplay
DW
DIV
DW
DIV
DH
Oberon
AllocateSystemViewer
DX
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
ExtendDisplay
PROCEDURE
Trap
VAR
a
INTEGER
b
INTEGER
VAR
u
v
w
INTEGER
mod
Modules
Module
BEGIN
u
SYSTEM
REG
SYSTEM
GET
u
v
w
v
DIV
10H
MOD
10H
trap
number
IF
w
THEN
Kernel
New
a
b
ELSE
trap
Texts
WriteLn
W
Texts
WriteString
W
pos
Texts
WriteInt
W
v
DIV
100H
MOD
10000H
Texts
WriteString
W
TRAP
Texts
WriteInt
W
w
mod
Modules
root
WHILE
mod
NIL
u
mod
code
OR
u
mod
imp
DO
mod
mod
next
END
IF
mod
NIL
THEN
Texts
WriteString
W
in
Texts
WriteString
W
mod
name
END
Texts
WriteString
W
at
Texts
WriteHex
W
u
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Oberon
Reset
END
END
Trap
PROCEDURE
Abort
VAR
n
INTEGER
BEGIN
n
SYSTEM
REG
Texts
WriteString
W
ABORT
Texts
WriteHex
W
n
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Oberon
Reset
END
Abort
BEGIN
Texts
OpenWriter
W
Oberon
OpenLog
TextFrames
Text
OpenViewers
Kernel
Install
SYSTEM
ADR
Trap
20H
Kernel
Install
SYSTEM
ADR
Abort
END
System
MODULE
TextFrames
JG
NW
IMPORT
Modules
Input
Display
Viewers
Fonts
Texts
Oberon
MenuViewers
CONST
replace
insert
delete
unmark
message
id
BS
8X
TAB
9X
CR
0DX
DEL
7FX
TYPE
Line
POINTER
TO
LineDesc
LineDesc
RECORD
len
LONGINT
wid
INTEGER
eot
BOOLEAN
next
Line
END
Location
RECORD
org
pos
LONGINT
dx
x
y
INTEGER
lin
Line
END
Frame
POINTER
TO
FrameDesc
FrameDesc
RECORD
Display
FrameDesc
text
Texts
Text
org
LONGINT
col
INTEGER
lsp
INTEGER
left
right
top
bot
INTEGER
markH
INTEGER
time
LONGINT
hasCar
hasSel
hasMark
BOOLEAN
carloc
Location
selbeg
selend
Location
trailer
Line
END
UpdateMsg
RECORD
Display
FrameMsg
id
INTEGER
text
Texts
Text
beg
end
LONGINT
END
CopyOverMsg
RECORD
Display
FrameMsg
text
Texts
Text
beg
end
LONGINT
END
VAR
TBuf
DelBuf
Texts
Buffer
menuH
barW
left
right
top
bot
lsp
INTEGER
standard
sizes
asr
dsr
selH
markW
eolW
INTEGER
nextCh
CHAR
ScrollMarker
Oberon
Marker
W
KW
Texts
Writer
keyboard
writer
PROCEDURE
Min
i
j
INTEGER
INTEGER
BEGIN
IF
i
j
THEN
j
i
END
RETURN
j
END
Min
display
support
PROCEDURE
ReplConst
col
INTEGER
F
Frame
X
Y
W
H
INTEGER
mode
INTEGER
BEGIN
IF
X
W
F
X
F
W
THEN
Display
ReplConst
col
X
Y
W
H
mode
ELSIF
X
F
X
F
W
THEN
Display
ReplConst
col
X
Y
F
X
F
W
X
H
mode
END
END
ReplConst
PROCEDURE
FlipSM
X
Y
INTEGER
VAR
DW
DH
CL
INTEGER
BEGIN
DW
Display
Width
DH
Display
Height
CL
DW
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
updown
X
Y
Display
invert
END
FlipSM
PROCEDURE
UpdateMark
F
Frame
in
scroll
bar
VAR
oldH
INTEGER
BEGIN
oldH
F
markH
F
markH
F
org
F
H
DIV
F
text
len
IF
F
hasMark
F
left
barW
F
markH
oldH
THEN
Display
ReplConst
Display
white
F
X
F
Y
F
H
oldH
markW
Display
invert
Display
ReplConst
Display
white
F
X
F
Y
F
H
F
markH
markW
Display
invert
END
END
UpdateMark
PROCEDURE
SetChangeMark
F
Frame
on
BOOLEAN
in
corner
BEGIN
IF
F
H
menuH
THEN
IF
on
THEN
Display
CopyPattern
Display
white
Display
block
F
X
F
W
F
Y
F
H
Display
paint
ELSE
Display
ReplConst
F
col
F
X
F
W
F
Y
F
H
Display
replace
END
END
END
SetChangeMark
PROCEDURE
Width
VAR
R
Texts
Reader
len
LONGINT
INTEGER
VAR
patadr
pos
LONGINT
ox
dx
x
y
w
h
INTEGER
BEGIN
pos
ox
WHILE
pos
len
DO
Fonts
GetPat
R
fnt
nextCh
dx
x
y
w
h
patadr
ox
ox
dx
INC
pos
Texts
Read
R
nextCh
END
RETURN
ox
END
Width
PROCEDURE
DisplayLine
F
Frame
L
Line
VAR
R
Texts
Reader
X
Y
INTEGER
len
LONGINT
VAR
patadr
NX
dx
x
y
w
h
INTEGER
BEGIN
NX
F
X
F
W
WHILE
nextCh
CR
R
fnt
NIL
DO
Fonts
GetPat
R
fnt
nextCh
dx
x
y
w
h
patadr
IF
X
x
w
NX
h
THEN
Display
CopyPattern
R
col
patadr
X
x
Y
y
Display
invert
END
X
X
dx
INC
len
Texts
Read
R
nextCh
END
L
len
len
L
wid
X
eolW
F
X
F
left
L
eot
R
fnt
NIL
Texts
Read
R
nextCh
END
DisplayLine
PROCEDURE
Validate
T
Texts
Text
VAR
pos
LONGINT
VAR
R
Texts
Reader
BEGIN
IF
pos
T
len
THEN
pos
T
len
ELSIF
pos
THEN
DEC
pos
Texts
OpenReader
R
T
pos
REPEAT
Texts
Read
R
nextCh
INC
pos
UNTIL
R
eot
OR
nextCh
CR
ELSE
pos
END
END
Validate
PROCEDURE
Mark
F
Frame
on
BOOLEAN
BEGIN
IF
F
H
F
left
barW
F
hasMark
on
OR
F
hasMark
on
THEN
Display
ReplConst
Display
white
F
X
F
Y
F
H
F
markH
markW
Display
invert
END
F
hasMark
on
END
Mark
PROCEDURE
Restore
F
Frame
VAR
R
Texts
Reader
L
l
Line
curY
botY
INTEGER
BEGIN
Display
ReplConst
F
col
F
X
F
Y
F
W
F
H
Display
replace
IF
F
left
barW
THEN
Display
ReplConst
Display
white
F
X
barW
F
Y
F
H
Display
invert
END
Validate
F
text
F
org
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
F
org
Texts
Read
R
nextCh
L
F
trailer
curY
F
Y
F
H
F
top
asr
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
F
markH
F
org
F
H
DIV
F
text
len
END
Restore
PROCEDURE
Suspend
F
Frame
BEGIN
F
trailer
next
F
trailer
END
Suspend
PROCEDURE
Extend
F
Frame
newY
INTEGER
VAR
R
Texts
Reader
L
l
Line
org
LONGINT
curY
botY
INTEGER
BEGIN
Display
ReplConst
F
col
F
X
newY
F
W
F
Y
newY
Display
replace
IF
F
left
barW
THEN
Display
ReplConst
Display
white
F
X
barW
newY
F
Y
newY
Display
invert
END
botY
F
Y
F
bot
dsr
F
H
F
H
F
Y
newY
F
Y
newY
IF
F
trailer
next
F
trailer
THEN
Validate
F
text
F
org
END
L
F
trailer
org
F
org
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
org
org
L
len
curY
curY
lsp
END
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
F
markH
F
org
F
H
DIV
F
text
len
END
Extend
PROCEDURE
Reduce
F
Frame
newY
INTEGER
VAR
L
Line
curY
botY
INTEGER
BEGIN
F
H
F
H
F
Y
newY
F
Y
newY
botY
F
Y
F
bot
dsr
L
F
trailer
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
curY
curY
lsp
END
L
next
F
trailer
IF
curY
asr
F
Y
THEN
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
asr
F
Y
Display
replace
END
F
markH
F
org
F
H
DIV
F
text
len
Mark
F
TRUE
END
Reduce
PROCEDURE
Show
F
Frame
pos
LONGINT
VAR
R
Texts
Reader
L
L0
Line
org
LONGINT
curY
botY
Y0
INTEGER
BEGIN
IF
F
trailer
next
F
trailer
THEN
Validate
F
text
pos
IF
pos
F
org
THEN
Mark
F
FALSE
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
F
H
Display
replace
botY
F
Y
F
Y
F
Y
F
H
F
H
F
org
pos
F
trailer
next
F
trailer
Extend
F
botY
Mark
F
TRUE
ELSIF
pos
F
org
THEN
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
org
pos
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
org
pos
THEN
F
org
org
F
trailer
next
L
Y0
curY
WHILE
L
next
F
trailer
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
Display
CopyBlock
F
X
F
left
curY
dsr
F
W
F
left
Y0
asr
curY
dsr
F
X
F
left
curY
dsr
F
Y
F
H
F
top
asr
Y0
curY
curY
F
Y
F
H
F
top
asr
Y0
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
dsr
F
Y
Display
replace
botY
F
Y
F
bot
dsr
org
org
L
len
curY
curY
lsp
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
L0
DisplayLine
F
L0
R
F
X
F
left
curY
L
next
L0
L
L0
curY
curY
lsp
END
L
next
F
trailer
UpdateMark
F
ELSE
Mark
F
FALSE
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
F
H
Display
replace
botY
F
Y
F
Y
F
Y
F
H
F
H
F
org
pos
F
trailer
next
F
trailer
Extend
F
botY
Mark
F
TRUE
END
END
END
SetChangeMark
F
F
text
changed
END
Show
PROCEDURE
LocateLine
F
Frame
y
INTEGER
VAR
loc
Location
VAR
L
Line
org
LONGINT
cury
INTEGER
BEGIN
org
F
org
L
F
trailer
next
cury
F
H
F
top
asr
WHILE
L
next
F
trailer
cury
y
dsr
DO
org
org
L
len
L
L
next
cury
cury
lsp
END
loc
org
org
loc
lin
L
loc
y
cury
END
LocateLine
PROCEDURE
LocateString
F
Frame
x
y
INTEGER
VAR
loc
Location
VAR
R
Texts
Reader
patadr
bpos
pos
lim
LONGINT
bx
ex
ox
dx
u
v
w
h
INTEGER
BEGIN
LocateLine
F
y
loc
lim
loc
org
loc
lin
len
bpos
loc
org
bx
F
left
pos
loc
org
ox
F
left
Texts
OpenReader
R
F
text
loc
org
Texts
Read
R
nextCh
REPEAT
WHILE
pos
lim
nextCh
DO
scan
string
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
END
ex
ox
WHILE
pos
lim
nextCh
DO
scan
gap
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
END
IF
pos
lim
ox
x
THEN
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
bpos
pos
bx
ox
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
ELSE
pos
lim
END
UNTIL
pos
lim
loc
pos
bpos
loc
dx
ex
bx
loc
x
bx
END
LocateString
PROCEDURE
LocateChar
F
Frame
x
y
INTEGER
VAR
loc
Location
VAR
R
Texts
Reader
patadr
pos
lim
LONGINT
ox
dx
u
v
w
h
INTEGER
BEGIN
LocateLine
F
y
loc
lim
loc
org
loc
lin
len
pos
loc
org
ox
F
left
dx
eolW
Texts
OpenReader
R
F
text
loc
org
WHILE
pos
lim
DO
Texts
Read
R
nextCh
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
IF
ox
dx
x
THEN
INC
pos
ox
ox
dx
IF
pos
lim
THEN
dx
eolW
END
ELSE
lim
pos
END
END
loc
pos
pos
loc
dx
dx
loc
x
ox
END
LocateChar
PROCEDURE
LocatePos
F
Frame
pos
LONGINT
VAR
loc
Location
VAR
T
Texts
Text
R
Texts
Reader
L
Line
org
LONGINT
cury
INTEGER
BEGIN
T
F
text
org
F
org
L
F
trailer
next
cury
F
H
F
top
asr
IF
pos
org
THEN
pos
org
END
WHILE
L
next
F
trailer
pos
org
L
len
DO
org
org
L
len
L
L
next
cury
cury
lsp
END
IF
pos
org
L
len
THEN
pos
org
L
len
END
Texts
OpenReader
R
T
org
Texts
Read
R
nextCh
loc
org
org
loc
pos
pos
loc
lin
L
loc
x
F
left
Width
R
pos
org
loc
y
cury
END
LocatePos
PROCEDURE
Pos
F
Frame
X
Y
INTEGER
LONGINT
VAR
loc
Location
BEGIN
LocateChar
F
X
F
X
Y
F
Y
loc
RETURN
loc
pos
END
Pos
PROCEDURE
FlipCaret
F
Frame
BEGIN
IF
F
carloc
x
F
W
F
carloc
y
F
carloc
x
F
W
THEN
Display
CopyPattern
Display
white
Display
hook
F
X
F
carloc
x
F
Y
F
carloc
y
Display
invert
END
END
FlipCaret
PROCEDURE
SetCaret
F
Frame
pos
LONGINT
BEGIN
LocatePos
F
pos
F
carloc
FlipCaret
F
F
hasCar
TRUE
END
SetCaret
PROCEDURE
TrackCaret
F
Frame
X
Y
INTEGER
VAR
keysum
SET
VAR
loc
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateChar
F
X
F
X
Y
F
Y
F
carloc
FlipCaret
F
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateChar
F
X
F
X
Y
F
Y
loc
IF
loc
pos
F
carloc
pos
THEN
FlipCaret
F
F
carloc
loc
FlipCaret
F
END
UNTIL
keys
F
hasCar
TRUE
END
END
TrackCaret
PROCEDURE
RemoveCaret
F
Frame
BEGIN
IF
F
hasCar
THEN
FlipCaret
F
F
hasCar
FALSE
END
END
RemoveCaret
PROCEDURE
FlipSelection
F
Frame
VAR
beg
end
Location
VAR
L
Line
Y
INTEGER
BEGIN
L
beg
lin
Y
F
Y
beg
y
IF
L
end
lin
THEN
ReplConst
Display
white
F
F
X
beg
x
Y
end
x
beg
x
selH
Display
invert
ELSE
ReplConst
Display
white
F
F
X
beg
x
Y
F
left
L
wid
beg
x
selH
Display
invert
L
L
next
Y
Y
lsp
WHILE
L
end
lin
DO
ReplConst
Display
white
F
F
X
F
left
Y
L
wid
selH
Display
invert
L
L
next
Y
Y
lsp
END
ReplConst
Display
white
F
F
X
F
left
Y
end
x
F
left
selH
Display
invert
END
END
FlipSelection
PROCEDURE
SetSelection
F
Frame
beg
end
LONGINT
BEGIN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
END
LocatePos
F
beg
F
selbeg
LocatePos
F
end
F
selend
IF
F
selbeg
pos
F
selend
pos
THEN
FlipSelection
F
F
selbeg
F
selend
F
time
Oberon
Time
F
hasSel
TRUE
END
END
SetSelection
PROCEDURE
TrackSelection
F
Frame
X
Y
INTEGER
VAR
keysum
SET
VAR
loc
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
END
LocateChar
F
X
F
X
Y
F
Y
loc
IF
F
hasSel
loc
pos
F
selbeg
pos
F
selend
pos
F
selbeg
pos
THEN
LocateChar
F
F
left
Y
F
Y
F
selbeg
ELSE
F
selbeg
loc
END
INC
loc
pos
loc
x
loc
x
loc
dx
F
selend
loc
FlipSelection
F
F
selbeg
F
selend
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateChar
F
X
F
X
Y
F
Y
loc
IF
loc
pos
F
selbeg
pos
THEN
loc
F
selbeg
END
INC
loc
pos
loc
x
loc
x
loc
dx
IF
loc
pos
F
selend
pos
THEN
FlipSelection
F
loc
F
selend
F
selend
loc
ELSIF
loc
pos
F
selend
pos
THEN
FlipSelection
F
F
selend
loc
F
selend
loc
END
UNTIL
keys
F
time
Oberon
Time
F
hasSel
TRUE
END
END
TrackSelection
PROCEDURE
RemoveSelection
F
Frame
BEGIN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
F
hasSel
FALSE
END
END
RemoveSelection
PROCEDURE
TrackLine
F
Frame
X
Y
INTEGER
VAR
org
LONGINT
VAR
keysum
SET
VAR
old
new
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateLine
F
Y
F
Y
old
ReplConst
Display
white
F
F
X
F
left
F
Y
old
y
dsr
old
lin
wid
Display
invert
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouse
ScrollMarker
X
Y
LocateLine
F
Y
F
Y
new
IF
new
org
old
org
THEN
ReplConst
Display
white
F
F
X
F
left
F
Y
old
y
dsr
old
lin
wid
Display
invert
ReplConst
Display
white
F
F
X
F
left
F
Y
new
y
dsr
new
lin
wid
Display
invert
old
new
END
UNTIL
keys
ReplConst
Display
white
F
F
X
F
left
F
Y
new
y
dsr
new
lin
wid
Display
invert
org
new
org
ELSE
org
END
END
TrackLine
PROCEDURE
TrackWord
F
Frame
X
Y
INTEGER
VAR
pos
LONGINT
VAR
keysum
SET
VAR
old
new
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateString
F
X
F
X
Y
F
Y
old
ReplConst
Display
white
F
F
X
old
x
F
Y
old
y
dsr
old
dx
Display
invert
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateString
F
X
F
X
Y
F
Y
new
IF
new
pos
old
pos
THEN
ReplConst
Display
white
F
F
X
old
x
F
Y
old
y
dsr
old
dx
Display
invert
ReplConst
Display
white
F
F
X
new
x
F
Y
new
y
dsr
new
dx
Display
invert
old
new
END
UNTIL
keys
ReplConst
Display
white
F
F
X
new
x
F
Y
new
y
dsr
new
dx
Display
invert
pos
new
pos
ELSE
pos
END
END
TrackWord
PROCEDURE
Replace
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
Line
org
len
LONGINT
curY
wid
INTEGER
BEGIN
IF
end
F
org
THEN
IF
beg
F
org
THEN
beg
F
org
END
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
len
beg
org
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
curY
dsr
L
wid
wid
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
wid
curY
len
org
org
L
len
L
L
next
curY
curY
lsp
WHILE
L
F
trailer
org
end
DO
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
curY
org
org
L
len
L
L
next
curY
curY
lsp
END
END
END
UpdateMark
F
END
Replace
PROCEDURE
Insert
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
L0
l
Line
org
len
LONGINT
curY
botY
Y0
Y1
Y2
dY
wid
INTEGER
BEGIN
IF
beg
F
org
THEN
F
org
F
org
end
beg
ELSE
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
len
beg
org
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
curY
dsr
L
wid
wid
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
wid
curY
len
org
org
L
len
curY
curY
lsp
Y0
curY
L0
L
next
WHILE
org
end
curY
botY
DO
NEW
l
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
org
org
L
len
curY
curY
lsp
END
IF
L0
L
next
THEN
Y1
curY
L
next
L0
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
curY
curY
lsp
END
L
next
F
trailer
dY
Y0
Y1
IF
Y1
curY
dY
THEN
Display
CopyBlock
F
X
F
left
curY
dY
lsp
dsr
F
W
F
left
Y1
curY
dY
F
X
F
left
curY
lsp
dsr
Y2
Y1
dY
ELSE
Y2
curY
END
curY
Y1
L
L0
WHILE
curY
Y2
DO
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
curY
L
L
next
curY
curY
lsp
END
END
END
END
UpdateMark
F
END
Insert
PROCEDURE
Delete
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
L0
l
Line
org
org0
len
LONGINT
curY
botY
Y0
Y1
wid
INTEGER
BEGIN
IF
end
F
org
THEN
F
org
F
org
end
beg
ELSE
IF
beg
F
org
THEN
F
trailer
next
len
F
trailer
next
len
F
org
beg
F
org
beg
END
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
botY
F
Y
F
bot
dsr
org0
org
L0
L
Y0
curY
WHILE
L
F
trailer
org
end
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
Y1
curY
Texts
OpenReader
R
F
text
org0
Texts
Read
R
nextCh
len
beg
org0
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
Y0
dsr
L0
wid
wid
lsp
Display
replace
DisplayLine
F
L0
R
F
X
F
left
wid
Y0
len
Y0
Y0
lsp
IF
L
L0
next
THEN
L0
next
L
L
L0
org
org0
L0
len
WHILE
L
next
F
trailer
DO
L
L
next
org
org
L
len
curY
curY
lsp
END
Display
CopyBlock
F
X
F
left
curY
lsp
dsr
F
W
F
left
Y1
curY
F
X
F
left
curY
lsp
dsr
Y0
Y1
curY
curY
Y0
Y1
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
lsp
F
Y
dsr
Display
replace
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
END
END
END
UpdateMark
F
END
Delete
PROCEDURE
Recall
VAR
B
Texts
Buffer
BEGIN
B
TBuf
NEW
TBuf
Texts
OpenBuf
TBuf
END
Recall
message
handling
PROCEDURE
RemoveMarks
F
Frame
BEGIN
RemoveCaret
F
RemoveSelection
F
END
RemoveMarks
PROCEDURE
NotifyDisplay
T
Texts
Text
op
INTEGER
beg
end
LONGINT
VAR
M
UpdateMsg
BEGIN
M
id
op
M
text
T
M
beg
beg
M
end
end
Viewers
Broadcast
M
END
NotifyDisplay
PROCEDURE
Call
F
Frame
pos
LONGINT
new
BOOLEAN
VAR
S
Texts
Scanner
res
INTEGER
BEGIN
Texts
OpenScanner
S
F
text
pos
Texts
Scan
S
IF
S
class
Texts
Name
S
line
THEN
Oberon
SetPar
F
F
text
pos
S
len
Oberon
Call
S
s
res
IF
res
THEN
Texts
WriteString
W
Call
error
Texts
WriteString
W
Modules
importing
IF
res
THEN
Texts
WriteString
W
module
not
found
ELSIF
res
THEN
Texts
WriteString
W
bad
version
ELSIF
res
THEN
Texts
WriteString
W
imports
Texts
WriteString
W
Modules
imported
Texts
WriteString
W
with
bad
key
ELSIF
res
THEN
Texts
WriteString
W
corrupted
obj
file
ELSIF
res
THEN
Texts
WriteString
W
command
not
found
ELSIF
res
THEN
Texts
WriteString
W
insufficient
space
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
END
Call
PROCEDURE
Write
F
Frame
ch
CHAR
fnt
Fonts
Font
col
voff
INTEGER
VAR
buf
Texts
Buffer
BEGIN
F
hasCar
IF
ch
BS
THEN
backspace
IF
F
carloc
pos
F
org
THEN
Texts
Delete
F
text
F
carloc
pos
F
carloc
pos
DelBuf
SetCaret
F
F
carloc
pos
END
ELSIF
ch
3X
THEN
ctrl
c
copy
IF
F
hasSel
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Save
F
text
F
selbeg
pos
F
selend
pos
TBuf
END
ELSIF
ch
16X
THEN
ctrl
v
paste
NEW
buf
Texts
OpenBuf
buf
Texts
Copy
TBuf
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
TBuf
len
ELSIF
ch
18X
THEN
ctrl
x
cut
IF
F
hasSel
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Delete
F
text
F
selbeg
pos
F
selend
pos
TBuf
END
ELSIF
20X
ch
ch
DEL
OR
ch
CR
OR
ch
TAB
THEN
KW
fnt
fnt
KW
col
col
KW
voff
voff
Texts
Write
KW
ch
Texts
Insert
F
text
F
carloc
pos
KW
buf
SetCaret
F
F
carloc
pos
END
END
Write
PROCEDURE
Defocus
F
Frame
BEGIN
RemoveCaret
F
END
Defocus
PROCEDURE
Neutralize
F
Frame
BEGIN
RemoveMarks
F
END
Neutralize
PROCEDURE
Modify
F
Frame
id
dY
Y
H
INTEGER
BEGIN
Mark
F
FALSE
RemoveMarks
F
SetChangeMark
F
FALSE
IF
id
MenuViewers
extend
THEN
IF
dY
THEN
Display
CopyBlock
F
X
F
Y
F
W
F
H
F
X
F
Y
dY
F
Y
F
Y
dY
END
Extend
F
Y
ELSIF
id
MenuViewers
reduce
THEN
Reduce
F
Y
dY
IF
dY
THEN
Display
CopyBlock
F
X
F
Y
F
W
F
H
F
X
Y
F
Y
Y
END
END
IF
F
H
THEN
Mark
F
TRUE
SetChangeMark
F
F
text
changed
END
END
Modify
PROCEDURE
Open
F
Frame
H
Display
Handler
T
Texts
Text
org
LONGINT
col
left
right
top
bot
lsp
INTEGER
VAR
L
Line
BEGIN
NEW
L
L
len
L
wid
L
eot
FALSE
L
next
L
F
handle
H
F
text
T
F
org
org
F
trailer
L
F
left
left
F
right
right
F
top
top
F
bot
bot
F
lsp
lsp
F
col
col
F
hasMark
FALSE
F
hasCar
FALSE
F
hasSel
FALSE
END
Open
PROCEDURE
Copy
F
Frame
VAR
F1
Frame
BEGIN
NEW
F1
Open
F1
F
handle
F
text
F
org
F
col
F
left
F
right
F
top
F
bot
F
lsp
END
Copy
PROCEDURE
CopyOver
F
Frame
text
Texts
Text
beg
end
LONGINT
VAR
buf
Texts
Buffer
BEGIN
IF
F
hasCar
THEN
NEW
buf
Texts
OpenBuf
buf
Texts
Save
text
beg
end
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
end
beg
END
END
CopyOver
PROCEDURE
GetSelection
F
Frame
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
BEGIN
IF
F
hasSel
THEN
IF
F
text
text
THEN
IF
F
selbeg
pos
beg
THEN
beg
F
selbeg
pos
END
leftmost
IF
F
time
time
THEN
end
F
selend
pos
time
F
time
END
last
selected
ELSIF
F
time
time
THEN
text
F
text
beg
F
selbeg
pos
end
F
selend
pos
time
F
time
END
END
END
GetSelection
PROCEDURE
Update
F
Frame
VAR
M
UpdateMsg
BEGIN
F
text
M
text
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
IF
M
id
replace
THEN
Replace
F
M
beg
M
end
ELSIF
M
id
insert
THEN
Insert
F
M
beg
M
end
ELSIF
M
id
delete
THEN
Delete
F
M
beg
M
end
END
SetChangeMark
F
F
text
changed
END
Update
PROCEDURE
Edit
F
Frame
X
Y
INTEGER
Keys
SET
VAR
M
CopyOverMsg
text
Texts
Text
buf
Texts
Buffer
v
Viewers
Viewer
beg
end
time
pos
LONGINT
keysum
SET
fnt
Fonts
Font
col
voff
INTEGER
BEGIN
IF
X
F
X
Min
F
left
barW
THEN
scroll
bar
Oberon
DrawMouse
ScrollMarker
X
Y
keysum
Keys
IF
Keys
THEN
ML
scroll
up
TrackLine
F
X
Y
pos
keysum
IF
pos
keysum
THEN
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
pos
END
ELSIF
Keys
THEN
MM
keysum
Keys
REPEAT
Input
Mouse
Keys
X
Y
keysum
keysum
Keys
Oberon
DrawMouse
ScrollMarker
X
Y
UNTIL
Keys
IF
keysum
THEN
IF
IN
keysum
THEN
pos
ELSIF
IN
keysum
THEN
pos
F
text
len
ELSE
pos
F
Y
F
H
Y
F
text
len
DIV
F
H
END
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
pos
END
ELSIF
Keys
THEN
MR
scroll
down
TrackLine
F
X
Y
pos
keysum
IF
keysum
THEN
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
F
org
pos
END
END
ELSE
text
area
Oberon
DrawMouseArrow
X
Y
IF
IN
Keys
THEN
MR
select
TrackSelection
F
X
Y
keysum
IF
F
hasSel
THEN
IF
keysum
THEN
MR
ML
delete
text
Oberon
GetSelection
text
beg
end
time
Texts
Delete
text
beg
end
TBuf
Oberon
PassFocus
Viewers
This
F
X
F
Y
SetCaret
F
beg
ELSIF
keysum
THEN
MR
MM
copy
to
caret
Oberon
GetSelection
text
beg
end
time
M
text
text
M
beg
beg
M
end
end
Oberon
FocusViewer
handle
Oberon
FocusViewer
M
END
END
ELSIF
IN
Keys
THEN
MM
call
TrackWord
F
X
Y
pos
keysum
IF
pos
IN
keysum
THEN
Call
F
pos
IN
keysum
END
ELSIF
IN
Keys
THEN
ML
set
caret
Oberon
PassFocus
Viewers
This
F
X
F
Y
TrackCaret
F
X
Y
keysum
IF
keysum
THEN
ML
MM
copy
from
selection
to
caret
Oberon
GetSelection
text
beg
end
time
IF
time
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Save
text
beg
end
TBuf
Texts
Insert
F
text
F
carloc
pos
TBuf
SetSelection
F
F
carloc
pos
F
carloc
pos
end
beg
SetCaret
F
F
carloc
pos
end
beg
ELSIF
TBuf
NIL
THEN
NEW
buf
Texts
OpenBuf
buf
Texts
Copy
TBuf
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
buf
len
END
ELSIF
keysum
THEN
ML
MR
copy
looks
Oberon
GetSelection
text
beg
end
time
IF
time
THEN
Texts
Attributes
F
text
F
carloc
pos
fnt
col
voff
IF
fnt
NIL
THEN
Texts
ChangeLooks
text
beg
end
fnt
col
voff
END
END
END
END
END
END
Edit
PROCEDURE
Handle
F
Display
Frame
VAR
M
Display
FrameMsg
VAR
F1
Frame
buf
Texts
Buffer
BEGIN
CASE
F
OF
Frame
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
Edit
F
M
X
M
Y
M
keys
ELSIF
M
id
Oberon
consume
THEN
IF
F
hasCar
THEN
Write
F
M
ch
M
fnt
M
col
M
voff
END
END
Oberon
ControlMsg
IF
M
id
Oberon
defocus
THEN
Defocus
F
ELSIF
M
id
Oberon
neutralize
THEN
Neutralize
F
END
Oberon
SelectionMsg
GetSelection
F
M
text
M
beg
M
end
M
time
Oberon
CopyMsg
Copy
F
F1
M
F
F1
MenuViewers
ModifyMsg
Modify
F
M
id
M
dY
M
Y
M
H
CopyOverMsg
CopyOver
F
M
text
M
beg
M
end
UpdateMsg
IF
F
text
M
text
THEN
Update
F
M
END
END
END
END
Handle
creation
PROCEDURE
Menu
name
commands
ARRAY
OF
CHAR
Texts
Text
VAR
T
Texts
Text
BEGIN
NEW
T
T
notify
NotifyDisplay
Texts
Open
T
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
commands
Texts
Append
T
W
buf
RETURN
T
END
Menu
PROCEDURE
Text
name
ARRAY
OF
CHAR
Texts
Text
VAR
T
Texts
Text
BEGIN
NEW
T
T
notify
NotifyDisplay
Texts
Open
T
name
RETURN
T
END
Text
PROCEDURE
NewMenu
name
commands
ARRAY
OF
CHAR
Frame
VAR
F
Frame
T
Texts
Text
BEGIN
NEW
F
T
Menu
name
commands
Open
F
Handle
T
Display
white
left
DIV
lsp
RETURN
F
END
NewMenu
PROCEDURE
NewText
text
Texts
Text
pos
LONGINT
Frame
VAR
F
Frame
BEGIN
NEW
F
Open
F
Handle
text
pos
Display
black
left
right
top
bot
lsp
RETURN
F
END
NewText
BEGIN
NEW
TBuf
NEW
DelBuf
Texts
OpenBuf
TBuf
Texts
OpenBuf
DelBuf
lsp
Fonts
Default
height
menuH
lsp
barW
menuH
left
barW
lsp
DIV
right
lsp
DIV
top
lsp
DIV
bot
lsp
DIV
asr
Fonts
Default
maxY
dsr
Fonts
Default
minY
selH
lsp
markW
lsp
DIV
eolW
lsp
DIV
ScrollMarker
Fade
FlipSM
ScrollMarker
Draw
FlipSM
Texts
OpenWriter
W
Texts
OpenWriter
KW
END
TextFrames
MODULE
Texts
JG
NW
IMPORT
Files
Fonts
CONST
scanner
symbol
classes
Inval
invalid
symbol
Name
name
s
length
len
String
literal
string
s
length
len
Int
integer
i
decimal
or
hexadecimal
Real
real
number
x
Char
special
character
c
TextBlock
TextTag
offset
run
run
len
AsciiCode
run
fnt
name
col
voff
len
TAB
9X
CR
0DX
maxD
TextTag
0F1X
replace
insert
delete
unmark
op
codes
TYPE
Piece
POINTER
TO
PieceDesc
PieceDesc
RECORD
f
Files
File
off
len
LONGINT
fnt
Fonts
Font
col
voff
INTEGER
prev
next
Piece
END
Text
POINTER
TO
TextDesc
Notifier
PROCEDURE
T
Text
op
INTEGER
beg
end
LONGINT
TextDesc
RECORD
len
LONGINT
changed
BOOLEAN
notify
Notifier
trailer
Piece
pce
Piece
cache
org
LONGINT
cache
END
Reader
RECORD
eot
BOOLEAN
fnt
Fonts
Font
col
voff
INTEGER
ref
Piece
org
LONGINT
off
LONGINT
rider
Files
Rider
END
Scanner
RECORD
Reader
nextCh
CHAR
line
class
INTEGER
i
LONGINT
x
REAL
y
LONGREAL
c
CHAR
len
INTEGER
s
ARRAY
OF
CHAR
END
Buffer
POINTER
TO
BufDesc
BufDesc
RECORD
len
LONGINT
header
last
Piece
END
Writer
RECORD
buf
Buffer
fnt
Fonts
Font
col
voff
INTEGER
rider
Files
Rider
END
VAR
TrailerFile
Files
File
Filing
PROCEDURE
Trailer
Piece
VAR
Q
Piece
BEGIN
NEW
Q
Q
f
TrailerFile
Q
off
Q
len
Q
fnt
NIL
Q
col
Q
voff
RETURN
Q
END
Trailer
PROCEDURE
Load
VAR
R
Files
Rider
T
Text
VAR
Q
q
p
Piece
off
LONGINT
N
fno
INTEGER
bt
BYTE
f
Files
File
FName
ARRAY
OF
CHAR
Dict
ARRAY
OF
Fonts
Font
BEGIN
f
Files
Base
R
N
Q
Trailer
p
Q
Files
ReadInt
R
off
Files
ReadByte
R
bt
fno
bt
WHILE
fno
DO
IF
fno
N
THEN
Files
ReadString
R
FName
Dict
N
Fonts
This
FName
INC
N
END
NEW
q
q
fnt
Dict
fno
Files
ReadByte
R
bt
q
col
bt
Files
ReadByte
R
bt
q
voff
ASR
LSL
bt
Files
ReadInt
R
q
len
Files
ReadByte
R
bt
fno
bt
q
f
f
q
off
off
off
off
q
len
p
next
q
q
prev
p
p
q
END
p
next
Q
Q
prev
p
T
trailer
Q
Files
ReadInt
R
T
len
Files
Set
R
f
Files
Pos
R
T
len
END
Load
PROCEDURE
Open
T
Text
name
ARRAY
OF
CHAR
VAR
f
Files
File
R
Files
Rider
Q
q
Piece
tag
CHAR
len
LONGINT
BEGIN
f
Files
Old
name
IF
f
NIL
THEN
Files
Set
R
f
Files
Read
R
tag
IF
tag
TextTag
THEN
Load
R
T
ELSE
Ascii
file
len
Files
Length
f
Q
Trailer
NEW
q
q
fnt
Fonts
Default
q
col
q
voff
q
f
f
q
off
q
len
len
Q
next
q
q
prev
Q
q
next
Q
Q
prev
q
T
trailer
Q
T
len
len
END
ELSE
create
new
text
Q
Trailer
Q
next
Q
Q
prev
Q
T
trailer
Q
T
len
END
T
changed
FALSE
T
org
T
pce
T
trailer
init
cache
END
Open
PROCEDURE
Store
VAR
W
Files
Rider
T
Text
VAR
p
q
Piece
R
Files
Rider
off
rlen
pos
LONGINT
N
n
INTEGER
ch
CHAR
Dict
ARRAY
OF
CHAR
BEGIN
pos
Files
Pos
W
Files
WriteInt
W
place
holder
N
p
T
trailer
next
WHILE
p
T
trailer
DO
rlen
p
len
q
p
next
WHILE
q
T
trailer
q
fnt
p
fnt
q
col
p
col
q
voff
p
voff
DO
rlen
rlen
q
len
q
q
next
END
Dict
N
p
fnt
name
n
WHILE
Dict
n
p
fnt
name
DO
INC
n
END
Files
WriteByte
W
n
IF
n
N
THEN
Files
WriteString
W
p
fnt
name
INC
N
END
Files
WriteByte
W
p
col
Files
WriteByte
W
p
voff
Files
WriteInt
W
rlen
p
q
END
Files
WriteByte
W
Files
WriteInt
W
T
len
off
Files
Pos
W
p
T
trailer
next
WHILE
p
T
trailer
DO
rlen
p
len
Files
Set
R
p
f
p
off
WHILE
rlen
DO
Files
Read
R
ch
Files
Write
W
ch
DEC
rlen
END
p
p
next
END
Files
Set
W
Files
Base
W
pos
Files
WriteInt
W
off
fixup
T
changed
FALSE
IF
T
notify
NIL
THEN
T
notify
T
unmark
END
END
Store
PROCEDURE
Close
T
Text
name
ARRAY
OF
CHAR
VAR
f
Files
File
w
Files
Rider
BEGIN
f
Files
New
name
Files
Set
w
f
Files
Write
w
TextTag
Store
w
T
Files
Register
f
END
Close
Editing
PROCEDURE
OpenBuf
B
Buffer
BEGIN
NEW
B
header
null
piece
B
last
B
header
B
len
END
OpenBuf
PROCEDURE
FindPiece
T
Text
pos
LONGINT
VAR
org
LONGINT
VAR
pce
Piece
VAR
p
Piece
porg
LONGINT
BEGIN
p
T
pce
porg
T
org
IF
pos
porg
THEN
WHILE
pos
porg
p
len
DO
INC
porg
p
len
p
p
next
END
ELSE
p
p
prev
DEC
porg
p
len
WHILE
pos
porg
DO
p
p
prev
DEC
porg
p
len
END
END
T
pce
p
T
org
porg
update
cache
pce
p
org
porg
END
FindPiece
PROCEDURE
SplitPiece
p
Piece
off
LONGINT
VAR
pr
Piece
VAR
q
Piece
BEGIN
IF
off
THEN
NEW
q
q
fnt
p
fnt
q
col
p
col
q
voff
p
voff
q
len
p
len
off
q
f
p
f
q
off
p
off
off
p
len
off
q
next
p
next
p
next
q
q
prev
p
q
next
prev
q
pr
q
ELSE
pr
p
END
END
SplitPiece
PROCEDURE
Save
T
Text
beg
end
LONGINT
B
Buffer
VAR
p
q
qb
qe
Piece
org
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
org
p
NEW
qb
qb
p
qb
len
qb
len
beg
org
qb
off
qb
off
beg
org
qe
qb
WHILE
end
org
p
len
DO
org
org
p
len
p
p
next
NEW
q
q
p
qe
next
q
q
prev
qe
qe
q
END
qe
next
NIL
qe
len
qe
len
org
p
len
end
B
last
next
qb
qb
prev
B
last
B
last
qe
B
len
B
len
end
beg
END
Save
PROCEDURE
Copy
SB
DB
Buffer
VAR
Q
q
p
Piece
BEGIN
p
SB
header
Q
DB
last
WHILE
p
SB
last
DO
p
p
next
NEW
q
q
p
Q
next
q
q
prev
Q
Q
q
END
DB
last
Q
DB
len
DB
len
SB
len
END
Copy
PROCEDURE
Insert
T
Text
pos
LONGINT
B
Buffer
VAR
pl
pr
p
qb
qe
Piece
org
end
LONGINT
BEGIN
FindPiece
T
pos
org
p
SplitPiece
p
pos
org
pr
IF
T
org
org
THEN
T
org
org
p
prev
len
T
pce
p
prev
END
pl
pr
prev
qb
B
header
next
IF
qb
NIL
qb
f
pl
f
qb
off
pl
off
pl
len
qb
fnt
pl
fnt
qb
col
pl
col
qb
voff
pl
voff
THEN
pl
len
pl
len
qb
len
qb
qb
next
END
IF
qb
NIL
THEN
qe
B
last
qb
prev
pl
pl
next
qb
qe
next
pr
pr
prev
qe
END
T
len
T
len
B
len
end
pos
B
len
B
last
B
header
B
last
next
NIL
B
len
T
changed
TRUE
T
notify
T
insert
pos
end
END
Insert
PROCEDURE
Append
T
Text
B
Buffer
BEGIN
Insert
T
T
len
B
END
Append
PROCEDURE
Delete
T
Text
beg
end
LONGINT
B
Buffer
VAR
pb
pe
pbr
per
Piece
orgb
orge
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
orgb
pb
SplitPiece
pb
beg
orgb
pbr
FindPiece
T
end
orge
pe
SplitPiece
pe
end
orge
per
IF
T
org
orgb
THEN
adjust
cache
T
org
orgb
pb
prev
len
T
pce
pb
prev
END
B
header
next
pbr
B
last
per
prev
B
last
next
NIL
B
len
end
beg
per
prev
pbr
prev
pbr
prev
next
per
T
len
T
len
B
len
T
changed
TRUE
T
notify
T
delete
beg
end
END
Delete
PROCEDURE
ChangeLooks
T
Text
beg
end
LONGINT
sel
SET
fnt
Fonts
Font
col
voff
INTEGER
VAR
pb
pe
p
Piece
org
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
org
p
SplitPiece
p
beg
org
pb
FindPiece
T
end
org
p
SplitPiece
p
end
org
pe
p
pb
REPEAT
IF
IN
sel
THEN
p
fnt
fnt
END
IF
IN
sel
THEN
p
col
col
END
IF
IN
sel
THEN
p
voff
voff
END
p
p
next
UNTIL
p
pe
T
changed
TRUE
T
notify
T
replace
beg
end
END
ChangeLooks
PROCEDURE
Attributes
T
Text
pos
LONGINT
VAR
fnt
Fonts
Font
VAR
col
voff
INTEGER
VAR
p
Piece
org
LONGINT
BEGIN
FindPiece
T
pos
org
p
fnt
p
fnt
col
p
col
voff
p
voff
END
Attributes
Access
Readers
PROCEDURE
OpenReader
VAR
R
Reader
T
Text
pos
LONGINT
VAR
p
Piece
org
LONGINT
BEGIN
FindPiece
T
pos
org
p
R
ref
p
R
org
org
R
off
pos
org
Files
Set
R
rider
p
f
p
off
R
off
R
eot
FALSE
END
OpenReader
PROCEDURE
Read
VAR
R
Reader
VAR
ch
CHAR
BEGIN
Files
Read
R
rider
ch
R
fnt
R
ref
fnt
R
col
R
ref
col
R
voff
R
ref
voff
INC
R
off
IF
R
off
R
ref
len
THEN
IF
R
ref
f
TrailerFile
THEN
R
eot
TRUE
END
R
org
R
org
R
off
R
off
R
ref
R
ref
next
R
org
R
org
R
off
R
off
Files
Set
R
rider
R
ref
f
R
ref
off
END
END
Read
PROCEDURE
Pos
VAR
R
Reader
LONGINT
BEGIN
RETURN
R
org
R
off
END
Pos
Access
Scanners
NW
PROCEDURE
OpenScanner
VAR
S
Scanner
T
Text
pos
LONGINT
BEGIN
OpenReader
S
T
pos
S
line
S
nextCh
END
OpenScanner
floating
point
formats
x
m
e
bit
sign
bits
e
bits
m
x
m
e
bit
sign
bits
e
bits
m
PROCEDURE
Ten
n
INTEGER
REAL
VAR
t
p
REAL
BEGIN
t
p
compute
n
WHILE
n
DO
IF
ODD
n
THEN
t
p
t
END
p
p
p
n
n
DIV
END
RETURN
t
END
Ten
PROCEDURE
Scan
VAR
S
Scanner
CONST
maxExp
maxM
VAR
ch
term
CHAR
neg
negE
hex
BOOLEAN
i
j
h
d
e
n
s
INTEGER
k
LONGINT
x
REAL
BEGIN
ch
S
nextCh
i
WHILE
S
eot
ch
DO
IF
ch
CR
THEN
INC
S
line
END
Read
S
ch
END
IF
A
ch
ch
Z
OR
a
ch
ch
z
THEN
name
REPEAT
S
s
i
ch
INC
i
Read
S
ch
UNTIL
ch
ch
OR
ch
ch
A
OR
Z
ch
ch
a
OR
z
ch
OR
i
S
s
i
0X
S
len
i
S
class
Name
ELSIF
ch
22X
THEN
string
Read
S
ch
WHILE
ch
22X
ch
i
DO
S
s
i
ch
INC
i
Read
S
ch
END
S
s
i
0X
S
len
i
Read
S
ch
S
class
String
ELSE
hex
FALSE
IF
ch
THEN
neg
TRUE
Read
S
ch
ELSE
neg
FALSE
END
IF
ch
ch
THEN
number
n
ORD
ch
30H
h
n
Read
S
ch
WHILE
ch
ch
OR
A
ch
ch
F
DO
IF
ch
THEN
d
ORD
ch
30H
ELSE
d
ORD
ch
37H
hex
TRUE
END
n
n
d
h
10H
h
d
Read
S
ch
END
IF
ch
H
THEN
hex
integer
Read
S
ch
S
i
h
S
class
Int
neg
ELSIF
ch
THEN
real
number
Read
S
ch
x
e
j
WHILE
ch
ch
DO
fraction
h
n
ORD
ch
30H
IF
h
maxM
THEN
n
h
INC
j
END
Read
S
ch
END
IF
ch
E
THEN
scale
factor
s
Read
S
ch
IF
ch
THEN
negE
TRUE
Read
S
ch
ELSE
negE
FALSE
IF
ch
THEN
Read
S
ch
END
END
WHILE
ch
ch
DO
s
s
ORD
ch
30H
Read
S
ch
END
IF
negE
THEN
DEC
e
s
ELSE
INC
e
s
END
END
x
FLT
n
DEC
e
j
IF
e
THEN
IF
e
maxExp
THEN
x
x
Ten
e
ELSE
x
END
ELSIF
e
THEN
IF
e
maxExp
THEN
x
Ten
e
x
ELSE
x
END
END
IF
neg
THEN
S
x
x
ELSE
S
x
x
END
IF
hex
THEN
S
class
ELSE
S
class
Real
END
ELSE
decimal
integer
IF
neg
THEN
S
i
n
ELSE
S
i
n
END
IF
hex
THEN
S
class
Inval
ELSE
S
class
Int
END
END
ELSE
spectal
character
S
class
Char
IF
neg
THEN
S
c
ELSE
S
c
ch
Read
S
ch
END
END
END
S
nextCh
ch
END
Scan
Access
Writers
NW
PROCEDURE
OpenWriter
VAR
W
Writer
BEGIN
NEW
W
buf
OpenBuf
W
buf
W
fnt
Fonts
Default
W
col
W
voff
Files
Set
W
rider
Files
New
END
OpenWriter
PROCEDURE
SetFont
VAR
W
Writer
fnt
Fonts
Font
BEGIN
W
fnt
fnt
END
SetFont
PROCEDURE
SetColor
VAR
W
Writer
col
INTEGER
BEGIN
W
col
col
END
SetColor
PROCEDURE
SetOffset
VAR
W
Writer
voff
INTEGER
BEGIN
W
voff
voff
END
SetOffset
PROCEDURE
Write
VAR
W
Writer
ch
CHAR
VAR
p
Piece
BEGIN
IF
W
buf
last
fnt
W
fnt
OR
W
buf
last
col
W
col
OR
W
buf
last
voff
W
voff
THEN
NEW
p
p
f
Files
Base
W
rider
p
off
Files
Pos
W
rider
p
len
p
fnt
W
fnt
p
col
W
col
p
voff
W
voff
p
next
NIL
W
buf
last
next
p
p
prev
W
buf
last
W
buf
last
p
END
Files
Write
W
rider
ch
INC
W
buf
last
len
INC
W
buf
len
END
Write
PROCEDURE
WriteLn
VAR
W
Writer
BEGIN
Write
W
CR
END
WriteLn
PROCEDURE
WriteString
VAR
W
Writer
s
ARRAY
OF
CHAR
VAR
i
INTEGER
BEGIN
i
WHILE
s
i
DO
Write
W
s
i
INC
i
END
END
WriteString
PROCEDURE
WriteInt
VAR
W
Writer
x
n
LONGINT
VAR
i
INTEGER
x0
LONGINT
a
ARRAY
OF
CHAR
BEGIN
IF
ROR
x
THEN
WriteString
W
ELSE
i
IF
x
THEN
DEC
n
x0
x
ELSE
x0
x
END
REPEAT
a
i
CHR
x0
MOD
30H
x0
x0
DIV
INC
i
UNTIL
x0
WHILE
n
i
DO
Write
W
DEC
n
END
IF
x
THEN
Write
W
END
REPEAT
DEC
i
Write
W
a
i
UNTIL
i
END
END
WriteInt
PROCEDURE
WriteHex
VAR
W
Writer
x
LONGINT
VAR
i
INTEGER
y
LONGINT
a
ARRAY
OF
CHAR
BEGIN
i
Write
W
REPEAT
y
x
MOD
10H
IF
y
THEN
a
i
CHR
y
30H
ELSE
a
i
CHR
y
37H
END
x
x
DIV
10H
INC
i
UNTIL
i
REPEAT
DEC
i
Write
W
a
i
UNTIL
i
END
WriteHex
PROCEDURE
WriteReal
VAR
W
Writer
x
REAL
n
INTEGER
VAR
e
i
m
INTEGER
d
ARRAY
OF
CHAR
BEGIN
e
ASR
ORD
x
MOD
100H
binary
exponent
IF
e
THEN
WriteString
W
WHILE
n
DO
Write
W
DEC
n
END
ELSIF
e
THEN
WriteString
W
NaN
ELSE
Write
W
WHILE
n
DO
DEC
n
Write
W
END
n
digits
to
be
written
IF
x
THEN
Write
W
x
x
ELSE
Write
W
END
e
e
DIV
decimal
exponent
IF
e
THEN
x
x
Ten
e
ELSE
x
Ten
e
x
END
m
FLOOR
x
i
IF
m
THEN
INC
e
m
m
DIV
END
REPEAT
d
i
CHR
m
MOD
30H
m
m
DIV
INC
i
UNTIL
m
DEC
i
Write
W
d
i
Write
W
IF
i
n
THEN
n
ELSE
n
n
END
WHILE
i
n
DO
DEC
i
Write
W
d
i
END
Write
W
E
INC
e
IF
e
THEN
Write
W
e
e
ELSE
Write
W
END
Write
W
CHR
e
DIV
30H
Write
W
CHR
e
MOD
30H
END
END
WriteReal
PROCEDURE
WriteRealFix
VAR
W
Writer
x
REAL
n
k
INTEGER
VAR
i
m
INTEGER
neg
BOOLEAN
d
ARRAY
OF
CHAR
BEGIN
IF
x
THEN
WriteString
W
ELSE
IF
x
THEN
x
x
neg
TRUE
ELSE
neg
FALSE
END
IF
k
THEN
k
END
x
Ten
k
x
m
FLOOR
x
i
REPEAT
d
i
CHR
m
MOD
30H
m
m
DIV
INC
i
UNTIL
m
Write
W
WHILE
n
i
DO
Write
W
DEC
n
END
IF
neg
THEN
Write
W
DEC
n
ELSE
Write
W
END
WHILE
i
k
DO
DEC
i
Write
W
d
i
END
Write
W
WHILE
k
i
DO
DEC
k
Write
W
END
WHILE
i
DO
DEC
i
Write
W
d
i
END
END
END
WriteRealFix
PROCEDURE
WritePair
VAR
W
Writer
ch
CHAR
x
LONGINT
BEGIN
Write
W
ch
Write
W
CHR
x
DIV
30H
Write
W
CHR
x
MOD
30H
END
WritePair
PROCEDURE
WriteClock
VAR
W
Writer
d
LONGINT
BEGIN
WritePair
W
d
DIV
20000H
MOD
20H
day
WritePair
W
d
DIV
400000H
MOD
10H
month
WritePair
W
d
DIV
4000000H
MOD
40H
year
WritePair
W
d
DIV
1000H
MOD
20H
hour
WritePair
W
d
DIV
40H
MOD
40H
min
WritePair
W
d
MOD
40H
sec
END
WriteClock
BEGIN
TrailerFile
Files
New
END
Texts
MODULE
Viewers
JG
NW
IMPORT
Display
CONST
restore
modify
suspend
message
ids
inf
TYPE
Viewer
POINTER
TO
ViewerDesc
ViewerDesc
RECORD
Display
FrameDesc
state
INTEGER
END
state
displayed
state
filler
state
closed
state
suspended
ViewerMsg
RECORD
Display
FrameMsg
id
INTEGER
X
Y
W
H
INTEGER
state
INTEGER
END
Track
POINTER
TO
TrackDesc
TrackDesc
RECORD
ViewerDesc
under
Display
Frame
END
VAR
curW
minH
DH
INTEGER
FillerTrack
Track
FillerViewer
backup
Viewer
last
closed
viewer
PROCEDURE
Open
V
Viewer
X
Y
INTEGER
VAR
T
u
v
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
X
inf
THEN
IF
Y
DH
THEN
Y
DH
END
T
FillerTrack
next
WHILE
X
T
X
T
W
DO
T
T
next
END
u
T
dsc
v
u
next
WHILE
Y
v
Y
v
H
DO
u
v
v
u
next
END
IF
Y
v
Y
minH
THEN
Y
v
Y
minH
END
IF
v
next
Y
Y
v
Y
v
H
minH
THEN
V
X
T
X
V
W
T
W
V
Y
v
Y
V
H
v
H
M
id
suspend
M
state
v
handle
v
M
v
Viewer
state
V
next
v
next
u
next
V
V
state
ELSE
V
X
T
X
V
W
T
W
V
Y
v
Y
V
H
Y
v
Y
M
id
modify
M
Y
Y
M
H
v
Y
v
H
Y
v
handle
v
M
v
Y
M
Y
v
H
M
H
V
next
v
u
next
V
V
state
END
END
END
Open
PROCEDURE
Change
V
Viewer
Y
INTEGER
VAR
v
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
THEN
IF
Y
DH
THEN
Y
DH
END
v
V
next
IF
v
next
Y
Y
v
Y
v
H
minH
THEN
Y
v
Y
v
H
minH
END
IF
Y
V
Y
minH
THEN
M
id
modify
M
Y
Y
M
H
v
Y
v
H
Y
v
handle
v
M
v
Y
M
Y
v
H
M
H
V
H
Y
V
Y
END
END
END
Change
PROCEDURE
RestoreTrack
S
Display
Frame
VAR
T
t
v
Display
Frame
M
ViewerMsg
BEGIN
t
S
next
WHILE
t
next
S
DO
t
t
next
END
T
S
Track
under
WHILE
T
next
NIL
DO
T
T
next
END
t
next
S
Track
under
T
next
S
next
M
id
restore
REPEAT
t
t
next
v
t
dsc
REPEAT
v
v
next
v
handle
v
M
v
Viewer
state
v
Viewer
state
UNTIL
v
t
dsc
UNTIL
t
T
END
RestoreTrack
PROCEDURE
Close
V
Viewer
VAR
T
U
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
THEN
U
V
next
T
FillerTrack
REPEAT
T
T
next
UNTIL
V
X
T
X
T
W
IF
T
Track
under
NIL
OR
U
next
V
THEN
M
id
suspend
M
state
V
handle
V
M
V
state
backup
V
M
id
modify
M
Y
V
Y
M
H
V
H
U
H
U
handle
U
M
U
Y
M
Y
U
H
M
H
WHILE
U
next
V
DO
U
U
next
END
U
next
V
next
ELSE
close
track
M
id
suspend
M
state
V
handle
V
M
V
state
backup
V
U
handle
U
M
U
Viewer
state
RestoreTrack
T
END
END
END
Close
PROCEDURE
Recall
VAR
V
Viewer
BEGIN
V
backup
END
Recall
PROCEDURE
This
X
Y
INTEGER
Viewer
VAR
T
V
Display
Frame
BEGIN
IF
X
inf
Y
DH
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
V
T
dsc
REPEAT
V
V
next
UNTIL
Y
V
Y
V
H
ELSE
V
NIL
END
RETURN
V
Viewer
END
This
PROCEDURE
Next
V
Viewer
Viewer
BEGIN
RETURN
V
next
Viewer
END
Next
PROCEDURE
Locate
X
H
INTEGER
VAR
fil
bot
alt
max
Display
Frame
VAR
T
V
Display
Frame
BEGIN
IF
X
inf
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
fil
T
dsc
bot
fil
next
IF
bot
next
fil
THEN
alt
bot
next
V
alt
next
WHILE
V
fil
alt
H
H
DO
IF
V
H
alt
H
THEN
alt
V
END
V
V
next
END
ELSE
alt
bot
END
max
T
dsc
V
max
next
WHILE
V
fil
DO
IF
V
H
max
H
THEN
max
V
END
V
V
next
END
END
END
Locate
PROCEDURE
InitTrack
W
H
INTEGER
Filler
Viewer
VAR
S
Display
Frame
T
Track
BEGIN
IF
Filler
state
THEN
Filler
X
curW
Filler
W
W
Filler
Y
Filler
H
H
Filler
state
Filler
next
Filler
NEW
T
T
X
curW
T
W
W
T
Y
T
H
H
T
dsc
Filler
T
under
NIL
FillerViewer
X
curW
W
FillerViewer
W
inf
FillerViewer
X
FillerTrack
X
FillerViewer
X
FillerTrack
W
FillerViewer
W
S
FillerTrack
WHILE
S
next
FillerTrack
DO
S
S
next
END
S
next
T
T
next
FillerTrack
curW
curW
W
END
END
InitTrack
PROCEDURE
OpenTrack
X
W
INTEGER
Filler
Viewer
VAR
newT
Track
S
T
t
v
Display
Frame
M
ViewerMsg
v0
Viewer
BEGIN
IF
X
inf
Filler
state
THEN
S
FillerTrack
T
S
next
WHILE
X
T
X
T
W
DO
S
T
T
S
next
END
WHILE
X
W
T
X
T
W
DO
T
T
next
END
M
id
suspend
t
S
REPEAT
t
t
next
v
t
dsc
REPEAT
v
v
next
M
state
v
Viewer
state
v
handle
v
M
v
Viewer
state
M
state
UNTIL
v
t
dsc
UNTIL
t
T
Filler
X
S
next
X
Filler
W
T
X
T
W
S
next
X
Filler
Y
Filler
H
DH
Filler
state
Filler
next
Filler
NEW
newT
newT
X
Filler
X
newT
W
Filler
W
newT
Y
newT
H
DH
newT
dsc
Filler
newT
under
S
next
S
next
newT
newT
next
T
next
T
next
NIL
END
END
OpenTrack
PROCEDURE
CloseTrack
X
INTEGER
VAR
T
V
Display
Frame
M
ViewerMsg
BEGIN
IF
X
inf
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
IF
T
Track
under
NIL
THEN
M
id
suspend
M
state
V
T
dsc
REPEAT
V
V
next
V
handle
V
M
V
Viewer
state
UNTIL
V
T
dsc
RestoreTrack
T
END
END
END
CloseTrack
PROCEDURE
Broadcast
VAR
M
Display
FrameMsg
VAR
T
V
Display
Frame
BEGIN
T
FillerTrack
next
WHILE
T
FillerTrack
DO
V
T
dsc
REPEAT
V
V
next
V
handle
V
M
UNTIL
V
T
dsc
T
T
next
END
END
Broadcast
BEGIN
backup
NIL
curW
minH
DH
Display
Height
NEW
FillerViewer
FillerViewer
X
FillerViewer
W
inf
FillerViewer
Y
FillerViewer
H
DH
FillerViewer
next
FillerViewer
NEW
FillerTrack
FillerTrack
X
FillerTrack
W
inf
FillerTrack
Y
FillerTrack
H
DH
FillerTrack
dsc
FillerViewer
FillerTrack
next
FillerTrack
END
Viewers
MODULE
Curves
NW
IMPORT
Display
Files
Oberon
Graphics
GraphicFrames
TYPE
Curve
POINTER
TO
CurveDesc
CurveDesc
RECORD
Graphics
ObjectDesc
kind
lw
INTEGER
END
kind
up
line
down
line
circle
ellipse
VAR
method
Graphics
Method
PROCEDURE
Dot
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
IF
x
f
X
x
f
X1
y
f
Y
x
f
Y1
THEN
Display
Dot
col
x
y
Display
replace
END
END
Dot
PROCEDURE
mark
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
DEC
x
DEC
y
IF
x
f
X
x
f
X1
y
f
Y
y
f
Y1
THEN
IF
col
Display
black
THEN
Display
ReplConst
Display
black
x
y
Display
replace
ELSE
Display
CopyPattern
col
GraphicFrames
tack
x
y
Display
replace
END
END
END
mark
PROCEDURE
line
f
GraphicFrames
Frame
col
INTEGER
x
y
w
h
d
LONGINT
VAR
x1
y1
u
LONGINT
BEGIN
IF
h
w
THEN
x1
x
w
u
h
w
DIV
IF
d
THEN
INC
y
h
END
WHILE
x
x1
DO
Dot
f
col
x
y
INC
x
IF
u
THEN
INC
u
h
ELSE
INC
u
h
w
INC
y
d
END
END
ELSE
y1
y
h
u
w
h
DIV
IF
d
THEN
INC
x
w
END
WHILE
y
y1
DO
Dot
f
col
x
y
INC
y
IF
u
THEN
INC
u
w
ELSE
INC
u
w
h
INC
x
d
END
END
END
END
line
PROCEDURE
circle
f
GraphicFrames
Frame
col
INTEGER
x0
y0
r
LONGINT
VAR
x
y
u
LONGINT
BEGIN
u
r
x
r
y
WHILE
y
x
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
x
y0
y
IF
u
THEN
INC
u
y
ELSE
INC
u
y
x
DEC
x
END
INC
y
END
END
circle
PROCEDURE
ellipse
f
GraphicFrames
Frame
col
INTEGER
x0
y0
a
b
LONGINT
VAR
x
y
y1
aa
bb
d
g
h
LONGINT
BEGIN
aa
a
a
bb
b
b
h
aa
DIV
b
aa
bb
g
aa
DIV
b
aa
bb
x
y
b
WHILE
g
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
IF
h
THEN
d
x
bb
INC
g
d
ELSE
d
x
bb
y
aa
INC
g
d
aa
DEC
y
END
INC
h
d
INC
x
END
y1
y
h
bb
DIV
a
bb
aa
x
a
y
WHILE
y
y1
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
IF
h
THEN
INC
h
y
aa
ELSE
INC
h
y
aa
x
bb
DEC
x
END
INC
y
END
END
ellipse
PROCEDURE
New
VAR
c
Curve
BEGIN
NEW
c
c
do
method
Graphics
New
c
END
New
PROCEDURE
Copy
src
dst
Graphics
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Curve
kind
src
Curve
kind
dst
Curve
lw
src
Curve
lw
END
Copy
PROCEDURE
Draw
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
col
INTEGER
f
GraphicFrames
Frame
BEGIN
CASE
M
OF
GraphicFrames
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
M
col
Display
black
THEN
col
obj
col
ELSE
col
M
col
END
IF
x
f
X1
f
X
x
w
y
f
Y1
f
Y
y
h
THEN
IF
obj
Curve
kind
THEN
up
line
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
y
END
line
f
col
x
y
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
ELSIF
M
mode
THEN
mark
f
f
col
x
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
line
f
Display
black
x
y
w
h
END
ELSIF
obj
Curve
kind
THEN
down
line
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
y
h
END
line
f
col
x
y
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
h
ELSIF
M
mode
THEN
mark
f
f
col
x
y
h
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
h
line
f
Display
black
x
y
w
h
END
ELSIF
obj
Curve
kind
THEN
circle
w
w
DIV
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
w
y
END
circle
f
col
x
w
y
w
w
ELSIF
M
mode
THEN
mark
f
Display
white
x
w
y
ELSIF
M
mode
THEN
mark
f
f
col
x
w
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
w
y
circle
f
Display
black
x
w
y
w
w
END
ELSIF
obj
Curve
kind
THEN
ellipse
w
w
DIV
h
h
DIV
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
w
y
END
ellipse
f
col
x
w
y
h
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
w
y
ELSIF
M
mode
THEN
mark
f
f
col
x
w
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
w
y
ellipse
f
Display
black
x
w
y
h
w
h
END
END
END
END
END
Draw
PROCEDURE
Selectable
obj
Graphics
Object
x
y
INTEGER
BOOLEAN
VAR
xm
y0
w
h
INTEGER
res
BOOLEAN
BEGIN
IF
obj
Curve
kind
THEN
line
w
obj
w
h
obj
h
IF
obj
Curve
kind
THEN
y0
obj
y
h
h
h
ELSE
y0
obj
y
END
res
obj
x
x
x
obj
x
w
ABS
y
y0
w
x
obj
x
h
w
ELSE
circle
or
ellipse
xm
obj
w
DIV
obj
x
res
xm
x
x
xm
obj
y
y
y
obj
y
END
RETURN
res
END
Selectable
PROCEDURE
Change
obj
Graphics
Object
VAR
M
Graphics
Msg
BEGIN
IF
M
IS
Graphics
ColorMsg
THEN
obj
col
M
Graphics
ColorMsg
col
END
END
Change
PROCEDURE
Read
obj
Graphics
Object
VAR
R
Files
Rider
VAR
C
Graphics
Context
VAR
len
BYTE
BEGIN
Files
ReadByte
R
len
Files
ReadByte
R
len
obj
Curve
kind
len
Files
ReadByte
R
len
obj
Curve
lw
len
END
Read
PROCEDURE
Write
obj
Graphics
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Graphics
Context
BEGIN
Graphics
WriteObj
W
cno
obj
Files
WriteByte
W
Files
WriteByte
W
obj
Curve
kind
Files
WriteByte
W
obj
Curve
lw
END
Write
PROCEDURE
MakeLine
command
VAR
x0
x1
y0
y1
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
x1
G
mark
next
x
y1
G
mark
next
y
NEW
c
c
col
Oberon
CurCol
c
w
ABS
x1
x0
c
h
ABS
y1
y0
c
lw
Graphics
width
IF
x0
x1
THEN
c
x
x0
IF
y0
y1
THEN
c
kind
c
y
y0
ELSE
c
kind
c
y
y1
END
ELSE
c
x
x1
IF
y1
y0
THEN
c
kind
c
y
y1
ELSE
c
kind
c
y
y0
END
END
DEC
c
x
G
x
DEC
c
y
G
y
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
MakeLine
PROCEDURE
MakeCircle
command
VAR
x0
y0
r
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
r
ABS
G
mark
next
x
x0
IF
r
THEN
NEW
c
c
x
x0
r
G
x
c
y
y0
r
G
y
c
w
r
c
h
c
w
c
kind
c
col
Oberon
CurCol
c
lw
Graphics
width
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
END
MakeCircle
PROCEDURE
MakeEllipse
command
VAR
x0
y0
a
b
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
G
mark
next
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
a
ABS
G
mark
next
x
x0
b
ABS
G
mark
next
next
y
y0
IF
a
b
THEN
NEW
c
c
x
x0
a
G
x
c
y
y0
b
G
y
c
w
a
c
h
b
c
kind
c
col
Oberon
CurCol
c
lw
Graphics
width
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
END
MakeEllipse
BEGIN
NEW
method
method
module
Curves
method
allocator
New
method
new
New
method
copy
Copy
method
draw
Draw
method
selectable
Selectable
method
change
Change
method
read
Read
method
write
Write
END
Curves
MODULE
Display
NW
IMPORT
SYSTEM
CONST
black
white
black
background
replace
paint
invert
modes
base
0E7F00H
adr
of
x
pixel
monocolor
display
frame
TYPE
Frame
POINTER
TO
FrameDesc
FrameMsg
RECORD
END
Handler
PROCEDURE
F
Frame
VAR
M
FrameMsg
FrameDesc
RECORD
next
dsc
Frame
X
Y
W
H
INTEGER
handle
Handler
END
VAR
Base
Width
Height
INTEGER
arrow
star
hook
updown
block
cross
grey
INTEGER
a
pattern
is
an
array
of
bytes
the
first
is
its
width
the
second
its
height
the
rest
the
raster
PROCEDURE
Handle
F
Frame
VAR
M
FrameMsg
BEGIN
IF
F
NIL
F
handle
NIL
THEN
F
handle
F
M
END
END
Handle
raster
ops
PROCEDURE
Dot
col
x
y
mode
INTEGER
VAR
a
INTEGER
u
s
SET
BEGIN
a
base
x
DIV
y
s
x
MOD
SYSTEM
GET
a
u
IF
mode
paint
THEN
SYSTEM
PUT
a
u
s
ELSIF
mode
invert
THEN
SYSTEM
PUT
a
u
s
ELSE
mode
replace
IF
col
black
THEN
SYSTEM
PUT
a
u
s
ELSE
SYSTEM
PUT
a
u
s
END
END
END
Dot
PROCEDURE
ReplConst
col
x
y
w
h
mode
INTEGER
VAR
al
ar
a0
a1
INTEGER
left
right
mid
pix
pixl
pixr
SET
BEGIN
al
base
y
ar
x
w
DIV
al
al
x
DIV
al
IF
ar
al
THEN
mid
x
MOD
x
w
MOD
FOR
a1
al
TO
al
h
BY
DO
SYSTEM
GET
a1
pix
IF
mode
invert
THEN
SYSTEM
PUT
a1
pix
mid
ELSIF
mode
replace
col
black
THEN
erase
SYSTEM
PUT
a1
pix
mid
ELSE
mode
paint
OR
mode
replace
col
black
SYSTEM
PUT
a1
pix
mid
END
END
ELSIF
ar
al
THEN
left
x
MOD
right
x
w
MOD
FOR
a0
al
TO
al
h
BY
DO
SYSTEM
GET
a0
pixl
SYSTEM
GET
ar
pixr
IF
mode
invert
THEN
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
PUT
a1
pix
END
SYSTEM
PUT
ar
pixr
right
ELSIF
mode
replace
col
black
THEN
erase
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
PUT
a1
END
SYSTEM
PUT
ar
pixr
right
ELSE
mode
paint
OR
mode
replace
col
black
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
PUT
a1
END
SYSTEM
PUT
ar
pixr
right
END
INC
ar
END
END
END
ReplConst
PROCEDURE
CopyPattern
col
patadr
x
y
mode
INTEGER
only
for
modes
paint
invert
VAR
a
a0
pwd
INTEGER
w
h
pbt
BYTE
pix
SET
BEGIN
SYSTEM
GET
patadr
w
SYSTEM
GET
patadr
h
INC
patadr
a
base
x
DIV
y
FOR
a0
a
TO
a
h
BY
DO
build
pattern
line
w
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
100H
pwd
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
10000H
pwd
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
1000000H
pwd
END
END
END
SYSTEM
GET
a0
pix
IF
mode
invert
THEN
SYSTEM
PUT
a0
SYSTEM
VAL
SET
LSL
pwd
x
MOD
pix
ELSE
SYSTEM
PUT
a0
SYSTEM
VAL
SET
LSL
pwd
x
MOD
pix
END
IF
x
MOD
w
THEN
spill
over
SYSTEM
GET
a0
pix
IF
mode
invert
THEN
SYSTEM
PUT
a0
SYSTEM
VAL
SET
ASR
pwd
x
MOD
pix
ELSE
SYSTEM
PUT
a0
SYSTEM
VAL
SET
ASR
pwd
x
MOD
pix
END
END
END
END
CopyPattern
PROCEDURE
CopyBlock
sx
sy
w
h
dx
dy
mode
INTEGER
only
for
mode
replace
VAR
sa
da
sa0
sa1
d
len
INTEGER
u0
u1
u2
u3
v0
v1
v2
v3
n
INTEGER
end
step
INTEGER
src
dst
spill
SET
m0
m1
m2
m3
SET
BEGIN
u0
sx
DIV
u1
sx
MOD
u2
sx
w
DIV
u3
sx
w
MOD
v0
dx
DIV
v1
dx
MOD
v2
dx
w
DIV
v3
dx
w
MOD
sa
base
u0
sy
da
base
v0
dy
d
da
sa
n
u1
v1
displacement
in
words
and
bits
len
u2
u0
m0
v1
m2
v3
m3
m0
m2
IF
d
THEN
copy
up
scan
down
sa0
sa
h
end
sa
step
ELSE
copy
down
scan
up
sa0
sa
end
sa
h
step
END
WHILE
sa0
end
DO
IF
n
THEN
shift
right
m1
n
IF
v1
w
THEN
SYSTEM
GET
sa0
len
src
src
ROR
src
n
SYSTEM
GET
sa0
len
d
dst
SYSTEM
PUT
sa0
len
d
dst
m2
src
m2
spill
src
m1
FOR
sa1
sa0
len
TO
sa0
BY
DO
SYSTEM
GET
sa1
src
src
ROR
src
n
SYSTEM
PUT
sa1
d
spill
src
m1
spill
src
m1
END
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
SYSTEM
PUT
sa0
d
src
m0
dst
m0
ELSE
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
SYSTEM
PUT
sa0
d
src
m3
dst
m3
END
ELSE
shift
left
m1
n
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
IF
v1
w
THEN
SYSTEM
PUT
sa0
d
dst
m3
src
m3
ELSE
SYSTEM
PUT
sa0
d
dst
m0
src
m0
spill
src
m1
FOR
sa1
sa0
TO
sa0
len
BY
DO
SYSTEM
GET
sa1
src
src
ROR
src
n
SYSTEM
PUT
sa1
d
spill
src
m1
spill
src
m1
END
SYSTEM
GET
sa0
len
src
src
ROR
src
n
SYSTEM
GET
sa0
len
d
dst
SYSTEM
PUT
sa0
len
d
src
m2
dst
m2
END
END
INC
sa0
step
END
END
CopyBlock
PROCEDURE
ReplPattern
col
patadr
x
y
w
h
mode
INTEGER
pattern
width
fixed
pattern
starts
at
patadr
for
mode
invert
only
VAR
al
ar
a0
a1
INTEGER
pta0
pta1
INTEGER
pattern
addresses
ph
BYTE
left
right
mid
pix
pixl
pixr
ptw
SET
BEGIN
al
base
y
SYSTEM
GET
patadr
ph
pta0
patadr
pta1
ph
pta0
ar
x
w
DIV
al
al
x
DIV
al
IF
ar
al
THEN
mid
x
MOD
x
w
MOD
FOR
a1
al
TO
al
h
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
GET
pta0
ptw
SYSTEM
PUT
a1
pix
mid
pix
ptw
mid
INC
pta0
IF
pta0
pta1
THEN
pta0
patadr
END
END
ELSIF
ar
al
THEN
left
x
MOD
right
x
w
MOD
FOR
a0
al
TO
al
h
BY
DO
SYSTEM
GET
a0
pixl
SYSTEM
GET
pta0
ptw
SYSTEM
PUT
a0
pixl
left
pixl
ptw
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
PUT
a1
pix
ptw
END
SYSTEM
GET
ar
pixr
SYSTEM
PUT
ar
pixr
right
pixr
ptw
right
INC
pta0
INC
ar
IF
pta0
pta1
THEN
pta0
patadr
END
END
END
END
ReplPattern
BEGIN
Base
base
Width
Height
arrow
SYSTEM
ADR
0F0F
001C
000E
C101
E300
3F00
1F00
3F00
7F00
FF00
star
SYSTEM
ADR
0F0F
A002
C001
7F7F
C001
A002
hook
SYSTEM
ADR
0C0C
070F
C703
E701
F700
7F00
3F00
1F00
0F00
updown
SYSTEM
ADR
080E
183C
7EFF
FF7E3C18
block
SYSTEM
ADR
FFFF
C3C3
C3C3
FFFF
cross
SYSTEM
ADR
0F0F
grey
SYSTEM
ADR
AAAA
AAAA
END
Display
MODULE
Draw
NW
IMPORT
Files
Fonts
Viewers
Texts
Oberon
TextFrames
MenuViewers
Graphics
GraphicFrames
CONST
Menu
System
Close
System
Copy
System
Grow
Draw
Delete
Draw
Ticks
Draw
Restore
Draw
Store
VAR
W
Texts
Writer
Exported
commands
Open
Delete
SetWidth
ChangeColor
ChangeWidth
ChangeFont
Store
Print
Macro
Ticks
Restore
PROCEDURE
Open
VAR
X
Y
INTEGER
beg
end
t
LONGINT
G
Graphics
Graph
F
GraphicFrames
Frame
V
Viewers
Viewer
S
Texts
Scanner
text
Texts
Text
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
text
beg
end
t
IF
t
THEN
Texts
OpenScanner
S
text
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
THEN
NEW
G
Graphics
Open
G
S
s
NEW
F
GraphicFrames
Open
F
G
Oberon
AllocateUserViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
Menu
F
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Delete
VAR
F
GraphicFrames
Frame
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
F
Oberon
Par
vwr
dsc
next
GraphicFrames
Frame
GraphicFrames
Erase
F
Graphics
Delete
F
graph
END
END
Delete
PROCEDURE
GetArg
VAR
S
Texts
Scanner
VAR
T
Texts
Text
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
END
GetArg
PROCEDURE
SetWidth
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
S
i
S
i
THEN
Graphics
SetWidth
S
i
END
END
SetWidth
PROCEDURE
ChangeColor
VAR
S
Texts
Scanner
CM
Graphics
ColorMsg
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
CM
col
S
i
MOD
GraphicFrames
Change
GraphicFrames
Selected
CM
END
END
ChangeColor
PROCEDURE
ChangeWidth
VAR
S
Texts
Scanner
WM
Graphics
WidMsg
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
WM
w
S
i
GraphicFrames
Change
GraphicFrames
Selected
WM
END
END
ChangeWidth
PROCEDURE
ChangeFont
VAR
S
Texts
Scanner
FM
Graphics
FontMsg
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
FM
fnt
Fonts
This
S
s
IF
FM
fnt
NIL
THEN
GraphicFrames
Change
GraphicFrames
Selected
FM
END
END
END
ChangeFont
PROCEDURE
Redraw
Q
BOOLEAN
VAR
v
Viewers
Viewer
G
GraphicFrames
Frame
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
v
Oberon
Par
vwr
ELSE
v
Oberon
MarkedViewer
END
IF
v
NIL
v
dsc
NIL
v
dsc
next
IS
GraphicFrames
Frame
THEN
G
v
dsc
next
GraphicFrames
Frame
G
ticked
Q
OR
G
ticked
GraphicFrames
Restore
G
END
END
Redraw
PROCEDURE
Ticks
BEGIN
Redraw
FALSE
END
Ticks
PROCEDURE
Restore
BEGIN
Redraw
TRUE
END
Restore
PROCEDURE
Backup
VAR
name
ARRAY
OF
CHAR
VAR
res
i
INTEGER
ch
CHAR
bak
ARRAY
OF
CHAR
BEGIN
i
ch
name
WHILE
ch
0X
DO
bak
i
ch
INC
i
ch
name
i
END
IF
i
THEN
bak
i
bak
i
B
bak
i
a
bak
i
k
bak
i
0X
Files
Rename
name
bak
res
END
END
Backup
PROCEDURE
Store
VAR
S
Texts
Scanner
Menu
TextFrames
Frame
G
GraphicFrames
Frame
v
Viewers
Viewer
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
Menu
Oberon
Par
vwr
dsc
TextFrames
Frame
G
Menu
next
GraphicFrames
Frame
Texts
OpenScanner
S
Menu
text
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
S
s
Texts
WriteString
W
storing
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
GraphicFrames
Store
G
S
s
END
ELSE
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
v
Oberon
MarkedViewer
IF
v
dsc
NIL
v
dsc
next
IS
GraphicFrames
Frame
THEN
G
v
dsc
next
GraphicFrames
Frame
Texts
WriteString
W
S
s
Texts
WriteString
W
storing
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
GraphicFrames
Store
G
S
s
END
END
END
END
Store
PROCEDURE
Macro
VAR
S
Texts
Scanner
T
Texts
Text
time
beg
end
LONGINT
Lname
ARRAY
OF
CHAR
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Lname
S
s
Texts
Scan
S
IF
S
class
Texts
Name
THEN
GraphicFrames
Macro
Lname
S
s
END
END
END
Macro
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
Draw
NW
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
Draw
MODULE
Edit
JG
NW
IMPORT
Files
Fonts
Texts
Display
Viewers
Oberon
MenuViewers
TextFrames
CONST
CR
0DX
maxlen
StandardMenu
System
Close
System
Copy
System
Grow
Edit
Search
Edit
Store
VAR
W
Texts
Writer
time
LONGINT
M
INTEGER
pat
ARRAY
maxlen
OF
CHAR
d
ARRAY
OF
INTEGER
PROCEDURE
Max
i
j
LONGINT
LONGINT
VAR
m
LONGINT
BEGIN
IF
i
j
THEN
m
i
ELSE
m
j
END
RETURN
m
END
Max
PROCEDURE
Open
VAR
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
X
Y
INTEGER
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
OR
S
line
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
THEN
Oberon
AllocateUserViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Store
VAR
V
Viewers
Viewer
Text
TextFrames
Frame
T
Texts
Text
S
Texts
Scanner
f
Files
File
R
Files
Rider
beg
end
time
len
LONGINT
PROCEDURE
Backup
VAR
name
ARRAY
OF
CHAR
VAR
res
i
INTEGER
bak
ARRAY
OF
CHAR
BEGIN
i
WHILE
name
i
0X
DO
bak
i
name
i
INC
i
END
bak
i
bak
i
B
bak
i
a
bak
i
k
bak
i
0X
Files
Rename
name
bak
res
END
Backup
BEGIN
Texts
WriteString
W
Edit
Store
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
V
Oberon
Par
vwr
Texts
OpenScanner
S
V
dsc
TextFrames
Frame
text
ELSE
V
Oberon
MarkedViewer
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
END
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
Texts
WriteString
W
S
s
Texts
WriteInt
W
Text
text
len
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
Texts
Close
Text
text
S
s
END
END
Store
PROCEDURE
CopyLooks
VAR
T
Texts
Text
F
TextFrames
Frame
v
Viewers
Viewer
beg
end
time
LONGINT
fnt
Fonts
Font
col
voff
INTEGER
BEGIN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
v
Oberon
FocusViewer
IF
v
NIL
v
dsc
NIL
v
dsc
next
IS
TextFrames
Frame
THEN
F
v
dsc
next
TextFrames
Frame
Texts
Attributes
F
text
F
carloc
pos
fnt
col
voff
Texts
ChangeLooks
T
beg
end
fnt
col
voff
END
END
END
CopyLooks
PROCEDURE
ChangeFont
VAR
S
Texts
Scanner
T
Texts
Text
beg
end
LONGINT
BEGIN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
ChangeLooks
T
beg
end
Fonts
This
S
s
END
END
END
ChangeFont
PROCEDURE
ChangeColor
VAR
S
Texts
Scanner
T
Texts
Text
col
INTEGER
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
col
S
i
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
ChangeLooks
T
beg
end
NIL
col
END
END
END
ChangeColor
PROCEDURE
ChangeOffset
VAR
S
Texts
Scanner
T
Texts
Text
voff
INTEGER
ch
CHAR
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
voff
S
i
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
ChangeLooks
T
beg
end
NIL
voff
END
END
END
ChangeOffset
PROCEDURE
Search
uses
global
variables
M
pat
d
for
Boyer
Moore
search
VAR
Text
TextFrames
Frame
V
Viewers
Viewer
R
Texts
Reader
T
Texts
Text
pos
beg
end
prevTime
len
LONGINT
n
i
j
INTEGER
buf
ARRAY
OF
CHAR
PROCEDURE
Forward
n
INTEGER
VAR
R
Texts
Reader
VAR
buf
ARRAY
OF
CHAR
VAR
m
INTEGER
j
INTEGER
BEGIN
m
M
n
j
WHILE
j
m
DO
buf
j
buf
n
j
INC
j
END
WHILE
j
M
DO
Texts
Read
R
buf
j
INC
j
END
END
Forward
BEGIN
V
Oberon
Par
vwr
IF
Oberon
Par
frame
V
dsc
THEN
V
Oberon
FocusViewer
END
IF
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
prevTime
time
Oberon
GetSelection
T
beg
end
time
IF
time
prevTime
THEN
Texts
OpenReader
R
T
beg
i
pos
beg
REPEAT
Texts
Read
R
pat
i
INC
i
INC
pos
UNTIL
i
maxlen
OR
pos
end
M
i
j
WHILE
j
DO
d
j
M
INC
j
END
j
WHILE
j
M
DO
d
ORD
pat
j
M
j
INC
j
END
END
IF
Text
hasCar
THEN
pos
Text
carloc
pos
ELSE
pos
END
len
Text
text
len
Texts
OpenReader
R
Text
text
pos
Forward
M
R
buf
pos
pos
M
j
M
REPEAT
DEC
j
UNTIL
j
OR
buf
j
pat
j
WHILE
j
pos
len
DO
n
d
ORD
buf
M
Forward
n
R
buf
INC
pos
n
j
M
REPEAT
DEC
j
UNTIL
j
OR
buf
j
pat
j
END
IF
j
THEN
TextFrames
RemoveSelection
Text
TextFrames
RemoveCaret
Text
Oberon
RemoveMarks
Text
X
Text
Y
Text
W
Text
H
TextFrames
Show
Text
pos
Oberon
PassFocus
V
TextFrames
SetCaret
Text
pos
END
END
END
Search
PROCEDURE
Locate
VAR
Text
TextFrames
Frame
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
beg
end
time
LONGINT
BEGIN
V
Oberon
FocusViewer
IF
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
REPEAT
Texts
Scan
S
UNTIL
S
class
Texts
Int
skip
names
IF
S
class
Texts
Int
THEN
TextFrames
RemoveSelection
Text
TextFrames
RemoveCaret
Text
Oberon
RemoveMarks
Text
X
Text
Y
Text
W
Text
H
TextFrames
Show
Text
Max
S
i
Oberon
PassFocus
V
TextFrames
SetCaret
Text
S
i
END
END
END
END
Locate
PROCEDURE
Recall
VAR
Menu
Main
Display
Frame
buf
Texts
Buffer
V
Viewers
Viewer
pos
LONGINT
M
TextFrames
Frame
BEGIN
V
Oberon
FocusViewer
IF
V
NIL
V
IS
MenuViewers
Viewer
THEN
Menu
V
dsc
Main
V
dsc
next
IF
Main
IS
TextFrames
Frame
THEN
M
Main
TextFrames
Frame
IF
M
hasCar
THEN
TextFrames
Recall
buf
pos
M
carloc
pos
buf
len
Texts
Insert
M
text
M
carloc
pos
buf
TextFrames
SetCaret
M
pos
END
ELSIF
Menu
IS
TextFrames
Frame
THEN
M
Menu
TextFrames
Frame
IF
M
hasCar
THEN
TextFrames
Recall
buf
pos
M
carloc
pos
buf
len
Texts
Insert
M
text
M
carloc
pos
buf
TextFrames
SetCaret
M
pos
END
END
END
END
Recall
BEGIN
Texts
OpenWriter
W
END
Edit
MODULE
FileDir
NW
IMPORT
SYSTEM
Kernel
File
Directory
is
a
B
tree
with
its
root
page
at
DirRootAdr
Each
entry
contains
a
file
name
and
the
disk
address
of
the
file
s
head
sector
CONST
FnLength
SecTabSize
ExTabSize
SectorSize
IndexSize
SectorSize
DIV
HeaderSize
DirRootAdr
DirPgSize
N
DirPgSize
DIV
DirMark
9B1EA38DH
HeaderMark
9BA71D86H
FillerSize
TYPE
DiskAdr
INTEGER
FileName
ARRAY
FnLength
OF
CHAR
SectorTable
ARRAY
SecTabSize
OF
DiskAdr
ExtensionTable
ARRAY
ExTabSize
OF
DiskAdr
EntryHandler
PROCEDURE
name
FileName
sec
DiskAdr
VAR
continue
BOOLEAN
FileHeader
RECORD
first
page
of
each
file
on
disk
mark
INTEGER
name
FileName
aleng
bleng
date
INTEGER
ext
ExtensionTable
sec
SectorTable
fill
ARRAY
SectorSize
HeaderSize
OF
BYTE
END
FileHd
POINTER
TO
FileHeader
IndexSector
ARRAY
IndexSize
OF
DiskAdr
DataSector
ARRAY
SectorSize
OF
BYTE
DirEntry
B
tree
node
RECORD
name
FileName
adr
DiskAdr
sec
no
of
file
header
p
DiskAdr
sec
no
of
descendant
in
directory
END
DirPage
RECORD
mark
INTEGER
m
INTEGER
p0
DiskAdr
sec
no
of
left
descendant
in
directory
fill
ARRAY
FillerSize
OF
BYTE
e
ARRAY
DirPgSize
OF
DirEntry
END
Exported
procedures
Search
Insert
Delete
Enumerate
Init
PROCEDURE
Search
name
FileName
VAR
A
DiskAdr
VAR
i
L
R
INTEGER
dadr
DiskAdr
a
DirPage
BEGIN
dadr
DirRootAdr
A
REPEAT
Kernel
GetSector
dadr
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
a
m
name
a
e
R
name
THEN
A
a
e
R
adr
found
ELSIF
R
THEN
dadr
a
p0
ELSE
dadr
a
e
R
p
END
UNTIL
dadr
OR
A
END
Search
PROCEDURE
insert
name
FileName
dpg0
DiskAdr
VAR
h
BOOLEAN
VAR
v
DirEntry
fad
DiskAdr
h
tree
has
become
higher
and
v
is
ascending
element
VAR
ch
CHAR
i
j
L
R
INTEGER
dpg1
DiskAdr
u
DirEntry
a
DirPage
BEGIN
h
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
a
m
name
a
e
R
name
THEN
a
e
R
adr
fad
Kernel
PutSector
dpg0
a
replace
ELSE
not
on
this
page
IF
R
THEN
dpg1
a
p0
ELSE
dpg1
a
e
R
p
END
IF
dpg1
THEN
not
in
tree
insert
u
adr
fad
u
p
h
TRUE
j
REPEAT
ch
name
j
u
name
j
ch
INC
j
UNTIL
ch
0X
WHILE
j
FnLength
DO
u
name
j
0X
INC
j
END
ELSE
insert
name
dpg1
h
u
fad
END
IF
h
THEN
insert
u
to
the
left
of
e
R
IF
a
m
DirPgSize
THEN
h
FALSE
i
a
m
WHILE
i
R
DO
DEC
i
a
e
i
a
e
i
END
a
e
R
u
INC
a
m
ELSE
split
page
and
assign
the
middle
element
to
v
a
m
N
a
mark
DirMark
IF
R
N
THEN
insert
in
left
half
v
a
e
N
i
N
WHILE
i
R
DO
DEC
i
a
e
i
a
e
i
END
a
e
R
u
Kernel
PutSector
dpg0
a
Kernel
AllocSector
dpg0
dpg0
i
WHILE
i
N
DO
a
e
i
a
e
i
N
INC
i
END
ELSE
insert
in
right
half
Kernel
PutSector
dpg0
a
Kernel
AllocSector
dpg0
dpg0
DEC
R
N
i
IF
R
THEN
v
u
ELSE
v
a
e
N
WHILE
i
R
DO
a
e
i
a
e
N
i
INC
i
END
a
e
i
u
INC
i
END
WHILE
i
N
DO
a
e
i
a
e
N
i
INC
i
END
END
a
p0
v
p
v
p
dpg0
END
Kernel
PutSector
dpg0
a
END
END
END
insert
PROCEDURE
Insert
name
FileName
fad
DiskAdr
VAR
oldroot
DiskAdr
h
BOOLEAN
U
DirEntry
a
DirPage
BEGIN
h
FALSE
insert
name
DirRootAdr
h
U
fad
IF
h
THEN
root
overflow
Kernel
GetSector
DirRootAdr
a
ASSERT
a
mark
DirMark
Kernel
AllocSector
DirRootAdr
oldroot
Kernel
PutSector
oldroot
a
a
mark
DirMark
a
m
a
p0
oldroot
a
e
U
Kernel
PutSector
DirRootAdr
a
END
END
Insert
PROCEDURE
underflow
VAR
c
DirPage
ancestor
page
dpg0
DiskAdr
s
INTEGER
insertion
point
in
c
VAR
h
BOOLEAN
c
undersize
VAR
i
k
INTEGER
dpg1
DiskAdr
a
b
DirPage
a
underflowing
page
b
neighbouring
page
BEGIN
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
h
a
m
N
dpg0
c
e
s
p
IF
s
c
m
THEN
b
page
to
the
right
of
a
dpg1
c
e
s
p
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
k
b
m
N
DIV
k
no
of
items
available
on
page
b
a
e
N
c
e
s
a
e
N
p
b
p0
IF
k
THEN
move
k
items
from
b
to
a
one
to
c
i
WHILE
i
k
DO
a
e
i
N
b
e
i
INC
i
END
c
e
s
b
e
i
b
p0
c
e
s
p
c
e
s
p
dpg1
b
m
b
m
k
i
WHILE
i
b
m
DO
b
e
i
b
e
i
k
INC
i
END
Kernel
PutSector
dpg1
b
a
m
N
k
h
FALSE
ELSE
merge
pages
a
and
b
discard
b
i
WHILE
i
N
DO
a
e
i
N
b
e
i
INC
i
END
i
s
DEC
c
m
WHILE
i
c
m
DO
c
e
i
c
e
i
INC
i
END
a
m
N
h
c
m
N
END
Kernel
PutSector
dpg0
a
ELSE
b
page
to
the
left
of
a
DEC
s
IF
s
THEN
dpg1
c
p0
ELSE
dpg1
c
e
s
p
END
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
k
b
m
N
DIV
k
no
of
items
available
on
page
b
IF
k
THEN
i
N
WHILE
i
DO
DEC
i
a
e
i
k
a
e
i
END
i
k
a
e
i
c
e
s
a
e
i
p
a
p0
move
k
items
from
b
to
a
one
to
c
b
m
b
m
k
WHILE
i
DO
DEC
i
a
e
i
b
e
i
b
m
END
c
e
s
b
e
b
m
a
p0
c
e
s
p
c
e
s
p
dpg0
a
m
N
k
h
FALSE
Kernel
PutSector
dpg0
a
ELSE
merge
pages
a
and
b
discard
a
c
e
s
p
a
p0
b
e
N
c
e
s
i
WHILE
i
N
DO
b
e
i
N
a
e
i
INC
i
END
b
m
N
DEC
c
m
h
c
m
N
END
Kernel
PutSector
dpg1
b
END
END
underflow
PROCEDURE
delete
name
FileName
dpg0
DiskAdr
VAR
h
BOOLEAN
VAR
fad
DiskAdr
search
and
delete
entry
with
key
name
if
a
page
underflow
arises
balance
with
adjacent
page
or
merge
h
page
dpg0
is
undersize
VAR
i
L
R
INTEGER
dpg1
DiskAdr
a
DirPage
PROCEDURE
del
VAR
a
DirPage
R
INTEGER
dpg1
DiskAdr
VAR
h
BOOLEAN
VAR
dpg2
DiskAdr
global
a
R
b
DirPage
BEGIN
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
dpg2
b
e
b
m
p
IF
dpg2
THEN
del
a
R
dpg2
h
IF
h
THEN
underflow
b
dpg2
b
m
h
Kernel
PutSector
dpg1
b
END
ELSE
b
e
b
m
p
a
e
R
p
a
e
R
b
e
b
m
DEC
b
m
h
b
m
N
Kernel
PutSector
dpg1
b
END
END
del
BEGIN
h
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
THEN
dpg1
a
p0
ELSE
dpg1
a
e
R
p
END
IF
R
a
m
name
a
e
R
name
THEN
found
now
delete
fad
a
e
R
adr
IF
dpg1
THEN
a
is
a
leaf
page
DEC
a
m
h
a
m
N
i
R
WHILE
i
a
m
DO
a
e
i
a
e
i
INC
i
END
ELSE
del
a
R
dpg1
h
IF
h
THEN
underflow
a
dpg1
R
h
END
END
Kernel
PutSector
dpg0
a
ELSIF
dpg1
THEN
delete
name
dpg1
h
fad
IF
h
THEN
underflow
a
dpg1
R
h
Kernel
PutSector
dpg0
a
END
ELSE
not
in
tree
fad
END
END
delete
PROCEDURE
Delete
name
FileName
VAR
fad
DiskAdr
VAR
h
BOOLEAN
newroot
DiskAdr
a
DirPage
BEGIN
h
FALSE
delete
name
DirRootAdr
h
fad
IF
h
THEN
root
underflow
Kernel
GetSector
DirRootAdr
a
ASSERT
a
mark
DirMark
IF
a
m
a
p0
THEN
newroot
a
p0
Kernel
GetSector
newroot
a
ASSERT
a
mark
DirMark
Kernel
PutSector
DirRootAdr
a
discard
newroot
END
END
END
Delete
PROCEDURE
enumerate
prefix
ARRAY
OF
CHAR
dpg
DiskAdr
proc
EntryHandler
VAR
continue
BOOLEAN
VAR
i
j
INTEGER
pfx
nmx
CHAR
dpg1
DiskAdr
a
DirPage
BEGIN
Kernel
GetSector
dpg
a
ASSERT
a
mark
DirMark
i
WHILE
i
a
m
continue
DO
j
REPEAT
pfx
prefix
j
nmx
a
e
i
name
j
INC
j
UNTIL
nmx
pfx
OR
pfx
0X
IF
nmx
pfx
THEN
IF
i
THEN
dpg1
a
p0
ELSE
dpg1
a
e
i
p
END
IF
dpg1
THEN
enumerate
prefix
dpg1
proc
continue
END
IF
pfx
0X
THEN
IF
continue
THEN
proc
a
e
i
name
a
e
i
adr
continue
END
ELSE
continue
FALSE
END
END
INC
i
END
IF
continue
i
a
e
i
p
THEN
enumerate
prefix
a
e
i
p
proc
continue
END
END
enumerate
PROCEDURE
Enumerate
prefix
ARRAY
OF
CHAR
proc
EntryHandler
VAR
b
BOOLEAN
BEGIN
b
TRUE
enumerate
prefix
DirRootAdr
proc
b
END
Enumerate
initialization
PROCEDURE
Init
VAR
k
INTEGER
A
ARRAY
OF
DiskAdr
PROCEDURE
MarkSectors
VAR
A
ARRAY
OF
DiskAdr
k
INTEGER
VAR
L
R
i
j
n
INTEGER
x
DiskAdr
hd
FileHeader
B
IndexSector
PROCEDURE
sift
VAR
A
ARRAY
OF
DiskAdr
L
R
INTEGER
VAR
i
j
INTEGER
x
DiskAdr
BEGIN
j
L
x
A
j
REPEAT
i
j
j
j
IF
j
R
A
j
A
j
THEN
INC
j
END
IF
j
R
x
A
j
THEN
A
i
A
j
END
UNTIL
j
R
OR
x
A
j
A
i
x
END
sift
BEGIN
L
k
DIV
R
k
heapsort
WHILE
L
DO
DEC
L
sift
A
L
R
END
WHILE
R
DO
DEC
R
x
A
A
A
R
A
R
x
sift
A
L
R
END
WHILE
L
k
DO
Kernel
GetSector
A
L
hd
ASSERT
hd
mark
HeaderMark
IF
hd
aleng
SecTabSize
THEN
j
hd
aleng
REPEAT
DEC
j
Kernel
MarkSector
hd
sec
j
UNTIL
j
ELSE
j
SecTabSize
REPEAT
DEC
j
Kernel
MarkSector
hd
sec
j
UNTIL
j
n
hd
aleng
SecTabSize
DIV
i
WHILE
i
n
DO
Kernel
MarkSector
hd
ext
i
Kernel
GetSector
hd
ext
i
B
index
sector
IF
i
n
THEN
j
ELSE
j
hd
aleng
SecTabSize
MOD
END
REPEAT
DEC
j
Kernel
MarkSector
B
j
UNTIL
j
INC
i
END
END
INC
L
END
END
MarkSectors
PROCEDURE
TraverseDir
VAR
A
ARRAY
OF
DiskAdr
VAR
k
INTEGER
dpg
DiskAdr
VAR
i
INTEGER
a
DirPage
BEGIN
Kernel
GetSector
dpg
a
ASSERT
a
mark
DirMark
Kernel
MarkSector
dpg
i
WHILE
i
a
m
DO
A
k
a
e
i
adr
INC
k
INC
i
IF
k
THEN
MarkSectors
A
k
k
END
END
IF
a
p0
THEN
TraverseDir
A
k
a
p0
i
WHILE
i
a
m
DO
TraverseDir
A
k
a
e
i
p
INC
i
END
END
END
TraverseDir
BEGIN
k
TraverseDir
A
k
DirRootAdr
MarkSectors
A
k
END
Init
END
FileDir
MODULE
Files
NW
IMPORT
SYSTEM
Kernel
FileDir
A
file
consists
of
a
sequence
of
pages
The
first
page
contains
the
header
Part
of
the
header
is
the
page
table
an
array
of
disk
addresses
to
the
pages
A
file
is
referenced
through
riders
A
rider
indicates
a
current
position
and
refers
to
a
file
CONST
MaxBufs
HS
FileDir
HeaderSize
SS
FileDir
SectorSize
STS
FileDir
SecTabSize
XS
FileDir
IndexSize
TYPE
DiskAdr
INTEGER
File
POINTER
TO
FileDesc
Buffer
POINTER
TO
BufferRecord
Index
POINTER
TO
IndexRecord
Rider
RECORD
eof
BOOLEAN
res
INTEGER
file
File
apos
bpos
INTEGER
buf
Buffer
END
FileDesc
RECORD
next
INTEGER
list
of
files
invisible
to
the
GC
nofbufs
aleng
bleng
INTEGER
modH
registered
BOOLEAN
firstbuf
Buffer
sechint
DiskAdr
name
FileDir
FileName
date
INTEGER
ext
ARRAY
FileDir
ExTabSize
OF
Index
sec
FileDir
SectorTable
END
BufferRecord
RECORD
apos
lim
INTEGER
mod
BOOLEAN
next
Buffer
data
FileDir
DataSector
END
IndexRecord
RECORD
adr
DiskAdr
mod
BOOLEAN
sec
FileDir
IndexSector
END
aleng
SS
bleng
length
including
header
apos
SS
bpos
current
position
bpos
lim
SS
apos
aleng
PgTabSize
apos
aleng
lim
SS
OR
apos
aleng
VAR
root
INTEGER
File
list
of
open
files
PROCEDURE
Check
s
ARRAY
OF
CHAR
VAR
name
FileDir
FileName
VAR
res
INTEGER
VAR
i
INTEGER
ch
CHAR
BEGIN
ch
s
i
IF
ch
A
ch
Z
OR
ch
a
ch
z
THEN
REPEAT
name
i
ch
INC
i
ch
s
i
UNTIL
ch
ch
OR
ch
A
ch
Z
OR
ch
a
ch
z
OR
ch
OR
i
FileDir
FnLength
IF
i
FileDir
FnLength
THEN
res
ELSIF
ch
0X
THEN
res
WHILE
i
FileDir
FnLength
DO
name
i
0X
INC
i
END
ELSE
res
END
ELSIF
ch
0X
THEN
name
0X
res
ELSE
res
END
END
Check
PROCEDURE
Old
name
ARRAY
OF
CHAR
File
VAR
i
k
res
INTEGER
f
File
header
DiskAdr
buf
Buffer
F
FileDir
FileHd
namebuf
FileDir
FileName
inxpg
Index
BEGIN
f
NIL
Check
name
namebuf
res
IF
res
THEN
FileDir
Search
namebuf
header
IF
header
THEN
f
SYSTEM
VAL
File
root
WHILE
f
NIL
f
sec
header
DO
f
SYSTEM
VAL
File
f
next
END
IF
f
NIL
THEN
file
not
yet
present
NEW
buf
buf
apos
buf
next
buf
buf
mod
FALSE
F
SYSTEM
VAL
FileDir
FileHd
SYSTEM
ADR
buf
data
Kernel
GetSector
header
buf
data
ASSERT
F
mark
FileDir
HeaderMark
NEW
f
f
aleng
F
aleng
f
bleng
F
bleng
f
date
F
date
IF
f
aleng
THEN
buf
lim
f
bleng
ELSE
buf
lim
SS
END
f
firstbuf
buf
f
nofbufs
f
name
namebuf
f
registered
TRUE
f
sec
F
sec
k
f
aleng
XS
STS
DIV
XS
i
WHILE
i
k
DO
NEW
inxpg
inxpg
adr
F
ext
i
inxpg
mod
FALSE
Kernel
GetSector
inxpg
adr
inxpg
sec
f
ext
i
inxpg
INC
i
END
WHILE
i
FileDir
ExTabSize
DO
f
ext
i
NIL
INC
i
END
f
sechint
header
f
modH
FALSE
f
next
root
root
SYSTEM
VAL
INTEGER
f
END
END
END
RETURN
f
END
Old
PROCEDURE
New
name
ARRAY
OF
CHAR
File
VAR
i
res
INTEGER
f
File
buf
Buffer
F
FileDir
FileHd
namebuf
FileDir
FileName
BEGIN
f
NIL
Check
name
namebuf
res
IF
res
THEN
NEW
buf
buf
apos
buf
mod
TRUE
buf
lim
HS
buf
next
buf
F
SYSTEM
VAL
FileDir
FileHd
SYSTEM
ADR
buf
data
F
mark
FileDir
HeaderMark
F
aleng
F
bleng
HS
F
name
namebuf
F
date
Kernel
Clock
NEW
f
f
aleng
f
bleng
HS
f
modH
TRUE
f
registered
FALSE
f
date
F
date
f
firstbuf
buf
f
nofbufs
f
name
namebuf
f
sechint
i
REPEAT
f
ext
i
NIL
F
ext
i
INC
i
UNTIL
i
FileDir
ExTabSize
i
REPEAT
f
sec
i
F
sec
i
INC
i
UNTIL
i
STS
END
RETURN
f
END
New
PROCEDURE
UpdateHeader
f
File
VAR
F
FileDir
FileHeader
VAR
k
INTEGER
BEGIN
F
aleng
f
aleng
F
bleng
f
bleng
F
sec
f
sec
k
f
aleng
XS
STS
DIV
XS
WHILE
k
DO
DEC
k
F
ext
k
f
ext
k
adr
END
END
UpdateHeader
PROCEDURE
ReadBuf
f
File
buf
Buffer
pos
INTEGER
VAR
sec
DiskAdr
BEGIN
IF
pos
STS
THEN
sec
f
sec
pos
ELSE
sec
f
ext
pos
STS
DIV
XS
sec
pos
STS
MOD
XS
END
Kernel
GetSector
sec
buf
data
IF
pos
f
aleng
THEN
buf
lim
SS
ELSE
buf
lim
f
bleng
END
buf
apos
pos
buf
mod
FALSE
END
ReadBuf
PROCEDURE
WriteBuf
f
File
buf
Buffer
VAR
i
k
INTEGER
secadr
DiskAdr
inx
Index
BEGIN
IF
buf
apos
STS
THEN
secadr
f
sec
buf
apos
IF
secadr
THEN
Kernel
AllocSector
f
sechint
secadr
f
modH
TRUE
f
sec
buf
apos
secadr
f
sechint
secadr
END
IF
buf
apos
THEN
UpdateHeader
f
SYSTEM
VAL
FileDir
FileHeader
buf
data
f
modH
FALSE
END
ELSE
i
buf
apos
STS
DIV
XS
inx
f
ext
i
IF
inx
NIL
THEN
NEW
inx
inx
adr
inx
sec
f
ext
i
inx
f
modH
TRUE
END
k
buf
apos
STS
MOD
XS
secadr
inx
sec
k
IF
secadr
THEN
Kernel
AllocSector
f
sechint
secadr
f
modH
TRUE
inx
mod
TRUE
inx
sec
k
secadr
f
sechint
secadr
END
END
Kernel
PutSector
secadr
buf
data
buf
mod
FALSE
END
WriteBuf
PROCEDURE
Buf
f
File
pos
INTEGER
Buffer
VAR
buf
Buffer
BEGIN
buf
f
firstbuf
WHILE
buf
apos
pos
buf
next
f
firstbuf
DO
buf
buf
next
END
IF
buf
apos
pos
THEN
buf
NIL
END
RETURN
buf
END
Buf
PROCEDURE
GetBuf
f
File
pos
INTEGER
Buffer
VAR
buf
Buffer
BEGIN
buf
f
firstbuf
WHILE
buf
apos
pos
buf
next
f
firstbuf
DO
buf
buf
next
END
IF
buf
apos
pos
THEN
IF
f
nofbufs
MaxBufs
THEN
allocate
new
buffer
NEW
buf
buf
next
f
firstbuf
next
f
firstbuf
next
buf
INC
f
nofbufs
ELSE
reuse
a
buffer
f
firstbuf
buf
IF
buf
mod
THEN
WriteBuf
f
buf
END
END
IF
pos
f
aleng
THEN
ReadBuf
f
buf
pos
ELSE
buf
apos
pos
buf
lim
buf
mod
FALSE
END
END
RETURN
buf
END
GetBuf
PROCEDURE
Unbuffer
f
File
VAR
i
k
INTEGER
buf
Buffer
inx
Index
head
FileDir
FileHeader
BEGIN
buf
f
firstbuf
REPEAT
IF
buf
mod
THEN
WriteBuf
f
buf
END
buf
buf
next
UNTIL
buf
f
firstbuf
k
f
aleng
XS
STS
DIV
XS
i
WHILE
i
k
DO
inx
f
ext
i
INC
i
IF
inx
mod
THEN
IF
inx
adr
THEN
Kernel
AllocSector
f
sechint
inx
adr
f
sechint
inx
adr
f
modH
TRUE
END
Kernel
PutSector
inx
adr
inx
sec
inx
mod
FALSE
END
END
IF
f
modH
THEN
Kernel
GetSector
f
sec
head
UpdateHeader
f
head
Kernel
PutSector
f
sec
head
f
modH
FALSE
END
END
Unbuffer
PROCEDURE
Register
f
File
BEGIN
IF
f
NIL
f
name
0X
THEN
Unbuffer
f
IF
f
registered
THEN
FileDir
Insert
f
name
f
sec
f
registered
TRUE
f
next
root
root
SYSTEM
VAL
INTEGER
f
END
END
END
Register
PROCEDURE
Close
f
File
BEGIN
IF
f
NIL
THEN
Unbuffer
f
END
END
Close
PROCEDURE
Purge
f
File
VAR
a
i
j
k
INTEGER
ind
FileDir
IndexSector
BEGIN
IF
f
NIL
THEN
a
f
aleng
f
aleng
f
bleng
HS
IF
a
STS
THEN
i
a
ELSE
i
STS
DEC
a
i
j
a
MOD
XS
k
a
DIV
XS
WHILE
k
DO
Kernel
GetSector
f
ext
k
adr
ind
REPEAT
DEC
j
Kernel
FreeSector
ind
j
UNTIL
j
Kernel
FreeSector
f
ext
k
adr
j
XS
DEC
k
END
END
REPEAT
DEC
i
Kernel
FreeSector
f
sec
i
UNTIL
i
END
END
Purge
PROCEDURE
Delete
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
adr
DiskAdr
namebuf
FileDir
FileName
BEGIN
Check
name
namebuf
res
IF
res
THEN
FileDir
Delete
namebuf
adr
IF
adr
THEN
res
END
END
END
Delete
PROCEDURE
Rename
old
new
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
adr
DiskAdr
oldbuf
newbuf
FileDir
FileName
head
FileDir
FileHeader
BEGIN
Check
old
oldbuf
res
IF
res
THEN
Check
new
newbuf
res
IF
res
THEN
FileDir
Delete
oldbuf
adr
IF
adr
THEN
FileDir
Insert
newbuf
adr
Kernel
GetSector
adr
head
head
name
newbuf
Kernel
PutSector
adr
head
ELSE
res
END
END
END
END
Rename
PROCEDURE
Length
f
File
INTEGER
BEGIN
RETURN
f
aleng
SS
f
bleng
HS
END
Length
PROCEDURE
Date
f
File
INTEGER
BEGIN
RETURN
f
date
END
Date
Read
PROCEDURE
Set
VAR
r
Rider
f
File
pos
INTEGER
VAR
a
b
INTEGER
BEGIN
r
eof
FALSE
r
res
IF
f
NIL
THEN
IF
pos
THEN
a
b
HS
ELSIF
pos
f
aleng
SS
f
bleng
HS
THEN
a
pos
HS
DIV
SS
b
pos
HS
MOD
SS
ELSE
a
f
aleng
b
f
bleng
END
r
file
f
r
apos
a
r
bpos
b
r
buf
f
firstbuf
ELSE
r
file
NIL
END
END
Set
PROCEDURE
Pos
VAR
r
Rider
INTEGER
BEGIN
RETURN
r
apos
SS
r
bpos
HS
END
Pos
PROCEDURE
Base
VAR
r
Rider
File
BEGIN
RETURN
r
file
END
Base
PROCEDURE
ReadByte
VAR
r
Rider
VAR
x
BYTE
VAR
buf
Buffer
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
x
r
buf
data
r
bpos
INC
r
bpos
ELSIF
r
apos
r
file
aleng
THEN
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
buf
mod
THEN
WriteBuf
r
file
r
buf
END
ReadBuf
r
file
r
buf
r
apos
ELSE
r
buf
buf
END
x
r
buf
data
r
bpos
ELSE
x
r
eof
TRUE
END
END
ReadByte
PROCEDURE
ReadBytes
VAR
r
Rider
VAR
x
ARRAY
OF
BYTE
n
INTEGER
VAR
i
INTEGER
BEGIN
i
this
implementation
is
to
be
improved
WHILE
i
n
DO
ReadByte
r
x
i
INC
i
END
END
ReadBytes
PROCEDURE
Read
VAR
r
Rider
VAR
ch
CHAR
VAR
buf
Buffer
same
as
ReadByte
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
ch
CHR
r
buf
data
r
bpos
INC
r
bpos
ELSIF
r
apos
r
file
aleng
THEN
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
buf
mod
THEN
WriteBuf
r
file
r
buf
END
ReadBuf
r
file
r
buf
r
apos
ELSE
r
buf
buf
END
ch
CHR
r
buf
data
r
bpos
ELSE
ch
0X
r
eof
TRUE
END
END
Read
PROCEDURE
ReadInt
VAR
R
Rider
VAR
x
INTEGER
VAR
x0
x1
x2
x3
BYTE
BEGIN
ReadByte
R
x0
ReadByte
R
x1
ReadByte
R
x2
ReadByte
R
x3
x
x3
100H
x2
100H
x1
100H
x0
END
ReadInt
PROCEDURE
ReadSet
VAR
R
Rider
VAR
s
SET
VAR
n
INTEGER
BEGIN
ReadInt
R
SYSTEM
VAL
INTEGER
s
END
ReadSet
PROCEDURE
ReadReal
VAR
R
Rider
VAR
x
REAL
VAR
n
INTEGER
BEGIN
ReadInt
R
SYSTEM
VAL
INTEGER
x
END
ReadReal
PROCEDURE
ReadString
VAR
R
Rider
VAR
x
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
i
Read
R
ch
WHILE
ch
0X
DO
IF
i
LEN
x
THEN
x
i
ch
INC
i
END
Read
R
ch
END
x
i
0X
END
ReadString
PROCEDURE
ReadNum
VAR
R
Rider
VAR
x
INTEGER
VAR
n
y
INTEGER
b
BYTE
BEGIN
n
y
ReadByte
R
b
WHILE
b
80H
DO
y
ROR
y
b
80H
DEC
n
ReadByte
R
b
END
IF
n
THEN
x
ROR
y
b
MOD
10H
ELSE
x
ASR
ROR
y
b
n
END
END
ReadNum
Write
PROCEDURE
NewExt
f
File
VAR
i
k
INTEGER
ext
Index
BEGIN
k
f
aleng
STS
DIV
XS
NEW
ext
ext
adr
ext
mod
TRUE
f
ext
k
ext
i
XS
REPEAT
DEC
i
ext
sec
i
UNTIL
i
END
NewExt
PROCEDURE
WriteByte
VAR
r
Rider
x
BYTE
VAR
f
File
buf
Buffer
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
IF
r
bpos
SS
THEN
INC
r
buf
lim
INC
r
file
bleng
r
file
modH
TRUE
ELSE
f
r
file
WriteBuf
f
r
buf
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
apos
f
aleng
THEN
ReadBuf
f
r
buf
r
apos
ELSE
r
buf
apos
r
apos
r
buf
lim
f
aleng
f
aleng
f
bleng
f
modH
TRUE
IF
f
aleng
STS
MOD
XS
THEN
NewExt
f
END
END
ELSE
r
buf
buf
END
r
bpos
END
END
r
buf
data
r
bpos
x
INC
r
bpos
r
buf
mod
TRUE
END
WriteByte
PROCEDURE
WriteBytes
VAR
r
Rider
x
ARRAY
OF
BYTE
n
INTEGER
VAR
i
INTEGER
BEGIN
i
this
implementation
is
to
be
improed
WHILE
i
n
DO
WriteByte
r
x
i
INC
i
END
END
WriteBytes
PROCEDURE
Write
VAR
r
Rider
ch
CHAR
VAR
f
File
buf
Buffer
BEGIN
same
as
WriteByte
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
IF
r
bpos
SS
THEN
INC
r
buf
lim
INC
r
file
bleng
r
file
modH
TRUE
ELSE
f
r
file
WriteBuf
f
r
buf
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
apos
f
aleng
THEN
ReadBuf
f
r
buf
r
apos
ELSE
r
buf
apos
r
apos
r
buf
lim
f
aleng
f
aleng
f
bleng
f
modH
TRUE
IF
f
aleng
STS
MOD
XS
THEN
NewExt
f
END
END
ELSE
r
buf
buf
END
r
bpos
END
END
r
buf
data
r
bpos
ORD
ch
INC
r
bpos
r
buf
mod
TRUE
END
Write
PROCEDURE
WriteInt
VAR
R
Rider
x
INTEGER
BEGIN
WriteByte
R
x
MOD
100H
WriteByte
R
x
DIV
100H
MOD
100H
WriteByte
R
x
DIV
10000H
MOD
100H
WriteByte
R
x
DIV
1000000H
MOD
100H
END
WriteInt
PROCEDURE
WriteSet
VAR
R
Rider
s
SET
BEGIN
WriteInt
R
ORD
s
END
WriteSet
PROCEDURE
WriteReal
VAR
R
Rider
x
REAL
BEGIN
WriteInt
R
ORD
x
END
WriteReal
PROCEDURE
WriteString
VAR
R
Rider
x
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
i
REPEAT
ch
x
i
Write
R
ch
INC
i
UNTIL
ch
0X
END
WriteString
PROCEDURE
WriteNum
VAR
R
Rider
x
INTEGER
BEGIN
WHILE
x
40H
OR
x
40H
DO
WriteByte
R
x
MOD
80H
80H
x
ASR
x
END
WriteByte
R
x
MOD
80H
END
WriteNum
System
use
PROCEDURE
Init
BEGIN
root
Kernel
Init
FileDir
Init
END
Init
PROCEDURE
RestoreList
after
mark
phase
of
garbage
collection
VAR
f
f0
INTEGER
PROCEDURE
mark
f
INTEGER
INTEGER
VAR
m
INTEGER
BEGIN
IF
f
THEN
m
ELSE
SYSTEM
GET
f
m
END
RETURN
m
END
mark
BEGIN
field
next
has
offset
WHILE
mark
root
DO
SYSTEM
GET
root
root
END
f
root
WHILE
f
DO
f0
f
REPEAT
SYSTEM
GET
f0
f0
UNTIL
mark
f0
SYSTEM
PUT
f
f0
f
f0
END
END
RestoreList
END
Files
MODULE
Fonts
JG
PDR
NW
IMPORT
SYSTEM
Files
CONST
FontFileId
0DBH
TYPE
Font
POINTER
TO
FontDesc
FontDesc
RECORD
name
ARRAY
OF
CHAR
height
minX
maxX
minY
maxY
INTEGER
next
Font
T
ARRAY
OF
INTEGER
raster
ARRAY
OF
BYTE
END
LargeFontDesc
RECORD
FontDesc
ext
ARRAY
OF
BYTE
END
LargeFont
POINTER
TO
LargeFontDesc
raster
sizes
Syntax8
Syntax10
Syntax12
Syntax14
Syntax14b
Syntax16
Syntax20
Syntac24
Syntax24b
VAR
Default
root
Font
PROCEDURE
GetPat
fnt
Font
ch
CHAR
VAR
dx
x
y
w
h
patadr
INTEGER
VAR
pa
INTEGER
dxb
xb
yb
wb
hb
BYTE
BEGIN
pa
fnt
T
ORD
ch
MOD
80H
patadr
pa
SYSTEM
GET
pa
dxb
SYSTEM
GET
pa
xb
SYSTEM
GET
pa
yb
SYSTEM
GET
pa
wb
SYSTEM
GET
pa
hb
dx
dxb
x
xb
y
yb
w
wb
h
hb
IF
yb
THEN
y
yb
ELSE
y
yb
END
END
GetPat
PROCEDURE
This
name
ARRAY
OF
CHAR
Font
TYPE
RunRec
RECORD
beg
end
BYTE
END
BoxRec
RECORD
dx
x
y
w
h
BYTE
END
VAR
F
Font
LF
LargeFont
f
Files
File
R
Files
Rider
NofRuns
NofBoxes
BYTE
NofBytes
INTEGER
height
minX
maxX
minY
maxY
BYTE
i
j
k
m
n
INTEGER
a
a0
INTEGER
b
beg
end
BYTE
run
ARRAY
OF
RunRec
box
ARRAY
OF
BoxRec
PROCEDURE
RdInt16
VAR
R
Files
Rider
VAR
b0
BYTE
VAR
b1
BYTE
BEGIN
Files
ReadByte
R
b0
Files
ReadByte
R
b1
END
RdInt16
BEGIN
F
root
WHILE
F
NIL
name
F
name
DO
F
F
next
END
IF
F
NIL
THEN
f
Files
Old
name
IF
f
NIL
THEN
Files
Set
R
f
Files
ReadByte
R
b
IF
b
FontFileId
THEN
Files
ReadByte
R
b
abstraction
Files
ReadByte
R
b
family
Files
ReadByte
R
b
variant
NEW
F
F
name
name
RdInt16
R
height
RdInt16
R
minX
RdInt16
R
maxX
RdInt16
R
minY
RdInt16
R
maxY
RdInt16
R
NofRuns
NofBoxes
k
WHILE
k
NofRuns
DO
RdInt16
R
beg
run
k
beg
beg
RdInt16
R
end
run
k
end
end
NofBoxes
NofBoxes
end
beg
INC
k
END
NofBytes
j
WHILE
j
NofBoxes
DO
RdInt16
R
box
j
dx
RdInt16
R
box
j
x
RdInt16
R
box
j
y
RdInt16
R
box
j
w
RdInt16
R
box
j
h
NofBytes
NofBytes
box
j
w
DIV
box
j
h
INC
j
END
IF
NofBytes
THEN
NEW
F
ELSE
NEW
LF
F
LF
END
F
name
name
F
height
height
F
minX
minX
F
maxX
maxX
F
maxY
maxY
IF
minY
80H
THEN
F
minY
minY
100H
ELSE
F
minY
minY
END
a0
SYSTEM
ADR
F
raster
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
null
pattern
for
characters
not
in
a
run
INC
a0
a
a0
j
k
m
WHILE
k
NofRuns
DO
WHILE
m
run
k
beg
m
DO
F
T
m
a0
INC
m
END
WHILE
m
run
k
end
m
DO
F
T
m
a
SYSTEM
PUT
a
box
j
dx
SYSTEM
PUT
a
box
j
x
SYSTEM
PUT
a
box
j
y
SYSTEM
PUT
a
box
j
w
SYSTEM
PUT
a
box
j
h
INC
a
n
box
j
w
DIV
box
j
h
WHILE
n
DO
DEC
n
Files
ReadByte
R
b
SYSTEM
PUT
a
b
INC
a
END
INC
j
INC
m
END
INC
k
END
WHILE
m
DO
F
T
m
a0
INC
m
END
F
next
root
root
F
ELSE
bad
file
id
F
Default
END
ELSE
font
file
not
available
F
Default
END
END
RETURN
F
END
This
PROCEDURE
Free
remove
all
but
first
two
from
font
list
VAR
f
Font
BEGIN
f
root
next
IF
f
NIL
THEN
f
f
next
END
f
next
NIL
END
Free
BEGIN
root
NIL
Default
This
Oberon10
Scn
Fnt
END
Fonts
MODULE
GraphicFrames
NW
IMPORT
SYSTEM
Display
Viewers
Input
Fonts
Texts
Graphics
Oberon
MenuViewers
CONST
update
message
ids
drawobj
drawobjs
drawobjd
drawnorm
drawsel
drawdel
markW
TYPE
Frame
POINTER
TO
FrameDesc
Location
POINTER
TO
LocDesc
LocDesc
RECORD
x
y
INTEGER
next
Location
END
FrameDesc
RECORD
Display
FrameDesc
graph
Graphics
Graph
Xg
Yg
INTEGER
pos
rel
to
graph
origin
X1
Y1
INTEGER
right
and
upper
margins
x
y
col
INTEGER
x
X
Xg
y
Y
Yg
marked
ticked
BOOLEAN
mark
LocDesc
END
DrawMsg
RECORD
Graphics
Msg
f
Frame
x
y
col
mode
INTEGER
END
UpdateMsg
RECORD
Display
FrameMsg
id
INTEGER
graph
Graphics
Graph
obj
Graphics
Object
END
ChangedMsg
RECORD
Display
FrameMsg
f
Frame
graph
Graphics
Graph
mode
INTEGER
END
SelQuery
RECORD
Display
FrameMsg
f
Frame
time
LONGINT
END
FocusQuery
RECORD
Display
FrameMsg
f
Frame
END
PosQuery
RECORD
Display
FrameMsg
f
Frame
x
y
INTEGER
END
DispMsg
RECORD
Display
FrameMsg
x1
y1
w
INTEGER
pat
INTEGER
graph
Graphics
Graph
END
VAR
Crosshair
Oberon
Marker
tack
dotted
dotted1
INTEGER
patterns
newcap
Graphics
Caption
TBuf
Texts
Buffer
DW
DH
CL
INTEGER
W
Texts
Writer
Exported
procedures
Restore
Focus
Selected
This
Draw
DrawNorm
Erase
DrawObj
EraseObj
Change
Defocus
Deselect
Macro
Open
PROCEDURE
SetChangeMark
F
Frame
col
INTEGER
set
mark
in
corner
of
frame
BEGIN
IF
F
H
THEN
IF
col
THEN
Display
ReplConst
Display
black
F
X
F
W
F
Y
F
H
Display
replace
ELSE
Display
CopyPattern
Display
white
Display
block
F
X
F
W
F
Y
F
H
Display
paint
END
END
END
SetChangeMark
PROCEDURE
Restore
F
Frame
VAR
x
x0
y
INTEGER
M
DrawMsg
BEGIN
F
X1
F
X
F
W
F
Y1
F
Y
F
H
F
x
F
X
F
Xg
DIV
F
y
F
Y
F
Yg
DIV
F
marked
FALSE
F
mark
next
NIL
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Display
ReplConst
F
col
F
X
F
Y
F
W
F
H
IF
F
ticked
THEN
x0
F
X
DIV
y
F
Y
DIV
WHILE
y
F
Y1
DO
x
x0
WHILE
x
F
X1
DO
Display
Dot
Display
white
x
y
Display
replace
INC
x
END
INC
y
END
END
M
f
F
M
x
F
x
M
y
F
y
M
col
M
mode
Graphics
Draw
F
graph
M
IF
F
graph
changed
THEN
SetChangeMark
F
END
END
Restore
PROCEDURE
FlipCross
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
cross
X
Y
Display
invert
END
FlipCross
PROCEDURE
Focus
Frame
VAR
FQ
FocusQuery
BEGIN
FQ
f
NIL
Viewers
Broadcast
FQ
RETURN
FQ
f
END
Focus
PROCEDURE
Selected
Frame
VAR
SQ
SelQuery
BEGIN
SQ
f
NIL
SQ
time
Viewers
Broadcast
SQ
RETURN
SQ
f
END
Selected
PROCEDURE
This
x
y
INTEGER
Frame
VAR
PQ
PosQuery
BEGIN
PQ
f
NIL
PQ
x
x
PQ
y
y
Viewers
Broadcast
PQ
RETURN
PQ
f
END
This
PROCEDURE
Mark
F
Frame
mode
INTEGER
VAR
CM
ChangedMsg
BEGIN
CM
f
F
CM
graph
F
graph
CM
mode
mode
Viewers
Broadcast
CM
END
Mark
PROCEDURE
Draw
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawsel
UM
graph
F
graph
Viewers
Broadcast
UM
END
Draw
PROCEDURE
DrawNorm
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawnorm
UM
graph
F
graph
Viewers
Broadcast
UM
END
DrawNorm
PROCEDURE
Erase
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawdel
UM
graph
F
graph
Viewers
Broadcast
UM
Mark
F
END
Erase
PROCEDURE
DrawObj
F
Frame
obj
Graphics
Object
VAR
UM
UpdateMsg
BEGIN
UM
id
drawobj
UM
graph
F
graph
UM
obj
obj
Viewers
Broadcast
UM
END
DrawObj
PROCEDURE
EraseObj
F
Frame
obj
Graphics
Object
VAR
UM
UpdateMsg
BEGIN
UM
id
drawobjd
UM
graph
F
graph
UM
obj
obj
Viewers
Broadcast
UM
END
EraseObj
PROCEDURE
Change
F
Frame
VAR
msg
Graphics
Msg
BEGIN
IF
F
NIL
THEN
Erase
F
Graphics
Change
F
graph
msg
Draw
F
END
END
Change
PROCEDURE
FlipMark
x
y
INTEGER
BEGIN
Display
ReplConst
Display
white
x
y
Display
ReplConst
Display
white
x
y
END
FlipMark
PROCEDURE
Defocus
F
Frame
VAR
m
Location
BEGIN
newcap
NIL
IF
F
marked
THEN
FlipMark
F
mark
x
F
mark
y
m
F
mark
next
WHILE
m
NIL
DO
FlipMark
m
x
m
y
m
m
next
END
F
marked
FALSE
F
mark
next
NIL
END
END
Defocus
PROCEDURE
Deselect
F
Frame
VAR
UM
UpdateMsg
BEGIN
IF
F
NIL
THEN
UM
id
drawnorm
UM
graph
F
graph
Viewers
Broadcast
UM
Graphics
Deselect
F
graph
END
END
Deselect
PROCEDURE
Macro
Lname
Mname
ARRAY
OF
CHAR
VAR
x
y
INTEGER
F
Frame
mac
Graphics
Macro
mh
Graphics
MacHead
L
Graphics
Library
BEGIN
F
Focus
IF
F
NIL
THEN
x
F
mark
x
F
x
y
F
mark
y
F
y
Graphics
GetLib
Lname
FALSE
L
IF
L
NIL
THEN
mh
Graphics
ThisMac
L
Mname
IF
mh
NIL
THEN
Deselect
F
Defocus
F
NEW
mac
mac
x
x
mac
y
y
mac
w
mh
w
mac
h
mh
h
mac
mac
mh
mac
do
Graphics
MacMethod
mac
col
Oberon
CurCol
Graphics
Add
F
graph
mac
DrawObj
F
mac
Mark
F
END
ELSE
Texts
WriteString
W
Lname
Texts
WriteString
W
not
available
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
END
Macro
PROCEDURE
CaptionCopy
F
Frame
x1
y1
INTEGER
T
Texts
Text
beg
end
LONGINT
Graphics
Caption
VAR
ch
CHAR
dx
w
x2
y2
w1
h1
INTEGER
cap
Graphics
Caption
pat
INTEGER
R
Texts
Reader
BEGIN
Texts
Write
W
0DX
NEW
cap
cap
len
end
beg
cap
pos
Graphics
T
len
cap
do
Graphics
CapMethod
Texts
OpenReader
R
T
beg
Texts
Read
R
ch
W
fnt
R
fnt
W
col
R
col
w
cap
x
x1
F
x
cap
y
y1
F
y
R
fnt
minY
WHILE
beg
end
DO
Fonts
GetPat
R
fnt
ch
dx
x2
y2
w1
h1
pat
INC
w
dx
INC
beg
Texts
Write
W
ch
Texts
Read
R
ch
END
cap
w
w
cap
h
W
fnt
height
cap
col
W
col
Texts
Append
Graphics
T
W
buf
Graphics
Add
F
graph
cap
Mark
F
RETURN
cap
END
CaptionCopy
PROCEDURE
NewLine
F
Frame
G
Graphics
Graph
x
y
w
h
INTEGER
VAR
line
Graphics
Line
BEGIN
NEW
line
line
col
Oberon
CurCol
line
x
x
F
x
line
y
y
F
y
line
w
w
line
h
h
line
do
Graphics
LineMethod
Graphics
Add
G
line
Mark
F
END
NewLine
PROCEDURE
Edit
F
Frame
x0
y0
INTEGER
k0
SET
VAR
obj
Graphics
Object
x1
y1
w
h
t
INTEGER
beg
end
time
LONGINT
k1
k2
SET
mark
newmark
Location
T
Texts
Text
Fd
Frame
G
Graphics
Graph
BEGIN
k1
k0
G
F
graph
REPEAT
Input
Mouse
k2
x1
y1
k1
k1
k2
DEC
x1
x1
F
x
MOD
DEC
y1
y1
F
y
MOD
Oberon
DrawMouse
Crosshair
x1
y1
UNTIL
k2
Oberon
FadeMouse
IF
k0
THEN
left
key
w
ABS
x1
x0
h
ABS
y1
y0
IF
k1
THEN
IF
w
h
THEN
set
mark
IF
x1
markW
F
X
x1
markW
F
X1
y1
markW
F
Y
y1
markW
F
Y1
THEN
Defocus
F
Oberon
PassFocus
Viewers
This
F
X
F
Y
F
mark
x
x1
F
mark
y
y1
F
marked
TRUE
FlipMark
x1
y1
END
ELSE
draw
line
Deselect
F
IF
w
h
THEN
IF
y1
y0
THEN
y0
y1
END
NewLine
F
G
x0
y0
Graphics
width
h
ELSE
IF
x1
x0
THEN
x0
x1
END
NewLine
F
G
x0
y0
w
Graphics
width
END
Draw
F
END
ELSIF
k1
THEN
copy
text
selection
to
mark
Deselect
F
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
DrawObj
F
CaptionCopy
F
x1
y1
T
beg
end
Mark
F
END
ELSIF
k1
THEN
IF
F
marked
THEN
set
secondary
mark
NEW
newmark
newmark
x
x1
newmark
y
y1
newmark
next
NIL
FlipMark
x1
y1
mark
F
mark
next
IF
mark
NIL
THEN
F
mark
next
newmark
ELSE
WHILE
mark
next
NIL
DO
mark
mark
next
END
mark
next
newmark
END
END
END
ELSIF
k0
THEN
middle
key
IF
k1
THEN
move
IF
x0
x1
OR
y0
y1
THEN
Fd
This
x1
y1
Erase
F
IF
Fd
F
THEN
Graphics
Move
G
x1
x0
y1
y0
ELSIF
Fd
NIL
Fd
graph
G
THEN
Graphics
Move
G
x1
Fd
x
x0
F
x
DIV
y1
Fd
y
y0
F
y
DIV
END
Draw
F
Mark
F
END
ELSIF
k1
THEN
copy
Fd
This
x1
y1
IF
Fd
NIL
THEN
DrawNorm
F
IF
Fd
F
THEN
Graphics
Copy
G
G
x1
x0
y1
y0
ELSE
Deselect
Fd
Graphics
Copy
G
Fd
graph
x1
Fd
x
x0
F
x
DIV
y1
Fd
y
y0
F
y
DIV
END
Draw
Fd
Mark
F
END
ELSIF
k1
THEN
shift
graph
INC
F
Xg
x1
x0
INC
F
Yg
y1
y0
Restore
F
END
ELSIF
k0
THEN
right
key
select
newcap
NIL
IF
k1
THEN
Deselect
F
END
IF
ABS
x0
x1
ABS
y0
y1
THEN
obj
Graphics
ThisObj
G
x1
F
x
y1
F
y
IF
obj
NIL
THEN
Graphics
SelectObj
G
obj
DrawObj
F
obj
END
ELSE
IF
x1
x0
THEN
t
x0
x0
x1
x1
t
END
IF
y1
y0
THEN
t
y0
y0
y1
y1
t
END
Graphics
SelectArea
G
x0
F
x
y0
F
y
x1
F
x
y1
F
y
Draw
F
END
END
END
Edit
PROCEDURE
NewCaption
F
Frame
col
INTEGER
font
Fonts
Font
BEGIN
Texts
Write
W
0DX
NEW
newcap
newcap
x
F
mark
x
F
x
newcap
y
F
mark
y
F
y
font
minY
newcap
w
newcap
h
font
height
newcap
col
col
newcap
pos
Graphics
T
len
newcap
len
newcap
do
Graphics
CapMethod
Graphics
Add
F
graph
newcap
W
fnt
font
Mark
F
END
NewCaption
PROCEDURE
InsertChar
F
Frame
ch
CHAR
VAR
w1
h1
INTEGER
DM
DispMsg
BEGIN
DM
graph
F
graph
Fonts
GetPat
W
fnt
ch
DM
w
DM
x1
DM
y1
w1
h1
DM
pat
DEC
DM
y1
W
fnt
minY
IF
newcap
x
newcap
w
DM
w
F
x
F
X1
THEN
Viewers
Broadcast
DM
INC
newcap
w
DM
w
INC
newcap
len
Texts
Write
W
ch
END
Texts
Append
Graphics
T
W
buf
END
InsertChar
PROCEDURE
DeleteChar
F
Frame
VAR
w1
h1
INTEGER
ch
CHAR
pos
LONGINT
DM
DispMsg
R
Texts
Reader
BEGIN
DM
graph
F
graph
IF
newcap
len
THEN
pos
Graphics
T
len
Texts
OpenReader
R
Graphics
T
pos
backspace
Texts
Read
R
ch
IF
ch
THEN
Fonts
GetPat
R
fnt
ch
DM
w
DM
x1
DM
y1
w1
h1
DM
pat
DEC
newcap
w
DM
w
DEC
newcap
len
DEC
DM
y1
R
fnt
minY
Viewers
Broadcast
DM
Texts
Delete
Graphics
T
pos
pos
TBuf
END
END
END
DeleteChar
PROCEDURE
GetSelection
F
Frame
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
VAR
obj
Graphics
Object
BEGIN
obj
F
graph
sel
IF
obj
NIL
F
graph
time
time
THEN
CASE
obj
OF
Graphics
Caption
beg
obj
pos
end
obj
pos
obj
len
text
Graphics
T
time
F
graph
time
END
END
END
GetSelection
PROCEDURE
Handle
G
Display
Frame
VAR
M
Display
FrameMsg
VAR
x
y
h
INTEGER
DM
DispMsg
dM
DrawMsg
G1
Frame
BEGIN
CASE
G
OF
Frame
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
x
M
X
M
X
G
x
MOD
y
M
Y
M
Y
G
y
MOD
IF
M
keys
THEN
Edit
G
x
y
M
keys
ELSE
Oberon
DrawMouse
Crosshair
x
y
END
ELSIF
M
id
Oberon
consume
THEN
IF
M
ch
7FX
THEN
DEL
Erase
G
Graphics
Delete
G
graph
Mark
G
ELSIF
M
ch
20X
M
ch
7FX
THEN
IF
newcap
NIL
THEN
InsertChar
G
M
ch
Mark
G
ELSIF
G
marked
THEN
Defocus
G
Deselect
G
NewCaption
G
M
col
M
fnt
InsertChar
G
M
ch
END
ELSIF
M
ch
8X
newcap
NIL
THEN
DeleteChar
G
Mark
G
END
END
UpdateMsg
IF
M
graph
G
graph
THEN
dM
f
G
dM
x
G
x
dM
y
G
y
dM
col
IF
M
id
drawobj
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawobjs
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawobjd
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawsel
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
ELSIF
M
id
drawnorm
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
ELSIF
M
id
drawdel
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
END
END
ChangedMsg
IF
M
graph
G
graph
THEN
SetChangeMark
G
M
mode
END
SelQuery
IF
G
graph
sel
NIL
M
time
G
graph
time
THEN
M
f
G
Frame
M
time
G
graph
time
END
FocusQuery
IF
G
marked
THEN
M
f
G
END
PosQuery
IF
G
X
M
x
M
x
G
X1
G
Y
M
y
M
y
G
Y1
THEN
M
f
G
END
DispMsg
DM
M
x
G
x
newcap
x
newcap
w
y
G
y
newcap
y
IF
DM
graph
G
graph
x
G
X
x
DM
w
G
X1
y
G
Y
y
G
Y1
THEN
Display
CopyPattern
Oberon
CurCol
DM
pat
x
DM
x1
y
DM
y1
Display
ReplConst
Display
white
x
y
DM
w
newcap
h
END
Oberon
ControlMsg
IF
M
id
Oberon
neutralize
THEN
Oberon
RemoveMarks
G
X
G
Y
G
W
G
H
Defocus
G
DrawNorm
G
Graphics
Deselect
G
graph
ELSIF
M
id
Oberon
defocus
THEN
Defocus
G
END
Oberon
SelectionMsg
GetSelection
G
M
text
M
beg
M
end
M
time
Oberon
CopyMsg
Oberon
RemoveMarks
G
X
G
Y
G
W
G
H
Defocus
G
NEW
G1
G1
G
M
F
G1
MenuViewers
ModifyMsg
G
Y
M
Y
G
H
M
H
Restore
G
END
END
END
Handle
PROCEDURE
Store
F
Frame
name
ARRAY
OF
CHAR
BEGIN
Mark
F
Graphics
WriteFile
F
graph
name
END
Store
Draw
Methods
PROCEDURE
ReplConst
F
Frame
col
x
y
w
h
mode
INTEGER
BEGIN
IF
x
F
X
THEN
DEC
w
F
X
x
x
F
X
END
IF
x
w
F
X1
THEN
w
F
X1
x
END
IF
y
F
Y
THEN
DEC
h
F
Y
y
y
F
Y
END
IF
y
h
F
Y1
THEN
h
F
Y1
y
END
Display
ReplConst
col
x
y
w
h
mode
END
ReplConst
PROCEDURE
ReplPattern
F
Frame
col
patadr
x
y
w
h
mode
INTEGER
BEGIN
IF
x
F
X
THEN
DEC
w
F
X
x
x
F
X
END
IF
x
w
F
X1
THEN
w
F
X1
x
END
IF
y
F
Y
THEN
DEC
h
F
Y
y
y
F
Y
END
IF
y
h
F
Y1
THEN
h
F
Y1
y
END
Display
ReplPattern
col
patadr
x
y
w
h
mode
END
ReplPattern
PROCEDURE
DrawLine
obj
Graphics
Object
VAR
M
Graphics
Msg
M
mode
draw
according
to
state
normal
selected
selected
normal
erase
VAR
x
y
w
h
col
INTEGER
f
Frame
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
x
w
f
X
x
f
X1
y
h
f
Y
y
f
Y1
THEN
col
obj
col
IF
M
mode
obj
selected
OR
M
mode
THEN
ReplPattern
f
col
Display
grey
x
y
w
h
Display
replace
ELSIF
M
mode
IN
THEN
ReplConst
f
col
x
y
w
h
Display
replace
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
erase
END
END
END
END
DrawLine
PROCEDURE
DrawCaption
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
dx
x0
x1
y0
y1
w
h
w1
h1
col
INTEGER
f
Frame
ch
CHAR
pat
INTEGER
fnt
Fonts
Font
R
Texts
Reader
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
f
X
x
x
f
X1
f
Y
y
y
h
f
Y1
THEN
IF
x
w
f
X1
THEN
w
f
X1
x
END
Texts
OpenReader
R
Graphics
T
obj
Graphics
Caption
pos
Texts
Read
R
ch
IF
M
mode
THEN
IF
ch
THEN
fnt
R
fnt
x0
x
y0
y
fnt
minY
col
obj
col
REPEAT
Fonts
GetPat
fnt
ch
dx
x1
y1
w1
h1
pat
IF
x0
x1
w1
f
X1
THEN
Display
CopyPattern
col
pat
x0
x1
y0
y1
Display
paint
INC
x0
dx
Texts
Read
R
ch
ELSE
ch
0X
END
UNTIL
ch
IF
obj
selected
THEN
ReplConst
f
Display
white
x
y
w
h
Display
invert
END
END
ELSIF
M
mode
IN
THEN
ReplConst
f
Display
white
x
y
w
h
Display
invert
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
END
END
END
END
DrawCaption
PROCEDURE
DrawMacro
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
INTEGER
f
Frame
M1
DrawMsg
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
x
w
f
X
x
f
X1
y
h
f
Y
y
f
Y1
THEN
M1
x
x
M1
y
y
IF
M
mode
THEN
M1
f
f
M1
col
obj
col
M1
mode
Graphics
DrawMac
obj
Graphics
Macro
mac
M1
IF
obj
selected
THEN
ReplPattern
f
Display
white
dotted
x
y
w
h
Display
invert
END
ELSIF
M
mode
IN
THEN
ReplPattern
f
Display
white
dotted
x
y
w
h
Display
invert
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
END
END
END
END
DrawMacro
PROCEDURE
Open
G
Frame
graph
Graphics
Graph
BEGIN
G
graph
graph
G
Xg
G
Yg
G
x
G
X
G
y
G
Y
G
col
Display
black
G
marked
FALSE
G
mark
next
NIL
G
ticked
TRUE
G
handle
Handle
END
Open
BEGIN
DW
Display
Width
DH
Display
Height
CL
Texts
OpenWriter
W
tack
SYSTEM
ADR
dotted
SYSTEM
ADR
dotted1
SYSTEM
ADR
Crosshair
Fade
FlipCross
Crosshair
Draw
FlipCross
Graphics
InstallDrawMethods
DrawLine
DrawCaption
DrawMacro
END
GraphicFrames
MODULE
Graphics
NW
IMPORT
SYSTEM
Files
Modules
Fonts
Printer
Texts
Oberon
CONST
NameLen
GraphFileId
0FAX
LibFileId
0FBX
TYPE
Graph
POINTER
TO
GraphDesc
Object
POINTER
TO
ObjectDesc
Method
POINTER
TO
MethodDesc
Line
POINTER
TO
LineDesc
Caption
POINTER
TO
CaptionDesc
Macro
POINTER
TO
MacroDesc
ObjectDesc
RECORD
x
y
w
h
INTEGER
col
BYTE
selected
marked
BOOLEAN
do
Method
next
Object
END
Msg
RECORD
END
WidMsg
RECORD
Msg
w
INTEGER
END
ColorMsg
RECORD
Msg
col
INTEGER
END
FontMsg
RECORD
Msg
fnt
Fonts
Font
END
Name
ARRAY
NameLen
OF
CHAR
GraphDesc
RECORD
time
LONGINT
sel
first
Object
changed
BOOLEAN
END
MacHead
POINTER
TO
MacHeadDesc
MacExt
POINTER
TO
MacExtDesc
Library
POINTER
TO
LibraryDesc
MacHeadDesc
RECORD
name
Name
w
h
INTEGER
ext
MacExt
lib
Library
first
Object
next
MacHead
END
LibraryDesc
RECORD
name
Name
first
MacHead
next
Library
END
MacExtDesc
RECORD
END
Context
RECORD
nofonts
noflibs
nofclasses
INTEGER
font
ARRAY
OF
Fonts
Font
lib
ARRAY
OF
Library
class
ARRAY
OF
Modules
Command
END
MethodDesc
RECORD
module
allocator
Name
new
Modules
Command
copy
PROCEDURE
from
to
Object
draw
change
PROCEDURE
obj
Object
VAR
msg
Msg
selectable
PROCEDURE
obj
Object
x
y
INTEGER
BOOLEAN
read
PROCEDURE
obj
Object
VAR
R
Files
Rider
VAR
C
Context
write
PROCEDURE
obj
Object
cno
INTEGER
VAR
R
Files
Rider
VAR
C
Context
print
PROCEDURE
obj
Object
x
y
INTEGER
END
LineDesc
RECORD
ObjectDesc
unused
INTEGER
END
CaptionDesc
RECORD
ObjectDesc
pos
len
INTEGER
END
MacroDesc
RECORD
ObjectDesc
mac
MacHead
END
VAR
width
res
INTEGER
new
Object
T
Texts
Text
captions
LineMethod
CapMethod
MacMethod
Method
GetLib0
PROCEDURE
name
ARRAY
OF
CHAR
replace
BOOLEAN
VAR
Lib
Library
FirstLib
Library
W
TW
XW
Texts
Writer
PROCEDURE
New
obj
Object
BEGIN
new
obj
END
New
PROCEDURE
Add
G
Graph
obj
Object
BEGIN
obj
marked
FALSE
obj
selected
TRUE
obj
next
G
first
G
first
obj
G
sel
obj
G
time
Oberon
Time
G
changed
TRUE
END
Add
PROCEDURE
ThisObj
G
Graph
x
y
INTEGER
Object
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
obj
do
selectable
obj
x
y
DO
obj
obj
next
END
RETURN
obj
END
ThisObj
PROCEDURE
SelectObj
G
Graph
obj
Object
BEGIN
IF
obj
NIL
THEN
obj
selected
TRUE
G
sel
obj
G
time
Oberon
Time
END
END
SelectObj
PROCEDURE
SelectArea
G
Graph
x0
y0
x1
y1
INTEGER
VAR
obj
Object
t
INTEGER
BEGIN
obj
G
first
IF
x1
x0
THEN
t
x0
x0
x1
x1
t
END
IF
y1
y0
THEN
t
y0
y0
y1
y1
t
END
WHILE
obj
NIL
DO
IF
x0
obj
x
obj
x
obj
w
x1
y0
obj
y
obj
y
obj
h
y1
THEN
obj
selected
TRUE
G
sel
obj
END
obj
obj
next
END
IF
G
sel
NIL
THEN
G
time
Oberon
Time
END
END
SelectArea
PROCEDURE
Draw
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
obj
do
draw
obj
M
obj
obj
next
END
END
Draw
PROCEDURE
List
G
Graph
VAR
obj
Object
tag
INTEGER
BEGIN
obj
G
first
WHILE
obj
NIL
DO
Texts
Write
XW
9X
Texts
WriteHex
XW
ORD
obj
Texts
Write
XW
9X
Texts
WriteInt
XW
obj
x
Texts
WriteInt
XW
obj
y
Texts
WriteInt
XW
obj
w
Texts
WriteInt
XW
obj
h
Texts
Write
XW
SYSTEM
GET
ORD
obj
tag
Texts
WriteHex
XW
tag
SYSTEM
GET
ORD
obj
tag
Texts
WriteHex
XW
tag
Texts
WriteLn
XW
obj
obj
next
END
Texts
Append
Oberon
Log
XW
buf
END
List
procedures
operating
on
selection
PROCEDURE
Deselect
G
Graph
VAR
obj
Object
BEGIN
obj
G
first
G
sel
NIL
G
time
WHILE
obj
NIL
DO
obj
selected
FALSE
obj
obj
next
END
END
Deselect
PROCEDURE
DrawSel
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
draw
obj
M
END
obj
obj
next
END
END
DrawSel
PROCEDURE
Change
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
G
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
change
obj
M
END
obj
obj
next
END
END
Change
PROCEDURE
Move
G
Graph
dx
dy
INTEGER
VAR
obj
ob0
Object
x0
x1
y0
y1
INTEGER
BEGIN
obj
G
first
G
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
obj
IS
Caption
THEN
x0
obj
x
x1
obj
w
x0
y0
obj
y
y1
obj
h
y0
IF
dx
THEN
vertical
move
ob0
G
first
WHILE
ob0
NIL
DO
IF
ob0
selected
ob0
IS
Line
x0
ob0
x
ob0
x
x1
ob0
w
ob0
h
THEN
IF
y0
ob0
y
ob0
y
y1
THEN
INC
ob0
y
dy
DEC
ob0
h
dy
ob0
marked
TRUE
ELSIF
y0
ob0
y
ob0
h
ob0
y
ob0
h
y1
THEN
INC
ob0
h
dy
ob0
marked
TRUE
END
END
ob0
ob0
next
END
ELSIF
dy
THEN
horizontal
move
ob0
G
first
WHILE
ob0
NIL
DO
IF
ob0
selected
ob0
IS
Line
y0
ob0
y
ob0
y
y1
ob0
h
ob0
w
THEN
IF
x0
ob0
x
ob0
x
x1
THEN
INC
ob0
x
dx
DEC
ob0
w
dx
ob0
marked
TRUE
ELSIF
x0
ob0
x
ob0
w
ob0
x
ob0
w
x1
THEN
INC
ob0
w
dx
ob0
marked
TRUE
END
END
ob0
ob0
next
END
END
END
obj
obj
next
END
obj
G
first
now
move
WHILE
obj
NIL
DO
IF
obj
selected
THEN
INC
obj
x
dx
INC
obj
y
dy
END
obj
marked
FALSE
obj
obj
next
END
END
Move
PROCEDURE
Copy
Gs
Gd
Graph
dx
dy
INTEGER
VAR
obj
Object
BEGIN
obj
Gs
first
Gd
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
new
obj
do
copy
obj
new
INC
new
x
dx
INC
new
y
dy
obj
selected
FALSE
Add
Gd
new
END
obj
obj
next
END
new
NIL
END
Copy
PROCEDURE
Delete
G
Graph
VAR
obj
pred
Object
BEGIN
G
sel
NIL
G
changed
TRUE
obj
G
first
WHILE
obj
NIL
obj
selected
DO
obj
obj
next
END
G
first
obj
IF
obj
NIL
THEN
pred
obj
obj
obj
next
WHILE
obj
NIL
DO
IF
obj
selected
THEN
pred
next
obj
next
ELSE
pred
obj
END
obj
obj
next
END
END
END
Delete
Storing
PROCEDURE
WMsg
s0
s1
ARRAY
OF
CHAR
BEGIN
Texts
WriteString
W
s0
Texts
WriteString
W
s1
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
WMsg
PROCEDURE
InitContext
VAR
C
Context
BEGIN
C
nofonts
C
noflibs
C
nofclasses
C
class
LineMethod
new
C
class
CapMethod
new
C
class
MacMethod
new
END
InitContext
PROCEDURE
FontNo
VAR
W
Files
Rider
VAR
C
Context
fnt
Fonts
Font
INTEGER
VAR
fno
INTEGER
BEGIN
fno
WHILE
fno
C
nofonts
C
font
fno
fnt
DO
INC
fno
END
IF
fno
C
nofonts
THEN
Files
WriteByte
W
Files
WriteByte
W
Files
WriteByte
W
fno
Files
WriteString
W
fnt
name
C
font
fno
fnt
INC
C
nofonts
END
RETURN
fno
END
FontNo
PROCEDURE
StoreElems
VAR
W
Files
Rider
VAR
C
Context
obj
Object
VAR
cno
INTEGER
BEGIN
WHILE
obj
NIL
DO
cno
WHILE
cno
C
nofclasses
obj
do
new
C
class
cno
DO
INC
cno
END
IF
cno
C
nofclasses
THEN
Files
WriteByte
W
Files
WriteByte
W
Files
WriteByte
W
cno
Files
WriteString
W
obj
do
module
Files
WriteString
W
obj
do
allocator
C
class
cno
obj
do
new
INC
C
nofclasses
END
obj
do
write
obj
cno
W
C
obj
obj
next
END
Files
WriteByte
W
END
StoreElems
PROCEDURE
Store
G
Graph
VAR
W
Files
Rider
VAR
C
Context
BEGIN
InitContext
C
StoreElems
W
C
G
first
G
changed
FALSE
END
Store
PROCEDURE
WriteObj
VAR
W
Files
Rider
cno
INTEGER
obj
Object
BEGIN
Files
WriteByte
W
cno
Files
WriteInt
W
obj
y
10000H
obj
x
Files
WriteInt
W
obj
h
10000H
obj
w
Files
WriteByte
W
obj
col
END
WriteObj
PROCEDURE
WriteFile
G
Graph
name
ARRAY
OF
CHAR
VAR
F
Files
File
W
Files
Rider
C
Context
BEGIN
F
Files
New
name
Files
Set
W
F
Files
Write
W
GraphFileId
InitContext
C
StoreElems
W
C
G
first
Files
Register
F
END
WriteFile
PROCEDURE
Print
G
Graph
x0
y0
INTEGER
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
obj
do
print
obj
x0
y0
obj
obj
next
END
END
Print
Loading
PROCEDURE
GetClass
module
allocator
ARRAY
OF
CHAR
VAR
com
Modules
Command
VAR
mod
Modules
Module
BEGIN
Modules
Load
module
mod
IF
mod
NIL
THEN
com
Modules
ThisCommand
mod
allocator
IF
com
NIL
THEN
WMsg
allocator
unknown
END
ELSE
WMsg
module
not
available
com
NIL
END
END
GetClass
PROCEDURE
Font
VAR
R
Files
Rider
VAR
C
Context
Fonts
Font
VAR
fno
BYTE
BEGIN
Files
ReadByte
R
fno
RETURN
C
font
fno
END
Font
PROCEDURE
ReadObj
VAR
R
Files
Rider
obj
Object
VAR
xy
wh
INTEGER
dmy
BYTE
BEGIN
Files
ReadInt
R
xy
obj
y
xy
DIV
10000H
obj
x
xy
10000H
DIV
10000H
Files
ReadInt
R
wh
obj
h
wh
DIV
10000H
obj
w
wh
10000H
DIV
10000H
Files
ReadByte
R
obj
col
END
ReadObj
PROCEDURE
LoadElems
VAR
R
Files
Rider
VAR
C
Context
VAR
fobj
Object
VAR
cno
m
n
len
BYTE
pos
INTEGER
obj
Object
fnt
Fonts
Font
name
name1
ARRAY
OF
CHAR
BEGIN
obj
NIL
Files
ReadByte
R
cno
WHILE
R
eof
cno
DO
IF
cno
THEN
Files
ReadByte
R
m
Files
ReadByte
R
n
Files
ReadString
R
name
IF
m
THEN
fnt
Fonts
This
name
C
font
n
fnt
ELSIF
m
THEN
GetLib0
name
FALSE
C
lib
n
ELSIF
m
THEN
Files
ReadString
R
name1
GetClass
name
name1
C
class
n
END
ELSIF
C
class
cno
NIL
THEN
C
class
cno
ReadObj
R
new
new
selected
FALSE
new
marked
FALSE
new
next
obj
obj
new
new
do
read
new
R
C
ELSE
ReadObj
R
new
Files
ReadByte
R
len
pos
Files
Pos
R
Files
Set
R
Files
Base
R
pos
len
END
Files
ReadByte
R
cno
END
new
NIL
fobj
obj
END
LoadElems
PROCEDURE
Load
G
Graph
VAR
R
Files
Rider
VAR
C
Context
BEGIN
G
sel
NIL
InitContext
C
LoadElems
R
C
G
first
END
Load
PROCEDURE
Open
G
Graph
name
ARRAY
OF
CHAR
VAR
tag
CHAR
F
Files
File
R
Files
Rider
C
Context
BEGIN
G
first
NIL
G
sel
NIL
G
time
G
changed
FALSE
F
Files
Old
name
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
tag
IF
tag
GraphFileId
THEN
InitContext
C
LoadElems
R
C
G
first
res
ELSE
res
END
ELSE
res
END
END
Open
PROCEDURE
SetWidth
w
INTEGER
BEGIN
width
w
END
SetWidth
Macros
Libraries
PROCEDURE
GetLib
name
ARRAY
OF
CHAR
replace
BOOLEAN
VAR
Lib
Library
VAR
i
wh
INTEGER
ch
CHAR
L
Library
mh
MacHead
obj
Object
F
Files
File
R
Files
Rider
C
Context
Lname
Fname
ARRAY
OF
CHAR
BEGIN
L
FirstLib
i
WHILE
L
NIL
L
name
name
DO
L
L
next
END
IF
L
NIL
THEN
load
library
from
file
i
WHILE
name
i
0X
DO
Fname
i
name
i
INC
i
END
Fname
i
Fname
i
L
Fname
i
i
Fname
i
b
Fname
i
0X
F
Files
Old
Fname
IF
F
NIL
THEN
WMsg
loading
Fname
Files
Set
R
F
Files
Read
R
ch
IF
ch
LibFileId
THEN
IF
L
NIL
THEN
NEW
L
L
name
name
L
next
FirstLib
FirstLib
L
END
L
first
NIL
InitContext
C
LoadElems
R
C
obj
WHILE
obj
NIL
DO
NEW
mh
mh
first
obj
Files
ReadInt
R
wh
mh
h
wh
DIV
10000H
MOD
10000H
mh
w
wh
MOD
10000H
Files
ReadString
R
mh
name
mh
lib
L
mh
next
L
first
L
first
mh
LoadElems
R
C
obj
END
ELSE
L
NIL
END
ELSE
L
NIL
END
END
Lib
L
END
GetLib
PROCEDURE
NewLib
Lname
ARRAY
OF
CHAR
Library
VAR
L
Library
BEGIN
NEW
L
L
name
Lname
L
first
NIL
L
next
FirstLib
FirstLib
L
RETURN
L
END
NewLib
PROCEDURE
StoreLib
L
Library
Fname
ARRAY
OF
CHAR
VAR
i
INTEGER
mh
MacHead
F
Files
File
W
Files
Rider
C
Context
Gname
ARRAY
OF
CHAR
BEGIN
L
FirstLib
WHILE
L
NIL
L
name
Fname
DO
L
L
next
END
IF
L
NIL
THEN
i
WHILE
Fname
i
0X
DO
Gname
i
Fname
i
INC
i
END
Gname
i
Gname
i
L
Gname
i
i
Gname
i
b
Gname
i
0X
F
Files
New
Gname
Files
Set
W
F
Files
Write
W
LibFileId
InitContext
C
mh
L
first
WHILE
mh
NIL
DO
StoreElems
W
C
mh
first
Files
WriteInt
W
mh
h
10000H
mh
w
Files
WriteString
W
mh
name
mh
mh
next
END
Files
WriteByte
W
Files
Register
F
ELSE
Texts
WriteString
TW
Fname
Texts
WriteString
TW
not
found
Texts
WriteLn
TW
Texts
Append
Oberon
Log
TW
buf
END
END
StoreLib
PROCEDURE
RemoveLibraries
BEGIN
FirstLib
NIL
END
RemoveLibraries
PROCEDURE
ThisMac
L
Library
Mname
ARRAY
OF
CHAR
MacHead
VAR
mh
MacHead
BEGIN
mh
L
first
WHILE
mh
NIL
mh
name
Mname
DO
mh
mh
next
END
RETURN
mh
END
ThisMac
PROCEDURE
DrawMac
mh
MacHead
VAR
M
Msg
VAR
elem
Object
BEGIN
elem
mh
first
WHILE
elem
NIL
DO
elem
do
draw
elem
M
elem
elem
next
END
END
DrawMac
Procedures
for
designing
macros
PROCEDURE
OpenMac
mh
MacHead
G
Graph
x
y
INTEGER
VAR
obj
Object
BEGIN
obj
mh
first
WHILE
obj
NIL
DO
obj
do
new
obj
do
copy
obj
new
INC
new
x
x
INC
new
y
y
new
selected
TRUE
Add
G
new
obj
obj
next
END
new
NIL
END
OpenMac
PROCEDURE
MakeMac
G
Graph
VAR
head
MacHead
VAR
x0
y0
x1
y1
INTEGER
obj
last
Object
mh
MacHead
BEGIN
obj
G
first
last
NIL
x0
x1
y0
y1
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
new
obj
do
copy
obj
new
new
next
last
new
selected
FALSE
last
new
IF
obj
x
x0
THEN
x0
obj
x
END
IF
obj
x
obj
w
x1
THEN
x1
obj
x
obj
w
END
IF
obj
y
y0
THEN
y0
obj
y
END
IF
obj
y
obj
h
y1
THEN
y1
obj
y
obj
h
END
END
obj
obj
next
END
obj
last
WHILE
obj
NIL
DO
obj
x
obj
x
x0
obj
y
obj
y
y0
obj
obj
next
END
NEW
mh
mh
w
x1
x0
mh
h
y1
y0
mh
first
last
mh
ext
NIL
new
NIL
head
mh
END
MakeMac
PROCEDURE
InsertMac
mh
MacHead
L
Library
VAR
new
BOOLEAN
VAR
mh1
MacHead
BEGIN
mh
lib
L
mh1
L
first
WHILE
mh1
NIL
mh1
name
mh
name
DO
mh1
mh1
next
END
IF
mh1
NIL
THEN
new
TRUE
mh
next
L
first
L
first
mh
ELSE
new
FALSE
mh1
w
mh
w
mh1
h
mh
h
mh1
first
mh
first
END
END
InsertMac
Line
Methods
PROCEDURE
NewLine
VAR
line
Line
BEGIN
NEW
line
new
line
line
do
LineMethod
END
NewLine
PROCEDURE
CopyLine
src
dst
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
END
CopyLine
PROCEDURE
ChangeLine
obj
Object
VAR
M
Msg
BEGIN
CASE
M
OF
WidMsg
IF
obj
w
obj
h
THEN
IF
obj
w
THEN
obj
w
M
w
END
ELSIF
obj
h
THEN
obj
h
M
w
END
ColorMsg
obj
col
M
col
END
END
ChangeLine
PROCEDURE
LineSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
w
obj
y
y
y
obj
y
obj
h
END
LineSelectable
PROCEDURE
ReadLine
obj
Object
VAR
R
Files
Rider
VAR
C
Context
BEGIN
END
ReadLine
PROCEDURE
WriteLine
obj
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Context
BEGIN
WriteObj
W
cno
obj
END
WriteLine
PROCEDURE
PrintLine
obj
Object
x
y
INTEGER
VAR
w
h
INTEGER
BEGIN
w
obj
w
h
obj
h
IF
w
h
THEN
h
h
ELSE
w
w
END
Printer
ReplConst
obj
x
x
obj
y
y
w
h
END
PrintLine
Caption
Methods
PROCEDURE
NewCaption
VAR
cap
Caption
BEGIN
NEW
cap
new
cap
cap
do
CapMethod
END
NewCaption
PROCEDURE
CopyCaption
src
dst
Object
VAR
ch
CHAR
R
Texts
Reader
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Caption
pos
T
len
dst
Caption
len
src
Caption
len
Texts
Write
TW
0DX
Texts
OpenReader
R
T
src
Caption
pos
Texts
Read
R
ch
TW
fnt
R
fnt
WHILE
ch
0DX
DO
Texts
Write
TW
ch
Texts
Read
R
ch
END
Texts
Append
T
TW
buf
END
CopyCaption
PROCEDURE
ChangeCaption
obj
Object
VAR
M
Msg
VAR
dx
x1
dy
y1
w
w1
h1
len
INTEGER
pos
LONGINT
ch
CHAR
patadr
INTEGER
fnt
Fonts
Font
R
Texts
Reader
BEGIN
CASE
M
OF
FontMsg
fnt
M
FontMsg
fnt
w
len
pos
obj
Caption
pos
Texts
OpenReader
R
T
pos
Texts
Read
R
ch
dy
R
fnt
minY
WHILE
ch
0DX
DO
Fonts
GetPat
fnt
ch
dx
x1
y1
w1
h1
patadr
INC
w
dx
INC
len
Texts
Read
R
ch
END
INC
obj
y
fnt
minY
dy
obj
w
w
obj
h
fnt
height
Texts
ChangeLooks
T
pos
pos
len
fnt
ColorMsg
obj
col
M
ColorMsg
col
END
END
ChangeCaption
PROCEDURE
CaptionSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
w
obj
y
y
y
obj
y
obj
h
END
CaptionSelectable
PROCEDURE
ReadCaption
obj
Object
VAR
R
Files
Rider
VAR
C
Context
VAR
ch
CHAR
fno
BYTE
len
INTEGER
BEGIN
obj
Caption
pos
T
len
Texts
Write
TW
0DX
Files
ReadByte
R
fno
TW
fnt
C
font
fno
len
Files
Read
R
ch
WHILE
ch
0DX
DO
Texts
Write
TW
ch
INC
len
Files
Read
R
ch
END
obj
Caption
len
len
Texts
Append
T
TW
buf
END
ReadCaption
PROCEDURE
WriteCaption
obj
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Context
VAR
ch
CHAR
fno
BYTE
TR
Texts
Reader
BEGIN
IF
obj
Caption
len
THEN
Texts
OpenReader
TR
T
obj
Caption
pos
Texts
Read
TR
ch
fno
FontNo
W
C
TR
fnt
WriteObj
W
cno
obj
Files
WriteByte
W
fno
WHILE
ch
0DX
DO
Files
Write
W
ch
Texts
Read
TR
ch
END
Files
Write
W
0X
END
END
WriteCaption
PROCEDURE
PrintCaption
obj
Object
x
y
INTEGER
VAR
fnt
Fonts
Font
i
INTEGER
ch
CHAR
R
Texts
Reader
s
ARRAY
OF
CHAR
BEGIN
IF
obj
Caption
len
THEN
Texts
OpenReader
R
T
obj
Caption
pos
Texts
Read
R
ch
fnt
R
fnt
DEC
y
fnt
minY
i
WHILE
ch
DO
s
i
ch
INC
i
Texts
Read
R
ch
END
s
i
0X
IF
i
THEN
Printer
String
obj
x
x
obj
y
y
s
fnt
name
END
END
END
PrintCaption
Macro
Methods
PROCEDURE
NewMacro
VAR
mac
Macro
BEGIN
NEW
mac
new
mac
mac
do
MacMethod
END
NewMacro
PROCEDURE
CopyMacro
src
dst
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Macro
mac
src
Macro
mac
END
CopyMacro
PROCEDURE
ChangeMacro
obj
Object
VAR
M
Msg
BEGIN
CASE
M
OF
ColorMsg
obj
col
M
col
END
END
ChangeMacro
PROCEDURE
MacroSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
y
y
y
obj
y
END
MacroSelectable
PROCEDURE
ReadMacro
obj
Object
VAR
R
Files
Rider
VAR
C
Context
VAR
lno
BYTE
name
ARRAY
OF
CHAR
BEGIN
Files
ReadByte
R
lno
Files
ReadString
R
name
obj
Macro
mac
ThisMac
C
lib
lno
name
END
ReadMacro
PROCEDURE
WriteMacro
obj
Object
cno
INTEGER
VAR
W1
Files
Rider
VAR
C
Context
VAR
lno
INTEGER
BEGIN
lno
WHILE
lno
C
noflibs
obj
Macro
mac
lib
C
lib
lno
DO
INC
lno
END
IF
lno
C
noflibs
THEN
Files
WriteByte
W1
Files
WriteByte
W1
Files
WriteByte
W1
lno
Files
WriteString
W1
obj
Macro
mac
lib
name
C
lib
lno
obj
Macro
mac
lib
INC
C
noflibs
END
WriteObj
W1
cno
obj
Files
WriteByte
W1
lno
Files
WriteString
W1
obj
Macro
mac
name
END
WriteMacro
PROCEDURE
PrintMacro
obj
Object
x
y
INTEGER
VAR
elem
Object
mh
MacHead
BEGIN
mh
obj
Macro
mac
IF
mh
NIL
THEN
elem
mh
first
WHILE
elem
NIL
DO
elem
do
print
elem
obj
x
x
obj
y
y
elem
elem
next
END
END
END
PrintMacro
PROCEDURE
Notify
T
Texts
Text
op
INTEGER
beg
end
LONGINT
BEGIN
END
Notify
PROCEDURE
InstallDrawMethods
drawLine
drawCaption
drawMacro
PROCEDURE
obj
Object
VAR
msg
Msg
BEGIN
LineMethod
draw
drawLine
CapMethod
draw
drawCaption
MacMethod
draw
drawMacro
END
InstallDrawMethods
BEGIN
Texts
OpenWriter
W
Texts
OpenWriter
TW
Texts
OpenWriter
XW
width
GetLib0
GetLib
NEW
T
Texts
Open
T
T
notify
Notify
NEW
LineMethod
LineMethod
new
NewLine
LineMethod
copy
CopyLine
LineMethod
selectable
LineSelectable
LineMethod
change
ChangeLine
LineMethod
read
ReadLine
LineMethod
write
WriteLine
LineMethod
print
PrintLine
NEW
CapMethod
CapMethod
new
NewCaption
CapMethod
copy
CopyCaption
CapMethod
selectable
CaptionSelectable
CapMethod
change
ChangeCaption
CapMethod
read
ReadCaption
CapMethod
write
WriteCaption
CapMethod
print
PrintCaption
NEW
MacMethod
MacMethod
new
NewMacro
MacMethod
copy
CopyMacro
MacMethod
selectable
MacroSelectable
MacMethod
change
ChangeMacro
MacMethod
read
ReadMacro
MacMethod
write
WriteMacro
MacMethod
print
PrintMacro
END
Graphics
MODULE
GraphTool
NW
IMPORT
Files
Texts
Oberon
CONST
Context
Line
Caption
Macro
Rectangles
VAR
W
Texts
Writer
PROCEDURE
DecGraph
VAR
ch
CHAR
class
col
fno
cat
inx
libno
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0F8X
THEN
Files
ReadByte
R
class
WHILE
R
eof
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Files
Read
R
ch
Texts
WriteInt
W
col
Texts
Write
W
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Macro
THEN
Files
ReadByte
R
libno
Files
ReadString
R
name
Texts
WriteInt
W
libno
Texts
Write
W
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
file
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecGraph
PROCEDURE
DecGraph1
VAR
ch
CHAR
class
col
fno
len
lw
vers
cat
inx
libno
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0FAX
THEN
Files
ReadByte
R
class
WHILE
R
eof
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Texts
WriteInt
W
col
Texts
Write
W
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Macro
THEN
Files
ReadByte
R
libno
Files
ReadString
R
name
Texts
WriteInt
W
libno
Texts
Write
W
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
len
Texts
WriteInt
W
len
Files
ReadByte
R
lw
Texts
WriteInt
W
lw
Files
ReadByte
R
vers
Texts
WriteInt
W
vers
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
file
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecGraph1
PROCEDURE
DecLibrary1
VAR
ch
CHAR
class
col
fno
cat
inx
libno
len
lnw
vers
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
library1
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0FBX
THEN
Files
ReadByte
R
class
WHILE
class
R
eof
DO
WHILE
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Texts
WriteInt
W
col
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Texts
Write
W
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Texts
Write
W
Files
ReadByte
R
len
Texts
WriteInt
W
len
Files
ReadByte
R
lnw
Texts
WriteInt
W
lnw
Files
ReadByte
R
vers
Texts
WriteInt
W
vers
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
end
macro
Texts
WriteString
W
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
MOD
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
library
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecLibrary1
PROCEDURE
ConvertFontname
VAR
x
ARRAY
OF
CHAR
BEGIN
Syntax
Oberon
IF
x
S
x
y
x
n
x
t
x
a
x
x
THEN
x
O
x
b
x
e
x
r
x
o
x
n
END
END
ConvertFontname
PROCEDURE
ConvertLibrary
VAR
ch
CHAR
class
col
fno
cat
inx
libno
len
lnw
vers
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
G
Files
File
R
Q
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
convert
library
Texts
WriteString
W
S
s
F
Files
Old
S
s
IF
F
NIL
THEN
Texts
Scan
S
G
Files
New
S
s
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Files
Set
R
F
Files
Set
Q
G
Files
Read
R
ch
IF
ch
0FDX
THEN
Files
Write
Q
0FBX
Files
ReadByte
R
class
WHILE
class
R
eof
DO
WHILE
class
DO
Files
WriteByte
Q
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
WriteByte
Q
cat
Files
WriteByte
Q
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
font
ConvertFontname
name
END
Files
WriteString
Q
name
IF
cat
THEN
class
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
Files
WriteString
Q
name
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
ELSE
Files
ReadInt
R
xy
Files
WriteInt
Q
xy
Files
ReadInt
R
wh
Files
WriteInt
Q
wh
Files
ReadByte
R
col
Files
Read
R
ch
Files
WriteByte
Q
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Files
WriteByte
Q
fno
Files
ReadString
R
name
Files
WriteString
Q
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
len
Files
WriteByte
Q
len
Files
ReadByte
R
len
Files
ReadByte
R
lnw
Files
WriteByte
Q
lnw
Files
ReadByte
R
vers
Files
WriteByte
Q
vers
ELSE
Texts
WriteString
W
alien
class
Texts
WriteInt
W
class
END
END
Files
ReadByte
R
class
END
Files
WriteByte
Q
end
macro
Files
ReadInt
R
wh
Files
WriteInt
Q
wh
Files
ReadString
R
name
Files
WriteString
Q
name
Texts
WriteString
W
name
Texts
WriteInt
W
wh
MOD
10000H
Texts
WriteInt
W
wh
DIV
10000H
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
library
END
Files
Register
G
Texts
WriteString
W
done
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
ConvertLibrary
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
GraphTool
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
GraphTool
MODULE
Input
NW
Ceres
PDR
NW
Ceres
IMPORT
SYSTEM
CONST
msAdr
kbdAdr
VAR
kbdCode
BYTE
last
keyboard
code
read
Recd
Up
Shift
Ctrl
Ext
BOOLEAN
KTabAdr
INTEGER
keyboard
code
translation
table
MW
MH
MX
MY
INTEGER
mouse
limits
and
coords
MK
SET
mouse
keys
FIFO
implemented
in
hardware
because
every
read
must
be
handled
including
tracking
the
state
of
the
Shift
and
Ctrl
keys
PROCEDURE
Peek
BEGIN
IF
SYSTEM
BIT
msAdr
THEN
SYSTEM
GET
kbdAdr
kbdCode
IF
kbdCode
0F0H
THEN
Up
TRUE
ELSIF
kbdCode
0E0H
THEN
Ext
TRUE
ELSE
IF
kbdCode
12H
OR
kbdCode
59H
THEN
shift
Shift
Up
ELSIF
kbdCode
14H
THEN
ctrl
Ctrl
Up
ELSIF
Up
THEN
Recd
TRUE
real
key
going
down
END
Up
FALSE
Ext
FALSE
END
END
END
Peek
PROCEDURE
Available
INTEGER
BEGIN
Peek
RETURN
ORD
Recd
END
Available
PROCEDURE
Read
VAR
ch
CHAR
BEGIN
WHILE
Recd
DO
Peek
END
IF
Shift
OR
Ctrl
THEN
INC
kbdCode
80H
END
ctrl
implies
shift
ch
kbdTab
kbdCode
SYSTEM
GET
KTabAdr
kbdCode
ch
IF
Ctrl
THEN
ch
CHR
ORD
ch
MOD
20H
END
Recd
FALSE
END
Read
PROCEDURE
Mouse
VAR
keys
SET
VAR
x
y
INTEGER
VAR
w
INTEGER
BEGIN
SYSTEM
GET
msAdr
w
keys
SYSTEM
VAL
SET
w
DIV
1000000H
MOD
x
w
MOD
400H
y
w
DIV
1000H
MOD
400H
IF
y
MH
THEN
y
MH
END
END
Mouse
PROCEDURE
SetMouseLimits
w
h
INTEGER
BEGIN
MW
w
MH
h
END
SetMouseLimits
PROCEDURE
Init
BEGIN
Up
FALSE
Shift
FALSE
Ctrl
FALSE
Recd
FALSE
KTabAdr
SYSTEM
ADR
1A
7A
6E
6D
6A
2C
6B
6F
2E
2F
6C
3B
2D
5B
3D
0D
5D
5C
7F
1B
7E
5A
4E
5E
4D
4A
2A
3C
4B
4F
3E
3F
4C
3A
5F
7B
2B
0D
7D
7C
7F
1B
END
Init
BEGIN
Init
END
Input
MODULE
Kernel
NW
PR
IMPORT
SYSTEM
CONST
SectorLength
timer
spiData
spiCtrl
CARD0
SPIFAST
FSoffset
80000H
256MB
in
byte
blocks
mapsize
10000H
1K
sectors
64MB
TYPE
Sector
ARRAY
SectorLength
OF
BYTE
VAR
allocated
NofSectors
INTEGER
heapOrg
heapLim
INTEGER
stackOrg
stackSize
MemLim
INTEGER
clock
INTEGER
list0
list1
list2
list3
INTEGER
lists
of
free
blocks
of
size
n
bytes
data
INTEGER
SPI
data
in
sectorMap
ARRAY
mapsize
DIV
OF
SET
New
heap
allocation
PROCEDURE
GetBlock
VAR
p
LONGINT
len
LONGINT
len
is
multiple
of
VAR
q0
q1
q2
size
LONGINT
done
BOOLEAN
BEGIN
q0
q1
list0
done
FALSE
WHILE
done
q1
DO
SYSTEM
GET
q1
size
SYSTEM
GET
q1
q2
IF
size
len
THEN
no
fit
q0
q1
q1
q2
ELSIF
size
len
THEN
extract
p
done
TRUE
p
q1
IF
q0
THEN
SYSTEM
PUT
q0
q2
ELSE
list0
q2
END
ELSE
reduce
size
done
TRUE
p
q1
q1
q1
len
SYSTEM
PUT
q1
size
len
SYSTEM
PUT
q1
SYSTEM
PUT
q1
q2
IF
q0
THEN
SYSTEM
PUT
q0
q1
ELSE
list0
q1
END
END
END
IF
done
THEN
p
END
END
GetBlock
PROCEDURE
GetBlock128
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list1
THEN
p
list1
SYSTEM
GET
list1
list1
ELSE
GetBlock
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list1
list1
q
p
q
END
END
GetBlock128
PROCEDURE
GetBlock64
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list2
THEN
p
list2
SYSTEM
GET
list2
list2
ELSE
GetBlock128
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list2
list2
q
p
q
END
END
GetBlock64
PROCEDURE
GetBlock32
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list3
THEN
p
list3
SYSTEM
GET
list3
list3
ELSE
GetBlock64
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list3
list3
q
p
q
END
END
GetBlock32
PROCEDURE
New
VAR
ptr
LONGINT
tag
LONGINT
called
by
NEW
via
MT
ptr
and
tag
are
pointers
VAR
p
size
lim
LONGINT
BEGIN
SYSTEM
GET
tag
size
IF
size
THEN
GetBlock32
p
ELSIF
size
THEN
GetBlock64
p
ELSIF
size
THEN
GetBlock128
p
ELSE
GetBlock
p
size
DIV
END
IF
p
THEN
ptr
ELSE
ptr
p
SYSTEM
PUT
p
tag
lim
p
size
INC
p
INC
allocated
size
WHILE
p
lim
DO
SYSTEM
PUT
p
INC
p
END
END
END
New
Garbage
collector
PROCEDURE
Mark
pref
LONGINT
VAR
pvadr
offadr
offset
tag
p
q
r
LONGINT
BEGIN
SYSTEM
GET
pref
pvadr
pointers
heapOrg
considered
NIL
WHILE
pvadr
DO
SYSTEM
GET
pvadr
p
SYSTEM
GET
p
offadr
IF
p
heapOrg
offadr
THEN
q
p
mark
elements
in
data
structure
with
root
p
REPEAT
SYSTEM
GET
p
offadr
IF
offadr
THEN
SYSTEM
GET
p
tag
offadr
tag
ELSE
INC
offadr
END
SYSTEM
PUT
p
offadr
SYSTEM
GET
offadr
offset
IF
offset
THEN
down
SYSTEM
GET
p
offset
r
SYSTEM
GET
r
offadr
IF
r
heapOrg
offadr
THEN
SYSTEM
PUT
p
offset
q
q
p
p
r
END
ELSE
up
SYSTEM
GET
q
offadr
SYSTEM
GET
offadr
offset
IF
p
q
THEN
SYSTEM
GET
q
offset
r
SYSTEM
PUT
q
offset
p
p
q
q
r
END
END
UNTIL
p
q
offset
END
INC
pref
SYSTEM
GET
pref
pvadr
END
END
Mark
PROCEDURE
Scan
VAR
p
q
mark
tag
size
LONGINT
BEGIN
p
heapOrg
REPEAT
SYSTEM
GET
p
mark
q
p
WHILE
mark
DO
SYSTEM
GET
p
tag
SYSTEM
GET
tag
size
INC
p
size
SYSTEM
GET
p
mark
END
size
p
q
DEC
allocated
size
size
of
free
block
IF
size
THEN
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list3
list3
q
INC
q
DEC
size
END
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list2
list2
q
INC
q
DEC
size
END
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list1
list1
q
INC
q
DEC
size
END
IF
size
THEN
SYSTEM
PUT
q
size
SYSTEM
PUT
q
SYSTEM
PUT
q
list0
list0
q
INC
q
size
END
END
IF
mark
THEN
SYSTEM
GET
p
tag
SYSTEM
GET
tag
size
SYSTEM
PUT
p
INC
p
size
ELSE
free
SYSTEM
GET
p
size
INC
p
size
END
UNTIL
p
heapLim
END
Scan
Disk
storage
management
PROCEDURE
SPIIdle
n
INTEGER
send
n
FFs
slowly
with
no
card
selected
BEGIN
SYSTEM
PUT
spiCtrl
WHILE
n
DO
DEC
n
SYSTEM
PUT
spiData
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
END
END
SPIIdle
PROCEDURE
SPI
n
INTEGER
send
rcv
byte
slowly
with
card
selected
BEGIN
SYSTEM
PUT
spiCtrl
CARD0
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
END
SPI
PROCEDURE
SPICmd
n
arg
INTEGER
VAR
i
crc
INTEGER
BEGIN
send
cmd
REPEAT
SPIIdle
UNTIL
data
flush
while
unselected
REPEAT
SPI
UNTIL
data
flush
while
selected
IF
n
THEN
crc
ELSIF
n
THEN
crc
ELSE
crc
END
SPI
n
MOD
send
command
FOR
i
TO
BY
DO
SPI
ROR
arg
i
END
send
arg
SPI
crc
i
REPEAT
SPI
DEC
i
UNTIL
data
80H
OR
i
END
SPICmd
PROCEDURE
SDShift
VAR
n
INTEGER
VAR
data
INTEGER
BEGIN
SPICmd
CMD58
get
card
capacity
bit
SYSTEM
GET
spiData
data
SPI
IF
data
OR
SYSTEM
BIT
spiData
THEN
n
n
END
non
SDHC
card
SPI
SPI
SPIIdle
flush
response
END
SDShift
PROCEDURE
ReadSD
src
dst
INTEGER
VAR
i
INTEGER
BEGIN
SDShift
src
SPICmd
src
ASSERT
data
CMD17
read
one
block
i
wait
for
start
data
marker
REPEAT
SPI
INC
i
UNTIL
data
SYSTEM
PUT
spiCtrl
SPIFAST
CARD0
FOR
i
TO
BY
DO
SYSTEM
PUT
spiData
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
SYSTEM
PUT
dst
data
INC
dst
END
SPI
SPI
SPIIdle
may
be
a
checksum
deselect
card
END
ReadSD
PROCEDURE
WriteSD
dst
src
INTEGER
VAR
i
n
INTEGER
x
BYTE
BEGIN
SDShift
dst
SPICmd
dst
ASSERT
data
CMD24
write
one
block
SPI
write
start
data
marker
SYSTEM
PUT
spiCtrl
SPIFAST
CARD0
FOR
i
TO
BY
DO
SYSTEM
GET
src
n
INC
src
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
END
SPI
SPI
dummy
checksum
i
REPEAT
SPI
INC
i
UNTIL
data
MOD
OR
i
ASSERT
data
MOD
SPIIdle
deselect
card
END
WriteSD
PROCEDURE
InitSecMap
VAR
i
INTEGER
BEGIN
NofSectors
sectorMap
sectorMap
FOR
i
TO
mapsize
DIV
DO
sectorMap
i
END
END
InitSecMap
PROCEDURE
MarkSector
sec
INTEGER
BEGIN
sec
sec
DIV
ASSERT
SYSTEM
H
INCL
sectorMap
sec
DIV
sec
MOD
INC
NofSectors
END
MarkSector
PROCEDURE
FreeSector
sec
INTEGER
BEGIN
sec
sec
DIV
ASSERT
SYSTEM
H
EXCL
sectorMap
sec
DIV
sec
MOD
DEC
NofSectors
END
FreeSector
PROCEDURE
AllocSector
hint
INTEGER
VAR
sec
INTEGER
VAR
s
INTEGER
BEGIN
find
free
sector
starting
after
hint
hint
hint
DIV
ASSERT
SYSTEM
H
s
hint
REPEAT
INC
s
IF
s
mapsize
THEN
s
END
UNTIL
s
MOD
IN
sectorMap
s
DIV
INCL
sectorMap
s
DIV
s
MOD
INC
NofSectors
sec
s
END
AllocSector
PROCEDURE
GetSector
src
INTEGER
VAR
dst
Sector
BEGIN
src
src
DIV
ASSERT
SYSTEM
H
src
src
FSoffset
ReadSD
src
SYSTEM
ADR
dst
ReadSD
src
SYSTEM
ADR
dst
END
GetSector
PROCEDURE
PutSector
dst
INTEGER
VAR
src
Sector
BEGIN
dst
dst
DIV
ASSERT
SYSTEM
H
dst
dst
FSoffset
WriteSD
dst
SYSTEM
ADR
src
WriteSD
dst
SYSTEM
ADR
src
END
PutSector
Miscellaneous
procedures
PROCEDURE
Time
INTEGER
VAR
t
INTEGER
BEGIN
SYSTEM
GET
timer
t
RETURN
t
END
Time
PROCEDURE
Clock
INTEGER
BEGIN
RETURN
clock
END
Clock
PROCEDURE
SetClock
dt
INTEGER
BEGIN
clock
dt
END
SetClock
PROCEDURE
Install
Padr
at
INTEGER
BEGIN
SYSTEM
PUT
at
0E7000000H
Padr
at
DIV
END
Install
PROCEDURE
Trap
VAR
a
INTEGER
b
INTEGER
VAR
u
v
w
INTEGER
BEGIN
u
SYSTEM
REG
SYSTEM
GET
u
v
w
v
DIV
10H
MOD
10H
trap
number
IF
w
THEN
New
a
b
ELSE
stop
LED
w
REPEAT
UNTIL
FALSE
END
END
Trap
PROCEDURE
Init
BEGIN
Install
SYSTEM
ADR
Trap
20H
install
temporary
trap
SYSTEM
GET
MemLim
SYSTEM
GET
heapOrg
stackOrg
heapOrg
stackSize
8000H
heapLim
MemLim
list1
list2
list3
list0
heapOrg
SYSTEM
PUT
list0
heapLim
heapOrg
SYSTEM
PUT
list0
SYSTEM
PUT
list0
allocated
clock
InitSecMap
END
Init
END
Kernel
MODULE
MenuViewers
JG
NW
IMPORT
Input
Display
Viewers
Oberon
CONST
extend
reduce
FrameColor
Display
white
TYPE
Viewer
POINTER
TO
ViewerDesc
ViewerDesc
RECORD
Viewers
ViewerDesc
menuH
INTEGER
END
ModifyMsg
RECORD
Display
FrameMsg
id
INTEGER
dY
Y
H
INTEGER
END
PROCEDURE
Copy
V
Viewer
VAR
V1
Viewer
VAR
Menu
Main
Display
Frame
M
Oberon
CopyMsg
BEGIN
Menu
V
dsc
Main
V
dsc
next
NEW
V1
V1
V
V1
state
M
F
NIL
Menu
handle
Menu
M
V1
dsc
M
F
M
F
NIL
Main
handle
Main
M
V1
dsc
next
M
F
END
Copy
PROCEDURE
Draw
V
Viewers
Viewer
BEGIN
Display
ReplConst
FrameColor
V
X
V
Y
V
H
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
V
Y
V
H
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
W
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
H
V
W
Display
replace
END
Draw
PROCEDURE
Extend
V
Viewer
newY
INTEGER
VAR
dH
INTEGER
BEGIN
dH
V
Y
newY
IF
dH
THEN
Display
ReplConst
Display
black
V
X
newY
V
W
dH
Display
replace
Display
ReplConst
FrameColor
V
X
newY
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
newY
dH
Display
replace
Display
ReplConst
FrameColor
V
X
newY
V
W
Display
replace
END
END
Extend
PROCEDURE
Reduce
V
Viewer
newY
INTEGER
BEGIN
Display
ReplConst
FrameColor
V
X
newY
V
W
Display
replace
END
Reduce
PROCEDURE
Grow
V
Viewer
oldH
INTEGER
VAR
dH
INTEGER
BEGIN
dH
V
H
oldH
IF
dH
THEN
Display
ReplConst
FrameColor
V
X
V
Y
oldH
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
V
Y
oldH
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
H
V
W
Display
replace
END
END
Grow
PROCEDURE
Shrink
V
Viewer
newH
INTEGER
BEGIN
Display
ReplConst
FrameColor
V
X
V
Y
newH
V
W
Display
replace
END
Shrink
PROCEDURE
Adjust
F
Display
Frame
id
dY
Y
H
INTEGER
VAR
M
ModifyMsg
BEGIN
M
id
id
M
dY
dY
M
Y
Y
M
H
H
F
handle
F
M
F
Y
Y
F
H
H
END
Adjust
PROCEDURE
Restore
V
Viewer
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
Draw
V
Menu
X
V
X
Menu
Y
V
Y
V
H
Menu
W
V
W
Menu
H
Main
X
V
X
Main
Y
V
Y
V
H
V
menuH
Main
W
V
W
Main
H
IF
V
H
V
menuH
THEN
Adjust
Menu
extend
V
Y
V
H
V
menuH
V
menuH
Adjust
Main
extend
V
Y
V
H
V
menuH
ELSE
Adjust
Menu
extend
V
Y
V
H
END
END
Restore
PROCEDURE
Modify
V
Viewer
Y
H
INTEGER
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
IF
Y
V
Y
THEN
extend
Oberon
RemoveMarks
V
X
Y
V
W
V
Y
Y
Extend
V
Y
IF
H
V
menuH
THEN
Adjust
Menu
extend
Y
H
V
menuH
V
menuH
Adjust
Main
extend
Y
H
V
menuH
ELSE
Adjust
Menu
extend
Y
H
END
ELSIF
Y
V
Y
THEN
reduce
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
IF
H
V
menuH
THEN
Adjust
Main
reduce
Y
H
V
menuH
Adjust
Menu
reduce
Y
H
V
menuH
V
menuH
ELSE
Adjust
Main
reduce
Y
H
V
menuH
Adjust
Menu
reduce
Y
H
END
Reduce
V
Y
END
END
Modify
PROCEDURE
Change
V
Viewer
X
Y
INTEGER
Keys
SET
VAR
Menu
Main
Display
Frame
V1
Viewers
Viewer
keysum
SET
Y0
dY
H
INTEGER
BEGIN
Keys
Menu
V
dsc
Main
V
dsc
next
Oberon
DrawMouseArrow
X
Y
Display
ReplConst
Display
white
V
X
V
Y
V
H
V
dsc
H
V
W
V
dsc
H
Display
invert
Y0
Y
keysum
Keys
Input
Mouse
Keys
X
Y
WHILE
Keys
DO
keysum
keysum
Keys
Oberon
DrawMouseArrow
X
Y
Input
Mouse
Keys
X
Y
END
Display
ReplConst
Display
white
V
X
V
Y
V
H
V
dsc
H
V
W
V
dsc
H
Display
invert
IF
IN
keysum
THEN
IF
IN
keysum
THEN
V1
Viewers
This
X
Y
IF
V1
IS
Viewer
Y
V1
Y
V1
H
V1
Viewer
menuH
THEN
Y
V1
Y
V1
H
END
IF
Y
V1
Y
V
menuH
THEN
Y
V1
Y
V
menuH
END
Viewers
Close
V
Viewers
Open
V
X
Y
Restore
V
ELSE
IF
Y
Y0
THEN
extend
dY
Y
Y0
V1
Viewers
Next
V
IF
V1
state
THEN
CASE
V1
OF
Viewer
IF
V1
H
V1
menuH
THEN
dY
ELSIF
V1
H
V1
menuH
dY
THEN
dY
V1
H
V1
menuH
END
Viewers
Viewer
IF
V1
H
dY
THEN
dY
V1
H
END
END
ELSIF
V1
H
dY
THEN
dY
V1
H
END
Viewers
Change
V
V
Y
V
H
dY
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
Grow
V
V
H
dY
IF
V
H
V
menuH
THEN
Adjust
Menu
extend
dY
V
Y
V
H
V
menuH
V
menuH
Adjust
Main
extend
dY
V
Y
V
H
V
menuH
ELSE
V
H
Adjust
Menu
extend
dY
V
Y
V
H
Adjust
Main
extend
dY
V
Y
V
H
V
menuH
END
ELSIF
Y
Y0
THEN
reduce
dY
Y0
Y
IF
V
H
V
menuH
THEN
IF
V
H
V
menuH
dY
THEN
dY
V
H
V
menuH
END
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
H
V
H
dY
Adjust
Main
reduce
dY
V
Y
H
V
menuH
Adjust
Menu
reduce
dY
V
Y
H
V
menuH
V
menuH
Shrink
V
H
Viewers
Change
V
V
Y
H
END
END
END
END
END
Change
PROCEDURE
Suspend
V
Viewer
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
Adjust
Main
reduce
V
Y
V
H
V
menuH
Adjust
Menu
reduce
V
Y
V
H
END
Suspend
PROCEDURE
Handle
V
Display
Frame
VAR
M
Display
FrameMsg
VAR
X
Y
INTEGER
Menu
Main
Display
Frame
V1
Viewer
BEGIN
Menu
V
dsc
Main
V
dsc
next
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
X
M
X
Y
M
Y
IF
Y
V
Y
THEN
Oberon
DrawMouseArrow
X
Y
ELSIF
Y
V
Y
V
H
V
Viewer
menuH
THEN
Main
handle
Main
M
ELSIF
Y
V
Y
V
H
V
Viewer
menuH
THEN
Menu
handle
Menu
M
ELSIF
Y
V
Y
V
H
THEN
IF
IN
M
keys
THEN
Change
V
Viewer
X
Y
M
keys
ELSE
Menu
handle
Menu
M
END
ELSE
Oberon
DrawMouseArrow
X
Y
END
ELSE
Menu
handle
Menu
M
Main
handle
Main
M
END
Oberon
ControlMsg
IF
M
id
Oberon
mark
THEN
X
M
X
Y
M
Y
Oberon
DrawMouseArrow
X
Y
Oberon
DrawPointer
X
Y
ELSE
Menu
handle
Menu
M
Main
handle
Main
M
END
Oberon
CopyMsg
Copy
V
Viewer
V1
M
F
V1
Viewers
ViewerMsg
IF
M
id
Viewers
restore
THEN
Restore
V
Viewer
ELSIF
M
id
Viewers
modify
THEN
Modify
V
Viewer
M
Y
M
H
ELSIF
M
id
Viewers
suspend
THEN
Suspend
V
Viewer
END
Display
FrameMsg
Menu
handle
Menu
M
Main
handle
Main
M
END
END
Handle
PROCEDURE
New
Menu
Main
Display
Frame
menuH
X
Y
INTEGER
Viewer
VAR
V
Viewer
BEGIN
NEW
V
V
handle
Handle
V
dsc
Menu
V
dsc
next
Main
V
menuH
menuH
Viewers
Open
V
X
Y
Restore
V
RETURN
V
END
New
END
MenuViewers
MODULE
Modules
Link
and
load
on
RISC
NW
IMPORT
SYSTEM
Files
CONST
versionkey
1X
MT
DescSize
TYPE
Module
POINTER
TO
ModDesc
Command
PROCEDURE
ModuleName
ARRAY
OF
CHAR
ModDesc
RECORD
name
ModuleName
next
Module
key
num
size
refcnt
INTEGER
data
code
imp
cmd
ent
ptr
unused
INTEGER
addresses
END
VAR
root
M
Module
MTOrg
AllocPtr
res
INTEGER
importing
imported
ModuleName
limit
INTEGER
PROCEDURE
ThisFile
name
ARRAY
OF
CHAR
Files
File
VAR
i
INTEGER
filename
ModuleName
BEGIN
i
WHILE
name
i
0X
DO
filename
i
name
i
INC
i
END
filename
i
filename
i
r
filename
i
s
filename
i
c
filename
i
0X
RETURN
Files
Old
filename
END
ThisFile
PROCEDURE
error
n
INTEGER
name
ARRAY
OF
CHAR
BEGIN
res
n
importing
name
END
error
PROCEDURE
Check
s
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
ch
s
res
i
IF
ch
A
ch
Z
OR
ch
a
ch
z
THEN
REPEAT
ch
s
i
INC
i
UNTIL
ch
ch
OR
ch
A
ch
Z
OR
ch
a
ch
z
OR
ch
OR
i
IF
i
ch
0X
THEN
res
END
END
END
Check
PROCEDURE
Load
name
ARRAY
OF
CHAR
VAR
newmod
Module
search
module
in
list
if
not
found
load
module
res
already
present
or
loaded
res
file
not
available
res
key
conflict
res
bad
file
version
res
corrupted
file
res
no
space
VAR
mod
impmod
Module
i
n
key
impkey
mno
nofimps
size
INTEGER
p
u
v
w
INTEGER
addresses
ch
CHAR
body
Command
fixorgP
fixorgD
fixorgT
INTEGER
disp
adr
inst
pno
vno
dest
offset
INTEGER
name1
impname
ModuleName
F
Files
File
R
Files
Rider
import
ARRAY
OF
Module
BEGIN
mod
root
res
nofimps
WHILE
mod
NIL
name
mod
name
DO
mod
mod
next
END
IF
mod
NIL
THEN
load
Check
name
IF
res
THEN
F
ThisFile
name
ELSE
F
NIL
END
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadString
R
name1
Files
ReadInt
R
key
Files
Read
R
ch
Files
ReadInt
R
size
importing
name1
IF
ch
versionkey
THEN
Files
ReadString
R
impname
imports
WHILE
impname
0X
res
DO
Files
ReadInt
R
impkey
Load
impname
impmod
import
nofimps
impmod
importing
name1
IF
res
THEN
IF
impmod
key
impkey
THEN
INC
impmod
refcnt
INC
nofimps
ELSE
error
name1
imported
impname
END
END
Files
ReadString
R
impname
END
ELSE
error
name1
END
ELSE
error
name
END
IF
res
THEN
search
for
a
hole
in
the
list
allocate
and
link
INC
size
DescSize
mod
root
WHILE
mod
NIL
mod
name
0X
mod
size
size
DO
mod
mod
next
END
IF
mod
NIL
THEN
no
large
enough
hole
was
found
IF
AllocPtr
size
limit
THEN
allocate
p
AllocPtr
mod
SYSTEM
VAL
Module
p
AllocPtr
p
size
100H
DIV
20H
20H
mod
size
AllocPtr
p
mod
num
root
num
mod
next
root
root
mod
ELSE
error
name1
END
ELSE
fill
hole
p
SYSTEM
VAL
INTEGER
mod
END
END
IF
res
THEN
read
file
INC
p
DescSize
allocate
descriptor
mod
name
name
mod
key
key
mod
refcnt
mod
data
p
data
SYSTEM
PUT
mod
num
MTOrg
p
module
table
entry
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
type
descriptors
Files
ReadInt
R
n
WHILE
n
DO
SYSTEM
PUT
p
INC
p
DEC
n
END
variable
space
Files
ReadInt
R
n
WHILE
n
DO
Files
Read
R
ch
SYSTEM
PUT
p
ch
INC
p
DEC
n
END
strings
mod
code
p
program
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
program
code
mod
imp
p
copy
imports
i
WHILE
i
nofimps
DO
SYSTEM
PUT
p
import
i
INC
p
INC
i
END
mod
cmd
p
commands
Files
Read
R
ch
WHILE
ch
0X
DO
REPEAT
SYSTEM
PUT
p
ch
INC
p
Files
Read
R
ch
UNTIL
ch
0X
REPEAT
SYSTEM
PUT
p
0X
INC
p
UNTIL
p
MOD
Files
ReadInt
R
n
SYSTEM
PUT
p
n
INC
p
Files
Read
R
ch
END
REPEAT
SYSTEM
PUT
p
0X
INC
p
UNTIL
p
MOD
mod
ent
p
entries
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
mod
ptr
p
pointer
references
Files
ReadInt
R
w
WHILE
w
DO
SYSTEM
PUT
p
mod
data
w
INC
p
Files
ReadInt
R
w
END
SYSTEM
PUT
p
INC
p
Files
ReadInt
R
fixorgP
Files
ReadInt
R
fixorgD
Files
ReadInt
R
fixorgT
Files
ReadInt
R
w
body
SYSTEM
VAL
Command
mod
code
w
Files
Read
R
ch
IF
ch
O
THEN
corrupted
file
mod
NIL
error
name
END
END
IF
res
THEN
fixup
of
BL
adr
mod
code
fixorgP
WHILE
adr
mod
code
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
100000H
MOD
10H
pno
inst
DIV
1000H
MOD
100H
disp
inst
MOD
1000H
SYSTEM
GET
mod
imp
mno
impmod
SYSTEM
GET
impmod
ent
pno
dest
dest
dest
impmod
code
offset
dest
adr
DIV
SYSTEM
PUT
adr
offset
MOD
1000000H
0F7000000H
adr
adr
disp
END
fixup
of
LDR
STR
ADD
adr
mod
code
fixorgD
WHILE
adr
mod
code
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
100000H
MOD
10H
disp
inst
MOD
1000H
IF
mno
THEN
global
SYSTEM
PUT
adr
inst
DIV
1000000H
10H
MT
100000H
mod
num
ELSE
import
SYSTEM
GET
mod
imp
mno
impmod
v
impmod
num
SYSTEM
PUT
adr
inst
DIV
1000000H
10H
MT
100000H
v
SYSTEM
GET
adr
inst
vno
inst
MOD
100H
SYSTEM
GET
impmod
ent
vno
offset
IF
ODD
inst
DIV
100H
THEN
offset
offset
impmod
code
impmod
data
END
SYSTEM
PUT
adr
inst
DIV
10000H
10000H
offset
END
adr
adr
disp
END
fixup
of
type
descriptors
adr
mod
data
fixorgT
WHILE
adr
mod
data
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
1000000H
MOD
10H
vno
inst
DIV
1000H
MOD
1000H
disp
inst
MOD
1000H
IF
mno
THEN
global
inst
mod
data
vno
ELSE
import
SYSTEM
GET
mod
imp
mno
impmod
SYSTEM
GET
impmod
ent
vno
offset
inst
impmod
data
offset
END
SYSTEM
PUT
adr
inst
adr
adr
disp
END
body
initialize
module
ELSIF
res
THEN
importing
name
WHILE
nofimps
DO
DEC
nofimps
DEC
import
nofimps
refcnt
END
END
END
newmod
mod
END
Load
PROCEDURE
ThisCommand
mod
Module
name
ARRAY
OF
CHAR
Command
VAR
k
adr
w
INTEGER
ch
CHAR
s
ARRAY
OF
CHAR
BEGIN
res
w
IF
mod
NIL
THEN
adr
mod
cmd
SYSTEM
GET
adr
ch
WHILE
ch
0X
res
DO
k
read
command
name
REPEAT
s
k
ch
INC
k
INC
adr
SYSTEM
GET
adr
ch
UNTIL
ch
0X
s
k
0X
REPEAT
INC
adr
UNTIL
adr
MOD
SYSTEM
GET
adr
k
INC
adr
IF
s
name
THEN
res
w
mod
code
k
ELSE
SYSTEM
GET
adr
ch
END
END
END
RETURN
SYSTEM
VAL
Command
w
END
ThisCommand
PROCEDURE
Free
name
ARRAY
OF
CHAR
VAR
mod
imp
Module
p
q
INTEGER
BEGIN
mod
root
res
WHILE
mod
NIL
mod
name
name
DO
mod
mod
next
END
IF
mod
NIL
THEN
IF
mod
refcnt
THEN
mod
name
0X
p
mod
imp
q
mod
cmd
WHILE
p
q
DO
SYSTEM
GET
p
imp
DEC
imp
refcnt
INC
p
END
ELSE
res
END
END
END
Free
PROCEDURE
Init
BEGIN
Files
Init
MTOrg
SYSTEM
REG
MT
SYSTEM
GET
AllocPtr
SYSTEM
GET
root
SYSTEM
GET
limit
DEC
limit
8000H
END
Init
BEGIN
Init
Load
Oberon
M
LED
res
REPEAT
UNTIL
FALSE
only
if
load
fails
END
Modules
MODULE
Net
NW
PR
IMPORT
SYSTEM
SCC
Files
Viewers
Texts
TextFrames
MenuViewers
Oberon
CONST
PakSize
T0
T1
timeouts
T0
T1
timeouts
ACK
10H
NAK
25H
NPR
26H
acknowledgements
NRQ
34H
NRS
35H
name
request
response
SND
41H
REC
42H
MSG
44H
TRQ
46H
TIM
47H
time
requests
VAR
W
Texts
Writer
Server
Oberon
Task
head0
head1
SCC
Header
partner
ARRAY
OF
CHAR
dmy
ARRAY
OF
BYTE
protected
BOOLEAN
write
protection
PROCEDURE
SetPartner
name
ARRAY
OF
CHAR
BEGIN
head0
dadr
head1
sadr
partner
name
END
SetPartner
PROCEDURE
Send
t
BYTE
L
INTEGER
data
ARRAY
OF
BYTE
BEGIN
head0
typ
t
head0
len
L
SCC
SendPacket
head0
data
END
Send
PROCEDURE
ReceiveHead
timeout
LONGINT
VAR
time
LONGINT
BEGIN
time
Oberon
Time
timeout
REPEAT
SCC
ReceiveHead
head1
IF
head1
valid
head1
sadr
head0
dadr
THEN
SCC
Skip
head1
len
head1
valid
FALSE
END
IF
head1
valid
Oberon
Time
time
THEN
head1
typ
0FFH
END
UNTIL
head1
valid
OR
head1
typ
0FFH
END
ReceiveHead
PROCEDURE
FindPartner
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
time
LONGINT
k
INTEGER
Id
ARRAY
OF
CHAR
IdB
ARRAY
OF
BYTE
BEGIN
SCC
Skip
SCC
Available
res
k
WHILE
k
name
k
0X
DO
Id
k
name
k
IdB
k
ORD
Id
k
INC
k
END
Id
k
0X
IdB
k
also
terminate
IdB
IF
Id
partner
THEN
head0
dadr
0FFH
Send
NRQ
k
IdB
time
Oberon
Time
T1
REPEAT
SCC
ReceiveHead
head1
IF
head1
valid
THEN
IF
head1
typ
NRS
THEN
SetPartner
Id
ELSE
SCC
Skip
head1
len
head1
valid
FALSE
END
ELSIF
Oberon
Time
time
THEN
res
partner
0X
END
UNTIL
head1
valid
OR
res
END
END
FindPartner
PROCEDURE
AppendS
s
ARRAY
OF
CHAR
VAR
d
ARRAY
OF
BYTE
VAR
k
INTEGER
VAR
i
INTEGER
ch
CHAR
BEGIN
i
REPEAT
ch
s
i
d
k
ORD
ch
INC
i
INC
k
UNTIL
ch
0X
END
AppendS
PROCEDURE
AppendW
s
LONGINT
VAR
d
ARRAY
OF
BYTE
n
INTEGER
VAR
k
INTEGER
VAR
i
INTEGER
BEGIN
i
REPEAT
d
k
s
MOD
100H
s
s
DIV
100H
INC
i
INC
k
UNTIL
i
n
END
AppendW
PROCEDURE
PickS
VAR
s
ARRAY
OF
CHAR
VAR
i
INTEGER
x
BYTE
BEGIN
i
REPEAT
SCC
Receive
x
s
i
CHR
x
INC
i
UNTIL
x
END
PickS
PROCEDURE
PickQ
VAR
w
LONGINT
VAR
x0
x1
x2
x3
BYTE
BEGIN
SCC
Receive
x0
SCC
Receive
x1
SCC
Receive
x2
SCC
Receive
x3
w
x0
100H
x1
100H
x2
100H
x3
END
PickQ
PROCEDURE
SendData
F
Files
File
VAR
k
seqno
INTEGER
x
BYTE
len
LONGINT
R
Files
Rider
buf
ARRAY
PakSize
OF
BYTE
BEGIN
Files
Set
R
F
len
seqno
REPEAT
k
REPEAT
Files
ReadByte
R
x
IF
R
eof
THEN
buf
k
x
INC
k
END
UNTIL
R
eof
OR
k
PakSize
REPEAT
Send
seqno
k
buf
ReceiveHead
T1
UNTIL
head1
typ
seqno
ACK
seqno
seqno
MOD
len
len
k
IF
head1
typ
seqno
ACK
THEN
Texts
WriteString
W
failed
k
END
UNTIL
k
PakSize
Texts
WriteInt
W
len
END
SendData
PROCEDURE
ReceiveData
F
Files
File
VAR
done
BOOLEAN
VAR
k
retry
seqno
INTEGER
x
BYTE
len
LONGINT
R
Files
Rider
BEGIN
Files
Set
R
F
seqno
len
retry
k
PakSize
REPEAT
IF
head1
typ
seqno
THEN
seqno
seqno
MOD
len
len
head1
len
retry
Send
seqno
ACK
dmy
k
WHILE
k
head1
len
DO
SCC
Receive
x
Files
WriteByte
R
x
INC
k
END
IF
k
PakSize
THEN
done
TRUE
END
ELSE
DEC
retry
IF
retry
THEN
Texts
WriteString
W
failed
done
FALSE
k
END
Send
seqno
ACK
dmy
END
ReceiveHead
T0
UNTIL
k
PakSize
Texts
WriteInt
W
len
END
ReceiveData
PROCEDURE
reply
msg
INTEGER
BEGIN
IF
msg
THEN
Texts
WriteString
W
no
link
ELSIF
msg
THEN
Texts
WriteString
W
no
permission
ELSIF
msg
THEN
Texts
WriteString
W
not
done
ELSIF
msg
THEN
Texts
WriteString
W
not
found
ELSIF
msg
THEN
Texts
WriteString
W
no
response
ELSIF
msg
THEN
Texts
WriteString
W
time
set
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
reply
PROCEDURE
Serve
VAR
i
INTEGER
done
BOOLEAN
x
BYTE
F
Files
File
pw
clock
newclock
LONGINT
Id
ARRAY
OF
CHAR
IdB
ARRAY
OF
BYTE
FileName
ARRAY
OF
CHAR
BEGIN
SCC
ReceiveHead
head1
IF
head1
valid
THEN
IF
head1
typ
SND
THEN
PickS
Id
PickQ
pw
PickS
FileName
Texts
WriteString
W
Id
Texts
Write
W
Texts
WriteString
W
FileName
F
Files
Old
FileName
IF
F
NIL
THEN
Texts
WriteString
W
sending
SetPartner
Id
Texts
Append
Oberon
Log
W
buf
SendData
F
ELSE
Send
NAK
dmy
Texts
Write
W
END
reply
ELSIF
head1
typ
REC
THEN
PickS
Id
PickQ
pw
PickS
FileName
IF
protected
THEN
Texts
WriteString
W
Id
Texts
Write
W
Texts
WriteString
W
FileName
F
Files
New
FileName
IF
F
NIL
THEN
Texts
WriteString
W
receiving
SetPartner
Id
Texts
Append
Oberon
Log
W
buf
Send
ACK
dmy
ReceiveHead
T0
ReceiveData
F
done
IF
done
THEN
Files
Register
F
END
ELSE
Send
NAK
dmy
Texts
Write
W
END
reply
ELSE
Send
NPR
dmy
END
ELSIF
head1
typ
MSG
THEN
i
WHILE
i
head1
len
DO
SCC
Receive
x
Texts
Write
W
CHR
x
INC
i
END
Send
ACK
dmy
reply
ELSIF
head1
typ
TRQ
THEN
i
AppendW
Oberon
Clock
IdB
i
Send
TIM
IdB
ELSIF
head1
typ
TIM
THEN
PickQ
newclock
PickS
Id
PickQ
pw
clock
Oberon
Clock
IF
protected
Id
0X
ABS
pw
clock
THEN
Oberon
SetClock
newclock
Texts
WriteString
W
Id
Texts
WriteString
W
changed
System
Date
Texts
WriteClock
W
newclock
reply
END
ELSIF
head1
typ
NRQ
THEN
i
REPEAT
SCC
Receive
x
Id
i
CHR
x
INC
i
IF
i
THEN
Id
0X
x
END
UNTIL
x
WHILE
i
head1
len
DO
SCC
Receive
x
INC
i
END
IF
Id
Oberon
User
THEN
SetPartner
Id
Send
NRS
dmy
END
ELSE
SCC
Skip
head1
len
END
END
END
Serve
PROCEDURE
GetPar1
VAR
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
END
GetPar1
PROCEDURE
GetPar
VAR
S
Texts
Scanner
VAR
end
LONGINT
VAR
T
Texts
Text
beg
tm
LONGINT
BEGIN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
tm
IF
tm
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
ELSE
end
Oberon
Par
text
len
END
END
GetPar
PROCEDURE
SendFiles
VAR
k
INTEGER
end
LONGINT
S
Texts
Scanner
F
Files
File
buf
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
k
IF
k
THEN
GetPar
S
end
WHILE
Texts
Pos
S
end
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
k
AppendS
Oberon
User
buf
k
AppendW
Oberon
Password
buf
k
AppendS
S
s
buf
k
IF
S
nextCh
THEN
prefix
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
THEN
buf
k
ORD
AppendS
S
s
buf
k
Texts
Write
W
Texts
WriteString
W
S
s
END
END
F
Files
Old
S
s
IF
F
NIL
THEN
Send
REC
k
buf
ReceiveHead
T0
IF
head1
typ
ACK
THEN
Texts
WriteString
W
sending
Texts
Append
Oberon
Log
W
buf
SendData
F
reply
ELSIF
head1
typ
NPR
THEN
reply
end
ELSIF
head1
typ
NAK
THEN
reply
end
ELSE
reply
end
END
ELSE
reply
END
Texts
Scan
S
END
ELSE
reply
END
END
END
SendFiles
PROCEDURE
ReceiveFiles
VAR
k
INTEGER
done
BOOLEAN
end
LONGINT
S
Texts
Scanner
F
Files
File
buf
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
k
IF
k
THEN
GetPar
S
end
WHILE
Texts
Pos
S
end
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
k
AppendS
Oberon
User
buf
k
AppendW
Oberon
Password
buf
k
AppendS
S
s
buf
k
IF
S
nextCh
THEN
prefix
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
THEN
buf
k
ORD
AppendS
S
s
buf
k
Texts
Write
W
Texts
WriteString
W
S
s
END
END
Send
SND
k
buf
Texts
WriteString
W
receiving
Texts
Append
Oberon
Log
W
buf
ReceiveHead
T1
IF
head1
typ
THEN
F
Files
New
S
s
IF
F
NIL
THEN
ReceiveData
F
done
IF
done
THEN
Files
Register
F
reply
ELSE
end
END
ELSE
reply
Send
NAK
dmy
END
ELSIF
head1
typ
NAK
THEN
reply
ELSIF
head1
typ
NPR
THEN
reply
end
ELSE
reply
end
END
Texts
Scan
S
END
ELSE
reply
END
END
END
ReceiveFiles
PROCEDURE
SendMsg
VAR
i
INTEGER
ch
CHAR
S
Texts
Scanner
msg
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
i
IF
i
THEN
Texts
Read
S
ch
WHILE
ch
i
DO
msg
i
ORD
ch
INC
i
Texts
Read
S
ch
END
Send
MSG
i
msg
ReceiveHead
T0
IF
head1
typ
ACK
THEN
reply
END
ELSE
reply
END
END
END
SendMsg
PROCEDURE
GetTime
VAR
dt
res
INTEGER
S
Texts
Scanner
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
res
IF
res
THEN
Send
TRQ
dmy
ReceiveHead
T1
IF
head1
typ
TIM
THEN
PickQ
dt
Oberon
SetClock
dt
reply
END
ELSE
reply
END
END
END
GetTime
PROCEDURE
StartServer
BEGIN
protected
TRUE
partner
0X
SCC
Start
TRUE
Oberon
Remove
Server
Oberon
Install
Server
Texts
WriteString
W
Server
started
as
Texts
WriteString
W
Oberon
User
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
StartServer
PROCEDURE
Unprotect
BEGIN
protected
FALSE
END
Unprotect
PROCEDURE
WProtect
BEGIN
protected
TRUE
END
WProtect
PROCEDURE
Reset
BEGIN
SCC
Start
TRUE
END
Reset
PROCEDURE
StopServer
BEGIN
Oberon
Remove
Server
Texts
WriteString
W
Server
stopped
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
StopServer
PROCEDURE
SCCStatus
BEGIN
Texts
WriteString
W
SCC
Available
Texts
WriteInt
W
SCC
Available
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
SCCStatus
BEGIN
Texts
OpenWriter
W
Server
Oberon
NewTask
Serve
END
Net
MODULE
Oberon
JG
NW
IMPORT
SYSTEM
Kernel
Files
Modules
Input
Display
Viewers
Fonts
Texts
CONST
message
ids
consume
track
defocus
neutralize
mark
off
idle
active
task
states
BasicCycle
ESC
1BX
SETSTAR
1AX
TYPE
Painter
PROCEDURE
x
y
INTEGER
Marker
RECORD
Fade
Draw
Painter
END
Cursor
RECORD
marker
Marker
on
BOOLEAN
X
Y
INTEGER
END
InputMsg
RECORD
Display
FrameMsg
id
INTEGER
keys
SET
X
Y
INTEGER
ch
CHAR
fnt
Fonts
Font
col
voff
INTEGER
END
SelectionMsg
RECORD
Display
FrameMsg
time
LONGINT
text
Texts
Text
beg
end
LONGINT
END
ControlMsg
RECORD
Display
FrameMsg
id
X
Y
INTEGER
END
CopyMsg
RECORD
Display
FrameMsg
F
Display
Frame
END
Task
POINTER
TO
TaskDesc
Handler
PROCEDURE
TaskDesc
RECORD
state
nextTime
period
INTEGER
next
Task
handle
Handler
END
VAR
User
ARRAY
OF
CHAR
Password
LONGINT
Arrow
Star
Marker
Mouse
Pointer
Cursor
FocusViewer
Viewers
Viewer
Log
Texts
Text
Par
RECORD
vwr
Viewers
Viewer
frame
Display
Frame
text
Texts
Text
pos
LONGINT
END
CurFnt
Fonts
Font
CurCol
CurOff
INTEGER
NofTasks
INTEGER
CurTask
Task
DW
DH
CL
INTEGER
ActCnt
INTEGER
action
count
for
GC
Mod
Modules
Module
user
identification
PROCEDURE
Code
VAR
s
ARRAY
OF
CHAR
LONGINT
VAR
i
INTEGER
a
b
c
LONGINT
BEGIN
a
b
i
WHILE
s
i
0X
DO
c
b
b
a
a
c
MOD
ORD
s
i
INC
i
END
IF
b
THEN
b
b
END
RETURN
b
a
END
Code
PROCEDURE
SetUser
VAR
user
password
ARRAY
OF
CHAR
BEGIN
User
user
Password
Code
password
END
SetUser
PROCEDURE
Clock
LONGINT
BEGIN
RETURN
Kernel
Clock
END
Clock
PROCEDURE
SetClock
d
LONGINT
BEGIN
Kernel
SetClock
d
END
SetClock
PROCEDURE
Time
LONGINT
BEGIN
RETURN
Kernel
Time
END
Time
cursor
handling
PROCEDURE
FlipArrow
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
arrow
X
Y
Display
invert
END
FlipArrow
PROCEDURE
FlipStar
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
star
X
Y
Display
invert
END
FlipStar
PROCEDURE
OpenCursor
VAR
c
Cursor
BEGIN
c
on
FALSE
c
X
c
Y
END
OpenCursor
PROCEDURE
FadeCursor
VAR
c
Cursor
BEGIN
IF
c
on
THEN
c
marker
Fade
c
X
c
Y
c
on
FALSE
END
END
FadeCursor
PROCEDURE
DrawCursor
VAR
c
Cursor
m
Marker
x
y
INTEGER
BEGIN
IF
c
on
x
c
X
OR
y
c
Y
OR
m
Draw
c
marker
Draw
THEN
c
marker
Fade
c
X
c
Y
c
on
FALSE
END
IF
c
on
THEN
m
Draw
x
y
c
marker
m
c
X
x
c
Y
y
c
on
TRUE
END
END
DrawCursor
PROCEDURE
DrawMouse
m
Marker
x
y
INTEGER
BEGIN
DrawCursor
Mouse
m
x
y
END
DrawMouse
PROCEDURE
DrawMouseArrow
x
y
INTEGER
BEGIN
DrawCursor
Mouse
Arrow
x
y
END
DrawMouseArrow
PROCEDURE
FadeMouse
BEGIN
FadeCursor
Mouse
END
FadeMouse
PROCEDURE
DrawPointer
x
y
INTEGER
BEGIN
DrawCursor
Pointer
Star
x
y
END
DrawPointer
display
management
PROCEDURE
RemoveMarks
X
Y
W
H
INTEGER
BEGIN
IF
Mouse
X
X
Mouse
X
X
W
Mouse
Y
Y
Mouse
Y
Y
H
THEN
FadeCursor
Mouse
END
IF
Pointer
X
X
Pointer
X
X
W
Pointer
Y
Y
Pointer
Y
Y
H
THEN
FadeCursor
Pointer
END
END
RemoveMarks
PROCEDURE
HandleFiller
V
Display
Frame
VAR
M
Display
FrameMsg
BEGIN
CASE
M
OF
InputMsg
IF
M
id
track
THEN
DrawCursor
Mouse
Arrow
M
X
M
Y
END
ControlMsg
IF
M
id
mark
THEN
DrawCursor
Pointer
Star
M
X
M
Y
END
Viewers
ViewerMsg
IF
M
id
Viewers
restore
V
W
V
H
THEN
RemoveMarks
V
X
V
Y
V
W
V
H
Display
ReplConst
Display
black
V
X
V
Y
V
W
V
H
Display
replace
ELSIF
M
id
Viewers
modify
M
Y
V
Y
THEN
RemoveMarks
V
X
M
Y
V
W
V
Y
M
Y
Display
ReplConst
Display
black
V
X
M
Y
V
W
V
Y
M
Y
Display
replace
END
END
END
HandleFiller
PROCEDURE
OpenDisplay
UW
SW
H
INTEGER
VAR
Filler
Viewers
Viewer
BEGIN
Input
SetMouseLimits
Viewers
curW
UW
SW
H
Display
ReplConst
Display
black
Viewers
curW
UW
SW
H
Display
replace
NEW
Filler
Filler
handle
HandleFiller
Viewers
InitTrack
UW
H
Filler
init
user
track
NEW
Filler
Filler
handle
HandleFiller
Viewers
InitTrack
SW
H
Filler
init
system
track
END
OpenDisplay
PROCEDURE
DisplayWidth
X
INTEGER
INTEGER
BEGIN
RETURN
DW
END
DisplayWidth
PROCEDURE
DisplayHeight
X
INTEGER
INTEGER
BEGIN
RETURN
DH
END
DisplayHeight
PROCEDURE
OpenTrack
X
W
INTEGER
VAR
Filler
Viewers
Viewer
BEGIN
NEW
Filler
Filler
handle
HandleFiller
Viewers
OpenTrack
X
W
Filler
END
OpenTrack
PROCEDURE
UserTrack
X
INTEGER
INTEGER
BEGIN
RETURN
X
DIV
DW
DW
END
UserTrack
PROCEDURE
SystemTrack
X
INTEGER
INTEGER
BEGIN
RETURN
X
DIV
DW
DW
DW
DIV
END
SystemTrack
PROCEDURE
UY
X
INTEGER
INTEGER
VAR
h
INTEGER
fil
bot
alt
max
Display
Frame
BEGIN
Viewers
Locate
X
fil
bot
alt
max
IF
fil
H
DH
DIV
THEN
h
DH
ELSE
h
max
Y
max
H
DIV
END
RETURN
h
END
UY
PROCEDURE
AllocateUserViewer
DX
INTEGER
VAR
X
Y
INTEGER
BEGIN
IF
Pointer
on
THEN
X
Pointer
X
Y
Pointer
Y
ELSE
X
DX
DIV
DW
DW
Y
UY
X
END
END
AllocateUserViewer
PROCEDURE
SY
X
INTEGER
INTEGER
VAR
H0
H1
H2
H3
y
INTEGER
fil
bot
alt
max
Display
Frame
BEGIN
H3
DH
DH
DIV
H2
H3
H3
DIV
H1
DH
DIV
H0
DH
DIV
Viewers
Locate
X
DH
fil
bot
alt
max
IF
fil
H
DH
DIV
THEN
y
DH
ELSIF
max
H
DH
H0
THEN
y
max
Y
H3
ELSIF
max
H
H3
H0
THEN
y
max
Y
H2
ELSIF
max
H
H2
H0
THEN
y
max
Y
H1
ELSIF
max
bot
THEN
y
max
Y
max
H
DIV
ELSIF
bot
H
H1
THEN
y
bot
H
DIV
ELSE
y
alt
Y
alt
H
DIV
END
RETURN
y
END
SY
PROCEDURE
AllocateSystemViewer
DX
INTEGER
VAR
X
Y
INTEGER
BEGIN
IF
Pointer
on
THEN
X
Pointer
X
Y
Pointer
Y
ELSE
X
DX
DIV
DW
DW
DW
DIV
Y
SY
X
END
END
AllocateSystemViewer
PROCEDURE
MarkedViewer
Viewers
Viewer
BEGIN
RETURN
Viewers
This
Pointer
X
Pointer
Y
END
MarkedViewer
PROCEDURE
PassFocus
V
Viewers
Viewer
VAR
M
ControlMsg
BEGIN
M
id
defocus
FocusViewer
handle
FocusViewer
M
FocusViewer
V
END
PassFocus
PROCEDURE
OpenLog
T
Texts
Text
BEGIN
Log
T
END
OpenLog
command
interpretation
PROCEDURE
SetPar
F
Display
Frame
T
Texts
Text
pos
LONGINT
BEGIN
Par
vwr
Viewers
This
F
X
F
Y
Par
frame
F
Par
text
T
Par
pos
pos
END
SetPar
PROCEDURE
Call
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
mod
Modules
Module
P
Modules
Command
i
j
INTEGER
ch
CHAR
Mname
Cname
ARRAY
OF
CHAR
BEGIN
i
ch
name
WHILE
ch
ch
0X
DO
Mname
i
ch
INC
i
ch
name
i
END
IF
ch
THEN
Mname
i
0X
INC
i
Modules
Load
Mname
mod
res
Modules
res
IF
Modules
res
THEN
j
ch
name
i
INC
i
WHILE
ch
0X
DO
Cname
j
ch
INC
j
ch
name
i
INC
i
END
Cname
j
0X
P
Modules
ThisCommand
mod
Cname
res
Modules
res
IF
Modules
res
THEN
P
END
END
ELSE
res
END
END
Call
PROCEDURE
GetSelection
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
VAR
M
SelectionMsg
BEGIN
M
time
Viewers
Broadcast
M
time
M
time
IF
time
THEN
text
M
text
beg
M
beg
end
M
end
END
END
GetSelection
PROCEDURE
GC
VAR
mod
Modules
Module
BEGIN
IF
ActCnt
OR
Kernel
allocated
Kernel
heapLim
Kernel
heapOrg
10000H
THEN
mod
Modules
root
LED
21H
WHILE
mod
NIL
DO
IF
mod
name
0X
THEN
Kernel
Mark
mod
ptr
END
mod
mod
next
END
LED
23H
Files
RestoreList
LED
27H
Kernel
Scan
LED
20H
ActCnt
BasicCycle
END
END
GC
PROCEDURE
NewTask
h
Handler
period
INTEGER
Task
VAR
t
Task
BEGIN
NEW
t
t
state
off
t
next
t
t
handle
h
t
period
period
RETURN
t
END
NewTask
PROCEDURE
Install
T
Task
BEGIN
IF
T
state
off
THEN
T
next
CurTask
next
CurTask
next
T
T
state
idle
T
nextTime
INC
NofTasks
END
END
Install
PROCEDURE
Remove
T
Task
VAR
t
Task
BEGIN
IF
T
state
off
THEN
t
T
WHILE
t
next
T
DO
t
t
next
END
t
next
T
next
T
state
off
T
next
NIL
CurTask
t
DEC
NofTasks
END
END
Remove
PROCEDURE
Collect
count
INTEGER
BEGIN
ActCnt
count
END
Collect
PROCEDURE
SetFont
fnt
Fonts
Font
BEGIN
CurFnt
fnt
END
SetFont
PROCEDURE
SetColor
col
INTEGER
BEGIN
CurCol
col
END
SetColor
PROCEDURE
SetOffset
voff
INTEGER
BEGIN
CurOff
voff
END
SetOffset
PROCEDURE
Loop
VAR
V
Viewers
Viewer
M
InputMsg
N
ControlMsg
prevX
prevY
X
Y
t
INTEGER
keys
SET
ch
CHAR
BEGIN
REPEAT
Input
Mouse
keys
X
Y
IF
Input
Available
THEN
Input
Read
ch
IF
ch
ESC
THEN
N
id
neutralize
Viewers
Broadcast
N
FadeCursor
Pointer
LED
ELSIF
ch
SETSTAR
THEN
N
id
mark
N
X
X
N
Y
Y
V
Viewers
This
X
Y
V
handle
V
N
ELSE
M
id
consume
M
ch
ch
M
fnt
CurFnt
M
col
CurCol
M
voff
CurOff
FocusViewer
handle
FocusViewer
M
DEC
ActCnt
END
ELSIF
keys
THEN
M
id
track
M
X
X
M
Y
Y
M
keys
keys
REPEAT
V
Viewers
This
M
X
M
Y
V
handle
V
M
Input
Mouse
M
keys
M
X
M
Y
UNTIL
M
keys
DEC
ActCnt
ELSE
IF
X
prevX
OR
Y
prevY
OR
Mouse
on
THEN
M
id
track
M
X
X
IF
Y
Display
Height
THEN
Y
Display
Height
END
M
Y
Y
M
keys
keys
V
Viewers
This
X
Y
V
handle
V
M
prevX
X
prevY
Y
END
CurTask
CurTask
next
t
Kernel
Time
IF
t
CurTask
nextTime
THEN
CurTask
nextTime
t
CurTask
period
CurTask
state
active
CurTask
handle
CurTask
state
idle
END
END
UNTIL
FALSE
END
Loop
PROCEDURE
Reset
BEGIN
IF
CurTask
state
active
THEN
Remove
CurTask
END
SYSTEM
LDREG
Kernel
stackOrg
reset
stack
pointer
Loop
END
Reset
BEGIN
User
0X
Arrow
Fade
FlipArrow
Arrow
Draw
FlipArrow
Star
Fade
FlipStar
Star
Draw
FlipStar
OpenCursor
Mouse
OpenCursor
Pointer
DW
Display
Width
DH
Display
Height
CL
DW
OpenDisplay
DW
DIV
DW
DIV
DH
FocusViewer
Viewers
This
CurFnt
Fonts
Default
CurCol
Display
white
CurOff
ActCnt
CurTask
NewTask
GC
Install
CurTask
Modules
Load
System
Mod
Mod
NIL
Loop
END
Oberon
MODULE
ORB
NW
in
Oberon
IMPORT
Files
ORS
Definition
of
data
types
Object
and
Type
which
together
form
the
data
structure
called
symbol
table
Contains
procedures
for
creation
of
Objects
and
for
search
NewObj
this
thisimport
thisfield
and
OpenScope
CloseScope
Handling
of
import
and
export
i
e
reading
and
writing
of
symbol
files
is
done
by
procedures
Import
and
Export
This
module
contains
the
list
of
standard
identifiers
with
which
the
symbol
table
universe
and
that
of
the
pseudo
module
SYSTEM
are
initialized
CONST
versionkey
maxTypTab
class
values
Head
Const
Var
Par
Fld
Typ
SProc
SFunc
Mod
form
values
Byte
Bool
Char
Int
Real
Set
Pointer
NilTyp
NoTyp
Proc
String
Array
Record
TYPE
Object
POINTER
TO
ObjDesc
Module
POINTER
TO
ModDesc
Type
POINTER
TO
TypeDesc
ObjDesc
RECORD
class
exno
BYTE
expo
rdo
BOOLEAN
exported
read
only
lev
INTEGER
next
dsc
Object
type
Type
name
ORS
Ident
val
LONGINT
END
ModDesc
RECORD
ObjDesc
orgname
ORS
Ident
END
TypeDesc
RECORD
form
ref
mno
INTEGER
ref
is
only
used
for
import
export
nofpar
INTEGER
for
procedures
extension
level
for
records
len
LONGINT
for
arrays
len
open
array
for
records
adr
of
descriptor
dsc
typobj
Object
base
Type
for
arrays
records
pointers
size
LONGINT
in
bytes
always
multiple
of
except
for
Byte
Bool
and
Char
END
Object
classes
and
the
meaning
of
val
class
val
Var
address
Par
address
Const
value
Fld
offset
Typ
type
descriptor
TD
address
SProc
inline
code
number
SFunc
inline
code
number
Mod
key
Type
forms
and
the
meaning
of
dsc
and
base
form
dsc
base
Pointer
type
of
dereferenced
object
Proc
params
result
type
Array
type
of
elements
Record
fields
extension
VAR
topScope
universe
system
Object
byteType
boolType
charType
Type
intType
realType
setType
nilType
noType
strType
Type
nofmod
Ref
INTEGER
typtab
ARRAY
maxTypTab
OF
Type
PROCEDURE
NewObj
VAR
obj
Object
id
ORS
Ident
class
INTEGER
insert
new
Object
with
name
id
VAR
new
x
Object
BEGIN
x
topScope
WHILE
x
next
NIL
x
next
name
id
DO
x
x
next
END
IF
x
next
NIL
THEN
NEW
new
new
name
id
new
class
class
new
next
NIL
new
rdo
FALSE
new
dsc
NIL
x
next
new
obj
new
ELSE
obj
x
next
ORS
Mark
mult
def
END
END
NewObj
PROCEDURE
thisObj
Object
VAR
s
x
Object
BEGIN
s
topScope
REPEAT
x
s
next
WHILE
x
NIL
x
name
ORS
id
DO
x
x
next
END
s
s
dsc
UNTIL
x
NIL
OR
s
NIL
RETURN
x
END
thisObj
PROCEDURE
thisimport
mod
Object
Object
VAR
obj
Object
BEGIN
IF
mod
rdo
THEN
IF
mod
name
0X
THEN
obj
mod
dsc
WHILE
obj
NIL
obj
name
ORS
id
DO
obj
obj
next
END
ELSE
obj
NIL
END
ELSE
obj
NIL
END
RETURN
obj
END
thisimport
PROCEDURE
thisfield
rec
Type
Object
VAR
fld
Object
BEGIN
fld
rec
dsc
WHILE
fld
NIL
fld
name
ORS
id
DO
fld
fld
next
END
RETURN
fld
END
thisfield
PROCEDURE
OpenScope
VAR
s
Object
BEGIN
NEW
s
s
class
Head
s
dsc
topScope
s
next
NIL
topScope
s
END
OpenScope
PROCEDURE
CloseScope
BEGIN
topScope
topScope
dsc
END
CloseScope
Import
PROCEDURE
MakeFileName
VAR
FName
ORS
Ident
name
ext
ARRAY
OF
CHAR
VAR
i
j
INTEGER
BEGIN
i
j
assume
name
suffix
less
than
characters
WHILE
i
ORS
IdLen
name
i
0X
DO
FName
i
name
i
INC
i
END
REPEAT
FName
i
ext
j
INC
i
INC
j
UNTIL
ext
j
0X
FName
i
0X
END
MakeFileName
PROCEDURE
ThisModule
name
orgname
ORS
Ident
non
BOOLEAN
key
LONGINT
Object
VAR
mod
Module
obj
obj1
Object
BEGIN
obj1
topScope
obj
obj1
next
search
for
module
WHILE
obj
NIL
obj
name
name
DO
obj1
obj
obj
obj1
next
END
IF
obj
NIL
THEN
insert
new
module
NEW
mod
mod
class
Mod
mod
rdo
FALSE
mod
name
name
mod
orgname
orgname
mod
val
key
mod
lev
nofmod
INC
nofmod
mod
type
noType
mod
dsc
NIL
mod
next
NIL
obj1
next
mod
obj
mod
ELSE
module
already
present
IF
non
THEN
ORS
Mark
invalid
import
order
END
END
RETURN
obj
END
ThisModule
PROCEDURE
Read
VAR
R
Files
Rider
VAR
x
INTEGER
VAR
b
BYTE
BEGIN
Files
ReadByte
R
b
IF
b
80H
THEN
x
b
ELSE
x
b
100H
END
END
Read
PROCEDURE
InType
VAR
R
Files
Rider
thismod
Object
VAR
T
Type
VAR
key
LONGINT
ref
class
form
np
readonly
INTEGER
fld
par
obj
mod
Object
t
Type
name
modname
ORS
Ident
BEGIN
Read
R
ref
IF
ref
THEN
T
typtab
ref
already
read
ELSE
NEW
t
T
t
typtab
ref
t
t
mno
thismod
lev
Read
R
form
t
form
form
IF
form
Pointer
THEN
InType
R
thismod
t
base
t
size
ELSIF
form
Array
THEN
InType
R
thismod
t
base
Files
ReadNum
R
t
len
Files
ReadNum
R
t
size
ELSIF
form
Record
THEN
InType
R
thismod
t
base
IF
t
base
form
NoTyp
THEN
t
base
NIL
obj
NIL
ELSE
obj
t
base
dsc
END
Files
ReadNum
R
t
len
TD
adr
exno
Files
ReadNum
R
t
nofpar
ext
level
Files
ReadNum
R
t
size
Read
R
class
WHILE
class
DO
fields
NEW
fld
fld
class
class
Files
ReadString
R
fld
name
IF
fld
name
0X
THEN
fld
expo
TRUE
InType
R
thismod
fld
type
ELSE
fld
expo
FALSE
fld
type
nilType
END
Files
ReadNum
R
fld
val
fld
next
obj
obj
fld
Read
R
class
END
t
dsc
obj
ELSIF
form
Proc
THEN
InType
R
thismod
t
base
obj
NIL
np
Read
R
class
WHILE
class
DO
parameters
NEW
par
par
class
class
Read
R
readonly
par
rdo
readonly
InType
R
thismod
par
type
par
next
obj
obj
par
INC
np
Read
R
class
END
t
dsc
obj
t
nofpar
np
t
size
END
Files
ReadString
R
modname
IF
modname
0X
THEN
re
import
Files
ReadInt
R
key
Files
ReadString
R
name
mod
ThisModule
modname
modname
FALSE
key
obj
mod
dsc
search
type
WHILE
obj
NIL
obj
name
name
DO
obj
obj
next
END
IF
obj
NIL
THEN
T
obj
type
type
object
found
in
object
list
of
mod
ELSE
insert
new
type
object
in
object
list
of
mod
NEW
obj
obj
name
name
obj
class
Typ
obj
next
mod
dsc
mod
dsc
obj
obj
type
t
t
mno
mod
lev
t
typobj
obj
T
t
END
typtab
ref
T
END
END
END
InType
PROCEDURE
Import
VAR
modid
modid1
ORS
Ident
VAR
key
LONGINT
class
k
INTEGER
obj
Object
t
Type
thismod
Object
modname
fname
ORS
Ident
F
Files
File
R
Files
Rider
BEGIN
IF
modid1
SYSTEM
THEN
thismod
ThisModule
modid
modid1
TRUE
key
DEC
nofmod
thismod
lev
thismod
dsc
system
thismod
rdo
TRUE
ELSE
MakeFileName
fname
modid1
smb
F
Files
Old
fname
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadInt
R
key
Files
ReadInt
R
key
Files
ReadString
R
modname
thismod
ThisModule
modid
modid1
TRUE
key
thismod
rdo
TRUE
Read
R
class
version
key
IF
class
versionkey
THEN
ORS
Mark
wrong
version
END
Read
R
class
WHILE
class
DO
NEW
obj
obj
class
class
Files
ReadString
R
obj
name
InType
R
thismod
obj
type
obj
lev
thismod
lev
IF
class
Typ
THEN
t
obj
type
t
typobj
obj
Read
R
k
fixup
bases
of
previously
declared
pointer
types
WHILE
k
DO
typtab
k
base
t
Read
R
k
END
ELSE
IF
class
Const
THEN
IF
obj
type
form
Real
THEN
Files
ReadInt
R
obj
val
ELSE
Files
ReadNum
R
obj
val
END
ELSIF
class
Var
THEN
Files
ReadNum
R
obj
val
obj
rdo
TRUE
END
END
obj
next
thismod
dsc
thismod
dsc
obj
Read
R
class
END
ELSE
ORS
Mark
import
not
available
END
END
END
Import
Export
PROCEDURE
Write
VAR
R
Files
Rider
x
INTEGER
BEGIN
Files
WriteByte
R
x
END
Write
PROCEDURE
OutType
VAR
R
Files
Rider
t
Type
VAR
obj
mod
fld
Object
PROCEDURE
OutPar
VAR
R
Files
Rider
par
Object
n
INTEGER
VAR
cl
INTEGER
BEGIN
IF
n
THEN
OutPar
R
par
next
n
cl
par
class
Write
R
cl
IF
par
rdo
THEN
Write
R
ELSE
Write
R
END
OutType
R
par
type
END
END
OutPar
PROCEDURE
FindHiddenPointers
VAR
R
Files
Rider
typ
Type
offset
LONGINT
VAR
fld
Object
i
n
LONGINT
BEGIN
IF
typ
form
Pointer
OR
typ
form
NilTyp
THEN
Write
R
Fld
Write
R
Files
WriteNum
R
offset
ELSIF
typ
form
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindHiddenPointers
R
fld
type
fld
val
offset
fld
fld
next
END
ELSIF
typ
form
Array
THEN
i
n
typ
len
WHILE
i
n
DO
FindHiddenPointers
R
typ
base
typ
base
size
i
offset
INC
i
END
END
END
FindHiddenPointers
BEGIN
IF
t
ref
THEN
type
was
already
output
Write
R
t
ref
ELSE
obj
t
typobj
IF
obj
NIL
THEN
Write
R
Ref
t
ref
Ref
INC
Ref
ELSE
anonymous
Write
R
END
Write
R
t
form
IF
t
form
Pointer
THEN
OutType
R
t
base
ELSIF
t
form
Array
THEN
OutType
R
t
base
Files
WriteNum
R
t
len
Files
WriteNum
R
t
size
ELSIF
t
form
Record
THEN
IF
t
base
NIL
THEN
OutType
R
t
base
ELSE
OutType
R
noType
END
IF
obj
NIL
THEN
Files
WriteNum
R
obj
exno
ELSE
Write
R
END
Files
WriteNum
R
t
nofpar
Files
WriteNum
R
t
size
fld
t
dsc
WHILE
fld
NIL
DO
fields
IF
fld
expo
THEN
Write
R
Fld
Files
WriteString
R
fld
name
OutType
R
fld
type
Files
WriteNum
R
fld
val
offset
ELSE
FindHiddenPointers
R
fld
type
fld
val
END
fld
fld
next
END
Write
R
ELSIF
t
form
Proc
THEN
OutType
R
t
base
OutPar
R
t
dsc
t
nofpar
Write
R
END
IF
t
mno
obj
NIL
THEN
re
export
output
name
mod
topScope
next
WHILE
mod
NIL
mod
lev
t
mno
DO
mod
mod
next
END
IF
mod
NIL
THEN
Files
WriteString
R
mod
Module
orgname
Files
WriteInt
R
mod
val
Files
WriteString
R
obj
name
ELSE
ORS
Mark
re
export
not
found
Write
R
END
ELSE
Write
R
END
END
END
OutType
PROCEDURE
Export
VAR
modid
ORS
Ident
VAR
newSF
BOOLEAN
VAR
key
LONGINT
VAR
x
sum
oldkey
LONGINT
obj
obj0
Object
filename
ORS
Ident
F
F1
Files
File
R
R1
Files
Rider
BEGIN
Ref
Record
MakeFileName
filename
modid
smb
F
Files
New
filename
Files
Set
R
F
Files
WriteInt
R
placeholder
Files
WriteInt
R
placeholder
for
key
to
be
inserted
at
the
end
Files
WriteString
R
modid
Write
R
versionkey
obj
topScope
next
WHILE
obj
NIL
DO
IF
obj
expo
THEN
Write
R
obj
class
Files
WriteString
R
obj
name
OutType
R
obj
type
IF
obj
class
Typ
THEN
IF
obj
type
form
Record
THEN
obj0
topScope
next
check
whether
this
is
base
of
previously
declared
pointer
types
WHILE
obj0
obj
DO
IF
obj0
type
form
Pointer
obj0
type
base
obj
type
obj0
type
ref
THEN
Write
R
obj0
type
ref
END
obj0
obj0
next
END
END
Write
R
ELSIF
obj
class
Const
THEN
IF
obj
type
form
Proc
THEN
Files
WriteNum
R
obj
exno
ELSIF
obj
type
form
Real
THEN
Files
WriteInt
R
obj
val
ELSE
Files
WriteNum
R
obj
val
END
ELSIF
obj
class
Var
THEN
Files
WriteNum
R
obj
exno
END
END
obj
obj
next
END
REPEAT
Write
R
UNTIL
Files
Length
F
MOD
FOR
Ref
Record
TO
maxTypTab
DO
typtab
Ref
NIL
END
Files
Set
R
F
sum
Files
ReadInt
R
x
compute
key
checksum
WHILE
R
eof
DO
sum
sum
x
Files
ReadInt
R
x
END
F1
Files
Old
filename
sum
is
new
key
IF
F1
NIL
THEN
Files
Set
R1
F1
Files
ReadInt
R1
oldkey
ELSE
oldkey
sum
END
IF
sum
oldkey
THEN
IF
newSF
OR
F1
NIL
THEN
key
sum
newSF
TRUE
Files
Set
R
F
Files
WriteInt
R
sum
Files
Register
F
insert
checksum
ELSE
ORS
Mark
new
symbol
file
inhibited
END
ELSE
newSF
FALSE
key
sum
END
END
Export
PROCEDURE
Init
BEGIN
topScope
universe
nofmod
END
Init
PROCEDURE
type
ref
form
INTEGER
size
LONGINT
Type
VAR
tp
Type
BEGIN
NEW
tp
tp
form
form
tp
size
size
tp
ref
ref
tp
base
NIL
typtab
ref
tp
RETURN
tp
END
type
PROCEDURE
enter
name
ARRAY
OF
CHAR
cl
INTEGER
type
Type
n
LONGINT
VAR
obj
Object
BEGIN
NEW
obj
obj
name
name
obj
class
cl
obj
type
type
obj
val
n
obj
dsc
NIL
IF
cl
Typ
THEN
type
typobj
obj
END
obj
next
system
system
obj
END
enter
BEGIN
byteType
type
Byte
Int
boolType
type
Bool
Bool
charType
type
Char
Char
intType
type
Int
Int
realType
type
Real
Real
setType
type
Set
Set
nilType
type
NilTyp
NilTyp
noType
type
NoTyp
NoTyp
strType
type
String
String
initialize
universe
with
data
types
and
in
line
procedures
LONGINT
is
synonym
to
INTEGER
LONGREAL
to
REAL
LED
ADC
SBC
LDPSR
LDREG
REG
COND
are
not
in
language
definition
system
NIL
n
procno
nofpar
enter
UML
SFunc
intType
functions
enter
SBC
SFunc
intType
enter
ADC
SFunc
intType
enter
ROR
SFunc
intType
enter
ASR
SFunc
intType
enter
LSL
SFunc
intType
enter
LEN
SFunc
intType
enter
CHR
SFunc
charType
enter
ORD
SFunc
intType
enter
FLT
SFunc
realType
enter
FLOOR
SFunc
intType
enter
ODD
SFunc
boolType
enter
ABS
SFunc
intType
enter
LED
SProc
noType
procedures
enter
UNPK
SProc
noType
enter
PACK
SProc
noType
enter
NEW
SProc
noType
enter
ASSERT
SProc
noType
enter
EXCL
SProc
noType
enter
INCL
SProc
noType
enter
DEC
SProc
noType
enter
INC
SProc
noType
enter
SET
Typ
setType
types
enter
BOOLEAN
Typ
boolType
enter
BYTE
Typ
byteType
enter
CHAR
Typ
charType
enter
LONGREAL
Typ
realType
enter
REAL
Typ
realType
enter
LONGINT
Typ
intType
enter
INTEGER
Typ
intType
topScope
NIL
OpenScope
topScope
next
system
universe
topScope
system
NIL
initialize
unsafe
pseudo
module
SYSTEM
enter
H
SFunc
intType
functions
enter
COND
SFunc
boolType
enter
SIZE
SFunc
intType
enter
ADR
SFunc
intType
enter
VAL
SFunc
intType
enter
REG
SFunc
intType
enter
BIT
SFunc
boolType
enter
LDREG
SProc
noType
procedures
enter
LDPSR
SProc
noType
enter
COPY
SProc
noType
enter
PUT
SProc
noType
enter
GET
SProc
noType
END
ORB
MODULE
ORG
N
Wirth
Oberon
compiler
code
generator
for
RISC
IMPORT
SYSTEM
Files
ORS
ORB
Code
generator
for
Oberon
compiler
for
RISC
processor
Procedural
interface
to
Parser
OSAP
result
in
array
code
Procedure
Close
writes
code
files
CONST
WordSize
StkOrg0
VarOrg0
for
RISC
only
MT
SP
LNK
dedicated
registers
maxCode
maxStrx
maxTD
C24
1000000H
Reg
RegI
Cond
internal
item
modes
frequently
used
opcodes
U
2000H
V
1000H
Mov
Lsl
Asr
Ror
And
Ann
Ior
Xor
Add
Sub
Cmp
Mul
Div
Fad
Fsb
Fml
Fdv
Ldr
Str
BR
BLR
BC
BL
MI
PL
EQ
NE
LT
GE
LE
GT
TYPE
Item
RECORD
mode
INTEGER
type
ORB
Type
a
b
r
LONGINT
rdo
BOOLEAN
read
only
END
Item
forms
and
meaning
of
fields
mode
r
a
b
Const
value
proc
adr
immediate
value
Var
base
off
direct
adr
Par
off0
off1
indirect
adr
Reg
regno
RegI
regno
off
Cond
cond
Fchain
Tchain
VAR
pc
varsize
LONGINT
program
counter
data
index
tdx
strx
LONGINT
entry
LONGINT
main
entry
point
RH
LONGINT
available
registers
R
R
H
frame
LONGINT
frame
offset
changed
in
SaveRegs
and
RestoreRegs
fixorgP
fixorgD
fixorgT
LONGINT
origins
of
lists
of
locations
to
be
fixed
up
by
loader
check
BOOLEAN
emit
run
time
checks
version
INTEGER
RISC
RISC
relmap
ARRAY
OF
INTEGER
condition
codes
for
relations
code
ARRAY
maxCode
OF
LONGINT
data
ARRAY
maxTD
OF
LONGINT
type
descriptors
str
ARRAY
maxStrx
OF
CHAR
instruction
assemblers
according
to
formats
PROCEDURE
Put0
op
a
b
c
LONGINT
BEGIN
emit
format
instruction
code
pc
a
10H
b
10H
op
10000H
c
INC
pc
END
Put0
PROCEDURE
Put1
op
a
b
im
LONGINT
BEGIN
emit
format
instruction
10000H
im
10000H
IF
im
THEN
INC
op
V
END
code
pc
a
40H
10H
b
10H
op
10000H
im
MOD
10000H
INC
pc
END
Put1
PROCEDURE
Put1a
op
a
b
im
LONGINT
BEGIN
same
as
Put1
but
with
range
test
10000H
im
10000H
IF
im
10000H
im
0FFFFH
THEN
Put1
op
a
b
im
ELSE
Put1
Mov
U
RH
im
DIV
10000H
IF
im
MOD
10000H
THEN
Put1
Ior
RH
RH
im
MOD
10000H
END
Put0
op
a
b
RH
END
END
Put1a
PROCEDURE
Put2
op
a
b
off
LONGINT
BEGIN
emit
load
store
instruction
code
pc
op
10H
a
10H
b
100000H
off
MOD
100000H
INC
pc
END
Put2
PROCEDURE
Put3
op
cond
off
LONGINT
BEGIN
emit
branch
instruction
code
pc
op
10H
cond
1000000H
off
MOD
1000000H
INC
pc
END
Put3
PROCEDURE
incR
BEGIN
IF
RH
MT
THEN
INC
RH
ELSE
ORS
Mark
register
stack
overflow
END
END
incR
PROCEDURE
CheckRegs
BEGIN
IF
RH
THEN
ORS
Mark
Reg
Stack
RH
END
IF
pc
maxCode
THEN
ORS
Mark
program
too
long
END
IF
frame
THEN
ORS
Mark
frame
error
frame
END
END
CheckRegs
PROCEDURE
SetCC
VAR
x
Item
n
LONGINT
BEGIN
x
mode
Cond
x
a
x
b
x
r
n
END
SetCC
PROCEDURE
Trap
cond
num
LONGINT
BEGIN
Put3
BLR
cond
ORS
Pos
100H
num
10H
MT
END
Trap
handling
of
forward
reference
fixups
of
branch
addresses
and
constant
tables
PROCEDURE
negated
cond
LONGINT
LONGINT
BEGIN
IF
cond
THEN
cond
cond
ELSE
cond
cond
END
RETURN
cond
END
negated
PROCEDURE
fix
at
with
LONGINT
BEGIN
code
at
code
at
DIV
C24
C24
with
MOD
C24
END
fix
PROCEDURE
FixOne
at
LONGINT
BEGIN
fix
at
pc
at
END
FixOne
PROCEDURE
FixLink
L
LONGINT
VAR
L1
LONGINT
BEGIN
WHILE
L
DO
L1
code
L
MOD
40000H
fix
L
pc
L
L
L1
END
END
FixLink
PROCEDURE
FixLinkWith
L0
dst
LONGINT
VAR
L1
LONGINT
BEGIN
WHILE
L0
DO
L1
code
L0
MOD
C24
code
L0
code
L0
DIV
C24
C24
dst
L0
MOD
C24
L0
L1
END
END
FixLinkWith
PROCEDURE
merged
L0
L1
LONGINT
LONGINT
VAR
L2
L3
LONGINT
BEGIN
IF
L0
THEN
L3
L0
REPEAT
L2
L3
L3
code
L2
MOD
40000H
UNTIL
L3
code
L2
code
L2
L1
L1
L0
END
RETURN
L1
END
merged
loading
of
operands
and
addresses
into
registers
PROCEDURE
GetSB
base
LONGINT
BEGIN
IF
version
THEN
Put1
Mov
RH
VarOrg0
ELSE
Put2
Ldr
RH
base
pc
fixorgD
fixorgD
pc
END
END
GetSB
PROCEDURE
NilCheck
BEGIN
IF
check
THEN
Trap
EQ
END
END
NilCheck
PROCEDURE
load
VAR
x
Item
VAR
op
LONGINT
BEGIN
IF
x
type
size
THEN
op
Ldr
ELSE
op
Ldr
END
IF
x
mode
Reg
THEN
IF
x
mode
ORB
Const
THEN
IF
x
type
form
ORB
Proc
THEN
IF
x
r
THEN
ORS
Mark
not
allowed
ELSIF
x
r
THEN
Put3
BL
Put1a
Sub
RH
LNK
pc
x
a
ELSE
GetSB
x
r
Put1
Add
RH
RH
x
a
100H
mark
as
progbase
relative
END
ELSIF
x
a
0FFFFH
x
a
10000H
THEN
Put1
Mov
RH
x
a
ELSE
Put1
Mov
U
RH
x
a
DIV
10000H
MOD
10000H
IF
x
a
MOD
10000H
THEN
Put1
Ior
RH
RH
x
a
MOD
10000H
END
END
x
r
RH
incR
ELSIF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
op
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put2
op
RH
RH
x
a
END
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
op
RH
RH
x
b
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
Put2
op
x
r
x
r
x
a
ELSIF
x
mode
Cond
THEN
Put3
BC
negated
x
r
FixLink
x
b
Put1
Mov
RH
Put3
BC
FixLink
x
a
Put1
Mov
RH
x
r
RH
incR
END
x
mode
Reg
END
END
load
PROCEDURE
loadAdr
VAR
x
Item
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put1a
Add
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put1a
Add
RH
RH
x
a
END
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
IF
x
b
THEN
Put1a
Add
RH
RH
x
b
END
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
IF
x
a
THEN
Put1a
Add
x
r
x
r
x
a
END
ELSE
ORS
Mark
address
error
END
x
mode
Reg
END
loadAdr
PROCEDURE
loadCond
VAR
x
Item
BEGIN
IF
x
type
form
ORB
Bool
THEN
IF
x
mode
ORB
Const
THEN
x
r
x
a
ELSE
load
x
IF
code
pc
DIV
40000000H
THEN
Put1
Cmp
x
r
x
r
END
x
r
NE
DEC
RH
END
x
mode
Cond
x
a
x
b
ELSE
ORS
Mark
not
Boolean
END
END
loadCond
PROCEDURE
loadTypTagAdr
T
ORB
Type
VAR
x
Item
BEGIN
x
mode
ORB
Var
x
a
T
len
x
r
T
mno
loadAdr
x
END
loadTypTagAdr
PROCEDURE
loadStringAdr
VAR
x
Item
BEGIN
GetSB
Put1a
Add
RH
RH
varsize
x
a
x
mode
Reg
x
r
RH
incR
END
loadStringAdr
Items
Conversion
from
constants
or
from
Objects
on
the
Heap
to
Items
on
the
Stack
PROCEDURE
MakeConstItem
VAR
x
Item
typ
ORB
Type
val
LONGINT
BEGIN
x
mode
ORB
Const
x
type
typ
x
a
val
END
MakeConstItem
PROCEDURE
MakeRealItem
VAR
x
Item
val
REAL
BEGIN
x
mode
ORB
Const
x
type
ORB
realType
x
a
SYSTEM
VAL
LONGINT
val
END
MakeRealItem
PROCEDURE
MakeStringItem
VAR
x
Item
len
LONGINT
copies
string
from
ORS
buffer
to
ORG
string
array
VAR
i
LONGINT
BEGIN
x
mode
ORB
Const
x
type
ORB
strType
x
a
strx
x
b
len
i
IF
strx
len
maxStrx
THEN
WHILE
len
DO
str
strx
ORS
str
i
INC
strx
INC
i
DEC
len
END
WHILE
strx
MOD
DO
str
strx
0X
INC
strx
END
ELSE
ORS
Mark
too
many
strings
END
END
MakeStringItem
PROCEDURE
MakeItem
VAR
x
Item
y
ORB
Object
curlev
LONGINT
BEGIN
x
mode
y
class
x
type
y
type
x
a
y
val
x
rdo
y
rdo
IF
y
class
ORB
Par
THEN
x
b
ELSIF
y
class
ORB
Const
y
type
form
ORB
String
THEN
x
b
y
lev
len
ELSE
x
r
y
lev
END
IF
y
lev
y
lev
curlev
y
class
ORB
Const
THEN
ORS
Mark
not
accessible
END
END
MakeItem
Code
generation
for
Selectors
Variables
Constants
PROCEDURE
Field
VAR
x
Item
y
ORB
Object
x
x
y
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
x
a
x
a
y
val
ELSE
loadAdr
x
x
mode
RegI
x
a
y
val
END
ELSIF
x
mode
RegI
THEN
x
a
x
a
y
val
ELSIF
x
mode
ORB
Par
THEN
x
b
x
b
y
val
END
END
Field
PROCEDURE
Index
VAR
x
y
Item
x
x
y
VAR
s
lim
LONGINT
BEGIN
s
x
type
base
size
lim
x
type
len
IF
y
mode
ORB
Const
lim
THEN
IF
y
a
OR
y
a
lim
THEN
ORS
Mark
bad
index
END
IF
x
mode
IN
ORB
Var
RegI
THEN
x
a
y
a
s
x
a
ELSIF
x
mode
ORB
Par
THEN
x
b
y
a
s
x
b
END
ELSE
load
y
IF
check
THEN
check
array
bounds
IF
lim
THEN
Put1a
Cmp
RH
y
r
lim
ELSE
open
array
IF
x
mode
IN
ORB
Var
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put0
Cmp
RH
y
r
RH
ELSE
ORS
Mark
error
in
Index
END
END
Trap
BCC
END
IF
s
THEN
Put1
Lsl
y
r
y
r
ELSIF
s
THEN
Put1a
Mul
y
r
y
r
s
END
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
Put0
Add
y
r
SP
y
r
INC
x
a
frame
ELSE
GetSB
x
r
IF
x
r
THEN
Put0
Add
y
r
RH
y
r
ELSE
Put1a
Add
RH
RH
x
a
Put0
Add
y
r
RH
y
r
x
a
END
END
x
r
y
r
x
mode
RegI
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put0
Add
y
r
RH
y
r
x
mode
RegI
x
r
y
r
x
a
x
b
ELSIF
x
mode
RegI
THEN
Put0
Add
x
r
x
r
y
r
DEC
RH
END
END
END
Index
PROCEDURE
DeRef
VAR
x
Item
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
Ldr
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put2
Ldr
RH
RH
x
a
END
NilCheck
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
Ldr
RH
RH
x
b
NilCheck
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
Put2
Ldr
x
r
x
r
x
a
NilCheck
ELSIF
x
mode
Reg
THEN
ORS
Mark
bad
mode
in
DeRef
END
x
mode
RegI
x
a
x
b
END
DeRef
PROCEDURE
Q
T
ORB
Type
VAR
dcw
LONGINT
BEGIN
one
entry
of
type
descriptor
extension
table
IF
T
base
NIL
THEN
Q
T
base
dcw
data
dcw
T
mno
1000H
T
len
1000H
dcw
fixorgT
fixorgT
dcw
INC
dcw
END
END
Q
PROCEDURE
FindPtrFlds
typ
ORB
Type
off
LONGINT
VAR
dcw
LONGINT
VAR
fld
ORB
Object
i
s
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
data
dcw
off
INC
dcw
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindPtrFlds
fld
type
fld
val
off
dcw
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
s
typ
base
size
FOR
i
TO
typ
len
DO
FindPtrFlds
typ
base
i
s
off
dcw
END
END
END
FindPtrFlds
PROCEDURE
BuildTD
T
ORB
Type
VAR
dc
LONGINT
VAR
dcw
k
s
LONGINT
dcw
word
address
BEGIN
dcw
dc
DIV
s
T
size
convert
size
for
heap
allocation
IF
s
THEN
s
ELSIF
s
THEN
s
ELSIF
s
THEN
s
ELSE
s
s
DIV
END
T
len
dc
data
dcw
s
INC
dcw
len
used
as
address
k
T
nofpar
extension
level
IF
k
THEN
ORS
Mark
ext
level
too
large
ELSE
Q
T
dcw
WHILE
k
DO
data
dcw
INC
dcw
INC
k
END
END
FindPtrFlds
T
dcw
data
dcw
INC
dcw
tdx
dcw
dc
dcw
IF
tdx
maxTD
THEN
ORS
Mark
too
many
record
types
tdx
END
END
BuildTD
PROCEDURE
TypeTest
VAR
x
Item
T
ORB
Type
varpar
isguard
BOOLEAN
VAR
pc0
LONGINT
BEGIN
fetch
tag
into
RH
IF
varpar
THEN
Put2
Ldr
RH
SP
x
a
frame
ELSE
load
x
pc0
pc
Put3
BC
EQ
NIL
belongs
to
every
pointer
type
Put2
Ldr
RH
x
r
END
Put2
Ldr
RH
RH
T
nofpar
incR
loadTypTagAdr
T
tag
of
T
Put0
Cmp
RH
RH
RH
DEC
RH
IF
varpar
THEN
fix
pc0
pc
pc0
END
IF
isguard
THEN
IF
check
THEN
Trap
NE
END
ELSE
SetCC
x
EQ
IF
varpar
THEN
DEC
RH
END
END
END
TypeTest
Code
generation
for
Boolean
operators
PROCEDURE
Not
VAR
x
Item
x
x
VAR
t
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
x
r
negated
x
r
t
x
a
x
a
x
b
x
b
t
END
Not
PROCEDURE
And1
VAR
x
Item
x
x
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
x
a
x
a
pc
FixLink
x
b
x
b
END
And1
PROCEDURE
And2
VAR
x
y
Item
BEGIN
IF
y
mode
Cond
THEN
loadCond
y
END
x
a
merged
y
a
x
a
x
b
y
b
x
r
y
r
END
And2
PROCEDURE
Or1
VAR
x
Item
x
x
OR
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
x
r
x
b
x
b
pc
FixLink
x
a
x
a
END
Or1
PROCEDURE
Or2
VAR
x
y
Item
BEGIN
IF
y
mode
Cond
THEN
loadCond
y
END
x
a
y
a
x
b
merged
y
b
x
b
x
r
y
r
END
Or2
Code
generation
for
arithmetic
operators
PROCEDURE
Neg
VAR
x
Item
x
x
BEGIN
IF
x
type
form
ORB
Int
THEN
IF
x
mode
ORB
Const
THEN
x
a
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Sub
x
r
RH
x
r
END
ELSIF
x
type
form
ORB
Real
THEN
IF
x
mode
ORB
Const
THEN
x
a
x
a
7FFFFFFFH
ELSE
load
x
Put1
Mov
RH
Put0
Fsb
x
r
RH
x
r
END
ELSE
form
Set
IF
x
mode
ORB
Const
THEN
x
a
x
a
ELSE
load
x
Put1
Xor
x
r
x
r
END
END
END
Neg
PROCEDURE
AddOp
op
LONGINT
VAR
x
y
Item
x
x
y
BEGIN
IF
op
ORS
plus
THEN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
y
a
THEN
Put1a
Add
x
r
x
r
y
a
END
ELSE
load
x
load
y
Put0
Add
RH
x
r
y
r
DEC
RH
x
r
RH
END
ELSE
op
ORS
minus
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
y
a
THEN
Put1a
Sub
x
r
x
r
y
a
END
ELSE
load
x
load
y
Put0
Sub
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
END
AddOp
PROCEDURE
log2
m
LONGINT
VAR
e
LONGINT
LONGINT
BEGIN
e
WHILE
ODD
m
DO
m
m
DIV
INC
e
END
RETURN
m
END
log2
PROCEDURE
MulOp
VAR
x
y
Item
x
x
y
VAR
e
LONGINT
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
Put1
Lsl
x
r
x
r
e
ELSIF
y
mode
ORB
Const
THEN
load
x
Put1a
Mul
x
r
x
r
y
a
ELSIF
x
mode
ORB
Const
x
a
log2
x
a
e
THEN
load
y
Put1
Lsl
y
r
y
r
e
x
mode
Reg
x
r
y
r
ELSIF
x
mode
ORB
Const
THEN
load
y
Put1a
Mul
y
r
y
r
x
a
x
mode
Reg
x
r
y
r
ELSE
load
x
load
y
Put0
Mul
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
MulOp
PROCEDURE
DivOp
op
LONGINT
VAR
x
y
Item
x
x
op
y
VAR
e
LONGINT
BEGIN
IF
op
ORS
div
THEN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
y
a
THEN
x
a
x
a
DIV
y
a
ELSE
ORS
Mark
bad
divisor
END
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
Put1
Asr
x
r
x
r
e
ELSIF
y
mode
ORB
Const
THEN
IF
y
a
THEN
load
x
Put1a
Div
x
r
x
r
y
a
ELSE
ORS
Mark
bad
divisor
END
ELSE
load
y
IF
check
THEN
Trap
LE
END
load
x
Put0
Div
RH
x
r
y
r
DEC
RH
x
r
RH
END
ELSE
op
ORS
mod
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
y
a
THEN
x
a
x
a
MOD
y
a
ELSE
ORS
Mark
bad
modulus
END
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
IF
e
THEN
Put1
And
x
r
x
r
y
a
ELSE
Put1
Lsl
x
r
x
r
e
Put1
Ror
x
r
x
r
e
END
ELSIF
y
mode
ORB
Const
THEN
IF
y
a
THEN
load
x
Put1a
Div
x
r
x
r
y
a
Put0
Mov
U
x
r
ELSE
ORS
Mark
bad
modulus
END
ELSE
load
y
IF
check
THEN
Trap
LE
END
load
x
Put0
Div
RH
x
r
y
r
Put0
Mov
U
RH
DEC
RH
x
r
RH
END
END
END
DivOp
Code
generation
for
REAL
operators
PROCEDURE
RealOp
op
INTEGER
VAR
x
y
Item
x
x
op
y
BEGIN
load
x
load
y
IF
op
ORS
plus
THEN
Put0
Fad
RH
x
r
y
r
ELSIF
op
ORS
minus
THEN
Put0
Fsb
RH
x
r
y
r
ELSIF
op
ORS
times
THEN
Put0
Fml
RH
x
r
y
r
ELSIF
op
ORS
rdiv
THEN
Put0
Fdv
RH
x
r
y
r
END
DEC
RH
x
r
RH
END
RealOp
Code
generation
for
set
operators
PROCEDURE
Singleton
VAR
x
Item
x
x
BEGIN
IF
x
mode
ORB
Const
THEN
x
a
LSL
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Lsl
x
r
RH
x
r
END
END
Singleton
PROCEDURE
Set
VAR
x
y
Item
x
x
y
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
x
a
y
a
THEN
x
a
LSL
y
a
LSL
x
a
ELSE
x
a
END
ELSE
IF
x
mode
ORB
Const
x
a
THEN
x
a
LSL
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Lsl
x
r
RH
x
r
END
IF
y
mode
ORB
Const
y
a
THEN
Put1
Mov
RH
LSL
y
a
y
mode
Reg
y
r
RH
incR
ELSE
load
y
Put1
Mov
RH
Put0
Lsl
y
r
RH
y
r
END
IF
x
mode
ORB
Const
THEN
IF
x
a
THEN
Put1
Xor
y
r
y
r
Put1a
And
RH
y
r
x
a
END
x
mode
Reg
x
r
RH
ELSE
DEC
RH
Put0
Ann
RH
x
r
y
r
END
END
END
Set
PROCEDURE
In
VAR
x
y
Item
x
x
IN
y
BEGIN
load
y
IF
x
mode
ORB
Const
THEN
Put1
Ror
y
r
y
r
x
a
MOD
20H
DEC
RH
ELSE
load
x
Put1
Add
x
r
x
r
Put0
Ror
y
r
y
r
x
r
DEC
RH
END
SetCC
x
MI
END
In
PROCEDURE
SetOp
op
LONGINT
VAR
x
y
Item
x
x
op
y
VAR
xset
yset
SET
x
type
form
Set
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
xset
SYSTEM
VAL
SET
x
a
yset
SYSTEM
VAL
SET
y
a
IF
op
ORS
plus
THEN
xset
xset
yset
ELSIF
op
ORS
minus
THEN
xset
xset
yset
ELSIF
op
ORS
times
THEN
xset
xset
yset
ELSIF
op
ORS
rdiv
THEN
xset
xset
yset
END
x
a
SYSTEM
VAL
LONGINT
xset
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
op
ORS
plus
THEN
Put1a
Ior
x
r
x
r
y
a
ELSIF
op
ORS
minus
THEN
Put1a
Ann
x
r
x
r
y
a
ELSIF
op
ORS
times
THEN
Put1a
And
x
r
x
r
y
a
ELSIF
op
ORS
rdiv
THEN
Put1a
Xor
x
r
x
r
y
a
END
ELSE
load
x
load
y
IF
op
ORS
plus
THEN
Put0
Ior
RH
x
r
y
r
ELSIF
op
ORS
minus
THEN
Put0
Ann
RH
x
r
y
r
ELSIF
op
ORS
times
THEN
Put0
And
RH
x
r
y
r
ELSIF
op
ORS
rdiv
THEN
Put0
Xor
RH
x
r
y
r
END
DEC
RH
x
r
RH
END
END
SetOp
Code
generation
for
relations
PROCEDURE
IntRelation
op
INTEGER
VAR
x
y
Item
x
x
y
BEGIN
IF
y
mode
ORB
Const
y
type
form
ORB
Proc
THEN
load
x
IF
y
a
OR
op
IN
ORS
eql
ORS
neq
OR
code
pc
DIV
40000000H
THEN
Put1a
Cmp
x
r
x
r
y
a
END
DEC
RH
ELSE
IF
x
mode
Cond
OR
y
mode
Cond
THEN
ORS
Mark
not
implemented
END
load
x
load
y
Put0
Cmp
x
r
x
r
y
r
DEC
RH
END
SetCC
x
relmap
op
ORS
eql
END
IntRelation
PROCEDURE
RealRelation
op
INTEGER
VAR
x
y
Item
x
x
y
BEGIN
load
x
IF
y
mode
ORB
Const
y
a
THEN
DEC
RH
ELSE
load
y
Put0
Fsb
x
r
x
r
y
r
DEC
RH
END
SetCC
x
relmap
op
ORS
eql
END
RealRelation
PROCEDURE
StringRelation
op
INTEGER
VAR
x
y
Item
x
x
y
x
y
are
char
arrays
or
strings
BEGIN
IF
x
type
form
ORB
String
THEN
loadStringAdr
x
ELSE
loadAdr
x
END
IF
y
type
form
ORB
String
THEN
loadStringAdr
y
ELSE
loadAdr
y
END
Put2
Ldr
RH
x
r
Put1
Add
x
r
x
r
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put0
Cmp
RH
RH
RH
Put3
BC
NE
Put1
Cmp
RH
RH
Put3
BC
NE
DEC
RH
SetCC
x
relmap
op
ORS
eql
END
StringRelation
Code
generation
of
Assignments
PROCEDURE
StrToChar
VAR
x
Item
BEGIN
x
type
ORB
charType
DEC
strx
x
a
ORD
str
x
a
END
StrToChar
PROCEDURE
Store
VAR
x
y
Item
x
y
VAR
op
LONGINT
BEGIN
load
y
IF
x
type
size
THEN
op
Str
ELSE
op
Str
END
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
op
y
r
SP
x
a
frame
ELSE
GetSB
x
r
Put2
op
y
r
RH
x
a
END
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
op
y
r
RH
x
b
ELSIF
x
mode
RegI
THEN
Put2
op
y
r
x
r
x
a
DEC
RH
ELSE
ORS
Mark
bad
mode
in
Store
END
DEC
RH
END
Store
PROCEDURE
StoreStruct
VAR
x
y
Item
x
y
frame
VAR
s
pc0
LONGINT
BEGIN
IF
y
type
size
THEN
loadAdr
x
loadAdr
y
IF
x
type
form
ORB
Array
x
type
len
THEN
IF
y
type
len
THEN
IF
x
type
size
y
type
size
THEN
Put1a
Mov
RH
y
type
size
DIV
ELSE
ORS
Mark
different
length
size
not
implemented
END
ELSE
y
open
array
Put2
Ldr
RH
SP
y
a
s
y
type
base
size
element
size
pc0
pc
Put3
BC
EQ
IF
s
THEN
Put1
Add
RH
RH
Put1
Asr
RH
RH
ELSIF
s
THEN
Put1a
Mul
RH
RH
s
DIV
END
IF
check
THEN
Put1a
Mov
RH
x
type
size
DIV
Put0
Cmp
RH
RH
RH
Trap
GT
END
fix
pc0
pc
pc0
END
ELSIF
x
type
form
ORB
Record
THEN
Put1a
Mov
RH
x
type
size
DIV
ELSE
ORS
Mark
inadmissible
assignment
END
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put2
Str
RH
x
r
Put1
Add
x
r
x
r
Put1
Sub
RH
RH
Put3
BC
NE
END
RH
END
StoreStruct
PROCEDURE
CopyString
VAR
x
y
Item
x
y
VAR
len
LONGINT
BEGIN
loadAdr
x
len
x
type
len
IF
len
THEN
IF
len
y
b
THEN
ORS
Mark
string
too
long
END
ELSIF
check
THEN
Put2
Ldr
RH
SP
x
a
open
array
len
frame
Put1
Cmp
RH
RH
y
b
Trap
LT
END
loadStringAdr
y
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put2
Str
RH
x
r
Put1
Add
x
r
x
r
Put1
Asr
RH
RH
Put3
BC
NE
RH
END
CopyString
Code
generation
for
parameters
PROCEDURE
OpenArrayParam
VAR
x
Item
BEGIN
loadAdr
x
IF
x
type
len
THEN
Put1a
Mov
RH
x
type
len
ELSE
Put2
Ldr
RH
SP
x
a
frame
END
incR
END
OpenArrayParam
PROCEDURE
VarParam
VAR
x
Item
ftype
ORB
Type
VAR
xmd
INTEGER
BEGIN
xmd
x
mode
loadAdr
x
IF
ftype
form
ORB
Array
ftype
len
THEN
open
array
IF
x
type
len
THEN
Put1a
Mov
RH
x
type
len
ELSE
Put2
Ldr
RH
SP
x
a
frame
END
incR
ELSIF
ftype
form
ORB
Record
THEN
IF
xmd
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
incR
ELSE
loadTypTagAdr
x
type
END
END
END
VarParam
PROCEDURE
ValueParam
VAR
x
Item
BEGIN
load
x
END
ValueParam
PROCEDURE
StringParam
VAR
x
Item
BEGIN
loadStringAdr
x
Put1
Mov
RH
x
b
incR
len
END
StringParam
For
Statements
PROCEDURE
For0
VAR
x
y
Item
BEGIN
load
y
END
For0
PROCEDURE
For1
VAR
x
y
z
w
Item
VAR
L
LONGINT
BEGIN
IF
z
mode
ORB
Const
THEN
Put1a
Cmp
RH
y
r
z
a
ELSE
load
z
Put0
Cmp
RH
y
r
z
r
DEC
RH
END
L
pc
IF
w
a
THEN
Put3
BC
GT
ELSIF
w
a
THEN
Put3
BC
LT
ELSE
ORS
Mark
zero
increment
Put3
BC
MI
END
Store
x
y
END
For1
PROCEDURE
For2
VAR
x
y
w
Item
BEGIN
load
x
DEC
RH
Put1a
Add
x
r
x
r
w
a
END
For2
Branches
procedure
calls
procedure
prolog
and
epilog
PROCEDURE
Here
LONGINT
BEGIN
RETURN
pc
END
Here
PROCEDURE
FJump
VAR
L
LONGINT
BEGIN
Put3
BC
L
L
pc
END
FJump
PROCEDURE
CFJump
VAR
x
Item
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
x
a
FixLink
x
b
x
a
pc
END
CFJump
PROCEDURE
BJump
L
LONGINT
BEGIN
Put3
BC
L
pc
END
BJump
PROCEDURE
CBJump
VAR
x
Item
L
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
L
pc
FixLink
x
b
FixLinkWith
x
a
L
END
CBJump
PROCEDURE
Fixup
VAR
x
Item
BEGIN
FixLink
x
a
END
Fixup
PROCEDURE
SaveRegs
r
LONGINT
R
r
VAR
r0
LONGINT
BEGIN
r
r0
Put1
Sub
SP
SP
r
INC
frame
r
REPEAT
Put2
Str
r0
SP
r
r0
INC
r0
UNTIL
r0
r
END
SaveRegs
PROCEDURE
RestoreRegs
r
LONGINT
R
r
VAR
r0
LONGINT
BEGIN
r
r0
r
REPEAT
DEC
r0
Put2
Ldr
r0
SP
r
r0
UNTIL
r0
Put1
Add
SP
SP
r
DEC
frame
r
END
RestoreRegs
PROCEDURE
PrepCall
VAR
x
Item
VAR
r
LONGINT
BEGIN
x
type
form
ORB
Proc
IF
x
mode
ORB
Par
THEN
load
x
END
r
RH
IF
RH
THEN
SaveRegs
RH
RH
END
END
PrepCall
PROCEDURE
Call
VAR
x
Item
r
LONGINT
BEGIN
x
type
form
ORB
Proc
IF
x
mode
ORB
Const
THEN
IF
x
r
THEN
Put3
BL
x
a
DIV
pc
ELSE
imported
IF
pc
fixorgP
1000H
THEN
Put3
BL
x
r
100H
x
a
1000H
pc
fixorgP
fixorgP
pc
ELSE
ORS
Mark
fixup
impossible
END
END
ELSE
IF
x
mode
ORB
Par
THEN
load
x
DEC
RH
ELSE
Put2
Ldr
RH
SP
Put1
Add
SP
SP
DEC
r
DEC
frame
END
IF
check
THEN
Trap
EQ
END
Put3
BLR
RH
END
IF
x
type
base
form
ORB
NoTyp
THEN
procedure
RH
ELSE
function
IF
r
THEN
Put0
Mov
r
RestoreRegs
r
END
x
mode
Reg
x
r
r
RH
r
END
END
Call
PROCEDURE
Enter
parblksize
locblksize
LONGINT
int
BOOLEAN
VAR
a
r
LONGINT
BEGIN
frame
IF
int
THEN
procedure
prolog
IF
locblksize
10000H
THEN
ORS
Mark
too
many
locals
END
a
r
Put1
Sub
SP
SP
locblksize
Put2
Str
LNK
SP
WHILE
a
parblksize
DO
Put2
Str
r
SP
a
INC
r
INC
a
END
ELSE
interrupt
procedure
Put1
Sub
SP
SP
locblksize
Put2
Str
SP
Put2
Str
SP
Put2
Str
SP
R0
R1
R2
saved
on
stack
END
END
Enter
PROCEDURE
Return
form
INTEGER
VAR
x
Item
size
LONGINT
int
BOOLEAN
BEGIN
IF
form
ORB
NoTyp
THEN
load
x
END
IF
int
THEN
procedure
epilog
Put2
Ldr
LNK
SP
Put1
Add
SP
SP
size
Put3
BR
LNK
ELSE
interrupt
return
restore
R2
R1
R0
Put2
Ldr
SP
Put2
Ldr
SP
Put2
Ldr
SP
Put1
Add
SP
SP
size
Put3
BR
10H
RTI
END
RH
END
Return
In
line
code
procedures
PROCEDURE
Increment
upordown
LONGINT
VAR
x
y
Item
VAR
op
zr
v
LONGINT
BEGIN
frame
IF
upordown
THEN
op
Add
ELSE
op
Sub
END
IF
x
type
ORB
byteType
THEN
v
ELSE
v
END
IF
y
type
form
ORB
NoTyp
THEN
y
mode
ORB
Const
y
a
END
IF
x
mode
ORB
Var
x
r
THEN
zr
RH
Put2
Ldr
v
zr
SP
x
a
incR
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
y
a
ELSE
load
y
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
v
zr
SP
x
a
DEC
RH
ELSE
loadAdr
x
zr
RH
Put2
Ldr
v
RH
x
r
incR
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
y
a
ELSE
load
y
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
v
zr
x
r
DEC
RH
END
END
Increment
PROCEDURE
Include
inorex
LONGINT
VAR
x
y
Item
VAR
op
zr
LONGINT
BEGIN
loadAdr
x
zr
RH
Put2
Ldr
RH
x
r
incR
IF
inorex
THEN
op
Ior
ELSE
op
Ann
END
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
LSL
y
a
ELSE
load
y
Put1
Mov
RH
Put0
Lsl
y
r
RH
y
r
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
zr
x
r
DEC
RH
END
Include
PROCEDURE
Assert
VAR
x
Item
VAR
cond
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
IF
x
a
THEN
cond
negated
x
r
ELSE
Put3
BC
x
r
x
b
FixLink
x
a
x
b
pc
cond
END
Trap
cond
FixLink
x
b
END
Assert
PROCEDURE
New
VAR
x
Item
BEGIN
loadAdr
x
loadTypTagAdr
x
type
base
Trap
RH
END
New
PROCEDURE
Pack
VAR
x
y
Item
VAR
z
Item
BEGIN
z
x
load
x
load
y
Put1
Lsl
y
r
y
r
Put0
Add
x
r
x
r
y
r
DEC
RH
Store
z
x
END
Pack
PROCEDURE
Unpk
VAR
x
y
Item
VAR
z
e0
Item
BEGIN
z
x
load
x
e0
mode
Reg
e0
r
RH
e0
type
ORB
intType
Put1
Asr
RH
x
r
Put1
Sub
RH
RH
Store
y
e0
incR
Put1
Lsl
RH
RH
Put0
Sub
x
r
x
r
RH
Store
z
x
END
Unpk
PROCEDURE
Led
VAR
x
Item
BEGIN
load
x
Put1
Mov
RH
Put2
Str
x
r
RH
DEC
RH
END
Led
PROCEDURE
Get
VAR
x
y
Item
BEGIN
load
x
x
type
y
type
x
mode
RegI
x
a
Store
y
x
END
Get
PROCEDURE
Put
VAR
x
y
Item
BEGIN
load
x
x
type
y
type
x
mode
RegI
x
a
Store
x
y
END
Put
PROCEDURE
Copy
VAR
x
y
z
Item
BEGIN
load
x
load
y
IF
z
mode
ORB
Const
THEN
IF
z
a
THEN
load
z
ELSE
ORS
Mark
bad
count
END
ELSE
load
z
IF
check
THEN
Trap
LT
END
Put3
BC
EQ
END
Put2
Ldr
RH
x
r
Put1
Add
x
r
x
r
Put2
Str
RH
y
r
Put1
Add
y
r
y
r
Put1
Sub
z
r
z
r
Put3
BC
NE
DEC
RH
END
Copy
PROCEDURE
LDPSR
VAR
x
Item
BEGIN
x
mode
Const
Put3
x
a
20H
END
LDPSR
PROCEDURE
LDREG
VAR
x
y
Item
BEGIN
IF
y
mode
ORB
Const
THEN
Put1a
Mov
x
a
y
a
ELSE
load
y
Put0
Mov
x
a
y
r
DEC
RH
END
END
LDREG
In
line
code
functions
PROCEDURE
Abs
VAR
x
Item
BEGIN
IF
x
mode
ORB
Const
THEN
x
a
ABS
x
a
ELSE
load
x
IF
x
type
form
ORB
Real
THEN
Put1
Lsl
x
r
x
r
Put1
Ror
x
r
x
r
ELSE
Put1
Cmp
x
r
x
r
Put3
BC
GE
Put1
Mov
RH
Put0
Sub
x
r
RH
x
r
END
END
END
Abs
PROCEDURE
Odd
VAR
x
Item
BEGIN
load
x
Put1
And
x
r
x
r
SetCC
x
NE
DEC
RH
END
Odd
PROCEDURE
Floor
VAR
x
Item
BEGIN
load
x
Put1
Mov
U
RH
4B00H
Put0
Fad
V
x
r
x
r
RH
END
Floor
PROCEDURE
Float
VAR
x
Item
BEGIN
load
x
Put1
Mov
U
RH
4B00H
Put0
Fad
U
x
r
x
r
RH
END
Float
PROCEDURE
Ord
VAR
x
Item
BEGIN
IF
x
mode
IN
ORB
Var
ORB
Par
RegI
Cond
THEN
load
x
END
END
Ord
PROCEDURE
Len
VAR
x
Item
BEGIN
IF
x
type
len
THEN
IF
x
mode
RegI
THEN
DEC
RH
END
x
mode
ORB
Const
x
a
x
type
len
ELSE
open
array
Put2
Ldr
RH
SP
x
a
frame
x
mode
Reg
x
r
RH
incR
END
END
Len
PROCEDURE
Shift
fct
LONGINT
VAR
x
y
Item
VAR
op
LONGINT
BEGIN
load
x
IF
fct
THEN
op
Lsl
ELSIF
fct
THEN
op
Asr
ELSE
op
Ror
END
IF
y
mode
ORB
Const
THEN
Put1
op
x
r
x
r
y
a
MOD
20H
ELSE
load
y
Put0
op
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
Shift
PROCEDURE
ADC
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Add
2000H
x
r
x
r
y
r
DEC
RH
END
ADC
PROCEDURE
SBC
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Sub
2000H
x
r
x
r
y
r
DEC
RH
END
SBC
PROCEDURE
UML
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Mul
2000H
x
r
x
r
y
r
DEC
RH
END
UML
PROCEDURE
Bit
VAR
x
y
Item
BEGIN
load
x
Put2
Ldr
x
r
x
r
IF
y
mode
ORB
Const
THEN
Put1
Ror
x
r
x
r
y
a
DEC
RH
ELSE
load
y
Put1
Add
y
r
y
r
Put0
Ror
x
r
x
r
y
r
DEC
RH
END
SetCC
x
MI
END
Bit
PROCEDURE
Register
VAR
x
Item
BEGIN
x
mode
Const
Put0
Mov
RH
x
a
MOD
10H
x
mode
Reg
x
r
RH
incR
END
Register
PROCEDURE
H
VAR
x
Item
BEGIN
x
mode
Const
Put0
Mov
U
x
a
MOD
V
RH
x
mode
Reg
x
r
RH
incR
END
H
PROCEDURE
Adr
VAR
x
Item
BEGIN
IF
x
mode
IN
ORB
Var
ORB
Par
RegI
THEN
loadAdr
x
ELSIF
x
mode
ORB
Const
x
type
form
ORB
Proc
THEN
load
x
ELSIF
x
mode
ORB
Const
x
type
form
ORB
String
THEN
loadStringAdr
x
ELSE
ORS
Mark
not
addressable
END
END
Adr
PROCEDURE
Condition
VAR
x
Item
BEGIN
x
mode
Const
SetCC
x
x
a
END
Condition
PROCEDURE
Open
v
INTEGER
BEGIN
pc
tdx
strx
RH
fixorgP
fixorgD
fixorgT
check
v
version
v
IF
v
THEN
pc
REPEAT
code
pc
INC
pc
UNTIL
pc
END
END
Open
PROCEDURE
SetDataSize
dc
LONGINT
BEGIN
varsize
dc
END
SetDataSize
PROCEDURE
Header
BEGIN
entry
pc
IF
version
THEN
code
0E7000000H
pc
Put1a
Mov
SP
StkOrg0
RISC
ELSE
Put1
Sub
SP
SP
Put2
Str
LNK
SP
END
END
Header
PROCEDURE
NofPtrs
typ
ORB
Type
LONGINT
VAR
fld
ORB
Object
n
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
n
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
n
WHILE
fld
NIL
DO
n
NofPtrs
fld
type
n
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
n
NofPtrs
typ
base
typ
len
ELSE
n
END
RETURN
n
END
NofPtrs
PROCEDURE
FindPtrs
VAR
R
Files
Rider
typ
ORB
Type
adr
LONGINT
VAR
fld
ORB
Object
i
s
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
Files
WriteInt
R
adr
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindPtrs
R
fld
type
fld
val
adr
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
s
typ
base
size
FOR
i
TO
typ
len
DO
FindPtrs
R
typ
base
i
s
adr
END
END
END
FindPtrs
PROCEDURE
Close
VAR
modid
ORS
Ident
key
nofent
LONGINT
VAR
obj
ORB
Object
i
comsize
nofimps
nofptrs
size
LONGINT
name
ORS
Ident
F
Files
File
R
Files
Rider
BEGIN
exit
code
IF
version
THEN
Put1
Mov
Put3
BR
RISC
ELSE
Put2
Ldr
LNK
SP
Put1
Add
SP
SP
Put3
BR
LNK
END
obj
ORB
topScope
next
nofimps
comsize
nofptrs
WHILE
obj
NIL
DO
IF
obj
class
ORB
Mod
obj
dsc
ORB
system
THEN
INC
nofimps
count
imports
ELSIF
obj
exno
obj
class
ORB
Const
obj
type
form
ORB
Proc
obj
type
nofpar
obj
type
base
ORB
noType
THEN
i
count
commands
WHILE
obj
name
i
0X
DO
INC
i
END
i
i
DIV
INC
comsize
i
ELSIF
obj
class
ORB
Var
THEN
INC
nofptrs
NofPtrs
obj
type
count
pointers
END
obj
obj
next
END
size
varsize
strx
comsize
pc
nofimps
nofent
nofptrs
varsize
includes
type
descriptors
ORB
MakeFileName
name
modid
rsc
write
code
file
F
Files
New
name
Files
Set
R
F
Files
WriteString
R
modid
Files
WriteInt
R
key
Files
Write
R
CHR
version
Files
WriteInt
R
size
obj
ORB
topScope
next
WHILE
obj
NIL
obj
class
ORB
Mod
DO
imports
IF
obj
dsc
ORB
system
THEN
Files
WriteString
R
obj
ORB
Module
orgname
Files
WriteInt
R
obj
val
END
obj
obj
next
END
Files
Write
R
0X
Files
WriteInt
R
tdx
i
WHILE
i
tdx
DO
Files
WriteInt
R
data
i
INC
i
END
type
descriptors
Files
WriteInt
R
varsize
tdx
data
Files
WriteInt
R
strx
FOR
i
TO
strx
DO
Files
Write
R
str
i
END
strings
Files
WriteInt
R
pc
code
len
FOR
i
TO
pc
DO
Files
WriteInt
R
code
i
END
program
obj
ORB
topScope
next
WHILE
obj
NIL
DO
commands
IF
obj
exno
obj
class
ORB
Const
obj
type
form
ORB
Proc
obj
type
nofpar
obj
type
base
ORB
noType
THEN
Files
WriteString
R
obj
name
Files
WriteInt
R
obj
val
END
obj
obj
next
END
Files
Write
R
0X
Files
WriteInt
R
nofent
Files
WriteInt
R
entry
obj
ORB
topScope
next
WHILE
obj
NIL
DO
entries
IF
obj
exno
THEN
IF
obj
class
ORB
Const
obj
type
form
ORB
Proc
OR
obj
class
ORB
Var
THEN
Files
WriteInt
R
obj
val
ELSIF
obj
class
ORB
Typ
THEN
IF
obj
type
form
ORB
Record
THEN
Files
WriteInt
R
obj
type
len
MOD
10000H
ELSIF
obj
type
form
ORB
Pointer
obj
type
base
typobj
NIL
OR
obj
type
base
typobj
exno
THEN
Files
WriteInt
R
obj
type
base
len
MOD
10000H
END
END
END
obj
obj
next
END
obj
ORB
topScope
next
WHILE
obj
NIL
DO
pointer
variables
IF
obj
class
ORB
Var
THEN
FindPtrs
R
obj
type
obj
val
END
obj
obj
next
END
Files
WriteInt
R
Files
WriteInt
R
fixorgP
Files
WriteInt
R
fixorgD
Files
WriteInt
R
fixorgT
Files
WriteInt
R
entry
Files
Write
R
O
Files
Register
F
END
Close
BEGIN
relmap
relmap
relmap
relmap
relmap
relmap
END
ORG
MODULE
ORP
N
Wirth
Oberon
compiler
for
RISC
in
Oberon
IMPORT
Texts
Oberon
ORS
ORB
ORG
Author
Niklaus
Wirth
Parser
of
Oberon
RISC
compiler
Uses
Scanner
ORS
to
obtain
symbols
tokens
ORB
for
definition
of
data
structures
and
for
handling
import
and
export
and
ORG
to
produce
binary
code
ORP
performs
type
checking
and
data
allocation
Parser
is
target
independent
except
for
part
of
the
handling
of
allocations
TYPE
PtrBase
POINTER
TO
PtrBaseDesc
PtrBaseDesc
RECORD
list
of
names
of
pointer
base
types
name
ORS
Ident
type
ORB
Type
next
PtrBase
END
VAR
sym
INTEGER
last
symbol
read
dc
LONGINT
data
counter
level
exno
version
INTEGER
newSF
BOOLEAN
option
flag
expression
PROCEDURE
VAR
x
ORG
Item
to
avoid
forward
reference
Type
PROCEDURE
VAR
type
ORB
Type
FormalType
PROCEDURE
VAR
typ
ORB
Type
dim
INTEGER
modid
ORS
Ident
pbsList
PtrBase
list
of
names
of
pointer
base
types
dummy
ORB
Object
W
Texts
Writer
PROCEDURE
Check
s
INTEGER
msg
ARRAY
OF
CHAR
BEGIN
IF
sym
s
THEN
ORS
Get
sym
ELSE
ORS
Mark
msg
END
END
Check
PROCEDURE
qualident
VAR
obj
ORB
Object
BEGIN
obj
ORB
thisObj
ORS
Get
sym
IF
obj
NIL
THEN
ORS
Mark
undef
obj
dummy
END
IF
sym
ORS
period
obj
class
ORB
Mod
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
obj
ORB
thisimport
obj
ORS
Get
sym
IF
obj
NIL
THEN
ORS
Mark
undef
obj
dummy
END
ELSE
ORS
Mark
identifier
expected
obj
dummy
END
END
END
qualident
PROCEDURE
CheckBool
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Bool
THEN
ORS
Mark
not
Boolean
x
type
ORB
boolType
END
END
CheckBool
PROCEDURE
CheckInt
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Int
THEN
ORS
Mark
not
Integer
x
type
ORB
intType
END
END
CheckInt
PROCEDURE
CheckReal
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Real
THEN
ORS
Mark
not
Real
x
type
ORB
realType
END
END
CheckReal
PROCEDURE
CheckSet
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Set
THEN
ORS
Mark
not
Set
x
type
ORB
setType
END
END
CheckSet
PROCEDURE
CheckSetVal
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Int
THEN
ORS
Mark
not
Int
x
type
ORB
setType
ELSIF
x
mode
ORB
Const
THEN
IF
x
a
OR
x
a
THEN
ORS
Mark
invalid
set
END
END
END
CheckSetVal
PROCEDURE
CheckConst
VAR
x
ORG
Item
BEGIN
IF
x
mode
ORB
Const
THEN
ORS
Mark
not
a
constant
x
mode
ORB
Const
END
END
CheckConst
PROCEDURE
CheckReadOnly
VAR
x
ORG
Item
BEGIN
IF
x
rdo
THEN
ORS
Mark
read
only
END
END
CheckReadOnly
PROCEDURE
CheckExport
VAR
expo
BOOLEAN
BEGIN
IF
sym
ORS
times
THEN
expo
TRUE
ORS
Get
sym
IF
level
THEN
ORS
Mark
remove
asterisk
END
ELSE
expo
FALSE
END
END
CheckExport
PROCEDURE
IsExtension
t0
t1
ORB
Type
BOOLEAN
BEGIN
t1
is
an
extension
of
t0
RETURN
t0
t1
OR
t1
NIL
IsExtension
t0
t1
base
END
IsExtension
expressions
PROCEDURE
TypeTest
VAR
x
ORG
Item
T
ORB
Type
guard
BOOLEAN
VAR
xt
ORB
Type
BEGIN
xt
x
type
IF
T
form
xt
form
T
form
ORB
Pointer
OR
T
form
ORB
Record
x
mode
ORB
Par
THEN
WHILE
xt
T
xt
NIL
DO
xt
xt
base
END
IF
xt
T
THEN
xt
x
type
IF
xt
form
ORB
Pointer
THEN
IF
IsExtension
xt
base
T
base
THEN
ORG
TypeTest
x
T
base
FALSE
guard
x
type
T
ELSE
ORS
Mark
not
an
extension
END
ELSIF
xt
form
ORB
Record
x
mode
ORB
Par
THEN
IF
IsExtension
xt
T
THEN
ORG
TypeTest
x
T
TRUE
guard
x
type
T
ELSE
ORS
Mark
not
an
extension
END
ELSE
ORS
Mark
incompatible
types
END
ELSIF
guard
THEN
ORG
MakeConstItem
x
ORB
boolType
END
ELSE
ORS
Mark
type
mismatch
END
IF
guard
THEN
x
type
ORB
boolType
END
END
TypeTest
PROCEDURE
selector
VAR
x
ORG
Item
VAR
y
ORG
Item
obj
ORB
Object
BEGIN
WHILE
sym
ORS
lbrak
OR
sym
ORS
period
OR
sym
ORS
arrow
OR
sym
ORS
lparen
x
type
form
IN
ORB
Record
ORB
Pointer
DO
IF
sym
ORS
lbrak
THEN
REPEAT
ORS
Get
sym
expression
y
IF
x
type
form
ORB
Array
THEN
CheckInt
y
ORG
Index
x
y
x
type
x
type
base
ELSE
ORS
Mark
not
an
array
END
UNTIL
sym
ORS
comma
Check
ORS
rbrak
no
ELSIF
sym
ORS
period
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
IF
x
type
form
ORB
Pointer
THEN
ORG
DeRef
x
x
type
x
type
base
END
IF
x
type
form
ORB
Record
THEN
obj
ORB
thisfield
x
type
ORS
Get
sym
IF
obj
NIL
THEN
ORG
Field
x
obj
x
type
obj
type
ELSE
ORS
Mark
undef
END
ELSE
ORS
Mark
not
a
record
END
ELSE
ORS
Mark
ident
END
ELSIF
sym
ORS
arrow
THEN
ORS
Get
sym
IF
x
type
form
ORB
Pointer
THEN
ORG
DeRef
x
x
type
x
type
base
ELSE
ORS
Mark
not
a
pointer
END
ELSIF
sym
ORS
lparen
x
type
form
IN
ORB
Record
ORB
Pointer
THEN
type
guard
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
TypeTest
x
obj
type
TRUE
ELSE
ORS
Mark
guard
type
expected
END
ELSE
ORS
Mark
not
an
identifier
END
Check
ORS
rparen
missing
END
END
END
selector
PROCEDURE
EqualSignatures
t0
t1
ORB
Type
BOOLEAN
VAR
p0
p1
ORB
Object
com
BOOLEAN
BEGIN
com
TRUE
IF
t0
base
t1
base
t0
nofpar
t1
nofpar
THEN
p0
t0
dsc
p1
t1
dsc
WHILE
p0
NIL
DO
IF
p0
class
p1
class
p0
rdo
p1
rdo
p0
type
p1
type
OR
p0
type
form
ORB
Array
p1
type
form
ORB
Array
p0
type
len
p1
type
len
p0
type
base
p1
type
base
OR
p0
type
form
ORB
Proc
p1
type
form
ORB
Proc
EqualSignatures
p0
type
p1
type
THEN
p0
p0
next
p1
p1
next
ELSE
p0
NIL
com
FALSE
END
END
ELSE
com
FALSE
END
RETURN
com
END
EqualSignatures
PROCEDURE
CompTypes
t0
t1
ORB
Type
varpar
BOOLEAN
BOOLEAN
BEGIN
check
for
assignment
compatibility
RETURN
t0
t1
openarray
assignment
disallowed
in
ORG
OR
t0
form
ORB
Array
t1
form
ORB
Array
t0
base
t1
base
t0
len
t1
len
OR
t0
form
ORB
Record
t1
form
ORB
Record
IsExtension
t0
t1
OR
varpar
t0
form
ORB
Pointer
t1
form
ORB
Pointer
IsExtension
t0
base
t1
base
OR
t0
form
ORB
Proc
t1
form
ORB
Proc
EqualSignatures
t0
t1
OR
t0
form
IN
ORB
Pointer
ORB
Proc
t1
form
ORB
NilTyp
END
CompTypes
PROCEDURE
Parameter
par
ORB
Object
VAR
x
ORG
Item
varpar
BOOLEAN
BEGIN
expression
x
IF
par
NIL
THEN
varpar
par
class
ORB
Par
IF
CompTypes
par
type
x
type
varpar
THEN
IF
varpar
THEN
ORG
ValueParam
x
ELSE
par
class
Par
IF
par
rdo
THEN
CheckReadOnly
x
END
ORG
VarParam
x
par
type
END
ELSIF
x
type
form
ORB
Array
par
type
form
ORB
Array
x
type
base
par
type
base
par
type
len
THEN
IF
par
rdo
THEN
CheckReadOnly
x
END
ORG
OpenArrayParam
x
ELSIF
x
type
form
ORB
String
varpar
par
rdo
par
type
form
ORB
Array
par
type
base
form
ORB
Char
par
type
len
THEN
ORG
StringParam
x
ELSIF
varpar
par
type
form
ORB
Int
x
type
form
ORB
Int
THEN
ORG
ValueParam
x
BYTE
ELSIF
x
type
form
ORB
String
x
b
par
class
ORB
Var
par
type
form
ORB
Char
THEN
ORG
StrToChar
x
ORG
ValueParam
x
ELSIF
par
type
form
ORB
Array
par
type
base
ORB
byteType
par
type
len
par
type
size
x
type
size
THEN
ORG
VarParam
x
par
type
ELSE
ORS
Mark
incompatible
parameters
END
END
END
Parameter
PROCEDURE
ParamList
VAR
x
ORG
Item
VAR
n
INTEGER
par
ORB
Object
BEGIN
par
x
type
dsc
n
IF
sym
ORS
rparen
THEN
Parameter
par
n
WHILE
sym
ORS
comma
DO
Check
sym
comma
IF
par
NIL
THEN
par
par
next
END
INC
n
Parameter
par
END
Check
ORS
rparen
missing
ELSE
ORS
Get
sym
END
IF
n
x
type
nofpar
THEN
ORS
Mark
too
few
params
ELSIF
n
x
type
nofpar
THEN
ORS
Mark
too
many
params
END
END
ParamList
PROCEDURE
StandFunc
VAR
x
ORG
Item
fct
LONGINT
restyp
ORB
Type
VAR
y
ORG
Item
n
npar
LONGINT
BEGIN
Check
ORS
lparen
no
npar
fct
MOD
fct
fct
DIV
expression
x
n
WHILE
sym
ORS
comma
DO
ORS
Get
sym
expression
y
INC
n
END
Check
ORS
rparen
no
IF
n
npar
THEN
IF
fct
THEN
ABS
IF
x
type
form
IN
ORB
Int
ORB
Real
THEN
ORG
Abs
x
restyp
x
type
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
ODD
CheckInt
x
ORG
Odd
x
ELSIF
fct
THEN
FLOOR
CheckReal
x
ORG
Floor
x
ELSIF
fct
THEN
FLT
CheckInt
x
ORG
Float
x
ELSIF
fct
THEN
ORD
IF
x
type
form
ORB
Proc
THEN
ORG
Ord
x
ELSIF
x
type
form
ORB
String
x
b
THEN
ORG
StrToChar
x
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
CHR
CheckInt
x
ORG
Ord
x
ELSIF
fct
THEN
LEN
IF
x
type
form
ORB
Array
THEN
ORG
Len
x
ELSE
ORS
Mark
not
an
array
END
ELSIF
fct
IN
THEN
LSL
ASR
ROR
CheckInt
y
IF
x
type
form
IN
ORB
Int
ORB
Set
THEN
ORG
Shift
fct
x
y
restyp
x
type
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
ADC
ORG
ADC
x
y
ELSIF
fct
THEN
SBC
ORG
SBC
x
y
ELSIF
fct
THEN
UML
ORG
UML
x
y
ELSIF
fct
THEN
BIT
CheckInt
x
CheckInt
y
ORG
Bit
x
y
ELSIF
fct
THEN
REG
CheckConst
x
CheckInt
x
ORG
Register
x
ELSIF
fct
THEN
VAL
IF
x
mode
ORB
Typ
x
type
size
y
type
size
THEN
restyp
x
type
x
y
ELSE
ORS
Mark
casting
not
allowed
END
ELSIF
fct
THEN
ADR
ORG
Adr
x
ELSIF
fct
THEN
SIZE
IF
x
mode
ORB
Typ
THEN
ORG
MakeConstItem
x
ORB
intType
x
type
size
ELSE
ORS
Mark
must
be
a
type
END
ELSIF
fct
THEN
COND
CheckConst
x
CheckInt
x
ORG
Condition
x
ELSIF
fct
THEN
H
CheckConst
x
CheckInt
x
ORG
H
x
END
x
type
restyp
ELSE
ORS
Mark
wrong
nof
params
END
END
StandFunc
PROCEDURE
element
VAR
x
ORG
Item
VAR
y
ORG
Item
BEGIN
expression
x
CheckSetVal
x
IF
sym
ORS
upto
THEN
ORS
Get
sym
expression
y
CheckSetVal
y
ORG
Set
x
y
ELSE
ORG
Singleton
x
END
x
type
ORB
setType
END
element
PROCEDURE
set
VAR
x
ORG
Item
VAR
y
ORG
Item
BEGIN
IF
sym
ORS
if
THEN
IF
sym
ORS
rbrace
THEN
ORS
Mark
missing
END
ORG
MakeConstItem
x
ORB
setType
empty
set
ELSE
element
x
WHILE
sym
ORS
rparen
OR
sym
ORS
rbrace
DO
IF
sym
ORS
comma
THEN
ORS
Get
sym
ELSIF
sym
ORS
rbrace
THEN
ORS
Mark
missing
comma
END
element
y
ORG
SetOp
ORS
plus
x
y
END
END
END
set
PROCEDURE
factor
VAR
x
ORG
Item
VAR
obj
ORB
Object
rx
LONGINT
BEGIN
sync
IF
sym
ORS
char
OR
sym
ORS
ident
THEN
ORS
Mark
expression
expected
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
char
sym
ORS
for
OR
sym
ORS
then
END
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
SFunc
THEN
StandFunc
x
obj
val
obj
type
ELSE
ORG
MakeItem
x
obj
level
selector
x
IF
sym
ORS
lparen
THEN
ORS
Get
sym
IF
x
type
form
ORB
Proc
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ParamList
x
ORG
Call
x
rx
x
type
x
type
base
ELSE
ORS
Mark
not
a
function
ParamList
x
END
END
END
ELSIF
sym
ORS
int
THEN
ORG
MakeConstItem
x
ORB
intType
ORS
ival
ORS
Get
sym
ELSIF
sym
ORS
real
THEN
ORG
MakeRealItem
x
ORS
rval
ORS
Get
sym
ELSIF
sym
ORS
char
THEN
ORG
MakeConstItem
x
ORB
charType
ORS
ival
ORS
Get
sym
ELSIF
sym
ORS
nil
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
nilType
ELSIF
sym
ORS
string
THEN
ORG
MakeStringItem
x
ORS
slen
ORS
Get
sym
ELSIF
sym
ORS
lparen
THEN
ORS
Get
sym
expression
x
Check
ORS
rparen
no
ELSIF
sym
ORS
lbrace
THEN
ORS
Get
sym
set
x
Check
ORS
rbrace
no
ELSIF
sym
ORS
not
THEN
ORS
Get
sym
factor
x
CheckBool
x
ORG
Not
x
ELSIF
sym
ORS
false
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
boolType
ELSIF
sym
ORS
true
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
boolType
ELSE
ORS
Mark
not
a
factor
ORG
MakeConstItem
x
ORB
intType
END
END
factor
PROCEDURE
term
VAR
x
ORG
Item
VAR
y
ORG
Item
op
f
INTEGER
BEGIN
factor
x
f
x
type
form
WHILE
sym
ORS
times
sym
ORS
and
DO
op
sym
ORS
Get
sym
IF
op
ORS
times
THEN
IF
f
ORB
Int
THEN
factor
y
CheckInt
y
ORG
MulOp
x
y
ELSIF
f
ORB
Real
THEN
factor
y
CheckReal
y
ORG
RealOp
op
x
y
ELSIF
f
ORB
Set
THEN
factor
y
CheckSet
y
ORG
SetOp
op
x
y
ELSE
ORS
Mark
bad
type
END
ELSIF
op
ORS
div
OR
op
ORS
mod
THEN
CheckInt
x
factor
y
CheckInt
y
ORG
DivOp
op
x
y
ELSIF
op
ORS
rdiv
THEN
IF
f
ORB
Real
THEN
factor
y
CheckReal
y
ORG
RealOp
op
x
y
ELSIF
f
ORB
Set
THEN
factor
y
CheckSet
y
ORG
SetOp
op
x
y
ELSE
ORS
Mark
bad
type
END
ELSE
op
and
CheckBool
x
ORG
And1
x
factor
y
CheckBool
y
ORG
And2
x
y
END
END
END
term
PROCEDURE
SimpleExpression
VAR
x
ORG
Item
VAR
y
ORG
Item
op
INTEGER
BEGIN
IF
sym
ORS
minus
THEN
ORS
Get
sym
term
x
IF
x
type
form
IN
ORB
Int
ORB
Real
ORB
Set
THEN
ORG
Neg
x
ELSE
CheckInt
x
END
ELSIF
sym
ORS
plus
THEN
ORS
Get
sym
term
x
ELSE
term
x
END
WHILE
sym
ORS
plus
sym
ORS
or
DO
op
sym
ORS
Get
sym
IF
op
ORS
or
THEN
ORG
Or1
x
CheckBool
x
term
y
CheckBool
y
ORG
Or2
x
y
ELSIF
x
type
form
ORB
Int
THEN
term
y
CheckInt
y
ORG
AddOp
op
x
y
ELSIF
x
type
form
ORB
Real
THEN
term
y
CheckReal
y
ORG
RealOp
op
x
y
ELSE
CheckSet
x
term
y
CheckSet
y
ORG
SetOp
op
x
y
END
END
END
SimpleExpression
PROCEDURE
expression0
VAR
x
ORG
Item
VAR
y
ORG
Item
obj
ORB
Object
rel
xf
yf
INTEGER
BEGIN
SimpleExpression
x
IF
sym
ORS
eql
sym
ORS
geq
THEN
rel
sym
ORS
Get
sym
SimpleExpression
y
xf
x
type
form
yf
y
type
form
IF
x
type
y
type
THEN
IF
xf
IN
ORB
Char
ORB
Int
THEN
ORG
IntRelation
rel
x
y
ELSIF
xf
ORB
Real
THEN
ORG
RealRelation
rel
x
y
ELSIF
xf
IN
ORB
Set
ORB
Pointer
ORB
Proc
ORB
NilTyp
ORB
Bool
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Array
x
type
base
form
ORB
Char
OR
xf
ORB
String
THEN
ORG
StringRelation
rel
x
y
ELSE
ORS
Mark
illegal
comparison
END
ELSIF
xf
IN
ORB
Pointer
ORB
Proc
yf
ORB
NilTyp
OR
yf
IN
ORB
Pointer
ORB
Proc
xf
ORB
NilTyp
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Pointer
yf
ORB
Pointer
IsExtension
x
type
base
y
type
base
OR
IsExtension
y
type
base
x
type
base
OR
xf
ORB
Proc
yf
ORB
Proc
EqualSignatures
x
type
y
type
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Array
x
type
base
form
ORB
Char
yf
ORB
String
OR
yf
ORB
Array
y
type
base
form
ORB
Char
OR
yf
ORB
Array
y
type
base
form
ORB
Char
xf
ORB
String
THEN
ORG
StringRelation
rel
x
y
ELSIF
xf
ORB
Char
yf
ORB
String
y
b
THEN
ORG
StrToChar
y
ORG
IntRelation
rel
x
y
ELSIF
yf
ORB
Char
xf
ORB
String
x
b
THEN
ORG
StrToChar
x
ORG
IntRelation
rel
x
y
ELSIF
xf
ORB
Int
yf
ORB
Int
THEN
ORG
IntRelation
rel
x
y
BYTE
ELSE
ORS
Mark
illegal
comparison
END
x
type
ORB
boolType
ELSIF
sym
ORS
in
THEN
ORS
Get
sym
CheckInt
x
SimpleExpression
y
CheckSet
y
ORG
In
x
y
x
type
ORB
boolType
ELSIF
sym
ORS
is
THEN
ORS
Get
sym
qualident
obj
TypeTest
x
obj
type
FALSE
x
type
ORB
boolType
END
END
expression0
statements
PROCEDURE
StandProc
pno
LONGINT
VAR
nap
npar
LONGINT
nof
actual
formal
parameters
x
y
z
ORG
Item
BEGIN
Check
ORS
lparen
no
npar
pno
MOD
pno
pno
DIV
expression
x
nap
IF
sym
ORS
comma
THEN
ORS
Get
sym
expression
y
nap
z
type
ORB
noType
WHILE
sym
ORS
comma
DO
ORS
Get
sym
expression
z
INC
nap
END
ELSE
y
type
ORB
noType
END
Check
ORS
rparen
no
IF
npar
nap
OR
pno
IN
THEN
IF
pno
IN
THEN
INC
DEC
CheckInt
x
CheckReadOnly
x
IF
y
type
ORB
noType
THEN
CheckInt
y
END
ORG
Increment
pno
x
y
ELSIF
pno
IN
THEN
INCL
EXCL
CheckSet
x
CheckReadOnly
x
CheckInt
y
ORG
Include
pno
x
y
ELSIF
pno
THEN
CheckBool
x
ORG
Assert
x
ELSIF
pno
THEN
NEW
CheckReadOnly
x
IF
x
type
form
ORB
Pointer
x
type
base
form
ORB
Record
THEN
ORG
New
x
ELSE
ORS
Mark
not
a
pointer
to
record
END
ELSIF
pno
THEN
CheckReal
x
CheckInt
y
CheckReadOnly
x
ORG
Pack
x
y
ELSIF
pno
THEN
CheckReal
x
CheckInt
y
CheckReadOnly
x
ORG
Unpk
x
y
ELSIF
pno
THEN
IF
x
type
form
ORB
Set
THEN
ORG
Led
x
ELSE
ORS
Mark
bad
type
END
ELSIF
pno
THEN
CheckInt
x
ORG
Get
x
y
ELSIF
pno
THEN
CheckInt
x
ORG
Put
x
y
ELSIF
pno
THEN
CheckInt
x
CheckInt
y
CheckInt
z
ORG
Copy
x
y
z
ELSIF
pno
THEN
CheckConst
x
CheckInt
x
ORG
LDPSR
x
ELSIF
pno
THEN
CheckInt
x
ORG
LDREG
x
y
END
ELSE
ORS
Mark
wrong
nof
parameters
END
END
StandProc
PROCEDURE
StatSequence
VAR
obj
ORB
Object
orgtype
ORB
Type
original
type
of
case
var
x
y
z
w
ORG
Item
L0
L1
rx
LONGINT
PROCEDURE
TypeCase
obj
ORB
Object
VAR
x
ORG
Item
VAR
typobj
ORB
Object
BEGIN
IF
sym
ORS
ident
THEN
qualident
typobj
ORG
MakeItem
x
obj
level
IF
typobj
class
ORB
Typ
THEN
ORS
Mark
not
a
type
END
TypeTest
x
typobj
type
FALSE
obj
type
typobj
type
ORG
CFJump
x
Check
ORS
colon
expected
StatSequence
ELSE
ORG
CFJump
x
ORS
Mark
type
id
expected
END
END
TypeCase
PROCEDURE
SkipCase
BEGIN
WHILE
sym
ORS
colon
DO
ORS
Get
sym
END
ORS
Get
sym
StatSequence
END
SkipCase
BEGIN
StatSequence
REPEAT
sync
obj
NIL
IF
sym
ORS
ident
sym
ORS
for
OR
sym
ORS
semicolon
THEN
ORS
Mark
statement
expected
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
ident
END
IF
sym
ORS
ident
THEN
qualident
obj
ORG
MakeItem
x
obj
level
IF
x
mode
ORB
SProc
THEN
StandProc
obj
val
ELSE
selector
x
IF
sym
ORS
becomes
THEN
assignment
ORS
Get
sym
CheckReadOnly
x
expression
y
IF
CompTypes
x
type
y
type
FALSE
THEN
IF
x
type
form
ORB
Pointer
OR
x
type
form
ORB
Proc
THEN
ORG
Store
x
y
ELSE
ORG
StoreStruct
x
y
END
ELSIF
x
type
form
ORB
Array
y
type
form
ORB
Array
x
type
base
y
type
base
y
type
len
THEN
ORG
StoreStruct
x
y
ELSIF
x
type
form
ORB
Array
x
type
base
form
ORB
Char
y
type
form
ORB
String
THEN
ORG
CopyString
x
y
ELSIF
x
type
form
ORB
Int
y
type
form
ORB
Int
THEN
ORG
Store
x
y
BYTE
ELSIF
x
type
form
ORB
Char
y
type
form
ORB
String
y
b
THEN
ORG
StrToChar
y
ORG
Store
x
y
ELSE
ORS
Mark
illegal
assignment
END
ELSIF
sym
ORS
eql
THEN
ORS
Mark
should
be
ORS
Get
sym
expression
y
ELSIF
sym
ORS
lparen
THEN
procedure
call
ORS
Get
sym
IF
x
type
form
ORB
Proc
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ParamList
x
ORG
Call
x
rx
ELSE
ORS
Mark
not
a
procedure
ParamList
x
END
ELSIF
x
type
form
ORB
Proc
THEN
procedure
call
without
parameters
IF
x
type
nofpar
THEN
ORS
Mark
missing
parameters
END
IF
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ORG
Call
x
rx
ELSE
ORS
Mark
not
a
procedure
END
ELSIF
x
mode
ORB
Typ
THEN
ORS
Mark
illegal
assignment
ELSE
ORS
Mark
not
a
procedure
END
END
ELSIF
sym
ORS
if
THEN
ORS
Get
sym
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
then
no
THEN
StatSequence
L0
WHILE
sym
ORS
elsif
DO
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
then
no
THEN
StatSequence
END
IF
sym
ORS
else
THEN
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
StatSequence
ELSE
ORG
Fixup
x
END
ORG
FixLink
L0
Check
ORS
end
no
END
ELSIF
sym
ORS
while
THEN
ORS
Get
sym
L0
ORG
Here
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
do
no
DO
StatSequence
ORG
BJump
L0
WHILE
sym
ORS
elsif
DO
ORS
Get
sym
ORG
Fixup
x
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
do
no
DO
StatSequence
ORG
BJump
L0
END
ORG
Fixup
x
Check
ORS
end
no
END
ELSIF
sym
ORS
repeat
THEN
ORS
Get
sym
L0
ORG
Here
StatSequence
IF
sym
ORS
until
THEN
ORS
Get
sym
expression
x
CheckBool
x
ORG
CBJump
x
L0
ELSE
ORS
Mark
missing
UNTIL
END
ELSIF
sym
ORS
for
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
ORG
MakeItem
x
obj
level
CheckInt
x
CheckReadOnly
x
IF
sym
ORS
becomes
THEN
ORS
Get
sym
expression
y
CheckInt
y
ORG
For0
x
y
L0
ORG
Here
Check
ORS
to
no
TO
expression
z
CheckInt
z
obj
rdo
TRUE
IF
sym
ORS
by
THEN
ORS
Get
sym
expression
w
CheckConst
w
CheckInt
w
ELSE
ORG
MakeConstItem
w
ORB
intType
END
Check
ORS
do
no
DO
ORG
For1
x
y
z
w
L1
StatSequence
Check
ORS
end
no
END
ORG
For2
x
y
w
ORG
BJump
L0
ORG
FixLink
L1
obj
rdo
FALSE
ELSE
ORS
Mark
expected
END
ELSE
ORS
Mark
identifier
expected
END
ELSIF
sym
ORS
case
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
orgtype
obj
type
IF
orgtype
form
ORB
Pointer
OR
orgtype
form
ORB
Record
obj
class
ORB
Par
THEN
Check
ORS
of
OF
expected
TypeCase
obj
x
L0
WHILE
sym
ORS
bar
DO
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
obj
type
orgtype
TypeCase
obj
x
END
ORG
Fixup
x
ORG
FixLink
L0
obj
type
orgtype
ELSE
ORS
Mark
numeric
case
not
implemented
Check
ORS
of
OF
expected
SkipCase
WHILE
sym
ORS
bar
DO
SkipCase
END
END
ELSE
ORS
Mark
ident
expected
END
Check
ORS
end
no
END
END
ORG
CheckRegs
IF
sym
ORS
semicolon
THEN
ORS
Get
sym
ELSIF
sym
ORS
semicolon
THEN
ORS
Mark
missing
semicolon
END
UNTIL
sym
ORS
semicolon
END
StatSequence
Types
and
declarations
PROCEDURE
IdentList
class
INTEGER
VAR
first
ORB
Object
VAR
obj
ORB
Object
BEGIN
IF
sym
ORS
ident
THEN
ORB
NewObj
first
ORS
id
class
ORS
Get
sym
CheckExport
first
expo
WHILE
sym
ORS
comma
DO
ORS
Get
sym
IF
sym
ORS
ident
THEN
ORB
NewObj
obj
ORS
id
class
ORS
Get
sym
CheckExport
obj
expo
ELSE
ORS
Mark
ident
END
END
IF
sym
ORS
colon
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
ELSE
first
NIL
END
END
IdentList
PROCEDURE
ArrayType
VAR
type
ORB
Type
VAR
x
ORG
Item
typ
ORB
Type
len
LONGINT
BEGIN
NEW
typ
typ
form
ORB
NoTyp
expression
x
IF
x
mode
ORB
Const
x
type
form
ORB
Int
x
a
THEN
len
x
a
ELSE
len
ORS
Mark
not
a
valid
length
END
IF
sym
ORS
of
THEN
ORS
Get
sym
Type
typ
base
IF
typ
base
form
ORB
Array
typ
base
len
THEN
ORS
Mark
dyn
array
not
allowed
END
ELSIF
sym
ORS
comma
THEN
ORS
Get
sym
ArrayType
typ
base
ELSE
ORS
Mark
missing
OF
typ
base
ORB
intType
END
typ
size
len
typ
base
size
DIV
typ
form
ORB
Array
typ
len
len
type
typ
END
ArrayType
PROCEDURE
RecordType
VAR
type
ORB
Type
VAR
obj
obj0
new
bot
base
ORB
Object
typ
tp
ORB
Type
offset
off
n
LONGINT
BEGIN
NEW
typ
typ
form
ORB
NoTyp
typ
base
NIL
typ
mno
level
typ
nofpar
offset
bot
NIL
IF
sym
ORS
lparen
THEN
ORS
Get
sym
record
extension
IF
level
THEN
ORS
Mark
extension
of
local
types
not
implemented
END
IF
sym
ORS
ident
THEN
qualident
base
IF
base
class
ORB
Typ
THEN
IF
base
type
form
ORB
Record
THEN
typ
base
base
type
ELSE
typ
base
ORB
intType
ORS
Mark
invalid
extension
END
typ
nofpar
typ
base
nofpar
nofpar
here
abused
for
extension
level
bot
typ
base
dsc
offset
typ
base
size
ELSE
ORS
Mark
type
expected
END
ELSE
ORS
Mark
ident
expected
END
Check
ORS
rparen
no
END
WHILE
sym
ORS
ident
DO
fields
n
obj
bot
WHILE
sym
ORS
ident
DO
obj0
obj
WHILE
obj0
NIL
obj0
name
ORS
id
DO
obj0
obj0
next
END
IF
obj0
NIL
THEN
ORS
Mark
mult
def
END
NEW
new
ORS
CopyId
new
name
new
class
ORB
Fld
new
next
obj
obj
new
INC
n
ORS
Get
sym
CheckExport
new
expo
IF
sym
ORS
comma
sym
ORS
colon
THEN
ORS
Mark
comma
expected
ELSIF
sym
ORS
comma
THEN
ORS
Get
sym
END
END
Check
ORS
colon
colon
expected
Type
tp
IF
tp
form
ORB
Array
tp
len
THEN
ORS
Mark
dyn
array
not
allowed
END
IF
tp
size
THEN
offset
offset
DIV
END
offset
offset
n
tp
size
off
offset
obj0
obj
WHILE
obj0
bot
DO
obj0
type
tp
obj0
lev
off
off
tp
size
obj0
val
off
obj0
obj0
next
END
bot
obj
IF
sym
ORS
semicolon
THEN
ORS
Get
sym
ELSIF
sym
ORS
end
THEN
ORS
Mark
or
END
END
END
typ
form
ORB
Record
typ
dsc
bot
typ
size
offset
DIV
type
typ
END
RecordType
PROCEDURE
FPSection
VAR
adr
LONGINT
VAR
nofpar
INTEGER
VAR
obj
first
ORB
Object
tp
ORB
Type
parsize
LONGINT
cl
INTEGER
rdo
BOOLEAN
BEGIN
IF
sym
ORS
var
THEN
ORS
Get
sym
cl
ORB
Par
ELSE
cl
ORB
Var
END
IdentList
cl
first
FormalType
tp
rdo
FALSE
IF
cl
ORB
Var
tp
form
ORB
Array
THEN
cl
ORB
Par
rdo
TRUE
END
IF
tp
form
ORB
Array
tp
len
OR
tp
form
ORB
Record
THEN
parsize
ORG
WordSize
open
array
or
record
needs
second
word
for
length
or
type
tag
ELSE
parsize
ORG
WordSize
END
obj
first
WHILE
obj
NIL
DO
INC
nofpar
obj
class
cl
obj
type
tp
obj
rdo
rdo
obj
lev
level
obj
val
adr
adr
adr
parsize
obj
obj
next
END
IF
adr
THEN
ORS
Mark
too
many
parameters
END
END
FPSection
PROCEDURE
ProcedureType
ptype
ORB
Type
VAR
parblksize
LONGINT
VAR
obj
ORB
Object
size
LONGINT
nofpar
INTEGER
BEGIN
ptype
base
ORB
noType
size
parblksize
nofpar
ptype
dsc
NIL
IF
sym
ORS
lparen
THEN
ORS
Get
sym
IF
sym
ORS
rparen
THEN
ORS
Get
sym
ELSE
FPSection
size
nofpar
WHILE
sym
ORS
semicolon
DO
ORS
Get
sym
FPSection
size
nofpar
END
Check
ORS
rparen
no
END
IF
sym
ORS
colon
THEN
function
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
ptype
base
obj
type
IF
obj
class
ORB
Typ
obj
type
form
IN
ORB
Byte
ORB
Pointer
ORB
Proc
THEN
ORS
Mark
illegal
function
type
END
ELSE
ORS
Mark
type
identifier
expected
END
END
END
ptype
nofpar
nofpar
parblksize
size
END
ProcedureType
PROCEDURE
FormalType0
VAR
typ
ORB
Type
dim
INTEGER
VAR
obj
ORB
Object
dmy
LONGINT
BEGIN
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
typ
obj
type
ELSE
ORS
Mark
not
a
type
typ
ORB
intType
END
ELSIF
sym
ORS
array
THEN
ORS
Get
sym
Check
ORS
of
OF
IF
dim
THEN
ORS
Mark
multi
dimensional
open
arrays
not
implemented
END
NEW
typ
typ
form
ORB
Array
typ
len
typ
size
ORG
WordSize
FormalType
typ
base
dim
ELSIF
sym
ORS
procedure
THEN
ORS
Get
sym
ORB
OpenScope
NEW
typ
typ
form
ORB
Proc
typ
size
ORG
WordSize
dmy
ProcedureType
typ
dmy
typ
dsc
ORB
topScope
next
ORB
CloseScope
ELSE
ORS
Mark
identifier
expected
typ
ORB
noType
END
END
FormalType0
PROCEDURE
CheckRecLevel
lev
INTEGER
BEGIN
IF
lev
THEN
ORS
Mark
ptr
base
must
be
global
END
END
CheckRecLevel
PROCEDURE
Type0
VAR
type
ORB
Type
VAR
dmy
LONGINT
obj
ORB
Object
ptbase
PtrBase
BEGIN
type
ORB
intType
sync
IF
sym
ORS
ident
sym
ORS
array
THEN
ORS
Mark
not
a
type
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
ident
OR
sym
ORS
array
END
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
IF
obj
type
NIL
obj
type
form
ORB
NoTyp
THEN
type
obj
type
END
ELSE
ORS
Mark
not
a
type
or
undefined
END
ELSIF
sym
ORS
array
THEN
ORS
Get
sym
ArrayType
type
ELSIF
sym
ORS
record
THEN
ORS
Get
sym
RecordType
type
Check
ORS
end
no
END
ELSIF
sym
ORS
pointer
THEN
ORS
Get
sym
Check
ORS
to
no
TO
NEW
type
type
form
ORB
Pointer
type
size
ORG
WordSize
type
base
ORB
intType
IF
sym
ORS
ident
THEN
obj
ORB
thisObj
IF
obj
NIL
THEN
IF
obj
class
ORB
Typ
obj
type
form
IN
ORB
Record
ORB
NoTyp
THEN
CheckRecLevel
obj
lev
type
base
obj
type
ELSIF
obj
class
ORB
Mod
THEN
ORS
Mark
external
base
type
not
implemented
ELSE
ORS
Mark
no
valid
base
type
END
ELSE
CheckRecLevel
level
enter
into
list
of
forward
references
to
be
fixed
in
Declarations
NEW
ptbase
ORS
CopyId
ptbase
name
ptbase
type
type
ptbase
next
pbsList
pbsList
ptbase
END
ORS
Get
sym
ELSE
Type
type
base
IF
type
base
form
ORB
Record
OR
type
base
typobj
NIL
THEN
ORS
Mark
must
point
to
named
record
END
CheckRecLevel
level
END
ELSIF
sym
ORS
procedure
THEN
ORS
Get
sym
ORB
OpenScope
NEW
type
type
form
ORB
Proc
type
size
ORG
WordSize
dmy
ProcedureType
type
dmy
type
dsc
ORB
topScope
next
ORB
CloseScope
ELSE
ORS
Mark
illegal
type
END
END
Type0
PROCEDURE
Declarations
VAR
varsize
LONGINT
VAR
obj
first
ORB
Object
x
ORG
Item
tp
ORB
Type
ptbase
PtrBase
expo
BOOLEAN
id
ORS
Ident
BEGIN
sync
pbsList
NIL
IF
sym
ORS
const
sym
ORS
end
sym
ORS
return
THEN
ORS
Mark
declaration
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
const
OR
sym
ORS
end
OR
sym
ORS
return
END
IF
sym
ORS
const
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
id
ORS
Get
sym
CheckExport
expo
IF
sym
ORS
eql
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
expression
x
IF
x
type
form
ORB
String
x
b
THEN
ORG
StrToChar
x
END
ORB
NewObj
obj
id
ORB
Const
obj
expo
expo
IF
x
mode
ORB
Const
THEN
obj
val
x
a
obj
lev
x
b
obj
type
x
type
ELSE
ORS
Mark
expression
not
constant
obj
type
ORB
intType
END
Check
ORS
semicolon
missing
END
END
IF
sym
ORS
type
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
id
ORS
Get
sym
CheckExport
expo
IF
sym
ORS
eql
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
Type
tp
ORB
NewObj
obj
id
ORB
Typ
obj
type
tp
obj
expo
expo
obj
lev
level
IF
tp
typobj
NIL
THEN
tp
typobj
obj
END
IF
expo
obj
type
form
ORB
Record
THEN
obj
exno
exno
INC
exno
ELSE
obj
exno
END
IF
tp
form
ORB
Record
THEN
ptbase
pbsList
check
whether
this
is
base
of
a
pointer
type
search
and
fixup
WHILE
ptbase
NIL
DO
IF
obj
name
ptbase
name
THEN
ptbase
type
base
obj
type
END
ptbase
ptbase
next
END
IF
level
THEN
ORG
BuildTD
tp
dc
END
type
descriptor
len
used
as
its
address
END
Check
ORS
semicolon
missing
END
END
IF
sym
ORS
var
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
IdentList
ORB
Var
first
Type
tp
obj
first
WHILE
obj
NIL
DO
obj
type
tp
obj
lev
level
IF
tp
size
THEN
varsize
varsize
DIV
align
END
obj
val
varsize
varsize
varsize
obj
type
size
IF
obj
expo
THEN
obj
exno
exno
INC
exno
END
obj
obj
next
END
Check
ORS
semicolon
missing
END
END
varsize
varsize
DIV
ptbase
pbsList
WHILE
ptbase
NIL
DO
IF
ptbase
type
base
form
ORB
Int
THEN
ORS
Mark
undefined
pointer
base
of
END
ptbase
ptbase
next
END
IF
sym
ORS
const
sym
ORS
var
THEN
ORS
Mark
declaration
in
bad
order
END
END
Declarations
PROCEDURE
ProcedureDecl
VAR
proc
ORB
Object
type
ORB
Type
procid
ORS
Ident
x
ORG
Item
locblksize
parblksize
L
LONGINT
int
BOOLEAN
BEGIN
ProcedureDecl
int
FALSE
ORS
Get
sym
IF
sym
ORS
times
THEN
ORS
Get
sym
int
TRUE
END
IF
sym
ORS
ident
THEN
ORS
CopyId
procid
ORS
Get
sym
ORB
NewObj
proc
ORS
id
ORB
Const
IF
int
THEN
parblksize
ELSE
parblksize
END
NEW
type
type
form
ORB
Proc
type
size
ORG
WordSize
proc
type
type
proc
val
proc
lev
level
CheckExport
proc
expo
IF
proc
expo
THEN
proc
exno
exno
INC
exno
END
ORB
OpenScope
INC
level
type
base
ORB
noType
ProcedureType
type
parblksize
formal
parameter
list
Check
ORS
semicolon
no
locblksize
parblksize
Declarations
locblksize
proc
val
ORG
Here
proc
type
dsc
ORB
topScope
next
IF
sym
ORS
procedure
THEN
L
ORG
FJump
L
REPEAT
ProcedureDecl
Check
ORS
semicolon
no
UNTIL
sym
ORS
procedure
ORG
FixOne
L
proc
val
ORG
Here
proc
type
dsc
ORB
topScope
next
END
ORG
Enter
parblksize
locblksize
int
IF
sym
ORS
begin
THEN
ORS
Get
sym
StatSequence
END
IF
sym
ORS
return
THEN
ORS
Get
sym
expression
x
IF
type
base
ORB
noType
THEN
ORS
Mark
this
is
not
a
function
ELSIF
CompTypes
type
base
x
type
FALSE
THEN
ORS
Mark
wrong
result
type
END
ELSIF
type
base
form
ORB
NoTyp
THEN
ORS
Mark
function
without
result
type
base
ORB
noType
END
ORG
Return
type
base
form
x
locblksize
int
ORB
CloseScope
DEC
level
Check
ORS
end
no
END
IF
sym
ORS
ident
THEN
IF
ORS
id
procid
THEN
ORS
Mark
no
match
END
ORS
Get
sym
ELSE
ORS
Mark
no
proc
id
END
END
END
ProcedureDecl
PROCEDURE
Module
VAR
key
LONGINT
impid
impid1
ORS
Ident
BEGIN
Texts
WriteString
W
compiling
ORS
Get
sym
IF
sym
ORS
module
THEN
ORS
Get
sym
IF
sym
ORS
times
THEN
version
Texts
Write
W
ORS
Get
sym
ELSE
version
END
ORB
Init
ORB
OpenScope
IF
sym
ORS
ident
THEN
ORS
CopyId
modid
ORS
Get
sym
Texts
WriteString
W
modid
Texts
Append
Oberon
Log
W
buf
ELSE
ORS
Mark
identifier
expected
END
Check
ORS
semicolon
no
level
dc
exno
key
IF
sym
ORS
import
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
impid
ORS
Get
sym
IF
sym
ORS
becomes
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
ORS
CopyId
impid1
ORS
Get
sym
ELSE
ORS
Mark
id
expected
END
ELSE
impid1
impid
END
ORB
Import
impid
impid1
IF
sym
ORS
comma
THEN
ORS
Get
sym
ELSIF
sym
ORS
ident
THEN
ORS
Mark
comma
missing
END
END
Check
ORS
semicolon
no
END
ORG
Open
version
Declarations
dc
ORG
SetDataSize
dc
DIV
WHILE
sym
ORS
procedure
DO
ProcedureDecl
Check
ORS
semicolon
no
END
ORG
Header
IF
sym
ORS
begin
THEN
ORS
Get
sym
StatSequence
END
Check
ORS
end
no
END
IF
sym
ORS
ident
THEN
IF
ORS
id
modid
THEN
ORS
Mark
no
match
END
ORS
Get
sym
ELSE
ORS
Mark
identifier
missing
END
IF
sym
ORS
period
THEN
ORS
Mark
period
missing
END
IF
ORS
errcnt
version
THEN
ORB
Export
modid
newSF
key
IF
newSF
THEN
Texts
WriteString
W
new
symbol
file
END
END
IF
ORS
errcnt
THEN
ORG
Close
modid
key
exno
Texts
WriteInt
W
ORG
pc
Texts
WriteInt
W
dc
Texts
WriteHex
W
key
ELSE
Texts
WriteLn
W
Texts
WriteString
W
compilation
FAILED
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
ORB
CloseScope
pbsList
NIL
ELSE
ORS
Mark
must
start
with
MODULE
END
END
Module
PROCEDURE
Option
VAR
S
Texts
Scanner
BEGIN
newSF
FALSE
IF
S
nextCh
THEN
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
S
s
s
THEN
newSF
TRUE
END
END
END
Option
PROCEDURE
Compile
VAR
beg
end
time
LONGINT
T
Texts
Text
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
THEN
IF
S
c
THEN
Option
S
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
ORS
Init
T
beg
Module
END
ELSIF
S
c
THEN
Option
S
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
S
s
NEW
T
Texts
Open
T
S
s
IF
T
len
THEN
ORS
Init
T
Module
END
END
END
END
ELSE
WHILE
S
class
Texts
Name
DO
NEW
T
Texts
Open
T
S
s
IF
T
len
THEN
Option
S
ORS
Init
T
Module
ELSE
Texts
WriteString
W
S
s
Texts
WriteString
W
not
found
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
IF
T
len
ORS
errcnt
THEN
Texts
Scan
S
ELSE
S
class
END
END
END
Oberon
Collect
END
Compile
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
OR
Compiler
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
NEW
dummy
dummy
class
ORB
Var
dummy
type
ORB
intType
expression
expression0
Type
Type0
FormalType
FormalType0
END
ORP
MODULE
ORS
NW
Scanner
in
Oberon
IMPORT
SYSTEM
Texts
Oberon
Oberon
Scanner
does
lexical
analysis
Input
is
Oberon
Text
output
is
sequence
of
symbols
i
e
identifiers
numbers
strings
and
special
symbols
Recognises
all
Oberon
keywords
and
skips
comments
The
keywords
are
recorded
in
a
table
Get
sym
delivers
next
symbol
from
input
text
with
Reader
R
Mark
msg
records
error
and
delivers
error
message
with
Writer
W
If
Get
delivers
ident
then
the
identifier
a
string
is
in
variable
id
if
int
or
char
in
ival
if
real
in
rval
and
if
string
in
str
and
slen
CONST
IdLen
NKW
nof
keywords
maxExp
stringBufSize
lexical
symbols
null
times
rdiv
div
mod
and
plus
minus
or
eql
neq
lss
leq
gtr
geq
in
is
arrow
period
char
int
real
false
true
nil
string
not
lparen
lbrak
lbrace
ident
if
while
repeat
case
for
comma
colon
becomes
upto
rparen
rbrak
rbrace
then
of
do
to
by
semicolon
end
bar
else
elsif
until
return
array
record
pointer
const
type
var
procedure
begin
import
module
eot
TYPE
Ident
ARRAY
IdLen
OF
CHAR
VAR
ival
slen
LONGINT
results
of
Get
rval
REAL
id
Ident
for
identifiers
str
ARRAY
stringBufSize
OF
CHAR
errcnt
INTEGER
ch
CHAR
last
character
read
errpos
LONGINT
R
Texts
Reader
W
Texts
Writer
k
INTEGER
KWX
ARRAY
OF
INTEGER
keyTab
ARRAY
NKW
OF
RECORD
sym
INTEGER
id
ARRAY
OF
CHAR
END
PROCEDURE
CopyId
VAR
ident
Ident
BEGIN
ident
id
END
CopyId
PROCEDURE
Pos
LONGINT
BEGIN
RETURN
Texts
Pos
R
END
Pos
PROCEDURE
Mark
msg
ARRAY
OF
CHAR
VAR
p
LONGINT
BEGIN
p
Pos
IF
p
errpos
errcnt
THEN
Texts
WriteLn
W
Texts
WriteString
W
pos
Texts
WriteInt
W
p
Texts
Write
W
Texts
WriteString
W
msg
Texts
Append
Oberon
Log
W
buf
END
INC
errcnt
errpos
p
END
Mark
PROCEDURE
Identifier
VAR
sym
INTEGER
VAR
i
k
INTEGER
BEGIN
i
REPEAT
IF
i
IdLen
THEN
id
i
ch
INC
i
END
Texts
Read
R
ch
UNTIL
ch
OR
ch
ch
A
OR
ch
Z
ch
a
OR
ch
z
id
i
0X
IF
i
THEN
k
KWX
i
search
for
keyword
WHILE
id
keyTab
k
id
k
KWX
i
DO
INC
k
END
IF
k
KWX
i
THEN
sym
keyTab
k
sym
ELSE
sym
ident
END
ELSE
sym
ident
END
END
Identifier
PROCEDURE
String
VAR
i
INTEGER
BEGIN
i
Texts
Read
R
ch
WHILE
R
eot
ch
22X
DO
IF
ch
THEN
IF
i
stringBufSize
THEN
str
i
ch
INC
i
ELSE
Mark
string
too
long
END
END
Texts
Read
R
ch
END
str
i
0X
INC
i
Texts
Read
R
ch
slen
i
END
String
PROCEDURE
HexString
VAR
i
m
n
INTEGER
BEGIN
i
Texts
Read
R
ch
WHILE
R
eot
ch
DO
WHILE
R
eot
ch
DO
Texts
Read
R
ch
END
skip
IF
ch
ch
THEN
m
ORD
ch
30H
ELSIF
A
ch
ch
F
THEN
m
ORD
ch
37H
ELSE
m
Mark
hexdig
expected
END
Texts
Read
R
ch
IF
ch
ch
THEN
n
ORD
ch
30H
ELSIF
A
ch
ch
F
THEN
n
ORD
ch
37H
ELSE
n
Mark
hexdig
expected
END
IF
i
stringBufSize
THEN
str
i
CHR
m
10H
n
INC
i
ELSE
Mark
string
too
long
END
Texts
Read
R
ch
END
Texts
Read
R
ch
slen
i
no
0X
appended
END
HexString
PROCEDURE
Ten
e
LONGINT
REAL
VAR
x
t
REAL
BEGIN
x
t
WHILE
e
DO
IF
ODD
e
THEN
x
t
x
END
t
t
t
e
e
DIV
END
RETURN
x
END
Ten
PROCEDURE
Number
VAR
sym
INTEGER
CONST
max
VAR
i
k
e
n
s
h
LONGINT
x
REAL
d
ARRAY
OF
INTEGER
negE
BOOLEAN
BEGIN
ival
i
n
k
REPEAT
IF
n
THEN
d
n
ORD
ch
30H
INC
n
ELSE
Mark
too
many
digits
n
END
Texts
Read
R
ch
UNTIL
ch
OR
ch
ch
A
OR
ch
F
IF
ch
H
OR
ch
R
OR
ch
X
THEN
hex
REPEAT
h
d
i
IF
h
THEN
h
h
END
k
k
10H
h
INC
i
no
overflow
check
UNTIL
i
n
IF
ch
X
THEN
sym
char
IF
k
100H
THEN
ival
k
ELSE
Mark
illegal
value
ival
END
ELSIF
ch
R
THEN
sym
real
rval
SYSTEM
VAL
REAL
k
ELSE
sym
int
ival
k
END
Texts
Read
R
ch
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
double
dot
ch
7FX
decimal
integer
REPEAT
IF
d
i
THEN
IF
k
max
d
i
DIV
THEN
k
k
d
i
ELSE
Mark
too
large
k
END
ELSE
Mark
bad
integer
END
INC
i
UNTIL
i
n
sym
int
ival
k
ELSE
real
number
x
e
REPEAT
integer
part
x
x
FLT
d
i
INC
i
UNTIL
i
n
WHILE
ch
ch
DO
fraction
x
x
FLT
ORD
ch
30H
DEC
e
Texts
Read
R
ch
END
IF
ch
E
OR
ch
D
THEN
scale
factor
Texts
Read
R
ch
s
IF
ch
THEN
negE
TRUE
Texts
Read
R
ch
ELSE
negE
FALSE
IF
ch
THEN
Texts
Read
R
ch
END
END
IF
ch
ch
THEN
REPEAT
s
s
ORD
ch
30H
Texts
Read
R
ch
UNTIL
ch
OR
ch
IF
negE
THEN
e
e
s
ELSE
e
e
s
END
ELSE
Mark
digit
END
END
IF
e
THEN
IF
e
maxExp
THEN
x
x
Ten
e
ELSE
x
END
ELSIF
e
THEN
IF
e
maxExp
THEN
x
Ten
e
x
ELSE
x
Mark
too
large
END
END
sym
real
rval
x
END
ELSE
decimal
integer
REPEAT
IF
d
i
THEN
IF
k
max
d
i
DIV
THEN
k
k
d
i
ELSE
Mark
too
large
k
END
ELSE
Mark
bad
integer
END
INC
i
UNTIL
i
n
sym
int
ival
k
END
END
Number
PROCEDURE
comment
BEGIN
Texts
Read
R
ch
REPEAT
WHILE
R
eot
ch
DO
IF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
comment
END
ELSE
Texts
Read
R
ch
END
END
WHILE
ch
DO
Texts
Read
R
ch
END
UNTIL
ch
OR
R
eot
IF
R
eot
THEN
Texts
Read
R
ch
ELSE
Mark
unterminated
comment
END
END
comment
PROCEDURE
Get
VAR
sym
INTEGER
BEGIN
REPEAT
WHILE
R
eot
ch
DO
Texts
Read
R
ch
END
IF
R
eot
THEN
sym
eot
ELSIF
ch
A
THEN
IF
ch
THEN
IF
ch
22X
THEN
String
sym
string
ELSIF
ch
THEN
Texts
Read
R
ch
sym
neq
ELSIF
ch
THEN
HexString
sym
string
ELSIF
ch
THEN
Texts
Read
R
ch
sym
and
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
sym
null
comment
ELSE
sym
lparen
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
rparen
ELSIF
ch
THEN
Texts
Read
R
ch
sym
times
ELSIF
ch
THEN
Texts
Read
R
ch
sym
plus
ELSIF
ch
THEN
Texts
Read
R
ch
sym
comma
ELSIF
ch
THEN
Texts
Read
R
ch
sym
minus
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
upto
ELSE
sym
period
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
rdiv
ELSE
Texts
Read
R
ch
sym
null
END
ELSIF
ch
THEN
Number
sym
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
becomes
ELSE
sym
colon
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
semicolon
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
leq
ELSE
sym
lss
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
eql
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
geq
ELSE
sym
gtr
END
ELSE
Texts
Read
R
ch
sym
null
END
ELSIF
ch
THEN
Identifier
sym
ELSIF
ch
a
THEN
IF
ch
THEN
sym
lbrak
ELSIF
ch
THEN
sym
rbrak
ELSIF
ch
THEN
sym
arrow
ELSE
sym
null
END
Texts
Read
R
ch
ELSIF
ch
THEN
Identifier
sym
ELSE
IF
ch
THEN
sym
lbrace
ELSIF
ch
THEN
sym
rbrace
ELSIF
ch
THEN
sym
bar
ELSIF
ch
THEN
sym
not
ELSIF
ch
7FX
THEN
sym
upto
ELSE
sym
null
END
Texts
Read
R
ch
END
UNTIL
sym
null
END
Get
PROCEDURE
Init
T
Texts
Text
pos
LONGINT
BEGIN
errpos
pos
errcnt
Texts
OpenReader
R
T
pos
Texts
Read
R
ch
END
Init
PROCEDURE
EnterKW
sym
INTEGER
name
ARRAY
OF
CHAR
BEGIN
keyTab
k
id
name
keyTab
k
sym
sym
INC
k
END
EnterKW
BEGIN
Texts
OpenWriter
W
k
KWX
KWX
EnterKW
if
IF
EnterKW
do
DO
EnterKW
of
OF
EnterKW
or
OR
EnterKW
to
TO
EnterKW
in
IN
EnterKW
is
IS
EnterKW
by
BY
KWX
k
EnterKW
end
END
EnterKW
nil
NIL
EnterKW
var
VAR
EnterKW
div
DIV
EnterKW
mod
MOD
EnterKW
for
FOR
KWX
k
EnterKW
else
ELSE
EnterKW
then
THEN
EnterKW
true
TRUE
EnterKW
type
TYPE
EnterKW
case
CASE
KWX
k
EnterKW
elsif
ELSIF
EnterKW
false
FALSE
EnterKW
array
ARRAY
EnterKW
begin
BEGIN
EnterKW
const
CONST
EnterKW
until
UNTIL
EnterKW
while
WHILE
KWX
k
EnterKW
record
RECORD
EnterKW
repeat
REPEAT
EnterKW
return
RETURN
EnterKW
import
IMPORT
EnterKW
module
MODULE
KWX
k
EnterKW
pointer
POINTER
KWX
k
KWX
k
EnterKW
procedure
PROCEDURE
KWX
k
END
ORS
MODULE
ORTool
NW
IMPORT
SYSTEM
Files
Texts
Oberon
ORB
VAR
W
Texts
Writer
Form
INTEGER
result
of
ReadType
mnemo0
mnemo1
ARRAY
OF
CHAR
mnemonics
PROCEDURE
Read
VAR
R
Files
Rider
VAR
n
INTEGER
VAR
b
BYTE
BEGIN
Files
ReadByte
R
b
IF
b
80H
THEN
n
b
ELSE
n
b
100H
END
END
Read
PROCEDURE
ReadType
VAR
R
Files
Rider
VAR
key
len
lev
size
off
INTEGER
ref
mno
class
form
readonly
INTEGER
name
modname
ARRAY
OF
CHAR
BEGIN
Read
R
ref
Texts
Write
W
Texts
Write
W
IF
ref
THEN
Texts
Write
W
Texts
WriteInt
W
ref
ELSE
Texts
WriteInt
W
ref
Read
R
form
Texts
WriteString
W
form
Texts
WriteInt
W
form
IF
form
ORB
Pointer
THEN
ReadType
R
ELSIF
form
ORB
Array
THEN
ReadType
R
Files
ReadNum
R
len
Files
ReadNum
R
size
Texts
WriteString
W
len
Texts
WriteInt
W
len
Texts
WriteString
W
size
Texts
WriteInt
W
size
ELSIF
form
ORB
Record
THEN
ReadType
R
base
type
Files
ReadNum
R
off
Texts
WriteString
W
exno
Texts
WriteInt
W
off
Files
ReadNum
R
off
Texts
WriteString
W
extlev
Texts
WriteInt
W
off
Files
ReadNum
R
size
Texts
WriteString
W
size
Texts
WriteInt
W
size
Texts
Write
W
Texts
Write
W
Read
R
class
WHILE
class
DO
fields
Files
ReadString
R
name
IF
name
0X
THEN
Texts
Write
W
Texts
WriteString
W
name
ReadType
R
ELSE
Texts
WriteString
W
END
Files
ReadNum
R
off
Texts
WriteInt
W
off
Read
R
class
END
Texts
Write
W
ELSIF
form
ORB
Proc
THEN
ReadType
R
Texts
Write
W
Read
R
class
WHILE
class
DO
Texts
WriteString
W
class
Texts
WriteInt
W
class
Read
R
readonly
IF
readonly
THEN
Texts
Write
W
END
ReadType
R
Read
R
class
END
Texts
Write
W
END
Files
ReadString
R
modname
IF
modname
0X
THEN
Files
ReadInt
R
key
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
modname
Texts
Write
W
Texts
WriteString
W
name
Texts
WriteHex
W
key
END
END
Form
form
Texts
Write
W
END
ReadType
PROCEDURE
DecSym
decode
symbol
file
VAR
class
typno
k
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
OR
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadInt
R
k
Files
ReadInt
R
k
Files
ReadString
R
name
Texts
WriteString
W
name
Texts
WriteHex
W
k
Read
R
class
Texts
WriteInt
W
class
sym
file
version
IF
class
ORB
versionkey
THEN
Texts
WriteLn
W
Read
R
class
WHILE
class
DO
Texts
WriteInt
W
class
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
ReadType
R
IF
class
ORB
Typ
THEN
Texts
Write
W
Read
R
class
WHILE
class
DO
pointer
base
fixup
Texts
WriteString
W
Texts
WriteInt
W
class
Read
R
class
END
Texts
Write
W
ELSIF
class
ORB
Const
OR
class
ORB
Var
THEN
Files
ReadNum
R
k
Texts
WriteInt
W
k
Reals
Strings
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Read
R
class
END
ELSE
Texts
WriteString
W
bad
symfile
version
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecSym
PROCEDURE
WriteReg
r
LONGINT
BEGIN
Texts
Write
W
IF
r
THEN
Texts
WriteString
W
R
Texts
WriteInt
W
r
MOD
10H
ELSIF
r
THEN
Texts
WriteString
W
MT
ELSIF
r
THEN
Texts
WriteString
W
SB
ELSIF
r
THEN
Texts
WriteString
W
SP
ELSE
Texts
WriteString
W
LNK
END
END
WriteReg
PROCEDURE
opcode
w
LONGINT
VAR
k
op
u
a
b
c
LONGINT
BEGIN
k
w
DIV
40000000H
MOD
a
w
DIV
1000000H
MOD
10H
b
w
DIV
100000H
MOD
10H
op
w
DIV
10000H
MOD
10H
u
w
DIV
20000000H
MOD
IF
k
THEN
Texts
WriteString
W
mnemo0
op
IF
u
THEN
Texts
Write
W
END
WriteReg
a
WriteReg
b
WriteReg
w
MOD
10H
ELSIF
k
THEN
Texts
WriteString
W
mnemo0
op
IF
u
THEN
Texts
Write
W
END
WriteReg
a
WriteReg
b
w
w
MOD
10000H
IF
w
8000H
THEN
w
w
10000H
END
Texts
WriteInt
W
w
ELSIF
k
THEN
LDR
STR
IF
u
THEN
Texts
WriteString
W
STR
ELSE
Texts
WriteString
W
LDR
END
WriteReg
a
WriteReg
b
w
w
MOD
100000H
IF
w
80000H
THEN
w
w
100000H
END
Texts
WriteInt
W
w
ELSIF
k
THEN
Branch
instr
Texts
Write
W
B
IF
ODD
w
DIV
10000000H
THEN
Texts
Write
W
L
END
Texts
WriteString
W
mnemo1
a
IF
u
THEN
WriteReg
w
MOD
10H
ELSE
w
w
MOD
100000H
IF
w
80000H
THEN
w
w
100000H
END
Texts
WriteInt
W
w
END
END
END
opcode
PROCEDURE
Sync
VAR
R
Files
Rider
VAR
ch
CHAR
BEGIN
Files
Read
R
ch
Texts
WriteString
W
Sync
Texts
Write
W
ch
Texts
WriteLn
W
END
Sync
PROCEDURE
Write
VAR
R
Files
Rider
x
INTEGER
BEGIN
Files
WriteByte
R
x
x
END
Write
PROCEDURE
DecObj
decode
object
file
VAR
class
i
n
key
size
fix
adr
data
len
INTEGER
ch
CHAR
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadString
R
name
Texts
WriteLn
W
Texts
WriteString
W
name
Files
ReadInt
R
key
Texts
WriteHex
W
key
Read
R
class
Texts
WriteInt
W
class
version
Files
ReadInt
R
size
Texts
WriteInt
W
size
Texts
WriteLn
W
Texts
WriteString
W
imports
Texts
WriteLn
W
Files
ReadString
R
name
WHILE
name
0X
DO
Texts
Write
W
9X
Texts
WriteString
W
name
Files
ReadInt
R
key
Texts
WriteHex
W
key
Texts
WriteLn
W
Files
ReadString
R
name
END
Sync
R
Texts
WriteString
W
type
descriptors
Texts
WriteLn
W
Files
ReadInt
R
n
n
n
DIV
i
WHILE
i
n
DO
Files
ReadInt
R
data
Texts
WriteHex
W
data
INC
i
END
Texts
WriteLn
W
Texts
WriteString
W
data
Files
ReadInt
R
data
Texts
WriteInt
W
data
Texts
WriteLn
W
Texts
WriteString
W
strings
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
Read
R
ch
Texts
Write
W
ch
INC
i
END
Texts
WriteLn
W
Texts
WriteString
W
code
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
ReadInt
R
data
Texts
WriteInt
W
i
Texts
Write
W
9X
Texts
WriteHex
W
data
Texts
Write
W
9X
opcode
data
Texts
WriteLn
W
INC
i
END
Sync
R
Texts
WriteString
W
commands
Texts
WriteLn
W
Files
ReadString
R
name
WHILE
name
0X
DO
Texts
Write
W
9X
Texts
WriteString
W
name
Files
ReadInt
R
adr
Texts
WriteInt
W
adr
Texts
WriteLn
W
Files
ReadString
R
name
END
Sync
R
Texts
WriteString
W
entries
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
ReadInt
R
adr
Texts
WriteInt
W
adr
INC
i
END
Texts
WriteLn
W
Sync
R
Texts
WriteString
W
pointer
refs
Texts
WriteLn
W
Files
ReadInt
R
adr
WHILE
adr
DO
Texts
WriteInt
W
adr
Files
ReadInt
R
adr
END
Texts
WriteLn
W
Sync
R
Files
ReadInt
R
data
Texts
WriteString
W
fixP
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
fixD
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
fixT
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
entry
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
Read
R
ch
IF
ch
O
THEN
Texts
WriteString
W
format
eror
Texts
WriteLn
W
END
Sync
R
ELSE
Texts
WriteString
W
not
found
Texts
WriteLn
W
END
Texts
Append
Oberon
Log
W
buf
END
END
DecObj
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
ORTool
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
mnemo0
MOV
mnemo0
LSL
mnemo0
ASR
mnemo0
ROR
mnemo0
AND
mnemo0
ANN
mnemo0
IOR
mnemo0
XOR
mnemo0
ADD
mnemo0
SUB
mnemo0
MUL
mnemo0
DIV
mnemo0
FAD
mnemo0
FSB
mnemo0
FML
mnemo0
FDV
mnemo1
MI
mnemo1
PL
mnemo1
EQ
mnemo1
NE
mnemo1
LS
mnemo1
HI
mnemo1
LT
mnemo1
GE
mnemo1
LE
mnemo1
GT
mnemo1
NO
END
ORTool
MODULE
Rectangles
NW
IMPORT
SYSTEM
Display
Files
Input
Texts
Oberon
Graphics
GraphicFrames
TYPE
Rectangle
POINTER
TO
RectDesc
RectDesc
RECORD
Graphics
ObjectDesc
lw
vers
INTEGER
END
VAR
method
Graphics
Method
tack
grey
INTEGER
PROCEDURE
New
VAR
r
Rectangle
BEGIN
NEW
r
r
do
method
Graphics
New
r
END
New
PROCEDURE
Copy
src
dst
Graphics
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Rectangle
lw
src
Rectangle
lw
dst
Rectangle
vers
src
Rectangle
vers
END
Copy
PROCEDURE
mark
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
GraphicFrames
ReplConst
f
col
x
y
END
mark
PROCEDURE
Draw
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
lw
col
INTEGER
f
GraphicFrames
Frame
PROCEDURE
draw
f
GraphicFrames
Frame
col
x
y
w
h
lw
INTEGER
BEGIN
GraphicFrames
ReplConst
f
col
x
y
w
lw
Display
replace
GraphicFrames
ReplConst
f
col
x
w
lw
y
lw
h
Display
replace
GraphicFrames
ReplConst
f
col
x
y
h
lw
w
lw
Display
replace
GraphicFrames
ReplConst
f
col
x
y
lw
h
Display
replace
END
draw
BEGIN
CASE
M
OF
GraphicFrames
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
lw
obj
Rectangle
lw
IF
x
f
X1
x
w
f
X
y
f
Y1
y
h
f
Y
THEN
IF
M
col
Display
black
THEN
col
obj
col
ELSE
col
M
col
END
IF
M
mode
THEN
draw
f
col
x
y
w
h
lw
IF
obj
selected
THEN
mark
f
Display
white
x
y
END
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
normal
selected
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
selected
normal
ELSIF
M
mode
THEN
draw
f
Display
black
x
y
w
h
lw
mark
f
Display
black
x
y
erase
END
END
END
END
Draw
PROCEDURE
Selectable
obj
Graphics
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
y
y
y
obj
y
END
Selectable
PROCEDURE
Change
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x0
y0
x1
y1
dx
dy
INTEGER
k
SET
BEGIN
CASE
M
OF
Graphics
WidMsg
obj
Rectangle
lw
M
w
Graphics
ColorMsg
obj
col
M
col
END
END
Change
PROCEDURE
Read
obj
Graphics
Object
VAR
R
Files
Rider
VAR
C
Graphics
Context
VAR
b
BYTE
len
INTEGER
BEGIN
Files
ReadByte
R
b
len
Files
ReadByte
R
b
obj
Rectangle
lw
b
Files
ReadByte
R
b
obj
Rectangle
vers
b
END
Read
PROCEDURE
Write
obj
Graphics
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Graphics
Context
BEGIN
Graphics
WriteObj
W
cno
obj
Files
WriteByte
W
Files
WriteByte
W
obj
Rectangle
lw
Files
WriteByte
W
obj
Rectangle
vers
END
Write
PROCEDURE
Print
obj
Graphics
Object
x
y
INTEGER
VAR
w
h
lw
s
INTEGER
BEGIN
INC
x
obj
x
INC
y
obj
y
w
obj
w
h
obj
h
lw
obj
Rectangle
lw
s
obj
Rectangle
vers
Printer
ReplConst
x
y
w
lw
Printer
ReplConst
x
w
lw
y
lw
h
Printer
ReplConst
x
y
h
lw
w
lw
Printer
ReplConst
x
y
lw
h
IF
s
THEN
Printer
ReplPattern
x
y
w
h
s
END
END
Print
PROCEDURE
Make
command
VAR
x0
x1
y0
y1
INTEGER
R
Rectangle
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
x1
G
mark
next
x
y1
G
mark
next
y
NEW
R
R
col
Oberon
CurCol
R
w
ABS
x1
x0
R
h
ABS
y1
y0
IF
x1
x0
THEN
x0
x1
END
IF
y1
y0
THEN
y0
y1
END
R
x
x0
G
x
R
y
y0
G
y
R
lw
Graphics
width
R
vers
R
do
method
Graphics
Add
G
graph
R
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
R
END
END
Make
BEGIN
NEW
method
method
module
Rectangles
method
allocator
New
method
new
New
method
copy
Copy
method
draw
Draw
method
selectable
Selectable
method
change
Change
method
read
Read
method
write
Write
method
print
Print
tack
SYSTEM
ADR
grey
SYSTEM
ADR
END
Rectangles
MODULE
SCC
NW
Ceres
nRF24L01
version
PR
IMPORT
SYSTEM
Kernel
CONST
swi
spiData
spiCtrl
netSelect
spiFast
netEnable
HdrSize
MaxPayload
SubPacket
Wait
SendTries
MaxPacket
HdrSize
MaxPayload
SubPacket
DIV
SubPacket
SubPacket
TYPE
Header
RECORD
valid
BOOLEAN
dadr
sadr
typ
BYTE
len
INTEGER
of
data
following
header
END
VAR
filter
BOOLEAN
Adr
BYTE
rcvd
INTEGER
rx
RECORD
hd
Header
dat
ARRAY
MaxPacket
HdrSize
OF
BYTE
END
PROCEDURE
SPICtrl
s
SET
BEGIN
SYSTEM
PUT
spiCtrl
s
IF
netEnable
IN
s
THEN
LED
55H
ELSE
LED
END
END
SPICtrl
PROCEDURE
SPI
n
INTEGER
BEGIN
send
rcv
into
shift
reg
one
byte
or
word
at
current
speed
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
wait
until
done
END
SPI
PROCEDURE
StartCmd
cmd
INTEGER
BEGIN
SPICtrl
netSelect
SPI
cmd
END
StartCmd
PROCEDURE
WriteReg1
reg
dat
INTEGER
disables
radio
BEGIN
StartCmd
reg
20H
SPI
dat
SPICtrl
W
REGISTER
END
WriteReg1
PROCEDURE
SubRcv
dst
INTEGER
VAR
i
dat
INTEGER
BEGIN
StartCmd
061H
R
RX
PAYLOAD
disables
radio
SPICtrl
netSelect
spiFast
FOR
i
TO
SubPacket
BY
DO
SPI
SYSTEM
GET
spiData
dat
SYSTEM
PUT
dst
i
dat
END
SPICtrl
WriteReg1
40H
done
STATUS
clear
RX
DR
SPICtrl
netEnable
enable
radio
END
SubRcv
PROCEDURE
SubSnd
src
INTEGER
VAR
timeout
BOOLEAN
VAR
i
dat
res
t1
try
INTEGER
x
status
BYTE
BEGIN
already
in
xmit
mode
StartCmd
0A0H
W
TX
PAYLOAD
SPICtrl
netSelect
spiFast
FOR
i
TO
SubPacket
BY
DO
SYSTEM
GET
src
i
dat
SPI
dat
END
SPICtrl
end
W
TX
PAYLOAD
command
try
SPICtrl
netEnable
netSelect
start
xmit
pulse
start
NOP
cmd
REPEAT
t1
Kernel
Time
Wait
REPEAT
wait
for
sent
or
retransmits
exceeded
SPI
0FFH
SYSTEM
GET
spiData
status
NOP
res
status
DIV
10H
MOD
SPICtrl
SPICtrl
netSelect
end
restart
NOP
cmd
end
10us
pulse
on
enable
UNTIL
res
IF
res
THEN
WriteReg1
20H
TX
DS
sent
ack
received
reset
it
ELSIF
res
THEN
WriteReg1
10H
INC
try
MAX
RT
retransmits
exceeded
reset
it
IF
try
SendTries
THEN
res
ELSE
REPEAT
UNTIL
Kernel
Time
t1
SPICtrl
netEnable
netSelect
start
xmit
pulse
start
NOP
cmd
again
END
END
UNTIL
res
timeout
res
END
SubSnd
PROCEDURE
Flush
BEGIN
StartCmd
0E1H
SPICtrl
StartCmd
0E2H
SPICtrl
FLUSH
TX
FLUSH
RX
END
Flush
PROCEDURE
ResetRcv
BEGIN
SYSTEM
PUT
SYSTEM
ADR
rx
rx
hd
len
rcvd
END
ResetRcv
PROCEDURE
Listen
b
BOOLEAN
BEGIN
WriteReg1
07EH
ORD
b
CONFIG
mask
ints
EN
CRC
byte
PWR
UP
PRX
PTX
WriteReg1
70H
STATUS
clear
ints
IF
b
THEN
SPICtrl
netEnable
END
turn
radio
on
END
Listen
PROCEDURE
Start
filt
BOOLEAN
VAR
n
INTEGER
BEGIN
filter
filt
Adr
SYSTEM
GET
swi
n
n
n
DIV
MOD
10H
WriteReg1
n
RF
CH
channel
WriteReg1
07H
RF
SETUP
1Mb
for
better
range
0dBm
WriteReg1
11H
SubPacket
RX
PW
P0
pipe
payload
width
Flush
Listen
TRUE
ResetRcv
END
Start
PROCEDURE
SendPacket
VAR
head
Header
dat
ARRAY
OF
BYTE
VAR
len
i
off
INTEGER
timeout
BOOLEAN
payload
ARRAY
SubPacket
OF
BYTE
BEGIN
let
any
receive
ack
finish
before
turning
radio
off
i
Kernel
Time
Wait
REPEAT
SPICtrl
netEnable
netSelect
SPI
0FFH
SPICtrl
netEnable
NOP
UNTIL
Kernel
Time
i
IF
Adr
THEN
Adr
i
MOD
100H
END
Listen
FALSE
head
sadr
Adr
head
valid
TRUE
SYSTEM
COPY
SYSTEM
ADR
head
SYSTEM
ADR
payload
HdrSize
DIV
i
HdrSize
off
len
head
len
WHILE
len
i
SubPacket
DO
payload
i
dat
off
INC
i
INC
off
DEC
len
END
WHILE
i
SubPacket
DO
payload
i
INC
i
END
SubSnd
SYSTEM
ADR
payload
timeout
WHILE
timeout
len
DO
i
send
the
rest
WHILE
len
i
SubPacket
DO
payload
i
dat
off
INC
i
INC
off
DEC
len
END
WHILE
i
SubPacket
DO
payload
i
INC
i
END
SubSnd
SYSTEM
ADR
payload
timeout
END
Listen
TRUE
END
SendPacket
PROCEDURE
Available
INTEGER
BEGIN
packet
already
rcvd
RETURN
rx
hd
len
rcvd
END
Available
PROCEDURE
Receive
VAR
x
BYTE
BEGIN
packet
already
rcvd
IF
rcvd
rx
hd
len
THEN
x
rx
dat
rcvd
INC
rcvd
ELSE
x
END
END
Receive
PROCEDURE
Rcvd
time
INTEGER
BOOLEAN
VAR
status
fifoStatus
BYTE
rcvd
BOOLEAN
BEGIN
time
time
Kernel
Time
REPEAT
SPICtrl
netEnable
netSelect
SPI
17H
R
REGISTER
FIFO
STATUS
SYSTEM
GET
spiData
status
SPI
SYSTEM
GET
spiData
fifoStatus
SPICtrl
netEnable
rcvd
ODD
status
DIV
40H
OR
ODD
fifoStatus
RX
DR
data
ready
or
RX
FIFO
not
empty
UNTIL
rcvd
OR
Kernel
Time
time
RETURN
rcvd
END
Rcvd
PROCEDURE
ReceiveHead
VAR
head
Header
actually
recv
whole
packet
VAR
adr
n
INTEGER
BEGIN
head
valid
FALSE
IF
Rcvd
THEN
ResetRcv
adr
SYSTEM
ADR
rx
SubRcv
adr
n
rx
hd
len
HdrSize
DIV
SubPacket
IF
rx
hd
len
MaxPayload
rx
hd
dadr
0FFH
OR
filter
OR
Adr
OR
rx
hd
dadr
Adr
THEN
WHILE
n
Rcvd
Wait
DO
INC
adr
SubPacket
SubRcv
adr
DEC
n
END
rx
hd
valid
n
ELSE
WHILE
Rcvd
Wait
DO
SubRcv
adr
END
ResetRcv
discard
packet
END
head
rx
hd
END
END
ReceiveHead
PROCEDURE
Skip
m
INTEGER
VAR
dmy
BYTE
BEGIN
WHILE
m
DO
Receive
dmy
DEC
m
END
END
Skip
PROCEDURE
Stop
BEGIN
SPICtrl
Flush
ResetRcv
END
Stop
BEGIN
Start
TRUE
END
SCC
MODULE
System
JG
NW
NW
IMPORT
SYSTEM
Kernel
FileDir
Files
Modules
Input
Display
Viewers
Fonts
Texts
Oberon
MenuViewers
TextFrames
CONST
StandardMenu
System
Close
System
Copy
System
Grow
Edit
Search
Edit
Store
LogMenu
Edit
Locate
Edit
Search
System
Copy
System
Grow
System
Clear
VAR
W
Texts
Writer
pat
ARRAY
OF
CHAR
PROCEDURE
GetArg
VAR
S
Texts
Scanner
VAR
T
Texts
Text
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
END
GetArg
PROCEDURE
EndLine
BEGIN
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
EndLine
Toolbox
for
system
control
PROCEDURE
SetUser
VAR
i
INTEGER
ch
CHAR
user
ARRAY
OF
CHAR
password
ARRAY
OF
CHAR
BEGIN
i
Input
Read
ch
WHILE
ch
i
DO
user
i
ch
INC
i
Input
Read
ch
END
user
i
0X
i
Input
Read
ch
WHILE
ch
i
DO
password
i
ch
INC
i
Input
Read
ch
END
password
i
0X
Oberon
SetUser
user
password
END
SetUser
PROCEDURE
SetFont
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Oberon
SetFont
Fonts
This
S
s
END
END
SetFont
PROCEDURE
SetColor
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
Oberon
SetColor
S
i
END
END
SetColor
PROCEDURE
SetOffset
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
Oberon
SetOffset
S
i
END
END
SetOffset
PROCEDURE
Date
VAR
S
Texts
Scanner
dt
hr
min
sec
yr
mo
day
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
set
clock
day
S
i
Texts
Scan
S
mo
S
i
Texts
Scan
S
yr
S
i
Texts
Scan
S
hr
S
i
Texts
Scan
S
min
S
i
Texts
Scan
S
sec
S
i
dt
yr
mo
day
hr
min
sec
Kernel
SetClock
dt
ELSE
read
clock
Texts
WriteString
W
System
Clock
dt
Oberon
Clock
Texts
WriteClock
W
dt
EndLine
END
END
Date
PROCEDURE
Collect
BEGIN
Oberon
Collect
END
Collect
Toolbox
for
standard
display
PROCEDURE
Open
open
viewer
in
system
track
VAR
X
Y
INTEGER
V
Viewers
Viewer
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Clear
clear
Log
VAR
T
Texts
Text
F
Display
Frame
buf
Texts
Buffer
BEGIN
F
Oberon
Par
frame
IF
F
NIL
F
next
IS
TextFrames
Frame
F
Oberon
Par
vwr
dsc
THEN
NEW
buf
Texts
OpenBuf
buf
T
F
next
TextFrames
Frame
text
Texts
Delete
T
T
len
buf
END
END
Clear
PROCEDURE
Close
VAR
V
Viewers
Viewer
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
V
Oberon
Par
vwr
ELSE
V
Oberon
MarkedViewer
END
Viewers
Close
V
END
Close
PROCEDURE
CloseTrack
VAR
V
Viewers
Viewer
BEGIN
V
Oberon
MarkedViewer
Viewers
CloseTrack
V
X
END
CloseTrack
PROCEDURE
Recall
VAR
V
Viewers
Viewer
M
Viewers
ViewerMsg
BEGIN
Viewers
Recall
V
IF
V
NIL
V
state
THEN
Viewers
Open
V
V
X
V
Y
V
H
M
id
Viewers
restore
V
handle
V
M
END
END
Recall
PROCEDURE
Copy
VAR
V
V1
Viewers
Viewer
M
Oberon
CopyMsg
N
Viewers
ViewerMsg
BEGIN
V
Oberon
Par
vwr
V
handle
V
M
V1
M
F
Viewers
Viewer
Viewers
Open
V1
V
X
V
Y
V
H
DIV
N
id
Viewers
restore
V1
handle
V1
N
END
Copy
PROCEDURE
Grow
VAR
V
V1
Viewers
Viewer
M
Oberon
CopyMsg
N
Viewers
ViewerMsg
DW
DH
INTEGER
BEGIN
V
Oberon
Par
vwr
DW
Oberon
DisplayWidth
V
X
DH
Oberon
DisplayHeight
V
X
IF
V
H
DH
Viewers
minH
THEN
Oberon
OpenTrack
V
X
V
W
ELSIF
V
W
DW
THEN
Oberon
OpenTrack
Oberon
UserTrack
V
X
DW
END
IF
V
H
DH
Viewers
minH
OR
V
W
DW
THEN
V
handle
V
M
V1
M
F
Viewers
Viewer
Viewers
Open
V1
V
X
DH
N
id
Viewers
restore
V1
handle
V1
N
END
END
Grow
Toolbox
for
module
management
PROCEDURE
Free1
VAR
S
Texts
Scanner
BEGIN
Texts
WriteString
W
S
s
Texts
WriteString
W
unloading
Modules
Free
S
s
IF
Modules
res
THEN
Texts
WriteString
W
failed
END
EndLine
END
Free1
PROCEDURE
Free
VAR
T
Texts
Text
beg
end
time
LONGINT
S
Texts
Scanner
BEGIN
Texts
WriteString
W
System
Free
EndLine
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Free1
S
END
END
ELSE
WHILE
S
class
Texts
Name
DO
Free1
S
Texts
Scan
S
END
END
Oberon
Collect
END
Free
PROCEDURE
FreeFonts
BEGIN
Texts
WriteString
W
System
FreeFonts
Fonts
Free
EndLine
END
FreeFonts
Toolbox
of
file
system
PROCEDURE
List
name
FileDir
FileName
adr
LONGINT
VAR
cont
BOOLEAN
VAR
i0
i
j0
j
INTEGER
hp
FileDir
FileHeader
BEGIN
i
WHILE
pat
i
pat
i
name
i
DO
INC
i
END
IF
pat
i
0X
name
i
0X
THEN
i0
i
j0
i
ELSIF
pat
i
THEN
i0
i
j0
i
WHILE
name
i0
0X
DO
i
i0
j
j0
WHILE
name
i
0X
name
i
pat
j
DO
INC
i
INC
j
END
IF
pat
j
0X
THEN
IF
name
i
0X
THEN
match
j0
j
ELSE
INC
i0
END
ELSIF
pat
j
THEN
i0
i
j0
j
ELSE
INC
i0
END
END
END
IF
name
i0
0X
pat
j0
0X
THEN
found
Texts
WriteString
W
name
IF
pat
j0
THEN
option
Kernel
GetSector
adr
hp
Texts
Write
W
9X
Texts
WriteClock
W
hp
date
Texts
WriteInt
W
hp
aleng
FileDir
SectorSize
hp
bleng
FileDir
HeaderSize
length
Texts
WriteHex
W
adr
END
Texts
WriteLn
W
END
END
List
PROCEDURE
Directory
VAR
X
Y
i
INTEGER
ch
CHAR
R
Texts
Reader
T
t
Texts
Text
V
Viewers
Viewer
beg
end
time
LONGINT
pre
ARRAY
OF
CHAR
BEGIN
Texts
OpenReader
R
Oberon
Par
text
Oberon
Par
pos
Texts
Read
R
ch
WHILE
ch
DO
Texts
Read
R
ch
END
IF
ch
OR
ch
0DX
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenReader
R
T
beg
Texts
Read
R
ch
WHILE
ch
DO
Texts
Read
R
ch
END
END
END
i
WHILE
ch
DO
pat
i
ch
INC
i
Texts
Read
R
ch
END
pat
i
0X
IF
ch
THEN
pat
i
END
directory
option
i
WHILE
pat
i
DO
pre
i
pat
i
INC
i
END
pre
i
0X
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
t
TextFrames
Text
V
MenuViewers
New
TextFrames
NewMenu
System
Directory
StandardMenu
TextFrames
NewText
t
TextFrames
menuH
X
Y
FileDir
Enumerate
pre
List
Texts
Append
t
W
buf
END
Directory
PROCEDURE
CopyFiles
VAR
f
g
Files
File
Rf
Rg
Files
Rider
ch
CHAR
name
ARRAY
OF
CHAR
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
CopyFiles
EndLine
WHILE
S
class
Texts
Name
DO
name
S
s
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteString
W
copying
Texts
Append
Oberon
Log
W
buf
f
Files
Old
name
IF
f
NIL
THEN
g
Files
New
S
s
Files
Set
Rf
f
Files
Set
Rg
g
Files
Read
Rf
ch
WHILE
Rf
eof
DO
Files
Write
Rg
ch
Files
Read
Rf
ch
END
Files
Register
g
ELSE
Texts
WriteString
W
failed
END
EndLine
END
END
END
Texts
Scan
S
END
END
CopyFiles
PROCEDURE
RenameFiles
VAR
res
INTEGER
name
ARRAY
OF
CHAR
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
RenameFiles
EndLine
WHILE
S
class
Texts
Name
DO
name
S
s
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteString
W
renaming
Files
Rename
name
S
s
res
IF
res
THEN
Texts
WriteString
W
failed
END
EndLine
END
END
END
Texts
Scan
S
END
END
RenameFiles
PROCEDURE
DeleteFiles
VAR
res
INTEGER
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
DeleteFiles
EndLine
WHILE
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
Texts
WriteString
W
deleting
Files
Delete
S
s
res
IF
res
THEN
Texts
WriteString
W
failed
END
EndLine
Texts
Scan
S
END
END
DeleteFiles
Toolbox
for
system
inspection
PROCEDURE
Watch
BEGIN
Texts
WriteString
W
System
Watch
Texts
WriteLn
W
Texts
WriteString
W
Modules
space
bytes
Texts
WriteInt
W
Modules
AllocPtr
Texts
WriteInt
W
Modules
AllocPtr
DIV
Kernel
heapOrg
Texts
Write
W
EndLine
Texts
WriteString
W
Heap
speace
Texts
WriteInt
W
Kernel
allocated
Texts
WriteInt
W
Kernel
allocated
DIV
Kernel
heapLim
Kernel
heapOrg
Texts
Write
W
EndLine
Texts
WriteString
W
Disk
sectors
Texts
WriteInt
W
Kernel
NofSectors
Texts
WriteInt
W
Kernel
NofSectors
DIV
10000H
Texts
Write
W
EndLine
Texts
WriteString
W
Tasks
Texts
WriteInt
W
Oberon
NofTasks
EndLine
END
Watch
PROCEDURE
ShowModules
VAR
T
Texts
Text
V
Viewers
Viewer
M
Modules
Module
X
Y
INTEGER
BEGIN
T
TextFrames
Text
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
System
ShowModules
StandardMenu
TextFrames
NewText
T
TextFrames
menuH
X
Y
M
Modules
root
WHILE
M
NIL
DO
IF
M
name
0X
THEN
Texts
WriteString
W
M
name
Texts
Write
W
9X
Texts
WriteHex
W
ORD
M
Texts
WriteHex
W
M
code
Texts
WriteInt
W
M
refcnt
ELSE
Texts
WriteString
W
END
Texts
WriteLn
W
M
M
next
END
Texts
Append
T
W
buf
END
ShowModules
PROCEDURE
ShowCommands
VAR
M
Modules
Module
comadr
LONGINT
ch
CHAR
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
X
Y
INTEGER
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Modules
Load
S
s
M
IF
M
NIL
THEN
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
T
TextFrames
Text
V
MenuViewers
New
TextFrames
NewMenu
System
Commands
StandardMenu
TextFrames
NewText
T
TextFrames
menuH
X
Y
comadr
M
cmd
SYSTEM
GET
comadr
ch
INC
comadr
WHILE
ch
0X
DO
Texts
WriteString
W
S
s
Texts
Write
W
REPEAT
Texts
Write
W
ch
SYSTEM
GET
comadr
ch
INC
comadr
UNTIL
ch
0X
WHILE
comadr
MOD
DO
INC
comadr
END
Texts
WriteLn
W
INC
comadr
SYSTEM
GET
comadr
ch
INC
comadr
END
Texts
Append
T
W
buf
END
END
END
ShowCommands
PROCEDURE
ShowFonts
VAR
fnt
Fonts
Font
BEGIN
Texts
WriteString
W
System
ShowFonts
Texts
WriteLn
W
fnt
Fonts
root
WHILE
fnt
NIL
DO
Texts
Write
W
9X
Texts
WriteString
W
fnt
name
Texts
WriteLn
W
fnt
fnt
next
END
Texts
Append
Oberon
Log
W
buf
END
ShowFonts
PROCEDURE
OpenViewers
VAR
logV
toolV
Viewers
Viewer
menu
main
Display
Frame
d
LONGINT
X
Y
INTEGER
BEGIN
d
Kernel
Clock
Texts
WriteString
W
Oberon
V5
NW
EndLine
Oberon
AllocateSystemViewer
X
Y
menu
TextFrames
NewMenu
System
Log
LogMenu
main
TextFrames
NewText
Oberon
Log
logV
MenuViewers
New
menu
main
TextFrames
menuH
X
Y
Oberon
AllocateSystemViewer
X
Y
menu
TextFrames
NewMenu
System
Tool
StandardMenu
main
TextFrames
NewText
TextFrames
Text
System
Tool
toolV
MenuViewers
New
menu
main
TextFrames
menuH
X
Y
END
OpenViewers
PROCEDURE
ExtendDisplay
VAR
V
Viewers
Viewer
X
Y
DX
DW
DH
INTEGER
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
DX
Viewers
curW
DW
Oberon
DisplayWidth
DX
DH
Oberon
DisplayHeight
DX
Oberon
OpenDisplay
DW
DIV
DW
DIV
DH
Oberon
AllocateSystemViewer
DX
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
ExtendDisplay
PROCEDURE
Trap
VAR
a
INTEGER
b
INTEGER
VAR
u
v
w
INTEGER
mod
Modules
Module
BEGIN
u
SYSTEM
REG
SYSTEM
GET
u
v
w
v
DIV
10H
MOD
10H
trap
number
IF
w
THEN
Kernel
New
a
b
ELSE
trap
Texts
WriteLn
W
Texts
WriteString
W
pos
Texts
WriteInt
W
v
DIV
100H
MOD
10000H
Texts
WriteString
W
TRAP
Texts
WriteInt
W
w
mod
Modules
root
WHILE
mod
NIL
u
mod
code
OR
u
mod
imp
DO
mod
mod
next
END
IF
mod
NIL
THEN
Texts
WriteString
W
in
Texts
WriteString
W
mod
name
END
Texts
WriteString
W
at
Texts
WriteHex
W
u
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Oberon
Reset
END
END
Trap
PROCEDURE
Abort
VAR
n
INTEGER
BEGIN
n
SYSTEM
REG
Texts
WriteString
W
ABORT
Texts
WriteHex
W
n
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Oberon
Reset
END
Abort
BEGIN
Texts
OpenWriter
W
Oberon
OpenLog
TextFrames
Text
OpenViewers
Kernel
Install
SYSTEM
ADR
Trap
20H
Kernel
Install
SYSTEM
ADR
Abort
END
System
MODULE
TextFrames
JG
NW
IMPORT
Modules
Input
Display
Viewers
Fonts
Texts
Oberon
MenuViewers
CONST
replace
insert
delete
unmark
message
id
BS
8X
TAB
9X
CR
0DX
DEL
7FX
TYPE
Line
POINTER
TO
LineDesc
LineDesc
RECORD
len
LONGINT
wid
INTEGER
eot
BOOLEAN
next
Line
END
Location
RECORD
org
pos
LONGINT
dx
x
y
INTEGER
lin
Line
END
Frame
POINTER
TO
FrameDesc
FrameDesc
RECORD
Display
FrameDesc
text
Texts
Text
org
LONGINT
col
INTEGER
lsp
INTEGER
left
right
top
bot
INTEGER
markH
INTEGER
time
LONGINT
hasCar
hasSel
hasMark
BOOLEAN
carloc
Location
selbeg
selend
Location
trailer
Line
END
UpdateMsg
RECORD
Display
FrameMsg
id
INTEGER
text
Texts
Text
beg
end
LONGINT
END
CopyOverMsg
RECORD
Display
FrameMsg
text
Texts
Text
beg
end
LONGINT
END
VAR
TBuf
DelBuf
Texts
Buffer
menuH
barW
left
right
top
bot
lsp
INTEGER
standard
sizes
asr
dsr
selH
markW
eolW
INTEGER
nextCh
CHAR
ScrollMarker
Oberon
Marker
W
KW
Texts
Writer
keyboard
writer
PROCEDURE
Min
i
j
INTEGER
INTEGER
BEGIN
IF
i
j
THEN
j
i
END
RETURN
j
END
Min
display
support
PROCEDURE
ReplConst
col
INTEGER
F
Frame
X
Y
W
H
INTEGER
mode
INTEGER
BEGIN
IF
X
W
F
X
F
W
THEN
Display
ReplConst
col
X
Y
W
H
mode
ELSIF
X
F
X
F
W
THEN
Display
ReplConst
col
X
Y
F
X
F
W
X
H
mode
END
END
ReplConst
PROCEDURE
FlipSM
X
Y
INTEGER
VAR
DW
DH
CL
INTEGER
BEGIN
DW
Display
Width
DH
Display
Height
CL
DW
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
updown
X
Y
Display
invert
END
FlipSM
PROCEDURE
UpdateMark
F
Frame
in
scroll
bar
VAR
oldH
INTEGER
BEGIN
oldH
F
markH
F
markH
F
org
F
H
DIV
F
text
len
IF
F
hasMark
F
left
barW
F
markH
oldH
THEN
Display
ReplConst
Display
white
F
X
F
Y
F
H
oldH
markW
Display
invert
Display
ReplConst
Display
white
F
X
F
Y
F
H
F
markH
markW
Display
invert
END
END
UpdateMark
PROCEDURE
SetChangeMark
F
Frame
on
BOOLEAN
in
corner
BEGIN
IF
F
H
menuH
THEN
IF
on
THEN
Display
CopyPattern
Display
white
Display
block
F
X
F
W
F
Y
F
H
Display
paint
ELSE
Display
ReplConst
F
col
F
X
F
W
F
Y
F
H
Display
replace
END
END
END
SetChangeMark
PROCEDURE
Width
VAR
R
Texts
Reader
len
LONGINT
INTEGER
VAR
patadr
pos
LONGINT
ox
dx
x
y
w
h
INTEGER
BEGIN
pos
ox
WHILE
pos
len
DO
Fonts
GetPat
R
fnt
nextCh
dx
x
y
w
h
patadr
ox
ox
dx
INC
pos
Texts
Read
R
nextCh
END
RETURN
ox
END
Width
PROCEDURE
DisplayLine
F
Frame
L
Line
VAR
R
Texts
Reader
X
Y
INTEGER
len
LONGINT
VAR
patadr
NX
dx
x
y
w
h
INTEGER
BEGIN
NX
F
X
F
W
WHILE
nextCh
CR
R
fnt
NIL
DO
Fonts
GetPat
R
fnt
nextCh
dx
x
y
w
h
patadr
IF
X
x
w
NX
h
THEN
Display
CopyPattern
R
col
patadr
X
x
Y
y
Display
invert
END
X
X
dx
INC
len
Texts
Read
R
nextCh
END
L
len
len
L
wid
X
eolW
F
X
F
left
L
eot
R
fnt
NIL
Texts
Read
R
nextCh
END
DisplayLine
PROCEDURE
Validate
T
Texts
Text
VAR
pos
LONGINT
VAR
R
Texts
Reader
BEGIN
IF
pos
T
len
THEN
pos
T
len
ELSIF
pos
THEN
DEC
pos
Texts
OpenReader
R
T
pos
REPEAT
Texts
Read
R
nextCh
INC
pos
UNTIL
R
eot
OR
nextCh
CR
ELSE
pos
END
END
Validate
PROCEDURE
Mark
F
Frame
on
BOOLEAN
BEGIN
IF
F
H
F
left
barW
F
hasMark
on
OR
F
hasMark
on
THEN
Display
ReplConst
Display
white
F
X
F
Y
F
H
F
markH
markW
Display
invert
END
F
hasMark
on
END
Mark
PROCEDURE
Restore
F
Frame
VAR
R
Texts
Reader
L
l
Line
curY
botY
INTEGER
BEGIN
Display
ReplConst
F
col
F
X
F
Y
F
W
F
H
Display
replace
IF
F
left
barW
THEN
Display
ReplConst
Display
white
F
X
barW
F
Y
F
H
Display
invert
END
Validate
F
text
F
org
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
F
org
Texts
Read
R
nextCh
L
F
trailer
curY
F
Y
F
H
F
top
asr
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
F
markH
F
org
F
H
DIV
F
text
len
END
Restore
PROCEDURE
Suspend
F
Frame
BEGIN
F
trailer
next
F
trailer
END
Suspend
PROCEDURE
Extend
F
Frame
newY
INTEGER
VAR
R
Texts
Reader
L
l
Line
org
LONGINT
curY
botY
INTEGER
BEGIN
Display
ReplConst
F
col
F
X
newY
F
W
F
Y
newY
Display
replace
IF
F
left
barW
THEN
Display
ReplConst
Display
white
F
X
barW
newY
F
Y
newY
Display
invert
END
botY
F
Y
F
bot
dsr
F
H
F
H
F
Y
newY
F
Y
newY
IF
F
trailer
next
F
trailer
THEN
Validate
F
text
F
org
END
L
F
trailer
org
F
org
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
org
org
L
len
curY
curY
lsp
END
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
F
markH
F
org
F
H
DIV
F
text
len
END
Extend
PROCEDURE
Reduce
F
Frame
newY
INTEGER
VAR
L
Line
curY
botY
INTEGER
BEGIN
F
H
F
H
F
Y
newY
F
Y
newY
botY
F
Y
F
bot
dsr
L
F
trailer
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
curY
curY
lsp
END
L
next
F
trailer
IF
curY
asr
F
Y
THEN
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
asr
F
Y
Display
replace
END
F
markH
F
org
F
H
DIV
F
text
len
Mark
F
TRUE
END
Reduce
PROCEDURE
Show
F
Frame
pos
LONGINT
VAR
R
Texts
Reader
L
L0
Line
org
LONGINT
curY
botY
Y0
INTEGER
BEGIN
IF
F
trailer
next
F
trailer
THEN
Validate
F
text
pos
IF
pos
F
org
THEN
Mark
F
FALSE
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
F
H
Display
replace
botY
F
Y
F
Y
F
Y
F
H
F
H
F
org
pos
F
trailer
next
F
trailer
Extend
F
botY
Mark
F
TRUE
ELSIF
pos
F
org
THEN
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
org
pos
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
org
pos
THEN
F
org
org
F
trailer
next
L
Y0
curY
WHILE
L
next
F
trailer
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
Display
CopyBlock
F
X
F
left
curY
dsr
F
W
F
left
Y0
asr
curY
dsr
F
X
F
left
curY
dsr
F
Y
F
H
F
top
asr
Y0
curY
curY
F
Y
F
H
F
top
asr
Y0
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
dsr
F
Y
Display
replace
botY
F
Y
F
bot
dsr
org
org
L
len
curY
curY
lsp
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
L0
DisplayLine
F
L0
R
F
X
F
left
curY
L
next
L0
L
L0
curY
curY
lsp
END
L
next
F
trailer
UpdateMark
F
ELSE
Mark
F
FALSE
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
F
H
Display
replace
botY
F
Y
F
Y
F
Y
F
H
F
H
F
org
pos
F
trailer
next
F
trailer
Extend
F
botY
Mark
F
TRUE
END
END
END
SetChangeMark
F
F
text
changed
END
Show
PROCEDURE
LocateLine
F
Frame
y
INTEGER
VAR
loc
Location
VAR
L
Line
org
LONGINT
cury
INTEGER
BEGIN
org
F
org
L
F
trailer
next
cury
F
H
F
top
asr
WHILE
L
next
F
trailer
cury
y
dsr
DO
org
org
L
len
L
L
next
cury
cury
lsp
END
loc
org
org
loc
lin
L
loc
y
cury
END
LocateLine
PROCEDURE
LocateString
F
Frame
x
y
INTEGER
VAR
loc
Location
VAR
R
Texts
Reader
patadr
bpos
pos
lim
LONGINT
bx
ex
ox
dx
u
v
w
h
INTEGER
BEGIN
LocateLine
F
y
loc
lim
loc
org
loc
lin
len
bpos
loc
org
bx
F
left
pos
loc
org
ox
F
left
Texts
OpenReader
R
F
text
loc
org
Texts
Read
R
nextCh
REPEAT
WHILE
pos
lim
nextCh
DO
scan
string
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
END
ex
ox
WHILE
pos
lim
nextCh
DO
scan
gap
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
END
IF
pos
lim
ox
x
THEN
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
bpos
pos
bx
ox
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
ELSE
pos
lim
END
UNTIL
pos
lim
loc
pos
bpos
loc
dx
ex
bx
loc
x
bx
END
LocateString
PROCEDURE
LocateChar
F
Frame
x
y
INTEGER
VAR
loc
Location
VAR
R
Texts
Reader
patadr
pos
lim
LONGINT
ox
dx
u
v
w
h
INTEGER
BEGIN
LocateLine
F
y
loc
lim
loc
org
loc
lin
len
pos
loc
org
ox
F
left
dx
eolW
Texts
OpenReader
R
F
text
loc
org
WHILE
pos
lim
DO
Texts
Read
R
nextCh
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
IF
ox
dx
x
THEN
INC
pos
ox
ox
dx
IF
pos
lim
THEN
dx
eolW
END
ELSE
lim
pos
END
END
loc
pos
pos
loc
dx
dx
loc
x
ox
END
LocateChar
PROCEDURE
LocatePos
F
Frame
pos
LONGINT
VAR
loc
Location
VAR
T
Texts
Text
R
Texts
Reader
L
Line
org
LONGINT
cury
INTEGER
BEGIN
T
F
text
org
F
org
L
F
trailer
next
cury
F
H
F
top
asr
IF
pos
org
THEN
pos
org
END
WHILE
L
next
F
trailer
pos
org
L
len
DO
org
org
L
len
L
L
next
cury
cury
lsp
END
IF
pos
org
L
len
THEN
pos
org
L
len
END
Texts
OpenReader
R
T
org
Texts
Read
R
nextCh
loc
org
org
loc
pos
pos
loc
lin
L
loc
x
F
left
Width
R
pos
org
loc
y
cury
END
LocatePos
PROCEDURE
Pos
F
Frame
X
Y
INTEGER
LONGINT
VAR
loc
Location
BEGIN
LocateChar
F
X
F
X
Y
F
Y
loc
RETURN
loc
pos
END
Pos
PROCEDURE
FlipCaret
F
Frame
BEGIN
IF
F
carloc
x
F
W
F
carloc
y
F
carloc
x
F
W
THEN
Display
CopyPattern
Display
white
Display
hook
F
X
F
carloc
x
F
Y
F
carloc
y
Display
invert
END
END
FlipCaret
PROCEDURE
SetCaret
F
Frame
pos
LONGINT
BEGIN
LocatePos
F
pos
F
carloc
FlipCaret
F
F
hasCar
TRUE
END
SetCaret
PROCEDURE
TrackCaret
F
Frame
X
Y
INTEGER
VAR
keysum
SET
VAR
loc
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateChar
F
X
F
X
Y
F
Y
F
carloc
FlipCaret
F
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateChar
F
X
F
X
Y
F
Y
loc
IF
loc
pos
F
carloc
pos
THEN
FlipCaret
F
F
carloc
loc
FlipCaret
F
END
UNTIL
keys
F
hasCar
TRUE
END
END
TrackCaret
PROCEDURE
RemoveCaret
F
Frame
BEGIN
IF
F
hasCar
THEN
FlipCaret
F
F
hasCar
FALSE
END
END
RemoveCaret
PROCEDURE
FlipSelection
F
Frame
VAR
beg
end
Location
VAR
L
Line
Y
INTEGER
BEGIN
L
beg
lin
Y
F
Y
beg
y
IF
L
end
lin
THEN
ReplConst
Display
white
F
F
X
beg
x
Y
end
x
beg
x
selH
Display
invert
ELSE
ReplConst
Display
white
F
F
X
beg
x
Y
F
left
L
wid
beg
x
selH
Display
invert
L
L
next
Y
Y
lsp
WHILE
L
end
lin
DO
ReplConst
Display
white
F
F
X
F
left
Y
L
wid
selH
Display
invert
L
L
next
Y
Y
lsp
END
ReplConst
Display
white
F
F
X
F
left
Y
end
x
F
left
selH
Display
invert
END
END
FlipSelection
PROCEDURE
SetSelection
F
Frame
beg
end
LONGINT
BEGIN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
END
LocatePos
F
beg
F
selbeg
LocatePos
F
end
F
selend
IF
F
selbeg
pos
F
selend
pos
THEN
FlipSelection
F
F
selbeg
F
selend
F
time
Oberon
Time
F
hasSel
TRUE
END
END
SetSelection
PROCEDURE
TrackSelection
F
Frame
X
Y
INTEGER
VAR
keysum
SET
VAR
loc
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
END
LocateChar
F
X
F
X
Y
F
Y
loc
IF
F
hasSel
loc
pos
F
selbeg
pos
F
selend
pos
F
selbeg
pos
THEN
LocateChar
F
F
left
Y
F
Y
F
selbeg
ELSE
F
selbeg
loc
END
INC
loc
pos
loc
x
loc
x
loc
dx
F
selend
loc
FlipSelection
F
F
selbeg
F
selend
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateChar
F
X
F
X
Y
F
Y
loc
IF
loc
pos
F
selbeg
pos
THEN
loc
F
selbeg
END
INC
loc
pos
loc
x
loc
x
loc
dx
IF
loc
pos
F
selend
pos
THEN
FlipSelection
F
loc
F
selend
F
selend
loc
ELSIF
loc
pos
F
selend
pos
THEN
FlipSelection
F
F
selend
loc
F
selend
loc
END
UNTIL
keys
F
time
Oberon
Time
F
hasSel
TRUE
END
END
TrackSelection
PROCEDURE
RemoveSelection
F
Frame
BEGIN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
F
hasSel
FALSE
END
END
RemoveSelection
PROCEDURE
TrackLine
F
Frame
X
Y
INTEGER
VAR
org
LONGINT
VAR
keysum
SET
VAR
old
new
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateLine
F
Y
F
Y
old
ReplConst
Display
white
F
F
X
F
left
F
Y
old
y
dsr
old
lin
wid
Display
invert
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouse
ScrollMarker
X
Y
LocateLine
F
Y
F
Y
new
IF
new
org
old
org
THEN
ReplConst
Display
white
F
F
X
F
left
F
Y
old
y
dsr
old
lin
wid
Display
invert
ReplConst
Display
white
F
F
X
F
left
F
Y
new
y
dsr
new
lin
wid
Display
invert
old
new
END
UNTIL
keys
ReplConst
Display
white
F
F
X
F
left
F
Y
new
y
dsr
new
lin
wid
Display
invert
org
new
org
ELSE
org
END
END
TrackLine
PROCEDURE
TrackWord
F
Frame
X
Y
INTEGER
VAR
pos
LONGINT
VAR
keysum
SET
VAR
old
new
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateString
F
X
F
X
Y
F
Y
old
ReplConst
Display
white
F
F
X
old
x
F
Y
old
y
dsr
old
dx
Display
invert
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateString
F
X
F
X
Y
F
Y
new
IF
new
pos
old
pos
THEN
ReplConst
Display
white
F
F
X
old
x
F
Y
old
y
dsr
old
dx
Display
invert
ReplConst
Display
white
F
F
X
new
x
F
Y
new
y
dsr
new
dx
Display
invert
old
new
END
UNTIL
keys
ReplConst
Display
white
F
F
X
new
x
F
Y
new
y
dsr
new
dx
Display
invert
pos
new
pos
ELSE
pos
END
END
TrackWord
PROCEDURE
Replace
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
Line
org
len
LONGINT
curY
wid
INTEGER
BEGIN
IF
end
F
org
THEN
IF
beg
F
org
THEN
beg
F
org
END
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
len
beg
org
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
curY
dsr
L
wid
wid
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
wid
curY
len
org
org
L
len
L
L
next
curY
curY
lsp
WHILE
L
F
trailer
org
end
DO
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
curY
org
org
L
len
L
L
next
curY
curY
lsp
END
END
END
UpdateMark
F
END
Replace
PROCEDURE
Insert
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
L0
l
Line
org
len
LONGINT
curY
botY
Y0
Y1
Y2
dY
wid
INTEGER
BEGIN
IF
beg
F
org
THEN
F
org
F
org
end
beg
ELSE
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
len
beg
org
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
curY
dsr
L
wid
wid
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
wid
curY
len
org
org
L
len
curY
curY
lsp
Y0
curY
L0
L
next
WHILE
org
end
curY
botY
DO
NEW
l
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
org
org
L
len
curY
curY
lsp
END
IF
L0
L
next
THEN
Y1
curY
L
next
L0
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
curY
curY
lsp
END
L
next
F
trailer
dY
Y0
Y1
IF
Y1
curY
dY
THEN
Display
CopyBlock
F
X
F
left
curY
dY
lsp
dsr
F
W
F
left
Y1
curY
dY
F
X
F
left
curY
lsp
dsr
Y2
Y1
dY
ELSE
Y2
curY
END
curY
Y1
L
L0
WHILE
curY
Y2
DO
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
curY
L
L
next
curY
curY
lsp
END
END
END
END
UpdateMark
F
END
Insert
PROCEDURE
Delete
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
L0
l
Line
org
org0
len
LONGINT
curY
botY
Y0
Y1
wid
INTEGER
BEGIN
IF
end
F
org
THEN
F
org
F
org
end
beg
ELSE
IF
beg
F
org
THEN
F
trailer
next
len
F
trailer
next
len
F
org
beg
F
org
beg
END
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
botY
F
Y
F
bot
dsr
org0
org
L0
L
Y0
curY
WHILE
L
F
trailer
org
end
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
Y1
curY
Texts
OpenReader
R
F
text
org0
Texts
Read
R
nextCh
len
beg
org0
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
Y0
dsr
L0
wid
wid
lsp
Display
replace
DisplayLine
F
L0
R
F
X
F
left
wid
Y0
len
Y0
Y0
lsp
IF
L
L0
next
THEN
L0
next
L
L
L0
org
org0
L0
len
WHILE
L
next
F
trailer
DO
L
L
next
org
org
L
len
curY
curY
lsp
END
Display
CopyBlock
F
X
F
left
curY
lsp
dsr
F
W
F
left
Y1
curY
F
X
F
left
curY
lsp
dsr
Y0
Y1
curY
curY
Y0
Y1
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
lsp
F
Y
dsr
Display
replace
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
END
END
END
UpdateMark
F
END
Delete
PROCEDURE
Recall
VAR
B
Texts
Buffer
BEGIN
B
TBuf
NEW
TBuf
Texts
OpenBuf
TBuf
END
Recall
message
handling
PROCEDURE
RemoveMarks
F
Frame
BEGIN
RemoveCaret
F
RemoveSelection
F
END
RemoveMarks
PROCEDURE
NotifyDisplay
T
Texts
Text
op
INTEGER
beg
end
LONGINT
VAR
M
UpdateMsg
BEGIN
M
id
op
M
text
T
M
beg
beg
M
end
end
Viewers
Broadcast
M
END
NotifyDisplay
PROCEDURE
Call
F
Frame
pos
LONGINT
new
BOOLEAN
VAR
S
Texts
Scanner
res
INTEGER
BEGIN
Texts
OpenScanner
S
F
text
pos
Texts
Scan
S
IF
S
class
Texts
Name
S
line
THEN
Oberon
SetPar
F
F
text
pos
S
len
Oberon
Call
S
s
res
IF
res
THEN
Texts
WriteString
W
Call
error
Texts
WriteString
W
Modules
importing
IF
res
THEN
Texts
WriteString
W
module
not
found
ELSIF
res
THEN
Texts
WriteString
W
bad
version
ELSIF
res
THEN
Texts
WriteString
W
imports
Texts
WriteString
W
Modules
imported
Texts
WriteString
W
with
bad
key
ELSIF
res
THEN
Texts
WriteString
W
corrupted
obj
file
ELSIF
res
THEN
Texts
WriteString
W
command
not
found
ELSIF
res
THEN
Texts
WriteString
W
insufficient
space
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
END
Call
PROCEDURE
Write
F
Frame
ch
CHAR
fnt
Fonts
Font
col
voff
INTEGER
VAR
buf
Texts
Buffer
BEGIN
F
hasCar
IF
ch
BS
THEN
backspace
IF
F
carloc
pos
F
org
THEN
Texts
Delete
F
text
F
carloc
pos
F
carloc
pos
DelBuf
SetCaret
F
F
carloc
pos
END
ELSIF
ch
3X
THEN
ctrl
c
copy
IF
F
hasSel
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Save
F
text
F
selbeg
pos
F
selend
pos
TBuf
END
ELSIF
ch
16X
THEN
ctrl
v
paste
NEW
buf
Texts
OpenBuf
buf
Texts
Copy
TBuf
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
TBuf
len
ELSIF
ch
18X
THEN
ctrl
x
cut
IF
F
hasSel
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Delete
F
text
F
selbeg
pos
F
selend
pos
TBuf
END
ELSIF
20X
ch
ch
DEL
OR
ch
CR
OR
ch
TAB
THEN
KW
fnt
fnt
KW
col
col
KW
voff
voff
Texts
Write
KW
ch
Texts
Insert
F
text
F
carloc
pos
KW
buf
SetCaret
F
F
carloc
pos
END
END
Write
PROCEDURE
Defocus
F
Frame
BEGIN
RemoveCaret
F
END
Defocus
PROCEDURE
Neutralize
F
Frame
BEGIN
RemoveMarks
F
END
Neutralize
PROCEDURE
Modify
F
Frame
id
dY
Y
H
INTEGER
BEGIN
Mark
F
FALSE
RemoveMarks
F
SetChangeMark
F
FALSE
IF
id
MenuViewers
extend
THEN
IF
dY
THEN
Display
CopyBlock
F
X
F
Y
F
W
F
H
F
X
F
Y
dY
F
Y
F
Y
dY
END
Extend
F
Y
ELSIF
id
MenuViewers
reduce
THEN
Reduce
F
Y
dY
IF
dY
THEN
Display
CopyBlock
F
X
F
Y
F
W
F
H
F
X
Y
F
Y
Y
END
END
IF
F
H
THEN
Mark
F
TRUE
SetChangeMark
F
F
text
changed
END
END
Modify
PROCEDURE
Open
F
Frame
H
Display
Handler
T
Texts
Text
org
LONGINT
col
left
right
top
bot
lsp
INTEGER
VAR
L
Line
BEGIN
NEW
L
L
len
L
wid
L
eot
FALSE
L
next
L
F
handle
H
F
text
T
F
org
org
F
trailer
L
F
left
left
F
right
right
F
top
top
F
bot
bot
F
lsp
lsp
F
col
col
F
hasMark
FALSE
F
hasCar
FALSE
F
hasSel
FALSE
END
Open
PROCEDURE
Copy
F
Frame
VAR
F1
Frame
BEGIN
NEW
F1
Open
F1
F
handle
F
text
F
org
F
col
F
left
F
right
F
top
F
bot
F
lsp
END
Copy
PROCEDURE
CopyOver
F
Frame
text
Texts
Text
beg
end
LONGINT
VAR
buf
Texts
Buffer
BEGIN
IF
F
hasCar
THEN
NEW
buf
Texts
OpenBuf
buf
Texts
Save
text
beg
end
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
end
beg
END
END
CopyOver
PROCEDURE
GetSelection
F
Frame
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
BEGIN
IF
F
hasSel
THEN
IF
F
text
text
THEN
IF
F
selbeg
pos
beg
THEN
beg
F
selbeg
pos
END
leftmost
IF
F
time
time
THEN
end
F
selend
pos
time
F
time
END
last
selected
ELSIF
F
time
time
THEN
text
F
text
beg
F
selbeg
pos
end
F
selend
pos
time
F
time
END
END
END
GetSelection
PROCEDURE
Update
F
Frame
VAR
M
UpdateMsg
BEGIN
F
text
M
text
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
IF
M
id
replace
THEN
Replace
F
M
beg
M
end
ELSIF
M
id
insert
THEN
Insert
F
M
beg
M
end
ELSIF
M
id
delete
THEN
Delete
F
M
beg
M
end
END
SetChangeMark
F
F
text
changed
END
Update
PROCEDURE
Edit
F
Frame
X
Y
INTEGER
Keys
SET
VAR
M
CopyOverMsg
text
Texts
Text
buf
Texts
Buffer
v
Viewers
Viewer
beg
end
time
pos
LONGINT
keysum
SET
fnt
Fonts
Font
col
voff
INTEGER
BEGIN
IF
X
F
X
Min
F
left
barW
THEN
scroll
bar
Oberon
DrawMouse
ScrollMarker
X
Y
keysum
Keys
IF
Keys
THEN
ML
scroll
up
TrackLine
F
X
Y
pos
keysum
IF
pos
keysum
THEN
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
pos
END
ELSIF
Keys
THEN
MM
keysum
Keys
REPEAT
Input
Mouse
Keys
X
Y
keysum
keysum
Keys
Oberon
DrawMouse
ScrollMarker
X
Y
UNTIL
Keys
IF
keysum
THEN
IF
IN
keysum
THEN
pos
ELSIF
IN
keysum
THEN
pos
F
text
len
ELSE
pos
F
Y
F
H
Y
F
text
len
DIV
F
H
END
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
pos
END
ELSIF
Keys
THEN
MR
scroll
down
TrackLine
F
X
Y
pos
keysum
IF
keysum
THEN
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
F
org
pos
END
END
ELSE
text
area
Oberon
DrawMouseArrow
X
Y
IF
IN
Keys
THEN
MR
select
TrackSelection
F
X
Y
keysum
IF
F
hasSel
THEN
IF
keysum
THEN
MR
ML
delete
text
Oberon
GetSelection
text
beg
end
time
Texts
Delete
text
beg
end
TBuf
Oberon
PassFocus
Viewers
This
F
X
F
Y
SetCaret
F
beg
ELSIF
keysum
THEN
MR
MM
copy
to
caret
Oberon
GetSelection
text
beg
end
time
M
text
text
M
beg
beg
M
end
end
Oberon
FocusViewer
handle
Oberon
FocusViewer
M
END
END
ELSIF
IN
Keys
THEN
MM
call
TrackWord
F
X
Y
pos
keysum
IF
pos
IN
keysum
THEN
Call
F
pos
IN
keysum
END
ELSIF
IN
Keys
THEN
ML
set
caret
Oberon
PassFocus
Viewers
This
F
X
F
Y
TrackCaret
F
X
Y
keysum
IF
keysum
THEN
ML
MM
copy
from
selection
to
caret
Oberon
GetSelection
text
beg
end
time
IF
time
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Save
text
beg
end
TBuf
Texts
Insert
F
text
F
carloc
pos
TBuf
SetSelection
F
F
carloc
pos
F
carloc
pos
end
beg
SetCaret
F
F
carloc
pos
end
beg
ELSIF
TBuf
NIL
THEN
NEW
buf
Texts
OpenBuf
buf
Texts
Copy
TBuf
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
buf
len
END
ELSIF
keysum
THEN
ML
MR
copy
looks
Oberon
GetSelection
text
beg
end
time
IF
time
THEN
Texts
Attributes
F
text
F
carloc
pos
fnt
col
voff
IF
fnt
NIL
THEN
Texts
ChangeLooks
text
beg
end
fnt
col
voff
END
END
END
END
END
END
Edit
PROCEDURE
Handle
F
Display
Frame
VAR
M
Display
FrameMsg
VAR
F1
Frame
buf
Texts
Buffer
BEGIN
CASE
F
OF
Frame
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
Edit
F
M
X
M
Y
M
keys
ELSIF
M
id
Oberon
consume
THEN
IF
F
hasCar
THEN
Write
F
M
ch
M
fnt
M
col
M
voff
END
END
Oberon
ControlMsg
IF
M
id
Oberon
defocus
THEN
Defocus
F
ELSIF
M
id
Oberon
neutralize
THEN
Neutralize
F
END
Oberon
SelectionMsg
GetSelection
F
M
text
M
beg
M
end
M
time
Oberon
CopyMsg
Copy
F
F1
M
F
F1
MenuViewers
ModifyMsg
Modify
F
M
id
M
dY
M
Y
M
H
CopyOverMsg
CopyOver
F
M
text
M
beg
M
end
UpdateMsg
IF
F
text
M
text
THEN
Update
F
M
END
END
END
END
Handle
creation
PROCEDURE
Menu
name
commands
ARRAY
OF
CHAR
Texts
Text
VAR
T
Texts
Text
BEGIN
NEW
T
T
notify
NotifyDisplay
Texts
Open
T
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
commands
Texts
Append
T
W
buf
RETURN
T
END
Menu
PROCEDURE
Text
name
ARRAY
OF
CHAR
Texts
Text
VAR
T
Texts
Text
BEGIN
NEW
T
T
notify
NotifyDisplay
Texts
Open
T
name
RETURN
T
END
Text
PROCEDURE
NewMenu
name
commands
ARRAY
OF
CHAR
Frame
VAR
F
Frame
T
Texts
Text
BEGIN
NEW
F
T
Menu
name
commands
Open
F
Handle
T
Display
white
left
DIV
lsp
RETURN
F
END
NewMenu
PROCEDURE
NewText
text
Texts
Text
pos
LONGINT
Frame
VAR
F
Frame
BEGIN
NEW
F
Open
F
Handle
text
pos
Display
black
left
right
top
bot
lsp
RETURN
F
END
NewText
BEGIN
NEW
TBuf
NEW
DelBuf
Texts
OpenBuf
TBuf
Texts
OpenBuf
DelBuf
lsp
Fonts
Default
height
menuH
lsp
barW
menuH
left
barW
lsp
DIV
right
lsp
DIV
top
lsp
DIV
bot
lsp
DIV
asr
Fonts
Default
maxY
dsr
Fonts
Default
minY
selH
lsp
markW
lsp
DIV
eolW
lsp
DIV
ScrollMarker
Fade
FlipSM
ScrollMarker
Draw
FlipSM
Texts
OpenWriter
W
Texts
OpenWriter
KW
END
TextFrames
MODULE
Texts
JG
NW
IMPORT
Files
Fonts
CONST
scanner
symbol
classes
Inval
invalid
symbol
Name
name
s
length
len
String
literal
string
s
length
len
Int
integer
i
decimal
or
hexadecimal
Real
real
number
x
Char
special
character
c
TextBlock
TextTag
offset
run
run
len
AsciiCode
run
fnt
name
col
voff
len
TAB
9X
CR
0DX
maxD
TextTag
0F1X
replace
insert
delete
unmark
op
codes
TYPE
Piece
POINTER
TO
PieceDesc
PieceDesc
RECORD
f
Files
File
off
len
LONGINT
fnt
Fonts
Font
col
voff
INTEGER
prev
next
Piece
END
Text
POINTER
TO
TextDesc
Notifier
PROCEDURE
T
Text
op
INTEGER
beg
end
LONGINT
TextDesc
RECORD
len
LONGINT
changed
BOOLEAN
notify
Notifier
trailer
Piece
pce
Piece
cache
org
LONGINT
cache
END
Reader
RECORD
eot
BOOLEAN
fnt
Fonts
Font
col
voff
INTEGER
ref
Piece
org
LONGINT
off
LONGINT
rider
Files
Rider
END
Scanner
RECORD
Reader
nextCh
CHAR
line
class
INTEGER
i
LONGINT
x
REAL
y
LONGREAL
c
CHAR
len
INTEGER
s
ARRAY
OF
CHAR
END
Buffer
POINTER
TO
BufDesc
BufDesc
RECORD
len
LONGINT
header
last
Piece
END
Writer
RECORD
buf
Buffer
fnt
Fonts
Font
col
voff
INTEGER
rider
Files
Rider
END
VAR
TrailerFile
Files
File
Filing
PROCEDURE
Trailer
Piece
VAR
Q
Piece
BEGIN
NEW
Q
Q
f
TrailerFile
Q
off
Q
len
Q
fnt
NIL
Q
col
Q
voff
RETURN
Q
END
Trailer
PROCEDURE
Load
VAR
R
Files
Rider
T
Text
VAR
Q
q
p
Piece
off
LONGINT
N
fno
INTEGER
bt
BYTE
f
Files
File
FName
ARRAY
OF
CHAR
Dict
ARRAY
OF
Fonts
Font
BEGIN
f
Files
Base
R
N
Q
Trailer
p
Q
Files
ReadInt
R
off
Files
ReadByte
R
bt
fno
bt
WHILE
fno
DO
IF
fno
N
THEN
Files
ReadString
R
FName
Dict
N
Fonts
This
FName
INC
N
END
NEW
q
q
fnt
Dict
fno
Files
ReadByte
R
bt
q
col
bt
Files
ReadByte
R
bt
q
voff
ASR
LSL
bt
Files
ReadInt
R
q
len
Files
ReadByte
R
bt
fno
bt
q
f
f
q
off
off
off
off
q
len
p
next
q
q
prev
p
p
q
END
p
next
Q
Q
prev
p
T
trailer
Q
Files
ReadInt
R
T
len
Files
Set
R
f
Files
Pos
R
T
len
END
Load
PROCEDURE
Open
T
Text
name
ARRAY
OF
CHAR
VAR
f
Files
File
R
Files
Rider
Q
q
Piece
tag
CHAR
len
LONGINT
BEGIN
f
Files
Old
name
IF
f
NIL
THEN
Files
Set
R
f
Files
Read
R
tag
IF
tag
TextTag
THEN
Load
R
T
ELSE
Ascii
file
len
Files
Length
f
Q
Trailer
NEW
q
q
fnt
Fonts
Default
q
col
q
voff
q
f
f
q
off
q
len
len
Q
next
q
q
prev
Q
q
next
Q
Q
prev
q
T
trailer
Q
T
len
len
END
ELSE
create
new
text
Q
Trailer
Q
next
Q
Q
prev
Q
T
trailer
Q
T
len
END
T
changed
FALSE
T
org
T
pce
T
trailer
init
cache
END
Open
PROCEDURE
Store
VAR
W
Files
Rider
T
Text
VAR
p
q
Piece
R
Files
Rider
off
rlen
pos
LONGINT
N
n
INTEGER
ch
CHAR
Dict
ARRAY
OF
CHAR
BEGIN
pos
Files
Pos
W
Files
WriteInt
W
place
holder
N
p
T
trailer
next
WHILE
p
T
trailer
DO
rlen
p
len
q
p
next
WHILE
q
T
trailer
q
fnt
p
fnt
q
col
p
col
q
voff
p
voff
DO
rlen
rlen
q
len
q
q
next
END
Dict
N
p
fnt
name
n
WHILE
Dict
n
p
fnt
name
DO
INC
n
END
Files
WriteByte
W
n
IF
n
N
THEN
Files
WriteString
W
p
fnt
name
INC
N
END
Files
WriteByte
W
p
col
Files
WriteByte
W
p
voff
Files
WriteInt
W
rlen
p
q
END
Files
WriteByte
W
Files
WriteInt
W
T
len
off
Files
Pos
W
p
T
trailer
next
WHILE
p
T
trailer
DO
rlen
p
len
Files
Set
R
p
f
p
off
WHILE
rlen
DO
Files
Read
R
ch
Files
Write
W
ch
DEC
rlen
END
p
p
next
END
Files
Set
W
Files
Base
W
pos
Files
WriteInt
W
off
fixup
T
changed
FALSE
IF
T
notify
NIL
THEN
T
notify
T
unmark
END
END
Store
PROCEDURE
Close
T
Text
name
ARRAY
OF
CHAR
VAR
f
Files
File
w
Files
Rider
BEGIN
f
Files
New
name
Files
Set
w
f
Files
Write
w
TextTag
Store
w
T
Files
Register
f
END
Close
Editing
PROCEDURE
OpenBuf
B
Buffer
BEGIN
NEW
B
header
null
piece
B
last
B
header
B
len
END
OpenBuf
PROCEDURE
FindPiece
T
Text
pos
LONGINT
VAR
org
LONGINT
VAR
pce
Piece
VAR
p
Piece
porg
LONGINT
BEGIN
p
T
pce
porg
T
org
IF
pos
porg
THEN
WHILE
pos
porg
p
len
DO
INC
porg
p
len
p
p
next
END
ELSE
p
p
prev
DEC
porg
p
len
WHILE
pos
porg
DO
p
p
prev
DEC
porg
p
len
END
END
T
pce
p
T
org
porg
update
cache
pce
p
org
porg
END
FindPiece
PROCEDURE
SplitPiece
p
Piece
off
LONGINT
VAR
pr
Piece
VAR
q
Piece
BEGIN
IF
off
THEN
NEW
q
q
fnt
p
fnt
q
col
p
col
q
voff
p
voff
q
len
p
len
off
q
f
p
f
q
off
p
off
off
p
len
off
q
next
p
next
p
next
q
q
prev
p
q
next
prev
q
pr
q
ELSE
pr
p
END
END
SplitPiece
PROCEDURE
Save
T
Text
beg
end
LONGINT
B
Buffer
VAR
p
q
qb
qe
Piece
org
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
org
p
NEW
qb
qb
p
qb
len
qb
len
beg
org
qb
off
qb
off
beg
org
qe
qb
WHILE
end
org
p
len
DO
org
org
p
len
p
p
next
NEW
q
q
p
qe
next
q
q
prev
qe
qe
q
END
qe
next
NIL
qe
len
qe
len
org
p
len
end
B
last
next
qb
qb
prev
B
last
B
last
qe
B
len
B
len
end
beg
END
Save
PROCEDURE
Copy
SB
DB
Buffer
VAR
Q
q
p
Piece
BEGIN
p
SB
header
Q
DB
last
WHILE
p
SB
last
DO
p
p
next
NEW
q
q
p
Q
next
q
q
prev
Q
Q
q
END
DB
last
Q
DB
len
DB
len
SB
len
END
Copy
PROCEDURE
Insert
T
Text
pos
LONGINT
B
Buffer
VAR
pl
pr
p
qb
qe
Piece
org
end
LONGINT
BEGIN
FindPiece
T
pos
org
p
SplitPiece
p
pos
org
pr
IF
T
org
org
THEN
T
org
org
p
prev
len
T
pce
p
prev
END
pl
pr
prev
qb
B
header
next
IF
qb
NIL
qb
f
pl
f
qb
off
pl
off
pl
len
qb
fnt
pl
fnt
qb
col
pl
col
qb
voff
pl
voff
THEN
pl
len
pl
len
qb
len
qb
qb
next
END
IF
qb
NIL
THEN
qe
B
last
qb
prev
pl
pl
next
qb
qe
next
pr
pr
prev
qe
END
T
len
T
len
B
len
end
pos
B
len
B
last
B
header
B
last
next
NIL
B
len
T
changed
TRUE
T
notify
T
insert
pos
end
END
Insert
PROCEDURE
Append
T
Text
B
Buffer
BEGIN
Insert
T
T
len
B
END
Append
PROCEDURE
Delete
T
Text
beg
end
LONGINT
B
Buffer
VAR
pb
pe
pbr
per
Piece
orgb
orge
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
orgb
pb
SplitPiece
pb
beg
orgb
pbr
FindPiece
T
end
orge
pe
SplitPiece
pe
end
orge
per
IF
T
org
orgb
THEN
adjust
cache
T
org
orgb
pb
prev
len
T
pce
pb
prev
END
B
header
next
pbr
B
last
per
prev
B
last
next
NIL
B
len
end
beg
per
prev
pbr
prev
pbr
prev
next
per
T
len
T
len
B
len
T
changed
TRUE
T
notify
T
delete
beg
end
END
Delete
PROCEDURE
ChangeLooks
T
Text
beg
end
LONGINT
sel
SET
fnt
Fonts
Font
col
voff
INTEGER
VAR
pb
pe
p
Piece
org
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
org
p
SplitPiece
p
beg
org
pb
FindPiece
T
end
org
p
SplitPiece
p
end
org
pe
p
pb
REPEAT
IF
IN
sel
THEN
p
fnt
fnt
END
IF
IN
sel
THEN
p
col
col
END
IF
IN
sel
THEN
p
voff
voff
END
p
p
next
UNTIL
p
pe
T
changed
TRUE
T
notify
T
replace
beg
end
END
ChangeLooks
PROCEDURE
Attributes
T
Text
pos
LONGINT
VAR
fnt
Fonts
Font
VAR
col
voff
INTEGER
VAR
p
Piece
org
LONGINT
BEGIN
FindPiece
T
pos
org
p
fnt
p
fnt
col
p
col
voff
p
voff
END
Attributes
Access
Readers
PROCEDURE
OpenReader
VAR
R
Reader
T
Text
pos
LONGINT
VAR
p
Piece
org
LONGINT
BEGIN
FindPiece
T
pos
org
p
R
ref
p
R
org
org
R
off
pos
org
Files
Set
R
rider
p
f
p
off
R
off
R
eot
FALSE
END
OpenReader
PROCEDURE
Read
VAR
R
Reader
VAR
ch
CHAR
BEGIN
Files
Read
R
rider
ch
R
fnt
R
ref
fnt
R
col
R
ref
col
R
voff
R
ref
voff
INC
R
off
IF
R
off
R
ref
len
THEN
IF
R
ref
f
TrailerFile
THEN
R
eot
TRUE
END
R
org
R
org
R
off
R
off
R
ref
R
ref
next
R
org
R
org
R
off
R
off
Files
Set
R
rider
R
ref
f
R
ref
off
END
END
Read
PROCEDURE
Pos
VAR
R
Reader
LONGINT
BEGIN
RETURN
R
org
R
off
END
Pos
Access
Scanners
NW
PROCEDURE
OpenScanner
VAR
S
Scanner
T
Text
pos
LONGINT
BEGIN
OpenReader
S
T
pos
S
line
S
nextCh
END
OpenScanner
floating
point
formats
x
m
e
bit
sign
bits
e
bits
m
x
m
e
bit
sign
bits
e
bits
m
PROCEDURE
Ten
n
INTEGER
REAL
VAR
t
p
REAL
BEGIN
t
p
compute
n
WHILE
n
DO
IF
ODD
n
THEN
t
p
t
END
p
p
p
n
n
DIV
END
RETURN
t
END
Ten
PROCEDURE
Scan
VAR
S
Scanner
CONST
maxExp
maxM
VAR
ch
term
CHAR
neg
negE
hex
BOOLEAN
i
j
h
d
e
n
s
INTEGER
k
LONGINT
x
REAL
BEGIN
ch
S
nextCh
i
WHILE
S
eot
ch
DO
IF
ch
CR
THEN
INC
S
line
END
Read
S
ch
END
IF
A
ch
ch
Z
OR
a
ch
ch
z
THEN
name
REPEAT
S
s
i
ch
INC
i
Read
S
ch
UNTIL
ch
ch
OR
ch
ch
A
OR
Z
ch
ch
a
OR
z
ch
OR
i
S
s
i
0X
S
len
i
S
class
Name
ELSIF
ch
22X
THEN
string
Read
S
ch
WHILE
ch
22X
ch
i
DO
S
s
i
ch
INC
i
Read
S
ch
END
S
s
i
0X
S
len
i
Read
S
ch
S
class
String
ELSE
hex
FALSE
IF
ch
THEN
neg
TRUE
Read
S
ch
ELSE
neg
FALSE
END
IF
ch
ch
THEN
number
n
ORD
ch
30H
h
n
Read
S
ch
WHILE
ch
ch
OR
A
ch
ch
F
DO
IF
ch
THEN
d
ORD
ch
30H
ELSE
d
ORD
ch
37H
hex
TRUE
END
n
n
d
h
10H
h
d
Read
S
ch
END
IF
ch
H
THEN
hex
integer
Read
S
ch
S
i
h
S
class
Int
neg
ELSIF
ch
THEN
real
number
Read
S
ch
x
e
j
WHILE
ch
ch
DO
fraction
h
n
ORD
ch
30H
IF
h
maxM
THEN
n
h
INC
j
END
Read
S
ch
END
IF
ch
E
THEN
scale
factor
s
Read
S
ch
IF
ch
THEN
negE
TRUE
Read
S
ch
ELSE
negE
FALSE
IF
ch
THEN
Read
S
ch
END
END
WHILE
ch
ch
DO
s
s
ORD
ch
30H
Read
S
ch
END
IF
negE
THEN
DEC
e
s
ELSE
INC
e
s
END
END
x
FLT
n
DEC
e
j
IF
e
THEN
IF
e
maxExp
THEN
x
x
Ten
e
ELSE
x
END
ELSIF
e
THEN
IF
e
maxExp
THEN
x
Ten
e
x
ELSE
x
END
END
IF
neg
THEN
S
x
x
ELSE
S
x
x
END
IF
hex
THEN
S
class
ELSE
S
class
Real
END
ELSE
decimal
integer
IF
neg
THEN
S
i
n
ELSE
S
i
n
END
IF
hex
THEN
S
class
Inval
ELSE
S
class
Int
END
END
ELSE
spectal
character
S
class
Char
IF
neg
THEN
S
c
ELSE
S
c
ch
Read
S
ch
END
END
END
S
nextCh
ch
END
Scan
Access
Writers
NW
PROCEDURE
OpenWriter
VAR
W
Writer
BEGIN
NEW
W
buf
OpenBuf
W
buf
W
fnt
Fonts
Default
W
col
W
voff
Files
Set
W
rider
Files
New
END
OpenWriter
PROCEDURE
SetFont
VAR
W
Writer
fnt
Fonts
Font
BEGIN
W
fnt
fnt
END
SetFont
PROCEDURE
SetColor
VAR
W
Writer
col
INTEGER
BEGIN
W
col
col
END
SetColor
PROCEDURE
SetOffset
VAR
W
Writer
voff
INTEGER
BEGIN
W
voff
voff
END
SetOffset
PROCEDURE
Write
VAR
W
Writer
ch
CHAR
VAR
p
Piece
BEGIN
IF
W
buf
last
fnt
W
fnt
OR
W
buf
last
col
W
col
OR
W
buf
last
voff
W
voff
THEN
NEW
p
p
f
Files
Base
W
rider
p
off
Files
Pos
W
rider
p
len
p
fnt
W
fnt
p
col
W
col
p
voff
W
voff
p
next
NIL
W
buf
last
next
p
p
prev
W
buf
last
W
buf
last
p
END
Files
Write
W
rider
ch
INC
W
buf
last
len
INC
W
buf
len
END
Write
PROCEDURE
WriteLn
VAR
W
Writer
BEGIN
Write
W
CR
END
WriteLn
PROCEDURE
WriteString
VAR
W
Writer
s
ARRAY
OF
CHAR
VAR
i
INTEGER
BEGIN
i
WHILE
s
i
DO
Write
W
s
i
INC
i
END
END
WriteString
PROCEDURE
WriteInt
VAR
W
Writer
x
n
LONGINT
VAR
i
INTEGER
x0
LONGINT
a
ARRAY
OF
CHAR
BEGIN
IF
ROR
x
THEN
WriteString
W
ELSE
i
IF
x
THEN
DEC
n
x0
x
ELSE
x0
x
END
REPEAT
a
i
CHR
x0
MOD
30H
x0
x0
DIV
INC
i
UNTIL
x0
WHILE
n
i
DO
Write
W
DEC
n
END
IF
x
THEN
Write
W
END
REPEAT
DEC
i
Write
W
a
i
UNTIL
i
END
END
WriteInt
PROCEDURE
WriteHex
VAR
W
Writer
x
LONGINT
VAR
i
INTEGER
y
LONGINT
a
ARRAY
OF
CHAR
BEGIN
i
Write
W
REPEAT
y
x
MOD
10H
IF
y
THEN
a
i
CHR
y
30H
ELSE
a
i
CHR
y
37H
END
x
x
DIV
10H
INC
i
UNTIL
i
REPEAT
DEC
i
Write
W
a
i
UNTIL
i
END
WriteHex
PROCEDURE
WriteReal
VAR
W
Writer
x
REAL
n
INTEGER
VAR
e
i
m
INTEGER
d
ARRAY
OF
CHAR
BEGIN
e
ASR
ORD
x
MOD
100H
binary
exponent
IF
e
THEN
WriteString
W
WHILE
n
DO
Write
W
DEC
n
END
ELSIF
e
THEN
WriteString
W
NaN
ELSE
Write
W
WHILE
n
DO
DEC
n
Write
W
END
n
digits
to
be
written
IF
x
THEN
Write
W
x
x
ELSE
Write
W
END
e
e
DIV
decimal
exponent
IF
e
THEN
x
x
Ten
e
ELSE
x
Ten
e
x
END
m
FLOOR
x
i
IF
m
THEN
INC
e
m
m
DIV
END
REPEAT
d
i
CHR
m
MOD
30H
m
m
DIV
INC
i
UNTIL
m
DEC
i
Write
W
d
i
Write
W
IF
i
n
THEN
n
ELSE
n
n
END
WHILE
i
n
DO
DEC
i
Write
W
d
i
END
Write
W
E
INC
e
IF
e
THEN
Write
W
e
e
ELSE
Write
W
END
Write
W
CHR
e
DIV
30H
Write
W
CHR
e
MOD
30H
END
END
WriteReal
PROCEDURE
WriteRealFix
VAR
W
Writer
x
REAL
n
k
INTEGER
VAR
i
m
INTEGER
neg
BOOLEAN
d
ARRAY
OF
CHAR
BEGIN
IF
x
THEN
WriteString
W
ELSE
IF
x
THEN
x
x
neg
TRUE
ELSE
neg
FALSE
END
IF
k
THEN
k
END
x
Ten
k
x
m
FLOOR
x
i
REPEAT
d
i
CHR
m
MOD
30H
m
m
DIV
INC
i
UNTIL
m
Write
W
WHILE
n
i
DO
Write
W
DEC
n
END
IF
neg
THEN
Write
W
DEC
n
ELSE
Write
W
END
WHILE
i
k
DO
DEC
i
Write
W
d
i
END
Write
W
WHILE
k
i
DO
DEC
k
Write
W
END
WHILE
i
DO
DEC
i
Write
W
d
i
END
END
END
WriteRealFix
PROCEDURE
WritePair
VAR
W
Writer
ch
CHAR
x
LONGINT
BEGIN
Write
W
ch
Write
W
CHR
x
DIV
30H
Write
W
CHR
x
MOD
30H
END
WritePair
PROCEDURE
WriteClock
VAR
W
Writer
d
LONGINT
BEGIN
WritePair
W
d
DIV
20000H
MOD
20H
day
WritePair
W
d
DIV
400000H
MOD
10H
month
WritePair
W
d
DIV
4000000H
MOD
40H
year
WritePair
W
d
DIV
1000H
MOD
20H
hour
WritePair
W
d
DIV
40H
MOD
40H
min
WritePair
W
d
MOD
40H
sec
END
WriteClock
BEGIN
TrailerFile
Files
New
END
Texts
MODULE
Viewers
JG
NW
IMPORT
Display
CONST
restore
modify
suspend
message
ids
inf
TYPE
Viewer
POINTER
TO
ViewerDesc
ViewerDesc
RECORD
Display
FrameDesc
state
INTEGER
END
state
displayed
state
filler
state
closed
state
suspended
ViewerMsg
RECORD
Display
FrameMsg
id
INTEGER
X
Y
W
H
INTEGER
state
INTEGER
END
Track
POINTER
TO
TrackDesc
TrackDesc
RECORD
ViewerDesc
under
Display
Frame
END
VAR
curW
minH
DH
INTEGER
FillerTrack
Track
FillerViewer
backup
Viewer
last
closed
viewer
PROCEDURE
Open
V
Viewer
X
Y
INTEGER
VAR
T
u
v
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
X
inf
THEN
IF
Y
DH
THEN
Y
DH
END
T
FillerTrack
next
WHILE
X
T
X
T
W
DO
T
T
next
END
u
T
dsc
v
u
next
WHILE
Y
v
Y
v
H
DO
u
v
v
u
next
END
IF
Y
v
Y
minH
THEN
Y
v
Y
minH
END
IF
v
next
Y
Y
v
Y
v
H
minH
THEN
V
X
T
X
V
W
T
W
V
Y
v
Y
V
H
v
H
M
id
suspend
M
state
v
handle
v
M
v
Viewer
state
V
next
v
next
u
next
V
V
state
ELSE
V
X
T
X
V
W
T
W
V
Y
v
Y
V
H
Y
v
Y
M
id
modify
M
Y
Y
M
H
v
Y
v
H
Y
v
handle
v
M
v
Y
M
Y
v
H
M
H
V
next
v
u
next
V
V
state
END
END
END
Open
PROCEDURE
Change
V
Viewer
Y
INTEGER
VAR
v
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
THEN
IF
Y
DH
THEN
Y
DH
END
v
V
next
IF
v
next
Y
Y
v
Y
v
H
minH
THEN
Y
v
Y
v
H
minH
END
IF
Y
V
Y
minH
THEN
M
id
modify
M
Y
Y
M
H
v
Y
v
H
Y
v
handle
v
M
v
Y
M
Y
v
H
M
H
V
H
Y
V
Y
END
END
END
Change
PROCEDURE
RestoreTrack
S
Display
Frame
VAR
T
t
v
Display
Frame
M
ViewerMsg
BEGIN
t
S
next
WHILE
t
next
S
DO
t
t
next
END
T
S
Track
under
WHILE
T
next
NIL
DO
T
T
next
END
t
next
S
Track
under
T
next
S
next
M
id
restore
REPEAT
t
t
next
v
t
dsc
REPEAT
v
v
next
v
handle
v
M
v
Viewer
state
v
Viewer
state
UNTIL
v
t
dsc
UNTIL
t
T
END
RestoreTrack
PROCEDURE
Close
V
Viewer
VAR
T
U
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
THEN
U
V
next
T
FillerTrack
REPEAT
T
T
next
UNTIL
V
X
T
X
T
W
IF
T
Track
under
NIL
OR
U
next
V
THEN
M
id
suspend
M
state
V
handle
V
M
V
state
backup
V
M
id
modify
M
Y
V
Y
M
H
V
H
U
H
U
handle
U
M
U
Y
M
Y
U
H
M
H
WHILE
U
next
V
DO
U
U
next
END
U
next
V
next
ELSE
close
track
M
id
suspend
M
state
V
handle
V
M
V
state
backup
V
U
handle
U
M
U
Viewer
state
RestoreTrack
T
END
END
END
Close
PROCEDURE
Recall
VAR
V
Viewer
BEGIN
V
backup
END
Recall
PROCEDURE
This
X
Y
INTEGER
Viewer
VAR
T
V
Display
Frame
BEGIN
IF
X
inf
Y
DH
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
V
T
dsc
REPEAT
V
V
next
UNTIL
Y
V
Y
V
H
ELSE
V
NIL
END
RETURN
V
Viewer
END
This
PROCEDURE
Next
V
Viewer
Viewer
BEGIN
RETURN
V
next
Viewer
END
Next
PROCEDURE
Locate
X
H
INTEGER
VAR
fil
bot
alt
max
Display
Frame
VAR
T
V
Display
Frame
BEGIN
IF
X
inf
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
fil
T
dsc
bot
fil
next
IF
bot
next
fil
THEN
alt
bot
next
V
alt
next
WHILE
V
fil
alt
H
H
DO
IF
V
H
alt
H
THEN
alt
V
END
V
V
next
END
ELSE
alt
bot
END
max
T
dsc
V
max
next
WHILE
V
fil
DO
IF
V
H
max
H
THEN
max
V
END
V
V
next
END
END
END
Locate
PROCEDURE
InitTrack
W
H
INTEGER
Filler
Viewer
VAR
S
Display
Frame
T
Track
BEGIN
IF
Filler
state
THEN
Filler
X
curW
Filler
W
W
Filler
Y
Filler
H
H
Filler
state
Filler
next
Filler
NEW
T
T
X
curW
T
W
W
T
Y
T
H
H
T
dsc
Filler
T
under
NIL
FillerViewer
X
curW
W
FillerViewer
W
inf
FillerViewer
X
FillerTrack
X
FillerViewer
X
FillerTrack
W
FillerViewer
W
S
FillerTrack
WHILE
S
next
FillerTrack
DO
S
S
next
END
S
next
T
T
next
FillerTrack
curW
curW
W
END
END
InitTrack
PROCEDURE
OpenTrack
X
W
INTEGER
Filler
Viewer
VAR
newT
Track
S
T
t
v
Display
Frame
M
ViewerMsg
v0
Viewer
BEGIN
IF
X
inf
Filler
state
THEN
S
FillerTrack
T
S
next
WHILE
X
T
X
T
W
DO
S
T
T
S
next
END
WHILE
X
W
T
X
T
W
DO
T
T
next
END
M
id
suspend
t
S
REPEAT
t
t
next
v
t
dsc
REPEAT
v
v
next
M
state
v
Viewer
state
v
handle
v
M
v
Viewer
state
M
state
UNTIL
v
t
dsc
UNTIL
t
T
Filler
X
S
next
X
Filler
W
T
X
T
W
S
next
X
Filler
Y
Filler
H
DH
Filler
state
Filler
next
Filler
NEW
newT
newT
X
Filler
X
newT
W
Filler
W
newT
Y
newT
H
DH
newT
dsc
Filler
newT
under
S
next
S
next
newT
newT
next
T
next
T
next
NIL
END
END
OpenTrack
PROCEDURE
CloseTrack
X
INTEGER
VAR
T
V
Display
Frame
M
ViewerMsg
BEGIN
IF
X
inf
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
IF
T
Track
under
NIL
THEN
M
id
suspend
M
state
V
T
dsc
REPEAT
V
V
next
V
handle
V
M
V
Viewer
state
UNTIL
V
T
dsc
RestoreTrack
T
END
END
END
CloseTrack
PROCEDURE
Broadcast
VAR
M
Display
FrameMsg
VAR
T
V
Display
Frame
BEGIN
T
FillerTrack
next
WHILE
T
FillerTrack
DO
V
T
dsc
REPEAT
V
V
next
V
handle
V
M
UNTIL
V
T
dsc
T
T
next
END
END
Broadcast
BEGIN
backup
NIL
curW
minH
DH
Display
Height
NEW
FillerViewer
FillerViewer
X
FillerViewer
W
inf
FillerViewer
Y
FillerViewer
H
DH
FillerViewer
next
FillerViewer
NEW
FillerTrack
FillerTrack
X
FillerTrack
W
inf
FillerTrack
Y
FillerTrack
H
DH
FillerTrack
dsc
FillerViewer
FillerTrack
next
FillerTrack
END
Viewers
MODULE
Curves
NW
IMPORT
Display
Files
Oberon
Graphics
GraphicFrames
TYPE
Curve
POINTER
TO
CurveDesc
CurveDesc
RECORD
Graphics
ObjectDesc
kind
lw
INTEGER
END
kind
up
line
down
line
circle
ellipse
VAR
method
Graphics
Method
PROCEDURE
Dot
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
IF
x
f
X
x
f
X1
y
f
Y
x
f
Y1
THEN
Display
Dot
col
x
y
Display
replace
END
END
Dot
PROCEDURE
mark
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
DEC
x
DEC
y
IF
x
f
X
x
f
X1
y
f
Y
y
f
Y1
THEN
IF
col
Display
black
THEN
Display
ReplConst
Display
black
x
y
Display
replace
ELSE
Display
CopyPattern
col
GraphicFrames
tack
x
y
Display
replace
END
END
END
mark
PROCEDURE
line
f
GraphicFrames
Frame
col
INTEGER
x
y
w
h
d
LONGINT
VAR
x1
y1
u
LONGINT
BEGIN
IF
h
w
THEN
x1
x
w
u
h
w
DIV
IF
d
THEN
INC
y
h
END
WHILE
x
x1
DO
Dot
f
col
x
y
INC
x
IF
u
THEN
INC
u
h
ELSE
INC
u
h
w
INC
y
d
END
END
ELSE
y1
y
h
u
w
h
DIV
IF
d
THEN
INC
x
w
END
WHILE
y
y1
DO
Dot
f
col
x
y
INC
y
IF
u
THEN
INC
u
w
ELSE
INC
u
w
h
INC
x
d
END
END
END
END
line
PROCEDURE
circle
f
GraphicFrames
Frame
col
INTEGER
x0
y0
r
LONGINT
VAR
x
y
u
LONGINT
BEGIN
u
r
x
r
y
WHILE
y
x
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
y
y0
x
Dot
f
col
x0
x
y0
y
IF
u
THEN
INC
u
y
ELSE
INC
u
y
x
DEC
x
END
INC
y
END
END
circle
PROCEDURE
ellipse
f
GraphicFrames
Frame
col
INTEGER
x0
y0
a
b
LONGINT
VAR
x
y
y1
aa
bb
d
g
h
LONGINT
BEGIN
aa
a
a
bb
b
b
h
aa
DIV
b
aa
bb
g
aa
DIV
b
aa
bb
x
y
b
WHILE
g
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
IF
h
THEN
d
x
bb
INC
g
d
ELSE
d
x
bb
y
aa
INC
g
d
aa
DEC
y
END
INC
h
d
INC
x
END
y1
y
h
bb
DIV
a
bb
aa
x
a
y
WHILE
y
y1
DO
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
Dot
f
col
x0
x
y0
y
IF
h
THEN
INC
h
y
aa
ELSE
INC
h
y
aa
x
bb
DEC
x
END
INC
y
END
END
ellipse
PROCEDURE
New
VAR
c
Curve
BEGIN
NEW
c
c
do
method
Graphics
New
c
END
New
PROCEDURE
Copy
src
dst
Graphics
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Curve
kind
src
Curve
kind
dst
Curve
lw
src
Curve
lw
END
Copy
PROCEDURE
Draw
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
col
INTEGER
f
GraphicFrames
Frame
BEGIN
CASE
M
OF
GraphicFrames
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
M
col
Display
black
THEN
col
obj
col
ELSE
col
M
col
END
IF
x
f
X1
f
X
x
w
y
f
Y1
f
Y
y
h
THEN
IF
obj
Curve
kind
THEN
up
line
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
y
END
line
f
col
x
y
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
ELSIF
M
mode
THEN
mark
f
f
col
x
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
line
f
Display
black
x
y
w
h
END
ELSIF
obj
Curve
kind
THEN
down
line
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
y
h
END
line
f
col
x
y
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
h
ELSIF
M
mode
THEN
mark
f
f
col
x
y
h
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
h
line
f
Display
black
x
y
w
h
END
ELSIF
obj
Curve
kind
THEN
circle
w
w
DIV
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
w
y
END
circle
f
col
x
w
y
w
w
ELSIF
M
mode
THEN
mark
f
Display
white
x
w
y
ELSIF
M
mode
THEN
mark
f
f
col
x
w
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
w
y
circle
f
Display
black
x
w
y
w
w
END
ELSIF
obj
Curve
kind
THEN
ellipse
w
w
DIV
h
h
DIV
IF
M
mode
THEN
IF
obj
selected
THEN
mark
f
Display
white
x
w
y
END
ellipse
f
col
x
w
y
h
w
h
ELSIF
M
mode
THEN
mark
f
Display
white
x
w
y
ELSIF
M
mode
THEN
mark
f
f
col
x
w
y
ELSIF
M
mode
THEN
mark
f
Display
black
x
w
y
ellipse
f
Display
black
x
w
y
h
w
h
END
END
END
END
END
Draw
PROCEDURE
Selectable
obj
Graphics
Object
x
y
INTEGER
BOOLEAN
VAR
xm
y0
w
h
INTEGER
res
BOOLEAN
BEGIN
IF
obj
Curve
kind
THEN
line
w
obj
w
h
obj
h
IF
obj
Curve
kind
THEN
y0
obj
y
h
h
h
ELSE
y0
obj
y
END
res
obj
x
x
x
obj
x
w
ABS
y
y0
w
x
obj
x
h
w
ELSE
circle
or
ellipse
xm
obj
w
DIV
obj
x
res
xm
x
x
xm
obj
y
y
y
obj
y
END
RETURN
res
END
Selectable
PROCEDURE
Change
obj
Graphics
Object
VAR
M
Graphics
Msg
BEGIN
IF
M
IS
Graphics
ColorMsg
THEN
obj
col
M
Graphics
ColorMsg
col
END
END
Change
PROCEDURE
Read
obj
Graphics
Object
VAR
R
Files
Rider
VAR
C
Graphics
Context
VAR
len
BYTE
BEGIN
Files
ReadByte
R
len
Files
ReadByte
R
len
obj
Curve
kind
len
Files
ReadByte
R
len
obj
Curve
lw
len
END
Read
PROCEDURE
Write
obj
Graphics
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Graphics
Context
BEGIN
Graphics
WriteObj
W
cno
obj
Files
WriteByte
W
Files
WriteByte
W
obj
Curve
kind
Files
WriteByte
W
obj
Curve
lw
END
Write
PROCEDURE
MakeLine
command
VAR
x0
x1
y0
y1
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
x1
G
mark
next
x
y1
G
mark
next
y
NEW
c
c
col
Oberon
CurCol
c
w
ABS
x1
x0
c
h
ABS
y1
y0
c
lw
Graphics
width
IF
x0
x1
THEN
c
x
x0
IF
y0
y1
THEN
c
kind
c
y
y0
ELSE
c
kind
c
y
y1
END
ELSE
c
x
x1
IF
y1
y0
THEN
c
kind
c
y
y1
ELSE
c
kind
c
y
y0
END
END
DEC
c
x
G
x
DEC
c
y
G
y
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
MakeLine
PROCEDURE
MakeCircle
command
VAR
x0
y0
r
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
r
ABS
G
mark
next
x
x0
IF
r
THEN
NEW
c
c
x
x0
r
G
x
c
y
y0
r
G
y
c
w
r
c
h
c
w
c
kind
c
col
Oberon
CurCol
c
lw
Graphics
width
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
END
MakeCircle
PROCEDURE
MakeEllipse
command
VAR
x0
y0
a
b
INTEGER
c
Curve
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
G
mark
next
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
a
ABS
G
mark
next
x
x0
b
ABS
G
mark
next
next
y
y0
IF
a
b
THEN
NEW
c
c
x
x0
a
G
x
c
y
y0
b
G
y
c
w
a
c
h
b
c
kind
c
col
Oberon
CurCol
c
lw
Graphics
width
c
do
method
Graphics
Add
G
graph
c
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
c
END
END
END
MakeEllipse
BEGIN
NEW
method
method
module
Curves
method
allocator
New
method
new
New
method
copy
Copy
method
draw
Draw
method
selectable
Selectable
method
change
Change
method
read
Read
method
write
Write
END
Curves
MODULE
Display
NW
IMPORT
SYSTEM
CONST
black
white
black
background
replace
paint
invert
modes
base
0E7F00H
adr
of
x
pixel
monocolor
display
frame
TYPE
Frame
POINTER
TO
FrameDesc
FrameMsg
RECORD
END
Handler
PROCEDURE
F
Frame
VAR
M
FrameMsg
FrameDesc
RECORD
next
dsc
Frame
X
Y
W
H
INTEGER
handle
Handler
END
VAR
Base
Width
Height
INTEGER
arrow
star
hook
updown
block
cross
grey
INTEGER
a
pattern
is
an
array
of
bytes
the
first
is
its
width
the
second
its
height
the
rest
the
raster
PROCEDURE
Handle
F
Frame
VAR
M
FrameMsg
BEGIN
IF
F
NIL
F
handle
NIL
THEN
F
handle
F
M
END
END
Handle
raster
ops
PROCEDURE
Dot
col
x
y
mode
INTEGER
VAR
a
INTEGER
u
s
SET
BEGIN
a
base
x
DIV
y
s
x
MOD
SYSTEM
GET
a
u
IF
mode
paint
THEN
SYSTEM
PUT
a
u
s
ELSIF
mode
invert
THEN
SYSTEM
PUT
a
u
s
ELSE
mode
replace
IF
col
black
THEN
SYSTEM
PUT
a
u
s
ELSE
SYSTEM
PUT
a
u
s
END
END
END
Dot
PROCEDURE
ReplConst
col
x
y
w
h
mode
INTEGER
VAR
al
ar
a0
a1
INTEGER
left
right
mid
pix
pixl
pixr
SET
BEGIN
al
base
y
ar
x
w
DIV
al
al
x
DIV
al
IF
ar
al
THEN
mid
x
MOD
x
w
MOD
FOR
a1
al
TO
al
h
BY
DO
SYSTEM
GET
a1
pix
IF
mode
invert
THEN
SYSTEM
PUT
a1
pix
mid
ELSIF
mode
replace
col
black
THEN
erase
SYSTEM
PUT
a1
pix
mid
ELSE
mode
paint
OR
mode
replace
col
black
SYSTEM
PUT
a1
pix
mid
END
END
ELSIF
ar
al
THEN
left
x
MOD
right
x
w
MOD
FOR
a0
al
TO
al
h
BY
DO
SYSTEM
GET
a0
pixl
SYSTEM
GET
ar
pixr
IF
mode
invert
THEN
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
PUT
a1
pix
END
SYSTEM
PUT
ar
pixr
right
ELSIF
mode
replace
col
black
THEN
erase
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
PUT
a1
END
SYSTEM
PUT
ar
pixr
right
ELSE
mode
paint
OR
mode
replace
col
black
SYSTEM
PUT
a0
pixl
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
PUT
a1
END
SYSTEM
PUT
ar
pixr
right
END
INC
ar
END
END
END
ReplConst
PROCEDURE
CopyPattern
col
patadr
x
y
mode
INTEGER
only
for
modes
paint
invert
VAR
a
a0
pwd
INTEGER
w
h
pbt
BYTE
pix
SET
BEGIN
SYSTEM
GET
patadr
w
SYSTEM
GET
patadr
h
INC
patadr
a
base
x
DIV
y
FOR
a0
a
TO
a
h
BY
DO
build
pattern
line
w
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
100H
pwd
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
10000H
pwd
IF
w
THEN
SYSTEM
GET
patadr
pbt
INC
patadr
pwd
pbt
1000000H
pwd
END
END
END
SYSTEM
GET
a0
pix
IF
mode
invert
THEN
SYSTEM
PUT
a0
SYSTEM
VAL
SET
LSL
pwd
x
MOD
pix
ELSE
SYSTEM
PUT
a0
SYSTEM
VAL
SET
LSL
pwd
x
MOD
pix
END
IF
x
MOD
w
THEN
spill
over
SYSTEM
GET
a0
pix
IF
mode
invert
THEN
SYSTEM
PUT
a0
SYSTEM
VAL
SET
ASR
pwd
x
MOD
pix
ELSE
SYSTEM
PUT
a0
SYSTEM
VAL
SET
ASR
pwd
x
MOD
pix
END
END
END
END
CopyPattern
PROCEDURE
CopyBlock
sx
sy
w
h
dx
dy
mode
INTEGER
only
for
mode
replace
VAR
sa
da
sa0
sa1
d
len
INTEGER
u0
u1
u2
u3
v0
v1
v2
v3
n
INTEGER
end
step
INTEGER
src
dst
spill
SET
m0
m1
m2
m3
SET
BEGIN
u0
sx
DIV
u1
sx
MOD
u2
sx
w
DIV
u3
sx
w
MOD
v0
dx
DIV
v1
dx
MOD
v2
dx
w
DIV
v3
dx
w
MOD
sa
base
u0
sy
da
base
v0
dy
d
da
sa
n
u1
v1
displacement
in
words
and
bits
len
u2
u0
m0
v1
m2
v3
m3
m0
m2
IF
d
THEN
copy
up
scan
down
sa0
sa
h
end
sa
step
ELSE
copy
down
scan
up
sa0
sa
end
sa
h
step
END
WHILE
sa0
end
DO
IF
n
THEN
shift
right
m1
n
IF
v1
w
THEN
SYSTEM
GET
sa0
len
src
src
ROR
src
n
SYSTEM
GET
sa0
len
d
dst
SYSTEM
PUT
sa0
len
d
dst
m2
src
m2
spill
src
m1
FOR
sa1
sa0
len
TO
sa0
BY
DO
SYSTEM
GET
sa1
src
src
ROR
src
n
SYSTEM
PUT
sa1
d
spill
src
m1
spill
src
m1
END
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
SYSTEM
PUT
sa0
d
src
m0
dst
m0
ELSE
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
SYSTEM
PUT
sa0
d
src
m3
dst
m3
END
ELSE
shift
left
m1
n
SYSTEM
GET
sa0
src
src
ROR
src
n
SYSTEM
GET
sa0
d
dst
IF
v1
w
THEN
SYSTEM
PUT
sa0
d
dst
m3
src
m3
ELSE
SYSTEM
PUT
sa0
d
dst
m0
src
m0
spill
src
m1
FOR
sa1
sa0
TO
sa0
len
BY
DO
SYSTEM
GET
sa1
src
src
ROR
src
n
SYSTEM
PUT
sa1
d
spill
src
m1
spill
src
m1
END
SYSTEM
GET
sa0
len
src
src
ROR
src
n
SYSTEM
GET
sa0
len
d
dst
SYSTEM
PUT
sa0
len
d
src
m2
dst
m2
END
END
INC
sa0
step
END
END
CopyBlock
PROCEDURE
ReplPattern
col
patadr
x
y
w
h
mode
INTEGER
pattern
width
fixed
pattern
starts
at
patadr
for
mode
invert
only
VAR
al
ar
a0
a1
INTEGER
pta0
pta1
INTEGER
pattern
addresses
ph
BYTE
left
right
mid
pix
pixl
pixr
ptw
SET
BEGIN
al
base
y
SYSTEM
GET
patadr
ph
pta0
patadr
pta1
ph
pta0
ar
x
w
DIV
al
al
x
DIV
al
IF
ar
al
THEN
mid
x
MOD
x
w
MOD
FOR
a1
al
TO
al
h
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
GET
pta0
ptw
SYSTEM
PUT
a1
pix
mid
pix
ptw
mid
INC
pta0
IF
pta0
pta1
THEN
pta0
patadr
END
END
ELSIF
ar
al
THEN
left
x
MOD
right
x
w
MOD
FOR
a0
al
TO
al
h
BY
DO
SYSTEM
GET
a0
pixl
SYSTEM
GET
pta0
ptw
SYSTEM
PUT
a0
pixl
left
pixl
ptw
left
FOR
a1
a0
TO
ar
BY
DO
SYSTEM
GET
a1
pix
SYSTEM
PUT
a1
pix
ptw
END
SYSTEM
GET
ar
pixr
SYSTEM
PUT
ar
pixr
right
pixr
ptw
right
INC
pta0
INC
ar
IF
pta0
pta1
THEN
pta0
patadr
END
END
END
END
ReplPattern
BEGIN
Base
base
Width
Height
arrow
SYSTEM
ADR
0F0F
001C
000E
C101
E300
3F00
1F00
3F00
7F00
FF00
star
SYSTEM
ADR
0F0F
A002
C001
7F7F
C001
A002
hook
SYSTEM
ADR
0C0C
070F
C703
E701
F700
7F00
3F00
1F00
0F00
updown
SYSTEM
ADR
080E
183C
7EFF
FF7E3C18
block
SYSTEM
ADR
FFFF
C3C3
C3C3
FFFF
cross
SYSTEM
ADR
0F0F
grey
SYSTEM
ADR
AAAA
AAAA
END
Display
MODULE
Draw
NW
IMPORT
Files
Fonts
Viewers
Texts
Oberon
TextFrames
MenuViewers
Graphics
GraphicFrames
CONST
Menu
System
Close
System
Copy
System
Grow
Draw
Delete
Draw
Ticks
Draw
Restore
Draw
Store
VAR
W
Texts
Writer
Exported
commands
Open
Delete
SetWidth
ChangeColor
ChangeWidth
ChangeFont
Store
Print
Macro
Ticks
Restore
PROCEDURE
Open
VAR
X
Y
INTEGER
beg
end
t
LONGINT
G
Graphics
Graph
F
GraphicFrames
Frame
V
Viewers
Viewer
S
Texts
Scanner
text
Texts
Text
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
text
beg
end
t
IF
t
THEN
Texts
OpenScanner
S
text
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
THEN
NEW
G
Graphics
Open
G
S
s
NEW
F
GraphicFrames
Open
F
G
Oberon
AllocateUserViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
Menu
F
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Delete
VAR
F
GraphicFrames
Frame
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
F
Oberon
Par
vwr
dsc
next
GraphicFrames
Frame
GraphicFrames
Erase
F
Graphics
Delete
F
graph
END
END
Delete
PROCEDURE
GetArg
VAR
S
Texts
Scanner
VAR
T
Texts
Text
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
END
GetArg
PROCEDURE
SetWidth
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
S
i
S
i
THEN
Graphics
SetWidth
S
i
END
END
SetWidth
PROCEDURE
ChangeColor
VAR
S
Texts
Scanner
CM
Graphics
ColorMsg
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
CM
col
S
i
MOD
GraphicFrames
Change
GraphicFrames
Selected
CM
END
END
ChangeColor
PROCEDURE
ChangeWidth
VAR
S
Texts
Scanner
WM
Graphics
WidMsg
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
WM
w
S
i
GraphicFrames
Change
GraphicFrames
Selected
WM
END
END
ChangeWidth
PROCEDURE
ChangeFont
VAR
S
Texts
Scanner
FM
Graphics
FontMsg
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
FM
fnt
Fonts
This
S
s
IF
FM
fnt
NIL
THEN
GraphicFrames
Change
GraphicFrames
Selected
FM
END
END
END
ChangeFont
PROCEDURE
Redraw
Q
BOOLEAN
VAR
v
Viewers
Viewer
G
GraphicFrames
Frame
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
v
Oberon
Par
vwr
ELSE
v
Oberon
MarkedViewer
END
IF
v
NIL
v
dsc
NIL
v
dsc
next
IS
GraphicFrames
Frame
THEN
G
v
dsc
next
GraphicFrames
Frame
G
ticked
Q
OR
G
ticked
GraphicFrames
Restore
G
END
END
Redraw
PROCEDURE
Ticks
BEGIN
Redraw
FALSE
END
Ticks
PROCEDURE
Restore
BEGIN
Redraw
TRUE
END
Restore
PROCEDURE
Backup
VAR
name
ARRAY
OF
CHAR
VAR
res
i
INTEGER
ch
CHAR
bak
ARRAY
OF
CHAR
BEGIN
i
ch
name
WHILE
ch
0X
DO
bak
i
ch
INC
i
ch
name
i
END
IF
i
THEN
bak
i
bak
i
B
bak
i
a
bak
i
k
bak
i
0X
Files
Rename
name
bak
res
END
END
Backup
PROCEDURE
Store
VAR
S
Texts
Scanner
Menu
TextFrames
Frame
G
GraphicFrames
Frame
v
Viewers
Viewer
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
Menu
Oberon
Par
vwr
dsc
TextFrames
Frame
G
Menu
next
GraphicFrames
Frame
Texts
OpenScanner
S
Menu
text
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
S
s
Texts
WriteString
W
storing
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
GraphicFrames
Store
G
S
s
END
ELSE
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
v
Oberon
MarkedViewer
IF
v
dsc
NIL
v
dsc
next
IS
GraphicFrames
Frame
THEN
G
v
dsc
next
GraphicFrames
Frame
Texts
WriteString
W
S
s
Texts
WriteString
W
storing
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
GraphicFrames
Store
G
S
s
END
END
END
END
Store
PROCEDURE
Macro
VAR
S
Texts
Scanner
T
Texts
Text
time
beg
end
LONGINT
Lname
ARRAY
OF
CHAR
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Lname
S
s
Texts
Scan
S
IF
S
class
Texts
Name
THEN
GraphicFrames
Macro
Lname
S
s
END
END
END
Macro
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
Draw
NW
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
Draw
MODULE
Edit
JG
NW
IMPORT
Files
Fonts
Texts
Display
Viewers
Oberon
MenuViewers
TextFrames
CONST
CR
0DX
maxlen
StandardMenu
System
Close
System
Copy
System
Grow
Edit
Search
Edit
Store
VAR
W
Texts
Writer
time
LONGINT
M
INTEGER
pat
ARRAY
maxlen
OF
CHAR
d
ARRAY
OF
INTEGER
PROCEDURE
Max
i
j
LONGINT
LONGINT
VAR
m
LONGINT
BEGIN
IF
i
j
THEN
m
i
ELSE
m
j
END
RETURN
m
END
Max
PROCEDURE
Open
VAR
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
X
Y
INTEGER
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
OR
S
line
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
THEN
Oberon
AllocateUserViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Store
VAR
V
Viewers
Viewer
Text
TextFrames
Frame
T
Texts
Text
S
Texts
Scanner
f
Files
File
R
Files
Rider
beg
end
time
len
LONGINT
PROCEDURE
Backup
VAR
name
ARRAY
OF
CHAR
VAR
res
i
INTEGER
bak
ARRAY
OF
CHAR
BEGIN
i
WHILE
name
i
0X
DO
bak
i
name
i
INC
i
END
bak
i
bak
i
B
bak
i
a
bak
i
k
bak
i
0X
Files
Rename
name
bak
res
END
Backup
BEGIN
Texts
WriteString
W
Edit
Store
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
V
Oberon
Par
vwr
Texts
OpenScanner
S
V
dsc
TextFrames
Frame
text
ELSE
V
Oberon
MarkedViewer
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
END
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
IF
S
class
Texts
Name
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
Texts
WriteString
W
S
s
Texts
WriteInt
W
Text
text
len
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Backup
S
s
Texts
Close
Text
text
S
s
END
END
Store
PROCEDURE
CopyLooks
VAR
T
Texts
Text
F
TextFrames
Frame
v
Viewers
Viewer
beg
end
time
LONGINT
fnt
Fonts
Font
col
voff
INTEGER
BEGIN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
v
Oberon
FocusViewer
IF
v
NIL
v
dsc
NIL
v
dsc
next
IS
TextFrames
Frame
THEN
F
v
dsc
next
TextFrames
Frame
Texts
Attributes
F
text
F
carloc
pos
fnt
col
voff
Texts
ChangeLooks
T
beg
end
fnt
col
voff
END
END
END
CopyLooks
PROCEDURE
ChangeFont
VAR
S
Texts
Scanner
T
Texts
Text
beg
end
LONGINT
BEGIN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
ChangeLooks
T
beg
end
Fonts
This
S
s
END
END
END
ChangeFont
PROCEDURE
ChangeColor
VAR
S
Texts
Scanner
T
Texts
Text
col
INTEGER
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
col
S
i
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
ChangeLooks
T
beg
end
NIL
col
END
END
END
ChangeColor
PROCEDURE
ChangeOffset
VAR
S
Texts
Scanner
T
Texts
Text
voff
INTEGER
ch
CHAR
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
voff
S
i
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
ChangeLooks
T
beg
end
NIL
voff
END
END
END
ChangeOffset
PROCEDURE
Search
uses
global
variables
M
pat
d
for
Boyer
Moore
search
VAR
Text
TextFrames
Frame
V
Viewers
Viewer
R
Texts
Reader
T
Texts
Text
pos
beg
end
prevTime
len
LONGINT
n
i
j
INTEGER
buf
ARRAY
OF
CHAR
PROCEDURE
Forward
n
INTEGER
VAR
R
Texts
Reader
VAR
buf
ARRAY
OF
CHAR
VAR
m
INTEGER
j
INTEGER
BEGIN
m
M
n
j
WHILE
j
m
DO
buf
j
buf
n
j
INC
j
END
WHILE
j
M
DO
Texts
Read
R
buf
j
INC
j
END
END
Forward
BEGIN
V
Oberon
Par
vwr
IF
Oberon
Par
frame
V
dsc
THEN
V
Oberon
FocusViewer
END
IF
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
prevTime
time
Oberon
GetSelection
T
beg
end
time
IF
time
prevTime
THEN
Texts
OpenReader
R
T
beg
i
pos
beg
REPEAT
Texts
Read
R
pat
i
INC
i
INC
pos
UNTIL
i
maxlen
OR
pos
end
M
i
j
WHILE
j
DO
d
j
M
INC
j
END
j
WHILE
j
M
DO
d
ORD
pat
j
M
j
INC
j
END
END
IF
Text
hasCar
THEN
pos
Text
carloc
pos
ELSE
pos
END
len
Text
text
len
Texts
OpenReader
R
Text
text
pos
Forward
M
R
buf
pos
pos
M
j
M
REPEAT
DEC
j
UNTIL
j
OR
buf
j
pat
j
WHILE
j
pos
len
DO
n
d
ORD
buf
M
Forward
n
R
buf
INC
pos
n
j
M
REPEAT
DEC
j
UNTIL
j
OR
buf
j
pat
j
END
IF
j
THEN
TextFrames
RemoveSelection
Text
TextFrames
RemoveCaret
Text
Oberon
RemoveMarks
Text
X
Text
Y
Text
W
Text
H
TextFrames
Show
Text
pos
Oberon
PassFocus
V
TextFrames
SetCaret
Text
pos
END
END
END
Search
PROCEDURE
Locate
VAR
Text
TextFrames
Frame
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
beg
end
time
LONGINT
BEGIN
V
Oberon
FocusViewer
IF
V
dsc
NIL
V
dsc
next
IS
TextFrames
Frame
THEN
Text
V
dsc
next
TextFrames
Frame
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
REPEAT
Texts
Scan
S
UNTIL
S
class
Texts
Int
skip
names
IF
S
class
Texts
Int
THEN
TextFrames
RemoveSelection
Text
TextFrames
RemoveCaret
Text
Oberon
RemoveMarks
Text
X
Text
Y
Text
W
Text
H
TextFrames
Show
Text
Max
S
i
Oberon
PassFocus
V
TextFrames
SetCaret
Text
S
i
END
END
END
END
Locate
PROCEDURE
Recall
VAR
Menu
Main
Display
Frame
buf
Texts
Buffer
V
Viewers
Viewer
pos
LONGINT
M
TextFrames
Frame
BEGIN
V
Oberon
FocusViewer
IF
V
NIL
V
IS
MenuViewers
Viewer
THEN
Menu
V
dsc
Main
V
dsc
next
IF
Main
IS
TextFrames
Frame
THEN
M
Main
TextFrames
Frame
IF
M
hasCar
THEN
TextFrames
Recall
buf
pos
M
carloc
pos
buf
len
Texts
Insert
M
text
M
carloc
pos
buf
TextFrames
SetCaret
M
pos
END
ELSIF
Menu
IS
TextFrames
Frame
THEN
M
Menu
TextFrames
Frame
IF
M
hasCar
THEN
TextFrames
Recall
buf
pos
M
carloc
pos
buf
len
Texts
Insert
M
text
M
carloc
pos
buf
TextFrames
SetCaret
M
pos
END
END
END
END
Recall
BEGIN
Texts
OpenWriter
W
END
Edit
MODULE
FileDir
NW
IMPORT
SYSTEM
Kernel
File
Directory
is
a
B
tree
with
its
root
page
at
DirRootAdr
Each
entry
contains
a
file
name
and
the
disk
address
of
the
file
s
head
sector
CONST
FnLength
SecTabSize
ExTabSize
SectorSize
IndexSize
SectorSize
DIV
HeaderSize
DirRootAdr
DirPgSize
N
DirPgSize
DIV
DirMark
9B1EA38DH
HeaderMark
9BA71D86H
FillerSize
TYPE
DiskAdr
INTEGER
FileName
ARRAY
FnLength
OF
CHAR
SectorTable
ARRAY
SecTabSize
OF
DiskAdr
ExtensionTable
ARRAY
ExTabSize
OF
DiskAdr
EntryHandler
PROCEDURE
name
FileName
sec
DiskAdr
VAR
continue
BOOLEAN
FileHeader
RECORD
first
page
of
each
file
on
disk
mark
INTEGER
name
FileName
aleng
bleng
date
INTEGER
ext
ExtensionTable
sec
SectorTable
fill
ARRAY
SectorSize
HeaderSize
OF
BYTE
END
FileHd
POINTER
TO
FileHeader
IndexSector
ARRAY
IndexSize
OF
DiskAdr
DataSector
ARRAY
SectorSize
OF
BYTE
DirEntry
B
tree
node
RECORD
name
FileName
adr
DiskAdr
sec
no
of
file
header
p
DiskAdr
sec
no
of
descendant
in
directory
END
DirPage
RECORD
mark
INTEGER
m
INTEGER
p0
DiskAdr
sec
no
of
left
descendant
in
directory
fill
ARRAY
FillerSize
OF
BYTE
e
ARRAY
DirPgSize
OF
DirEntry
END
Exported
procedures
Search
Insert
Delete
Enumerate
Init
PROCEDURE
Search
name
FileName
VAR
A
DiskAdr
VAR
i
L
R
INTEGER
dadr
DiskAdr
a
DirPage
BEGIN
dadr
DirRootAdr
A
REPEAT
Kernel
GetSector
dadr
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
a
m
name
a
e
R
name
THEN
A
a
e
R
adr
found
ELSIF
R
THEN
dadr
a
p0
ELSE
dadr
a
e
R
p
END
UNTIL
dadr
OR
A
END
Search
PROCEDURE
insert
name
FileName
dpg0
DiskAdr
VAR
h
BOOLEAN
VAR
v
DirEntry
fad
DiskAdr
h
tree
has
become
higher
and
v
is
ascending
element
VAR
ch
CHAR
i
j
L
R
INTEGER
dpg1
DiskAdr
u
DirEntry
a
DirPage
BEGIN
h
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
a
m
name
a
e
R
name
THEN
a
e
R
adr
fad
Kernel
PutSector
dpg0
a
replace
ELSE
not
on
this
page
IF
R
THEN
dpg1
a
p0
ELSE
dpg1
a
e
R
p
END
IF
dpg1
THEN
not
in
tree
insert
u
adr
fad
u
p
h
TRUE
j
REPEAT
ch
name
j
u
name
j
ch
INC
j
UNTIL
ch
0X
WHILE
j
FnLength
DO
u
name
j
0X
INC
j
END
ELSE
insert
name
dpg1
h
u
fad
END
IF
h
THEN
insert
u
to
the
left
of
e
R
IF
a
m
DirPgSize
THEN
h
FALSE
i
a
m
WHILE
i
R
DO
DEC
i
a
e
i
a
e
i
END
a
e
R
u
INC
a
m
ELSE
split
page
and
assign
the
middle
element
to
v
a
m
N
a
mark
DirMark
IF
R
N
THEN
insert
in
left
half
v
a
e
N
i
N
WHILE
i
R
DO
DEC
i
a
e
i
a
e
i
END
a
e
R
u
Kernel
PutSector
dpg0
a
Kernel
AllocSector
dpg0
dpg0
i
WHILE
i
N
DO
a
e
i
a
e
i
N
INC
i
END
ELSE
insert
in
right
half
Kernel
PutSector
dpg0
a
Kernel
AllocSector
dpg0
dpg0
DEC
R
N
i
IF
R
THEN
v
u
ELSE
v
a
e
N
WHILE
i
R
DO
a
e
i
a
e
N
i
INC
i
END
a
e
i
u
INC
i
END
WHILE
i
N
DO
a
e
i
a
e
N
i
INC
i
END
END
a
p0
v
p
v
p
dpg0
END
Kernel
PutSector
dpg0
a
END
END
END
insert
PROCEDURE
Insert
name
FileName
fad
DiskAdr
VAR
oldroot
DiskAdr
h
BOOLEAN
U
DirEntry
a
DirPage
BEGIN
h
FALSE
insert
name
DirRootAdr
h
U
fad
IF
h
THEN
root
overflow
Kernel
GetSector
DirRootAdr
a
ASSERT
a
mark
DirMark
Kernel
AllocSector
DirRootAdr
oldroot
Kernel
PutSector
oldroot
a
a
mark
DirMark
a
m
a
p0
oldroot
a
e
U
Kernel
PutSector
DirRootAdr
a
END
END
Insert
PROCEDURE
underflow
VAR
c
DirPage
ancestor
page
dpg0
DiskAdr
s
INTEGER
insertion
point
in
c
VAR
h
BOOLEAN
c
undersize
VAR
i
k
INTEGER
dpg1
DiskAdr
a
b
DirPage
a
underflowing
page
b
neighbouring
page
BEGIN
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
h
a
m
N
dpg0
c
e
s
p
IF
s
c
m
THEN
b
page
to
the
right
of
a
dpg1
c
e
s
p
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
k
b
m
N
DIV
k
no
of
items
available
on
page
b
a
e
N
c
e
s
a
e
N
p
b
p0
IF
k
THEN
move
k
items
from
b
to
a
one
to
c
i
WHILE
i
k
DO
a
e
i
N
b
e
i
INC
i
END
c
e
s
b
e
i
b
p0
c
e
s
p
c
e
s
p
dpg1
b
m
b
m
k
i
WHILE
i
b
m
DO
b
e
i
b
e
i
k
INC
i
END
Kernel
PutSector
dpg1
b
a
m
N
k
h
FALSE
ELSE
merge
pages
a
and
b
discard
b
i
WHILE
i
N
DO
a
e
i
N
b
e
i
INC
i
END
i
s
DEC
c
m
WHILE
i
c
m
DO
c
e
i
c
e
i
INC
i
END
a
m
N
h
c
m
N
END
Kernel
PutSector
dpg0
a
ELSE
b
page
to
the
left
of
a
DEC
s
IF
s
THEN
dpg1
c
p0
ELSE
dpg1
c
e
s
p
END
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
k
b
m
N
DIV
k
no
of
items
available
on
page
b
IF
k
THEN
i
N
WHILE
i
DO
DEC
i
a
e
i
k
a
e
i
END
i
k
a
e
i
c
e
s
a
e
i
p
a
p0
move
k
items
from
b
to
a
one
to
c
b
m
b
m
k
WHILE
i
DO
DEC
i
a
e
i
b
e
i
b
m
END
c
e
s
b
e
b
m
a
p0
c
e
s
p
c
e
s
p
dpg0
a
m
N
k
h
FALSE
Kernel
PutSector
dpg0
a
ELSE
merge
pages
a
and
b
discard
a
c
e
s
p
a
p0
b
e
N
c
e
s
i
WHILE
i
N
DO
b
e
i
N
a
e
i
INC
i
END
b
m
N
DEC
c
m
h
c
m
N
END
Kernel
PutSector
dpg1
b
END
END
underflow
PROCEDURE
delete
name
FileName
dpg0
DiskAdr
VAR
h
BOOLEAN
VAR
fad
DiskAdr
search
and
delete
entry
with
key
name
if
a
page
underflow
arises
balance
with
adjacent
page
or
merge
h
page
dpg0
is
undersize
VAR
i
L
R
INTEGER
dpg1
DiskAdr
a
DirPage
PROCEDURE
del
VAR
a
DirPage
R
INTEGER
dpg1
DiskAdr
VAR
h
BOOLEAN
VAR
dpg2
DiskAdr
global
a
R
b
DirPage
BEGIN
Kernel
GetSector
dpg1
b
ASSERT
b
mark
DirMark
dpg2
b
e
b
m
p
IF
dpg2
THEN
del
a
R
dpg2
h
IF
h
THEN
underflow
b
dpg2
b
m
h
Kernel
PutSector
dpg1
b
END
ELSE
b
e
b
m
p
a
e
R
p
a
e
R
b
e
b
m
DEC
b
m
h
b
m
N
Kernel
PutSector
dpg1
b
END
END
del
BEGIN
h
Kernel
GetSector
dpg0
a
ASSERT
a
mark
DirMark
L
R
a
m
binary
search
WHILE
L
R
DO
i
L
R
DIV
IF
name
a
e
i
name
THEN
R
i
ELSE
L
i
END
END
IF
R
THEN
dpg1
a
p0
ELSE
dpg1
a
e
R
p
END
IF
R
a
m
name
a
e
R
name
THEN
found
now
delete
fad
a
e
R
adr
IF
dpg1
THEN
a
is
a
leaf
page
DEC
a
m
h
a
m
N
i
R
WHILE
i
a
m
DO
a
e
i
a
e
i
INC
i
END
ELSE
del
a
R
dpg1
h
IF
h
THEN
underflow
a
dpg1
R
h
END
END
Kernel
PutSector
dpg0
a
ELSIF
dpg1
THEN
delete
name
dpg1
h
fad
IF
h
THEN
underflow
a
dpg1
R
h
Kernel
PutSector
dpg0
a
END
ELSE
not
in
tree
fad
END
END
delete
PROCEDURE
Delete
name
FileName
VAR
fad
DiskAdr
VAR
h
BOOLEAN
newroot
DiskAdr
a
DirPage
BEGIN
h
FALSE
delete
name
DirRootAdr
h
fad
IF
h
THEN
root
underflow
Kernel
GetSector
DirRootAdr
a
ASSERT
a
mark
DirMark
IF
a
m
a
p0
THEN
newroot
a
p0
Kernel
GetSector
newroot
a
ASSERT
a
mark
DirMark
Kernel
PutSector
DirRootAdr
a
discard
newroot
END
END
END
Delete
PROCEDURE
enumerate
prefix
ARRAY
OF
CHAR
dpg
DiskAdr
proc
EntryHandler
VAR
continue
BOOLEAN
VAR
i
j
INTEGER
pfx
nmx
CHAR
dpg1
DiskAdr
a
DirPage
BEGIN
Kernel
GetSector
dpg
a
ASSERT
a
mark
DirMark
i
WHILE
i
a
m
continue
DO
j
REPEAT
pfx
prefix
j
nmx
a
e
i
name
j
INC
j
UNTIL
nmx
pfx
OR
pfx
0X
IF
nmx
pfx
THEN
IF
i
THEN
dpg1
a
p0
ELSE
dpg1
a
e
i
p
END
IF
dpg1
THEN
enumerate
prefix
dpg1
proc
continue
END
IF
pfx
0X
THEN
IF
continue
THEN
proc
a
e
i
name
a
e
i
adr
continue
END
ELSE
continue
FALSE
END
END
INC
i
END
IF
continue
i
a
e
i
p
THEN
enumerate
prefix
a
e
i
p
proc
continue
END
END
enumerate
PROCEDURE
Enumerate
prefix
ARRAY
OF
CHAR
proc
EntryHandler
VAR
b
BOOLEAN
BEGIN
b
TRUE
enumerate
prefix
DirRootAdr
proc
b
END
Enumerate
initialization
PROCEDURE
Init
VAR
k
INTEGER
A
ARRAY
OF
DiskAdr
PROCEDURE
MarkSectors
VAR
A
ARRAY
OF
DiskAdr
k
INTEGER
VAR
L
R
i
j
n
INTEGER
x
DiskAdr
hd
FileHeader
B
IndexSector
PROCEDURE
sift
VAR
A
ARRAY
OF
DiskAdr
L
R
INTEGER
VAR
i
j
INTEGER
x
DiskAdr
BEGIN
j
L
x
A
j
REPEAT
i
j
j
j
IF
j
R
A
j
A
j
THEN
INC
j
END
IF
j
R
x
A
j
THEN
A
i
A
j
END
UNTIL
j
R
OR
x
A
j
A
i
x
END
sift
BEGIN
L
k
DIV
R
k
heapsort
WHILE
L
DO
DEC
L
sift
A
L
R
END
WHILE
R
DO
DEC
R
x
A
A
A
R
A
R
x
sift
A
L
R
END
WHILE
L
k
DO
Kernel
GetSector
A
L
hd
ASSERT
hd
mark
HeaderMark
IF
hd
aleng
SecTabSize
THEN
j
hd
aleng
REPEAT
DEC
j
Kernel
MarkSector
hd
sec
j
UNTIL
j
ELSE
j
SecTabSize
REPEAT
DEC
j
Kernel
MarkSector
hd
sec
j
UNTIL
j
n
hd
aleng
SecTabSize
DIV
i
WHILE
i
n
DO
Kernel
MarkSector
hd
ext
i
Kernel
GetSector
hd
ext
i
B
index
sector
IF
i
n
THEN
j
ELSE
j
hd
aleng
SecTabSize
MOD
END
REPEAT
DEC
j
Kernel
MarkSector
B
j
UNTIL
j
INC
i
END
END
INC
L
END
END
MarkSectors
PROCEDURE
TraverseDir
VAR
A
ARRAY
OF
DiskAdr
VAR
k
INTEGER
dpg
DiskAdr
VAR
i
INTEGER
a
DirPage
BEGIN
Kernel
GetSector
dpg
a
ASSERT
a
mark
DirMark
Kernel
MarkSector
dpg
i
WHILE
i
a
m
DO
A
k
a
e
i
adr
INC
k
INC
i
IF
k
THEN
MarkSectors
A
k
k
END
END
IF
a
p0
THEN
TraverseDir
A
k
a
p0
i
WHILE
i
a
m
DO
TraverseDir
A
k
a
e
i
p
INC
i
END
END
END
TraverseDir
BEGIN
k
TraverseDir
A
k
DirRootAdr
MarkSectors
A
k
END
Init
END
FileDir
MODULE
Files
NW
IMPORT
SYSTEM
Kernel
FileDir
A
file
consists
of
a
sequence
of
pages
The
first
page
contains
the
header
Part
of
the
header
is
the
page
table
an
array
of
disk
addresses
to
the
pages
A
file
is
referenced
through
riders
A
rider
indicates
a
current
position
and
refers
to
a
file
CONST
MaxBufs
HS
FileDir
HeaderSize
SS
FileDir
SectorSize
STS
FileDir
SecTabSize
XS
FileDir
IndexSize
TYPE
DiskAdr
INTEGER
File
POINTER
TO
FileDesc
Buffer
POINTER
TO
BufferRecord
Index
POINTER
TO
IndexRecord
Rider
RECORD
eof
BOOLEAN
res
INTEGER
file
File
apos
bpos
INTEGER
buf
Buffer
END
FileDesc
RECORD
next
INTEGER
list
of
files
invisible
to
the
GC
nofbufs
aleng
bleng
INTEGER
modH
registered
BOOLEAN
firstbuf
Buffer
sechint
DiskAdr
name
FileDir
FileName
date
INTEGER
ext
ARRAY
FileDir
ExTabSize
OF
Index
sec
FileDir
SectorTable
END
BufferRecord
RECORD
apos
lim
INTEGER
mod
BOOLEAN
next
Buffer
data
FileDir
DataSector
END
IndexRecord
RECORD
adr
DiskAdr
mod
BOOLEAN
sec
FileDir
IndexSector
END
aleng
SS
bleng
length
including
header
apos
SS
bpos
current
position
bpos
lim
SS
apos
aleng
PgTabSize
apos
aleng
lim
SS
OR
apos
aleng
VAR
root
INTEGER
File
list
of
open
files
PROCEDURE
Check
s
ARRAY
OF
CHAR
VAR
name
FileDir
FileName
VAR
res
INTEGER
VAR
i
INTEGER
ch
CHAR
BEGIN
ch
s
i
IF
ch
A
ch
Z
OR
ch
a
ch
z
THEN
REPEAT
name
i
ch
INC
i
ch
s
i
UNTIL
ch
ch
OR
ch
A
ch
Z
OR
ch
a
ch
z
OR
ch
OR
i
FileDir
FnLength
IF
i
FileDir
FnLength
THEN
res
ELSIF
ch
0X
THEN
res
WHILE
i
FileDir
FnLength
DO
name
i
0X
INC
i
END
ELSE
res
END
ELSIF
ch
0X
THEN
name
0X
res
ELSE
res
END
END
Check
PROCEDURE
Old
name
ARRAY
OF
CHAR
File
VAR
i
k
res
INTEGER
f
File
header
DiskAdr
buf
Buffer
F
FileDir
FileHd
namebuf
FileDir
FileName
inxpg
Index
BEGIN
f
NIL
Check
name
namebuf
res
IF
res
THEN
FileDir
Search
namebuf
header
IF
header
THEN
f
SYSTEM
VAL
File
root
WHILE
f
NIL
f
sec
header
DO
f
SYSTEM
VAL
File
f
next
END
IF
f
NIL
THEN
file
not
yet
present
NEW
buf
buf
apos
buf
next
buf
buf
mod
FALSE
F
SYSTEM
VAL
FileDir
FileHd
SYSTEM
ADR
buf
data
Kernel
GetSector
header
buf
data
ASSERT
F
mark
FileDir
HeaderMark
NEW
f
f
aleng
F
aleng
f
bleng
F
bleng
f
date
F
date
IF
f
aleng
THEN
buf
lim
f
bleng
ELSE
buf
lim
SS
END
f
firstbuf
buf
f
nofbufs
f
name
namebuf
f
registered
TRUE
f
sec
F
sec
k
f
aleng
XS
STS
DIV
XS
i
WHILE
i
k
DO
NEW
inxpg
inxpg
adr
F
ext
i
inxpg
mod
FALSE
Kernel
GetSector
inxpg
adr
inxpg
sec
f
ext
i
inxpg
INC
i
END
WHILE
i
FileDir
ExTabSize
DO
f
ext
i
NIL
INC
i
END
f
sechint
header
f
modH
FALSE
f
next
root
root
SYSTEM
VAL
INTEGER
f
END
END
END
RETURN
f
END
Old
PROCEDURE
New
name
ARRAY
OF
CHAR
File
VAR
i
res
INTEGER
f
File
buf
Buffer
F
FileDir
FileHd
namebuf
FileDir
FileName
BEGIN
f
NIL
Check
name
namebuf
res
IF
res
THEN
NEW
buf
buf
apos
buf
mod
TRUE
buf
lim
HS
buf
next
buf
F
SYSTEM
VAL
FileDir
FileHd
SYSTEM
ADR
buf
data
F
mark
FileDir
HeaderMark
F
aleng
F
bleng
HS
F
name
namebuf
F
date
Kernel
Clock
NEW
f
f
aleng
f
bleng
HS
f
modH
TRUE
f
registered
FALSE
f
date
F
date
f
firstbuf
buf
f
nofbufs
f
name
namebuf
f
sechint
i
REPEAT
f
ext
i
NIL
F
ext
i
INC
i
UNTIL
i
FileDir
ExTabSize
i
REPEAT
f
sec
i
F
sec
i
INC
i
UNTIL
i
STS
END
RETURN
f
END
New
PROCEDURE
UpdateHeader
f
File
VAR
F
FileDir
FileHeader
VAR
k
INTEGER
BEGIN
F
aleng
f
aleng
F
bleng
f
bleng
F
sec
f
sec
k
f
aleng
XS
STS
DIV
XS
WHILE
k
DO
DEC
k
F
ext
k
f
ext
k
adr
END
END
UpdateHeader
PROCEDURE
ReadBuf
f
File
buf
Buffer
pos
INTEGER
VAR
sec
DiskAdr
BEGIN
IF
pos
STS
THEN
sec
f
sec
pos
ELSE
sec
f
ext
pos
STS
DIV
XS
sec
pos
STS
MOD
XS
END
Kernel
GetSector
sec
buf
data
IF
pos
f
aleng
THEN
buf
lim
SS
ELSE
buf
lim
f
bleng
END
buf
apos
pos
buf
mod
FALSE
END
ReadBuf
PROCEDURE
WriteBuf
f
File
buf
Buffer
VAR
i
k
INTEGER
secadr
DiskAdr
inx
Index
BEGIN
IF
buf
apos
STS
THEN
secadr
f
sec
buf
apos
IF
secadr
THEN
Kernel
AllocSector
f
sechint
secadr
f
modH
TRUE
f
sec
buf
apos
secadr
f
sechint
secadr
END
IF
buf
apos
THEN
UpdateHeader
f
SYSTEM
VAL
FileDir
FileHeader
buf
data
f
modH
FALSE
END
ELSE
i
buf
apos
STS
DIV
XS
inx
f
ext
i
IF
inx
NIL
THEN
NEW
inx
inx
adr
inx
sec
f
ext
i
inx
f
modH
TRUE
END
k
buf
apos
STS
MOD
XS
secadr
inx
sec
k
IF
secadr
THEN
Kernel
AllocSector
f
sechint
secadr
f
modH
TRUE
inx
mod
TRUE
inx
sec
k
secadr
f
sechint
secadr
END
END
Kernel
PutSector
secadr
buf
data
buf
mod
FALSE
END
WriteBuf
PROCEDURE
Buf
f
File
pos
INTEGER
Buffer
VAR
buf
Buffer
BEGIN
buf
f
firstbuf
WHILE
buf
apos
pos
buf
next
f
firstbuf
DO
buf
buf
next
END
IF
buf
apos
pos
THEN
buf
NIL
END
RETURN
buf
END
Buf
PROCEDURE
GetBuf
f
File
pos
INTEGER
Buffer
VAR
buf
Buffer
BEGIN
buf
f
firstbuf
WHILE
buf
apos
pos
buf
next
f
firstbuf
DO
buf
buf
next
END
IF
buf
apos
pos
THEN
IF
f
nofbufs
MaxBufs
THEN
allocate
new
buffer
NEW
buf
buf
next
f
firstbuf
next
f
firstbuf
next
buf
INC
f
nofbufs
ELSE
reuse
a
buffer
f
firstbuf
buf
IF
buf
mod
THEN
WriteBuf
f
buf
END
END
IF
pos
f
aleng
THEN
ReadBuf
f
buf
pos
ELSE
buf
apos
pos
buf
lim
buf
mod
FALSE
END
END
RETURN
buf
END
GetBuf
PROCEDURE
Unbuffer
f
File
VAR
i
k
INTEGER
buf
Buffer
inx
Index
head
FileDir
FileHeader
BEGIN
buf
f
firstbuf
REPEAT
IF
buf
mod
THEN
WriteBuf
f
buf
END
buf
buf
next
UNTIL
buf
f
firstbuf
k
f
aleng
XS
STS
DIV
XS
i
WHILE
i
k
DO
inx
f
ext
i
INC
i
IF
inx
mod
THEN
IF
inx
adr
THEN
Kernel
AllocSector
f
sechint
inx
adr
f
sechint
inx
adr
f
modH
TRUE
END
Kernel
PutSector
inx
adr
inx
sec
inx
mod
FALSE
END
END
IF
f
modH
THEN
Kernel
GetSector
f
sec
head
UpdateHeader
f
head
Kernel
PutSector
f
sec
head
f
modH
FALSE
END
END
Unbuffer
PROCEDURE
Register
f
File
BEGIN
IF
f
NIL
f
name
0X
THEN
Unbuffer
f
IF
f
registered
THEN
FileDir
Insert
f
name
f
sec
f
registered
TRUE
f
next
root
root
SYSTEM
VAL
INTEGER
f
END
END
END
Register
PROCEDURE
Close
f
File
BEGIN
IF
f
NIL
THEN
Unbuffer
f
END
END
Close
PROCEDURE
Purge
f
File
VAR
a
i
j
k
INTEGER
ind
FileDir
IndexSector
BEGIN
IF
f
NIL
THEN
a
f
aleng
f
aleng
f
bleng
HS
IF
a
STS
THEN
i
a
ELSE
i
STS
DEC
a
i
j
a
MOD
XS
k
a
DIV
XS
WHILE
k
DO
Kernel
GetSector
f
ext
k
adr
ind
REPEAT
DEC
j
Kernel
FreeSector
ind
j
UNTIL
j
Kernel
FreeSector
f
ext
k
adr
j
XS
DEC
k
END
END
REPEAT
DEC
i
Kernel
FreeSector
f
sec
i
UNTIL
i
END
END
Purge
PROCEDURE
Delete
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
adr
DiskAdr
namebuf
FileDir
FileName
BEGIN
Check
name
namebuf
res
IF
res
THEN
FileDir
Delete
namebuf
adr
IF
adr
THEN
res
END
END
END
Delete
PROCEDURE
Rename
old
new
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
adr
DiskAdr
oldbuf
newbuf
FileDir
FileName
head
FileDir
FileHeader
BEGIN
Check
old
oldbuf
res
IF
res
THEN
Check
new
newbuf
res
IF
res
THEN
FileDir
Delete
oldbuf
adr
IF
adr
THEN
FileDir
Insert
newbuf
adr
Kernel
GetSector
adr
head
head
name
newbuf
Kernel
PutSector
adr
head
ELSE
res
END
END
END
END
Rename
PROCEDURE
Length
f
File
INTEGER
BEGIN
RETURN
f
aleng
SS
f
bleng
HS
END
Length
PROCEDURE
Date
f
File
INTEGER
BEGIN
RETURN
f
date
END
Date
Read
PROCEDURE
Set
VAR
r
Rider
f
File
pos
INTEGER
VAR
a
b
INTEGER
BEGIN
r
eof
FALSE
r
res
IF
f
NIL
THEN
IF
pos
THEN
a
b
HS
ELSIF
pos
f
aleng
SS
f
bleng
HS
THEN
a
pos
HS
DIV
SS
b
pos
HS
MOD
SS
ELSE
a
f
aleng
b
f
bleng
END
r
file
f
r
apos
a
r
bpos
b
r
buf
f
firstbuf
ELSE
r
file
NIL
END
END
Set
PROCEDURE
Pos
VAR
r
Rider
INTEGER
BEGIN
RETURN
r
apos
SS
r
bpos
HS
END
Pos
PROCEDURE
Base
VAR
r
Rider
File
BEGIN
RETURN
r
file
END
Base
PROCEDURE
ReadByte
VAR
r
Rider
VAR
x
BYTE
VAR
buf
Buffer
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
x
r
buf
data
r
bpos
INC
r
bpos
ELSIF
r
apos
r
file
aleng
THEN
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
buf
mod
THEN
WriteBuf
r
file
r
buf
END
ReadBuf
r
file
r
buf
r
apos
ELSE
r
buf
buf
END
x
r
buf
data
r
bpos
ELSE
x
r
eof
TRUE
END
END
ReadByte
PROCEDURE
ReadBytes
VAR
r
Rider
VAR
x
ARRAY
OF
BYTE
n
INTEGER
VAR
i
INTEGER
BEGIN
i
this
implementation
is
to
be
improved
WHILE
i
n
DO
ReadByte
r
x
i
INC
i
END
END
ReadBytes
PROCEDURE
Read
VAR
r
Rider
VAR
ch
CHAR
VAR
buf
Buffer
same
as
ReadByte
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
ch
CHR
r
buf
data
r
bpos
INC
r
bpos
ELSIF
r
apos
r
file
aleng
THEN
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
buf
mod
THEN
WriteBuf
r
file
r
buf
END
ReadBuf
r
file
r
buf
r
apos
ELSE
r
buf
buf
END
ch
CHR
r
buf
data
r
bpos
ELSE
ch
0X
r
eof
TRUE
END
END
Read
PROCEDURE
ReadInt
VAR
R
Rider
VAR
x
INTEGER
VAR
x0
x1
x2
x3
BYTE
BEGIN
ReadByte
R
x0
ReadByte
R
x1
ReadByte
R
x2
ReadByte
R
x3
x
x3
100H
x2
100H
x1
100H
x0
END
ReadInt
PROCEDURE
ReadSet
VAR
R
Rider
VAR
s
SET
VAR
n
INTEGER
BEGIN
ReadInt
R
SYSTEM
VAL
INTEGER
s
END
ReadSet
PROCEDURE
ReadReal
VAR
R
Rider
VAR
x
REAL
VAR
n
INTEGER
BEGIN
ReadInt
R
SYSTEM
VAL
INTEGER
x
END
ReadReal
PROCEDURE
ReadString
VAR
R
Rider
VAR
x
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
i
Read
R
ch
WHILE
ch
0X
DO
IF
i
LEN
x
THEN
x
i
ch
INC
i
END
Read
R
ch
END
x
i
0X
END
ReadString
PROCEDURE
ReadNum
VAR
R
Rider
VAR
x
INTEGER
VAR
n
y
INTEGER
b
BYTE
BEGIN
n
y
ReadByte
R
b
WHILE
b
80H
DO
y
ROR
y
b
80H
DEC
n
ReadByte
R
b
END
IF
n
THEN
x
ROR
y
b
MOD
10H
ELSE
x
ASR
ROR
y
b
n
END
END
ReadNum
Write
PROCEDURE
NewExt
f
File
VAR
i
k
INTEGER
ext
Index
BEGIN
k
f
aleng
STS
DIV
XS
NEW
ext
ext
adr
ext
mod
TRUE
f
ext
k
ext
i
XS
REPEAT
DEC
i
ext
sec
i
UNTIL
i
END
NewExt
PROCEDURE
WriteByte
VAR
r
Rider
x
BYTE
VAR
f
File
buf
Buffer
BEGIN
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
IF
r
bpos
SS
THEN
INC
r
buf
lim
INC
r
file
bleng
r
file
modH
TRUE
ELSE
f
r
file
WriteBuf
f
r
buf
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
apos
f
aleng
THEN
ReadBuf
f
r
buf
r
apos
ELSE
r
buf
apos
r
apos
r
buf
lim
f
aleng
f
aleng
f
bleng
f
modH
TRUE
IF
f
aleng
STS
MOD
XS
THEN
NewExt
f
END
END
ELSE
r
buf
buf
END
r
bpos
END
END
r
buf
data
r
bpos
x
INC
r
bpos
r
buf
mod
TRUE
END
WriteByte
PROCEDURE
WriteBytes
VAR
r
Rider
x
ARRAY
OF
BYTE
n
INTEGER
VAR
i
INTEGER
BEGIN
i
this
implementation
is
to
be
improed
WHILE
i
n
DO
WriteByte
r
x
i
INC
i
END
END
WriteBytes
PROCEDURE
Write
VAR
r
Rider
ch
CHAR
VAR
f
File
buf
Buffer
BEGIN
same
as
WriteByte
IF
r
apos
r
buf
apos
THEN
r
buf
GetBuf
r
file
r
apos
END
IF
r
bpos
r
buf
lim
THEN
IF
r
bpos
SS
THEN
INC
r
buf
lim
INC
r
file
bleng
r
file
modH
TRUE
ELSE
f
r
file
WriteBuf
f
r
buf
INC
r
apos
buf
Buf
r
file
r
apos
IF
buf
NIL
THEN
IF
r
apos
f
aleng
THEN
ReadBuf
f
r
buf
r
apos
ELSE
r
buf
apos
r
apos
r
buf
lim
f
aleng
f
aleng
f
bleng
f
modH
TRUE
IF
f
aleng
STS
MOD
XS
THEN
NewExt
f
END
END
ELSE
r
buf
buf
END
r
bpos
END
END
r
buf
data
r
bpos
ORD
ch
INC
r
bpos
r
buf
mod
TRUE
END
Write
PROCEDURE
WriteInt
VAR
R
Rider
x
INTEGER
BEGIN
WriteByte
R
x
MOD
100H
WriteByte
R
x
DIV
100H
MOD
100H
WriteByte
R
x
DIV
10000H
MOD
100H
WriteByte
R
x
DIV
1000000H
MOD
100H
END
WriteInt
PROCEDURE
WriteSet
VAR
R
Rider
s
SET
BEGIN
WriteInt
R
ORD
s
END
WriteSet
PROCEDURE
WriteReal
VAR
R
Rider
x
REAL
BEGIN
WriteInt
R
ORD
x
END
WriteReal
PROCEDURE
WriteString
VAR
R
Rider
x
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
i
REPEAT
ch
x
i
Write
R
ch
INC
i
UNTIL
ch
0X
END
WriteString
PROCEDURE
WriteNum
VAR
R
Rider
x
INTEGER
BEGIN
WHILE
x
40H
OR
x
40H
DO
WriteByte
R
x
MOD
80H
80H
x
ASR
x
END
WriteByte
R
x
MOD
80H
END
WriteNum
System
use
PROCEDURE
Init
BEGIN
root
Kernel
Init
FileDir
Init
END
Init
PROCEDURE
RestoreList
after
mark
phase
of
garbage
collection
VAR
f
f0
INTEGER
PROCEDURE
mark
f
INTEGER
INTEGER
VAR
m
INTEGER
BEGIN
IF
f
THEN
m
ELSE
SYSTEM
GET
f
m
END
RETURN
m
END
mark
BEGIN
field
next
has
offset
WHILE
mark
root
DO
SYSTEM
GET
root
root
END
f
root
WHILE
f
DO
f0
f
REPEAT
SYSTEM
GET
f0
f0
UNTIL
mark
f0
SYSTEM
PUT
f
f0
f
f0
END
END
RestoreList
END
Files
MODULE
Fonts
JG
PDR
NW
IMPORT
SYSTEM
Files
CONST
FontFileId
0DBH
TYPE
Font
POINTER
TO
FontDesc
FontDesc
RECORD
name
ARRAY
OF
CHAR
height
minX
maxX
minY
maxY
INTEGER
next
Font
T
ARRAY
OF
INTEGER
raster
ARRAY
OF
BYTE
END
LargeFontDesc
RECORD
FontDesc
ext
ARRAY
OF
BYTE
END
LargeFont
POINTER
TO
LargeFontDesc
raster
sizes
Syntax8
Syntax10
Syntax12
Syntax14
Syntax14b
Syntax16
Syntax20
Syntac24
Syntax24b
VAR
Default
root
Font
PROCEDURE
GetPat
fnt
Font
ch
CHAR
VAR
dx
x
y
w
h
patadr
INTEGER
VAR
pa
INTEGER
dxb
xb
yb
wb
hb
BYTE
BEGIN
pa
fnt
T
ORD
ch
MOD
80H
patadr
pa
SYSTEM
GET
pa
dxb
SYSTEM
GET
pa
xb
SYSTEM
GET
pa
yb
SYSTEM
GET
pa
wb
SYSTEM
GET
pa
hb
dx
dxb
x
xb
y
yb
w
wb
h
hb
IF
yb
THEN
y
yb
ELSE
y
yb
END
END
GetPat
PROCEDURE
This
name
ARRAY
OF
CHAR
Font
TYPE
RunRec
RECORD
beg
end
BYTE
END
BoxRec
RECORD
dx
x
y
w
h
BYTE
END
VAR
F
Font
LF
LargeFont
f
Files
File
R
Files
Rider
NofRuns
NofBoxes
BYTE
NofBytes
INTEGER
height
minX
maxX
minY
maxY
BYTE
i
j
k
m
n
INTEGER
a
a0
INTEGER
b
beg
end
BYTE
run
ARRAY
OF
RunRec
box
ARRAY
OF
BoxRec
PROCEDURE
RdInt16
VAR
R
Files
Rider
VAR
b0
BYTE
VAR
b1
BYTE
BEGIN
Files
ReadByte
R
b0
Files
ReadByte
R
b1
END
RdInt16
BEGIN
F
root
WHILE
F
NIL
name
F
name
DO
F
F
next
END
IF
F
NIL
THEN
f
Files
Old
name
IF
f
NIL
THEN
Files
Set
R
f
Files
ReadByte
R
b
IF
b
FontFileId
THEN
Files
ReadByte
R
b
abstraction
Files
ReadByte
R
b
family
Files
ReadByte
R
b
variant
NEW
F
F
name
name
RdInt16
R
height
RdInt16
R
minX
RdInt16
R
maxX
RdInt16
R
minY
RdInt16
R
maxY
RdInt16
R
NofRuns
NofBoxes
k
WHILE
k
NofRuns
DO
RdInt16
R
beg
run
k
beg
beg
RdInt16
R
end
run
k
end
end
NofBoxes
NofBoxes
end
beg
INC
k
END
NofBytes
j
WHILE
j
NofBoxes
DO
RdInt16
R
box
j
dx
RdInt16
R
box
j
x
RdInt16
R
box
j
y
RdInt16
R
box
j
w
RdInt16
R
box
j
h
NofBytes
NofBytes
box
j
w
DIV
box
j
h
INC
j
END
IF
NofBytes
THEN
NEW
F
ELSE
NEW
LF
F
LF
END
F
name
name
F
height
height
F
minX
minX
F
maxX
maxX
F
maxY
maxY
IF
minY
80H
THEN
F
minY
minY
100H
ELSE
F
minY
minY
END
a0
SYSTEM
ADR
F
raster
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
SYSTEM
PUT
a0
0X
null
pattern
for
characters
not
in
a
run
INC
a0
a
a0
j
k
m
WHILE
k
NofRuns
DO
WHILE
m
run
k
beg
m
DO
F
T
m
a0
INC
m
END
WHILE
m
run
k
end
m
DO
F
T
m
a
SYSTEM
PUT
a
box
j
dx
SYSTEM
PUT
a
box
j
x
SYSTEM
PUT
a
box
j
y
SYSTEM
PUT
a
box
j
w
SYSTEM
PUT
a
box
j
h
INC
a
n
box
j
w
DIV
box
j
h
WHILE
n
DO
DEC
n
Files
ReadByte
R
b
SYSTEM
PUT
a
b
INC
a
END
INC
j
INC
m
END
INC
k
END
WHILE
m
DO
F
T
m
a0
INC
m
END
F
next
root
root
F
ELSE
bad
file
id
F
Default
END
ELSE
font
file
not
available
F
Default
END
END
RETURN
F
END
This
PROCEDURE
Free
remove
all
but
first
two
from
font
list
VAR
f
Font
BEGIN
f
root
next
IF
f
NIL
THEN
f
f
next
END
f
next
NIL
END
Free
BEGIN
root
NIL
Default
This
Oberon10
Scn
Fnt
END
Fonts
MODULE
GraphicFrames
NW
IMPORT
SYSTEM
Display
Viewers
Input
Fonts
Texts
Graphics
Oberon
MenuViewers
CONST
update
message
ids
drawobj
drawobjs
drawobjd
drawnorm
drawsel
drawdel
markW
TYPE
Frame
POINTER
TO
FrameDesc
Location
POINTER
TO
LocDesc
LocDesc
RECORD
x
y
INTEGER
next
Location
END
FrameDesc
RECORD
Display
FrameDesc
graph
Graphics
Graph
Xg
Yg
INTEGER
pos
rel
to
graph
origin
X1
Y1
INTEGER
right
and
upper
margins
x
y
col
INTEGER
x
X
Xg
y
Y
Yg
marked
ticked
BOOLEAN
mark
LocDesc
END
DrawMsg
RECORD
Graphics
Msg
f
Frame
x
y
col
mode
INTEGER
END
UpdateMsg
RECORD
Display
FrameMsg
id
INTEGER
graph
Graphics
Graph
obj
Graphics
Object
END
ChangedMsg
RECORD
Display
FrameMsg
f
Frame
graph
Graphics
Graph
mode
INTEGER
END
SelQuery
RECORD
Display
FrameMsg
f
Frame
time
LONGINT
END
FocusQuery
RECORD
Display
FrameMsg
f
Frame
END
PosQuery
RECORD
Display
FrameMsg
f
Frame
x
y
INTEGER
END
DispMsg
RECORD
Display
FrameMsg
x1
y1
w
INTEGER
pat
INTEGER
graph
Graphics
Graph
END
VAR
Crosshair
Oberon
Marker
tack
dotted
dotted1
INTEGER
patterns
newcap
Graphics
Caption
TBuf
Texts
Buffer
DW
DH
CL
INTEGER
W
Texts
Writer
Exported
procedures
Restore
Focus
Selected
This
Draw
DrawNorm
Erase
DrawObj
EraseObj
Change
Defocus
Deselect
Macro
Open
PROCEDURE
SetChangeMark
F
Frame
col
INTEGER
set
mark
in
corner
of
frame
BEGIN
IF
F
H
THEN
IF
col
THEN
Display
ReplConst
Display
black
F
X
F
W
F
Y
F
H
Display
replace
ELSE
Display
CopyPattern
Display
white
Display
block
F
X
F
W
F
Y
F
H
Display
paint
END
END
END
SetChangeMark
PROCEDURE
Restore
F
Frame
VAR
x
x0
y
INTEGER
M
DrawMsg
BEGIN
F
X1
F
X
F
W
F
Y1
F
Y
F
H
F
x
F
X
F
Xg
DIV
F
y
F
Y
F
Yg
DIV
F
marked
FALSE
F
mark
next
NIL
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Display
ReplConst
F
col
F
X
F
Y
F
W
F
H
IF
F
ticked
THEN
x0
F
X
DIV
y
F
Y
DIV
WHILE
y
F
Y1
DO
x
x0
WHILE
x
F
X1
DO
Display
Dot
Display
white
x
y
Display
replace
INC
x
END
INC
y
END
END
M
f
F
M
x
F
x
M
y
F
y
M
col
M
mode
Graphics
Draw
F
graph
M
IF
F
graph
changed
THEN
SetChangeMark
F
END
END
Restore
PROCEDURE
FlipCross
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
cross
X
Y
Display
invert
END
FlipCross
PROCEDURE
Focus
Frame
VAR
FQ
FocusQuery
BEGIN
FQ
f
NIL
Viewers
Broadcast
FQ
RETURN
FQ
f
END
Focus
PROCEDURE
Selected
Frame
VAR
SQ
SelQuery
BEGIN
SQ
f
NIL
SQ
time
Viewers
Broadcast
SQ
RETURN
SQ
f
END
Selected
PROCEDURE
This
x
y
INTEGER
Frame
VAR
PQ
PosQuery
BEGIN
PQ
f
NIL
PQ
x
x
PQ
y
y
Viewers
Broadcast
PQ
RETURN
PQ
f
END
This
PROCEDURE
Mark
F
Frame
mode
INTEGER
VAR
CM
ChangedMsg
BEGIN
CM
f
F
CM
graph
F
graph
CM
mode
mode
Viewers
Broadcast
CM
END
Mark
PROCEDURE
Draw
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawsel
UM
graph
F
graph
Viewers
Broadcast
UM
END
Draw
PROCEDURE
DrawNorm
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawnorm
UM
graph
F
graph
Viewers
Broadcast
UM
END
DrawNorm
PROCEDURE
Erase
F
Frame
VAR
UM
UpdateMsg
BEGIN
UM
id
drawdel
UM
graph
F
graph
Viewers
Broadcast
UM
Mark
F
END
Erase
PROCEDURE
DrawObj
F
Frame
obj
Graphics
Object
VAR
UM
UpdateMsg
BEGIN
UM
id
drawobj
UM
graph
F
graph
UM
obj
obj
Viewers
Broadcast
UM
END
DrawObj
PROCEDURE
EraseObj
F
Frame
obj
Graphics
Object
VAR
UM
UpdateMsg
BEGIN
UM
id
drawobjd
UM
graph
F
graph
UM
obj
obj
Viewers
Broadcast
UM
END
EraseObj
PROCEDURE
Change
F
Frame
VAR
msg
Graphics
Msg
BEGIN
IF
F
NIL
THEN
Erase
F
Graphics
Change
F
graph
msg
Draw
F
END
END
Change
PROCEDURE
FlipMark
x
y
INTEGER
BEGIN
Display
ReplConst
Display
white
x
y
Display
ReplConst
Display
white
x
y
END
FlipMark
PROCEDURE
Defocus
F
Frame
VAR
m
Location
BEGIN
newcap
NIL
IF
F
marked
THEN
FlipMark
F
mark
x
F
mark
y
m
F
mark
next
WHILE
m
NIL
DO
FlipMark
m
x
m
y
m
m
next
END
F
marked
FALSE
F
mark
next
NIL
END
END
Defocus
PROCEDURE
Deselect
F
Frame
VAR
UM
UpdateMsg
BEGIN
IF
F
NIL
THEN
UM
id
drawnorm
UM
graph
F
graph
Viewers
Broadcast
UM
Graphics
Deselect
F
graph
END
END
Deselect
PROCEDURE
Macro
Lname
Mname
ARRAY
OF
CHAR
VAR
x
y
INTEGER
F
Frame
mac
Graphics
Macro
mh
Graphics
MacHead
L
Graphics
Library
BEGIN
F
Focus
IF
F
NIL
THEN
x
F
mark
x
F
x
y
F
mark
y
F
y
Graphics
GetLib
Lname
FALSE
L
IF
L
NIL
THEN
mh
Graphics
ThisMac
L
Mname
IF
mh
NIL
THEN
Deselect
F
Defocus
F
NEW
mac
mac
x
x
mac
y
y
mac
w
mh
w
mac
h
mh
h
mac
mac
mh
mac
do
Graphics
MacMethod
mac
col
Oberon
CurCol
Graphics
Add
F
graph
mac
DrawObj
F
mac
Mark
F
END
ELSE
Texts
WriteString
W
Lname
Texts
WriteString
W
not
available
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
END
Macro
PROCEDURE
CaptionCopy
F
Frame
x1
y1
INTEGER
T
Texts
Text
beg
end
LONGINT
Graphics
Caption
VAR
ch
CHAR
dx
w
x2
y2
w1
h1
INTEGER
cap
Graphics
Caption
pat
INTEGER
R
Texts
Reader
BEGIN
Texts
Write
W
0DX
NEW
cap
cap
len
end
beg
cap
pos
Graphics
T
len
cap
do
Graphics
CapMethod
Texts
OpenReader
R
T
beg
Texts
Read
R
ch
W
fnt
R
fnt
W
col
R
col
w
cap
x
x1
F
x
cap
y
y1
F
y
R
fnt
minY
WHILE
beg
end
DO
Fonts
GetPat
R
fnt
ch
dx
x2
y2
w1
h1
pat
INC
w
dx
INC
beg
Texts
Write
W
ch
Texts
Read
R
ch
END
cap
w
w
cap
h
W
fnt
height
cap
col
W
col
Texts
Append
Graphics
T
W
buf
Graphics
Add
F
graph
cap
Mark
F
RETURN
cap
END
CaptionCopy
PROCEDURE
NewLine
F
Frame
G
Graphics
Graph
x
y
w
h
INTEGER
VAR
line
Graphics
Line
BEGIN
NEW
line
line
col
Oberon
CurCol
line
x
x
F
x
line
y
y
F
y
line
w
w
line
h
h
line
do
Graphics
LineMethod
Graphics
Add
G
line
Mark
F
END
NewLine
PROCEDURE
Edit
F
Frame
x0
y0
INTEGER
k0
SET
VAR
obj
Graphics
Object
x1
y1
w
h
t
INTEGER
beg
end
time
LONGINT
k1
k2
SET
mark
newmark
Location
T
Texts
Text
Fd
Frame
G
Graphics
Graph
BEGIN
k1
k0
G
F
graph
REPEAT
Input
Mouse
k2
x1
y1
k1
k1
k2
DEC
x1
x1
F
x
MOD
DEC
y1
y1
F
y
MOD
Oberon
DrawMouse
Crosshair
x1
y1
UNTIL
k2
Oberon
FadeMouse
IF
k0
THEN
left
key
w
ABS
x1
x0
h
ABS
y1
y0
IF
k1
THEN
IF
w
h
THEN
set
mark
IF
x1
markW
F
X
x1
markW
F
X1
y1
markW
F
Y
y1
markW
F
Y1
THEN
Defocus
F
Oberon
PassFocus
Viewers
This
F
X
F
Y
F
mark
x
x1
F
mark
y
y1
F
marked
TRUE
FlipMark
x1
y1
END
ELSE
draw
line
Deselect
F
IF
w
h
THEN
IF
y1
y0
THEN
y0
y1
END
NewLine
F
G
x0
y0
Graphics
width
h
ELSE
IF
x1
x0
THEN
x0
x1
END
NewLine
F
G
x0
y0
w
Graphics
width
END
Draw
F
END
ELSIF
k1
THEN
copy
text
selection
to
mark
Deselect
F
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
DrawObj
F
CaptionCopy
F
x1
y1
T
beg
end
Mark
F
END
ELSIF
k1
THEN
IF
F
marked
THEN
set
secondary
mark
NEW
newmark
newmark
x
x1
newmark
y
y1
newmark
next
NIL
FlipMark
x1
y1
mark
F
mark
next
IF
mark
NIL
THEN
F
mark
next
newmark
ELSE
WHILE
mark
next
NIL
DO
mark
mark
next
END
mark
next
newmark
END
END
END
ELSIF
k0
THEN
middle
key
IF
k1
THEN
move
IF
x0
x1
OR
y0
y1
THEN
Fd
This
x1
y1
Erase
F
IF
Fd
F
THEN
Graphics
Move
G
x1
x0
y1
y0
ELSIF
Fd
NIL
Fd
graph
G
THEN
Graphics
Move
G
x1
Fd
x
x0
F
x
DIV
y1
Fd
y
y0
F
y
DIV
END
Draw
F
Mark
F
END
ELSIF
k1
THEN
copy
Fd
This
x1
y1
IF
Fd
NIL
THEN
DrawNorm
F
IF
Fd
F
THEN
Graphics
Copy
G
G
x1
x0
y1
y0
ELSE
Deselect
Fd
Graphics
Copy
G
Fd
graph
x1
Fd
x
x0
F
x
DIV
y1
Fd
y
y0
F
y
DIV
END
Draw
Fd
Mark
F
END
ELSIF
k1
THEN
shift
graph
INC
F
Xg
x1
x0
INC
F
Yg
y1
y0
Restore
F
END
ELSIF
k0
THEN
right
key
select
newcap
NIL
IF
k1
THEN
Deselect
F
END
IF
ABS
x0
x1
ABS
y0
y1
THEN
obj
Graphics
ThisObj
G
x1
F
x
y1
F
y
IF
obj
NIL
THEN
Graphics
SelectObj
G
obj
DrawObj
F
obj
END
ELSE
IF
x1
x0
THEN
t
x0
x0
x1
x1
t
END
IF
y1
y0
THEN
t
y0
y0
y1
y1
t
END
Graphics
SelectArea
G
x0
F
x
y0
F
y
x1
F
x
y1
F
y
Draw
F
END
END
END
Edit
PROCEDURE
NewCaption
F
Frame
col
INTEGER
font
Fonts
Font
BEGIN
Texts
Write
W
0DX
NEW
newcap
newcap
x
F
mark
x
F
x
newcap
y
F
mark
y
F
y
font
minY
newcap
w
newcap
h
font
height
newcap
col
col
newcap
pos
Graphics
T
len
newcap
len
newcap
do
Graphics
CapMethod
Graphics
Add
F
graph
newcap
W
fnt
font
Mark
F
END
NewCaption
PROCEDURE
InsertChar
F
Frame
ch
CHAR
VAR
w1
h1
INTEGER
DM
DispMsg
BEGIN
DM
graph
F
graph
Fonts
GetPat
W
fnt
ch
DM
w
DM
x1
DM
y1
w1
h1
DM
pat
DEC
DM
y1
W
fnt
minY
IF
newcap
x
newcap
w
DM
w
F
x
F
X1
THEN
Viewers
Broadcast
DM
INC
newcap
w
DM
w
INC
newcap
len
Texts
Write
W
ch
END
Texts
Append
Graphics
T
W
buf
END
InsertChar
PROCEDURE
DeleteChar
F
Frame
VAR
w1
h1
INTEGER
ch
CHAR
pos
LONGINT
DM
DispMsg
R
Texts
Reader
BEGIN
DM
graph
F
graph
IF
newcap
len
THEN
pos
Graphics
T
len
Texts
OpenReader
R
Graphics
T
pos
backspace
Texts
Read
R
ch
IF
ch
THEN
Fonts
GetPat
R
fnt
ch
DM
w
DM
x1
DM
y1
w1
h1
DM
pat
DEC
newcap
w
DM
w
DEC
newcap
len
DEC
DM
y1
R
fnt
minY
Viewers
Broadcast
DM
Texts
Delete
Graphics
T
pos
pos
TBuf
END
END
END
DeleteChar
PROCEDURE
GetSelection
F
Frame
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
VAR
obj
Graphics
Object
BEGIN
obj
F
graph
sel
IF
obj
NIL
F
graph
time
time
THEN
CASE
obj
OF
Graphics
Caption
beg
obj
pos
end
obj
pos
obj
len
text
Graphics
T
time
F
graph
time
END
END
END
GetSelection
PROCEDURE
Handle
G
Display
Frame
VAR
M
Display
FrameMsg
VAR
x
y
h
INTEGER
DM
DispMsg
dM
DrawMsg
G1
Frame
BEGIN
CASE
G
OF
Frame
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
x
M
X
M
X
G
x
MOD
y
M
Y
M
Y
G
y
MOD
IF
M
keys
THEN
Edit
G
x
y
M
keys
ELSE
Oberon
DrawMouse
Crosshair
x
y
END
ELSIF
M
id
Oberon
consume
THEN
IF
M
ch
7FX
THEN
DEL
Erase
G
Graphics
Delete
G
graph
Mark
G
ELSIF
M
ch
20X
M
ch
7FX
THEN
IF
newcap
NIL
THEN
InsertChar
G
M
ch
Mark
G
ELSIF
G
marked
THEN
Defocus
G
Deselect
G
NewCaption
G
M
col
M
fnt
InsertChar
G
M
ch
END
ELSIF
M
ch
8X
newcap
NIL
THEN
DeleteChar
G
Mark
G
END
END
UpdateMsg
IF
M
graph
G
graph
THEN
dM
f
G
dM
x
G
x
dM
y
G
y
dM
col
IF
M
id
drawobj
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawobjs
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawobjd
THEN
dM
mode
M
obj
do
draw
M
obj
dM
ELSIF
M
id
drawsel
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
ELSIF
M
id
drawnorm
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
ELSIF
M
id
drawdel
THEN
dM
mode
Graphics
DrawSel
G
graph
dM
END
END
ChangedMsg
IF
M
graph
G
graph
THEN
SetChangeMark
G
M
mode
END
SelQuery
IF
G
graph
sel
NIL
M
time
G
graph
time
THEN
M
f
G
Frame
M
time
G
graph
time
END
FocusQuery
IF
G
marked
THEN
M
f
G
END
PosQuery
IF
G
X
M
x
M
x
G
X1
G
Y
M
y
M
y
G
Y1
THEN
M
f
G
END
DispMsg
DM
M
x
G
x
newcap
x
newcap
w
y
G
y
newcap
y
IF
DM
graph
G
graph
x
G
X
x
DM
w
G
X1
y
G
Y
y
G
Y1
THEN
Display
CopyPattern
Oberon
CurCol
DM
pat
x
DM
x1
y
DM
y1
Display
ReplConst
Display
white
x
y
DM
w
newcap
h
END
Oberon
ControlMsg
IF
M
id
Oberon
neutralize
THEN
Oberon
RemoveMarks
G
X
G
Y
G
W
G
H
Defocus
G
DrawNorm
G
Graphics
Deselect
G
graph
ELSIF
M
id
Oberon
defocus
THEN
Defocus
G
END
Oberon
SelectionMsg
GetSelection
G
M
text
M
beg
M
end
M
time
Oberon
CopyMsg
Oberon
RemoveMarks
G
X
G
Y
G
W
G
H
Defocus
G
NEW
G1
G1
G
M
F
G1
MenuViewers
ModifyMsg
G
Y
M
Y
G
H
M
H
Restore
G
END
END
END
Handle
PROCEDURE
Store
F
Frame
name
ARRAY
OF
CHAR
BEGIN
Mark
F
Graphics
WriteFile
F
graph
name
END
Store
Draw
Methods
PROCEDURE
ReplConst
F
Frame
col
x
y
w
h
mode
INTEGER
BEGIN
IF
x
F
X
THEN
DEC
w
F
X
x
x
F
X
END
IF
x
w
F
X1
THEN
w
F
X1
x
END
IF
y
F
Y
THEN
DEC
h
F
Y
y
y
F
Y
END
IF
y
h
F
Y1
THEN
h
F
Y1
y
END
Display
ReplConst
col
x
y
w
h
mode
END
ReplConst
PROCEDURE
ReplPattern
F
Frame
col
patadr
x
y
w
h
mode
INTEGER
BEGIN
IF
x
F
X
THEN
DEC
w
F
X
x
x
F
X
END
IF
x
w
F
X1
THEN
w
F
X1
x
END
IF
y
F
Y
THEN
DEC
h
F
Y
y
y
F
Y
END
IF
y
h
F
Y1
THEN
h
F
Y1
y
END
Display
ReplPattern
col
patadr
x
y
w
h
mode
END
ReplPattern
PROCEDURE
DrawLine
obj
Graphics
Object
VAR
M
Graphics
Msg
M
mode
draw
according
to
state
normal
selected
selected
normal
erase
VAR
x
y
w
h
col
INTEGER
f
Frame
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
x
w
f
X
x
f
X1
y
h
f
Y
y
f
Y1
THEN
col
obj
col
IF
M
mode
obj
selected
OR
M
mode
THEN
ReplPattern
f
col
Display
grey
x
y
w
h
Display
replace
ELSIF
M
mode
IN
THEN
ReplConst
f
col
x
y
w
h
Display
replace
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
erase
END
END
END
END
DrawLine
PROCEDURE
DrawCaption
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
dx
x0
x1
y0
y1
w
h
w1
h1
col
INTEGER
f
Frame
ch
CHAR
pat
INTEGER
fnt
Fonts
Font
R
Texts
Reader
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
f
X
x
x
f
X1
f
Y
y
y
h
f
Y1
THEN
IF
x
w
f
X1
THEN
w
f
X1
x
END
Texts
OpenReader
R
Graphics
T
obj
Graphics
Caption
pos
Texts
Read
R
ch
IF
M
mode
THEN
IF
ch
THEN
fnt
R
fnt
x0
x
y0
y
fnt
minY
col
obj
col
REPEAT
Fonts
GetPat
fnt
ch
dx
x1
y1
w1
h1
pat
IF
x0
x1
w1
f
X1
THEN
Display
CopyPattern
col
pat
x0
x1
y0
y1
Display
paint
INC
x0
dx
Texts
Read
R
ch
ELSE
ch
0X
END
UNTIL
ch
IF
obj
selected
THEN
ReplConst
f
Display
white
x
y
w
h
Display
invert
END
END
ELSIF
M
mode
IN
THEN
ReplConst
f
Display
white
x
y
w
h
Display
invert
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
END
END
END
END
DrawCaption
PROCEDURE
DrawMacro
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
INTEGER
f
Frame
M1
DrawMsg
BEGIN
CASE
M
OF
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
IF
x
w
f
X
x
f
X1
y
h
f
Y
y
f
Y1
THEN
M1
x
x
M1
y
y
IF
M
mode
THEN
M1
f
f
M1
col
obj
col
M1
mode
Graphics
DrawMac
obj
Graphics
Macro
mac
M1
IF
obj
selected
THEN
ReplPattern
f
Display
white
dotted
x
y
w
h
Display
invert
END
ELSIF
M
mode
IN
THEN
ReplPattern
f
Display
white
dotted
x
y
w
h
Display
invert
ELSIF
M
mode
THEN
ReplConst
f
Display
black
x
y
w
h
Display
replace
END
END
END
END
DrawMacro
PROCEDURE
Open
G
Frame
graph
Graphics
Graph
BEGIN
G
graph
graph
G
Xg
G
Yg
G
x
G
X
G
y
G
Y
G
col
Display
black
G
marked
FALSE
G
mark
next
NIL
G
ticked
TRUE
G
handle
Handle
END
Open
BEGIN
DW
Display
Width
DH
Display
Height
CL
Texts
OpenWriter
W
tack
SYSTEM
ADR
dotted
SYSTEM
ADR
dotted1
SYSTEM
ADR
Crosshair
Fade
FlipCross
Crosshair
Draw
FlipCross
Graphics
InstallDrawMethods
DrawLine
DrawCaption
DrawMacro
END
GraphicFrames
MODULE
Graphics
NW
IMPORT
SYSTEM
Files
Modules
Fonts
Printer
Texts
Oberon
CONST
NameLen
GraphFileId
0FAX
LibFileId
0FBX
TYPE
Graph
POINTER
TO
GraphDesc
Object
POINTER
TO
ObjectDesc
Method
POINTER
TO
MethodDesc
Line
POINTER
TO
LineDesc
Caption
POINTER
TO
CaptionDesc
Macro
POINTER
TO
MacroDesc
ObjectDesc
RECORD
x
y
w
h
INTEGER
col
BYTE
selected
marked
BOOLEAN
do
Method
next
Object
END
Msg
RECORD
END
WidMsg
RECORD
Msg
w
INTEGER
END
ColorMsg
RECORD
Msg
col
INTEGER
END
FontMsg
RECORD
Msg
fnt
Fonts
Font
END
Name
ARRAY
NameLen
OF
CHAR
GraphDesc
RECORD
time
LONGINT
sel
first
Object
changed
BOOLEAN
END
MacHead
POINTER
TO
MacHeadDesc
MacExt
POINTER
TO
MacExtDesc
Library
POINTER
TO
LibraryDesc
MacHeadDesc
RECORD
name
Name
w
h
INTEGER
ext
MacExt
lib
Library
first
Object
next
MacHead
END
LibraryDesc
RECORD
name
Name
first
MacHead
next
Library
END
MacExtDesc
RECORD
END
Context
RECORD
nofonts
noflibs
nofclasses
INTEGER
font
ARRAY
OF
Fonts
Font
lib
ARRAY
OF
Library
class
ARRAY
OF
Modules
Command
END
MethodDesc
RECORD
module
allocator
Name
new
Modules
Command
copy
PROCEDURE
from
to
Object
draw
change
PROCEDURE
obj
Object
VAR
msg
Msg
selectable
PROCEDURE
obj
Object
x
y
INTEGER
BOOLEAN
read
PROCEDURE
obj
Object
VAR
R
Files
Rider
VAR
C
Context
write
PROCEDURE
obj
Object
cno
INTEGER
VAR
R
Files
Rider
VAR
C
Context
print
PROCEDURE
obj
Object
x
y
INTEGER
END
LineDesc
RECORD
ObjectDesc
unused
INTEGER
END
CaptionDesc
RECORD
ObjectDesc
pos
len
INTEGER
END
MacroDesc
RECORD
ObjectDesc
mac
MacHead
END
VAR
width
res
INTEGER
new
Object
T
Texts
Text
captions
LineMethod
CapMethod
MacMethod
Method
GetLib0
PROCEDURE
name
ARRAY
OF
CHAR
replace
BOOLEAN
VAR
Lib
Library
FirstLib
Library
W
TW
XW
Texts
Writer
PROCEDURE
New
obj
Object
BEGIN
new
obj
END
New
PROCEDURE
Add
G
Graph
obj
Object
BEGIN
obj
marked
FALSE
obj
selected
TRUE
obj
next
G
first
G
first
obj
G
sel
obj
G
time
Oberon
Time
G
changed
TRUE
END
Add
PROCEDURE
ThisObj
G
Graph
x
y
INTEGER
Object
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
obj
do
selectable
obj
x
y
DO
obj
obj
next
END
RETURN
obj
END
ThisObj
PROCEDURE
SelectObj
G
Graph
obj
Object
BEGIN
IF
obj
NIL
THEN
obj
selected
TRUE
G
sel
obj
G
time
Oberon
Time
END
END
SelectObj
PROCEDURE
SelectArea
G
Graph
x0
y0
x1
y1
INTEGER
VAR
obj
Object
t
INTEGER
BEGIN
obj
G
first
IF
x1
x0
THEN
t
x0
x0
x1
x1
t
END
IF
y1
y0
THEN
t
y0
y0
y1
y1
t
END
WHILE
obj
NIL
DO
IF
x0
obj
x
obj
x
obj
w
x1
y0
obj
y
obj
y
obj
h
y1
THEN
obj
selected
TRUE
G
sel
obj
END
obj
obj
next
END
IF
G
sel
NIL
THEN
G
time
Oberon
Time
END
END
SelectArea
PROCEDURE
Draw
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
obj
do
draw
obj
M
obj
obj
next
END
END
Draw
PROCEDURE
List
G
Graph
VAR
obj
Object
tag
INTEGER
BEGIN
obj
G
first
WHILE
obj
NIL
DO
Texts
Write
XW
9X
Texts
WriteHex
XW
ORD
obj
Texts
Write
XW
9X
Texts
WriteInt
XW
obj
x
Texts
WriteInt
XW
obj
y
Texts
WriteInt
XW
obj
w
Texts
WriteInt
XW
obj
h
Texts
Write
XW
SYSTEM
GET
ORD
obj
tag
Texts
WriteHex
XW
tag
SYSTEM
GET
ORD
obj
tag
Texts
WriteHex
XW
tag
Texts
WriteLn
XW
obj
obj
next
END
Texts
Append
Oberon
Log
XW
buf
END
List
procedures
operating
on
selection
PROCEDURE
Deselect
G
Graph
VAR
obj
Object
BEGIN
obj
G
first
G
sel
NIL
G
time
WHILE
obj
NIL
DO
obj
selected
FALSE
obj
obj
next
END
END
Deselect
PROCEDURE
DrawSel
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
draw
obj
M
END
obj
obj
next
END
END
DrawSel
PROCEDURE
Change
G
Graph
VAR
M
Msg
VAR
obj
Object
BEGIN
obj
G
first
G
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
change
obj
M
END
obj
obj
next
END
END
Change
PROCEDURE
Move
G
Graph
dx
dy
INTEGER
VAR
obj
ob0
Object
x0
x1
y0
y1
INTEGER
BEGIN
obj
G
first
G
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
obj
IS
Caption
THEN
x0
obj
x
x1
obj
w
x0
y0
obj
y
y1
obj
h
y0
IF
dx
THEN
vertical
move
ob0
G
first
WHILE
ob0
NIL
DO
IF
ob0
selected
ob0
IS
Line
x0
ob0
x
ob0
x
x1
ob0
w
ob0
h
THEN
IF
y0
ob0
y
ob0
y
y1
THEN
INC
ob0
y
dy
DEC
ob0
h
dy
ob0
marked
TRUE
ELSIF
y0
ob0
y
ob0
h
ob0
y
ob0
h
y1
THEN
INC
ob0
h
dy
ob0
marked
TRUE
END
END
ob0
ob0
next
END
ELSIF
dy
THEN
horizontal
move
ob0
G
first
WHILE
ob0
NIL
DO
IF
ob0
selected
ob0
IS
Line
y0
ob0
y
ob0
y
y1
ob0
h
ob0
w
THEN
IF
x0
ob0
x
ob0
x
x1
THEN
INC
ob0
x
dx
DEC
ob0
w
dx
ob0
marked
TRUE
ELSIF
x0
ob0
x
ob0
w
ob0
x
ob0
w
x1
THEN
INC
ob0
w
dx
ob0
marked
TRUE
END
END
ob0
ob0
next
END
END
END
obj
obj
next
END
obj
G
first
now
move
WHILE
obj
NIL
DO
IF
obj
selected
THEN
INC
obj
x
dx
INC
obj
y
dy
END
obj
marked
FALSE
obj
obj
next
END
END
Move
PROCEDURE
Copy
Gs
Gd
Graph
dx
dy
INTEGER
VAR
obj
Object
BEGIN
obj
Gs
first
Gd
changed
TRUE
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
new
obj
do
copy
obj
new
INC
new
x
dx
INC
new
y
dy
obj
selected
FALSE
Add
Gd
new
END
obj
obj
next
END
new
NIL
END
Copy
PROCEDURE
Delete
G
Graph
VAR
obj
pred
Object
BEGIN
G
sel
NIL
G
changed
TRUE
obj
G
first
WHILE
obj
NIL
obj
selected
DO
obj
obj
next
END
G
first
obj
IF
obj
NIL
THEN
pred
obj
obj
obj
next
WHILE
obj
NIL
DO
IF
obj
selected
THEN
pred
next
obj
next
ELSE
pred
obj
END
obj
obj
next
END
END
END
Delete
Storing
PROCEDURE
WMsg
s0
s1
ARRAY
OF
CHAR
BEGIN
Texts
WriteString
W
s0
Texts
WriteString
W
s1
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
WMsg
PROCEDURE
InitContext
VAR
C
Context
BEGIN
C
nofonts
C
noflibs
C
nofclasses
C
class
LineMethod
new
C
class
CapMethod
new
C
class
MacMethod
new
END
InitContext
PROCEDURE
FontNo
VAR
W
Files
Rider
VAR
C
Context
fnt
Fonts
Font
INTEGER
VAR
fno
INTEGER
BEGIN
fno
WHILE
fno
C
nofonts
C
font
fno
fnt
DO
INC
fno
END
IF
fno
C
nofonts
THEN
Files
WriteByte
W
Files
WriteByte
W
Files
WriteByte
W
fno
Files
WriteString
W
fnt
name
C
font
fno
fnt
INC
C
nofonts
END
RETURN
fno
END
FontNo
PROCEDURE
StoreElems
VAR
W
Files
Rider
VAR
C
Context
obj
Object
VAR
cno
INTEGER
BEGIN
WHILE
obj
NIL
DO
cno
WHILE
cno
C
nofclasses
obj
do
new
C
class
cno
DO
INC
cno
END
IF
cno
C
nofclasses
THEN
Files
WriteByte
W
Files
WriteByte
W
Files
WriteByte
W
cno
Files
WriteString
W
obj
do
module
Files
WriteString
W
obj
do
allocator
C
class
cno
obj
do
new
INC
C
nofclasses
END
obj
do
write
obj
cno
W
C
obj
obj
next
END
Files
WriteByte
W
END
StoreElems
PROCEDURE
Store
G
Graph
VAR
W
Files
Rider
VAR
C
Context
BEGIN
InitContext
C
StoreElems
W
C
G
first
G
changed
FALSE
END
Store
PROCEDURE
WriteObj
VAR
W
Files
Rider
cno
INTEGER
obj
Object
BEGIN
Files
WriteByte
W
cno
Files
WriteInt
W
obj
y
10000H
obj
x
Files
WriteInt
W
obj
h
10000H
obj
w
Files
WriteByte
W
obj
col
END
WriteObj
PROCEDURE
WriteFile
G
Graph
name
ARRAY
OF
CHAR
VAR
F
Files
File
W
Files
Rider
C
Context
BEGIN
F
Files
New
name
Files
Set
W
F
Files
Write
W
GraphFileId
InitContext
C
StoreElems
W
C
G
first
Files
Register
F
END
WriteFile
PROCEDURE
Print
G
Graph
x0
y0
INTEGER
VAR
obj
Object
BEGIN
obj
G
first
WHILE
obj
NIL
DO
obj
do
print
obj
x0
y0
obj
obj
next
END
END
Print
Loading
PROCEDURE
GetClass
module
allocator
ARRAY
OF
CHAR
VAR
com
Modules
Command
VAR
mod
Modules
Module
BEGIN
Modules
Load
module
mod
IF
mod
NIL
THEN
com
Modules
ThisCommand
mod
allocator
IF
com
NIL
THEN
WMsg
allocator
unknown
END
ELSE
WMsg
module
not
available
com
NIL
END
END
GetClass
PROCEDURE
Font
VAR
R
Files
Rider
VAR
C
Context
Fonts
Font
VAR
fno
BYTE
BEGIN
Files
ReadByte
R
fno
RETURN
C
font
fno
END
Font
PROCEDURE
ReadObj
VAR
R
Files
Rider
obj
Object
VAR
xy
wh
INTEGER
dmy
BYTE
BEGIN
Files
ReadInt
R
xy
obj
y
xy
DIV
10000H
obj
x
xy
10000H
DIV
10000H
Files
ReadInt
R
wh
obj
h
wh
DIV
10000H
obj
w
wh
10000H
DIV
10000H
Files
ReadByte
R
obj
col
END
ReadObj
PROCEDURE
LoadElems
VAR
R
Files
Rider
VAR
C
Context
VAR
fobj
Object
VAR
cno
m
n
len
BYTE
pos
INTEGER
obj
Object
fnt
Fonts
Font
name
name1
ARRAY
OF
CHAR
BEGIN
obj
NIL
Files
ReadByte
R
cno
WHILE
R
eof
cno
DO
IF
cno
THEN
Files
ReadByte
R
m
Files
ReadByte
R
n
Files
ReadString
R
name
IF
m
THEN
fnt
Fonts
This
name
C
font
n
fnt
ELSIF
m
THEN
GetLib0
name
FALSE
C
lib
n
ELSIF
m
THEN
Files
ReadString
R
name1
GetClass
name
name1
C
class
n
END
ELSIF
C
class
cno
NIL
THEN
C
class
cno
ReadObj
R
new
new
selected
FALSE
new
marked
FALSE
new
next
obj
obj
new
new
do
read
new
R
C
ELSE
ReadObj
R
new
Files
ReadByte
R
len
pos
Files
Pos
R
Files
Set
R
Files
Base
R
pos
len
END
Files
ReadByte
R
cno
END
new
NIL
fobj
obj
END
LoadElems
PROCEDURE
Load
G
Graph
VAR
R
Files
Rider
VAR
C
Context
BEGIN
G
sel
NIL
InitContext
C
LoadElems
R
C
G
first
END
Load
PROCEDURE
Open
G
Graph
name
ARRAY
OF
CHAR
VAR
tag
CHAR
F
Files
File
R
Files
Rider
C
Context
BEGIN
G
first
NIL
G
sel
NIL
G
time
G
changed
FALSE
F
Files
Old
name
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
tag
IF
tag
GraphFileId
THEN
InitContext
C
LoadElems
R
C
G
first
res
ELSE
res
END
ELSE
res
END
END
Open
PROCEDURE
SetWidth
w
INTEGER
BEGIN
width
w
END
SetWidth
Macros
Libraries
PROCEDURE
GetLib
name
ARRAY
OF
CHAR
replace
BOOLEAN
VAR
Lib
Library
VAR
i
wh
INTEGER
ch
CHAR
L
Library
mh
MacHead
obj
Object
F
Files
File
R
Files
Rider
C
Context
Lname
Fname
ARRAY
OF
CHAR
BEGIN
L
FirstLib
i
WHILE
L
NIL
L
name
name
DO
L
L
next
END
IF
L
NIL
THEN
load
library
from
file
i
WHILE
name
i
0X
DO
Fname
i
name
i
INC
i
END
Fname
i
Fname
i
L
Fname
i
i
Fname
i
b
Fname
i
0X
F
Files
Old
Fname
IF
F
NIL
THEN
WMsg
loading
Fname
Files
Set
R
F
Files
Read
R
ch
IF
ch
LibFileId
THEN
IF
L
NIL
THEN
NEW
L
L
name
name
L
next
FirstLib
FirstLib
L
END
L
first
NIL
InitContext
C
LoadElems
R
C
obj
WHILE
obj
NIL
DO
NEW
mh
mh
first
obj
Files
ReadInt
R
wh
mh
h
wh
DIV
10000H
MOD
10000H
mh
w
wh
MOD
10000H
Files
ReadString
R
mh
name
mh
lib
L
mh
next
L
first
L
first
mh
LoadElems
R
C
obj
END
ELSE
L
NIL
END
ELSE
L
NIL
END
END
Lib
L
END
GetLib
PROCEDURE
NewLib
Lname
ARRAY
OF
CHAR
Library
VAR
L
Library
BEGIN
NEW
L
L
name
Lname
L
first
NIL
L
next
FirstLib
FirstLib
L
RETURN
L
END
NewLib
PROCEDURE
StoreLib
L
Library
Fname
ARRAY
OF
CHAR
VAR
i
INTEGER
mh
MacHead
F
Files
File
W
Files
Rider
C
Context
Gname
ARRAY
OF
CHAR
BEGIN
L
FirstLib
WHILE
L
NIL
L
name
Fname
DO
L
L
next
END
IF
L
NIL
THEN
i
WHILE
Fname
i
0X
DO
Gname
i
Fname
i
INC
i
END
Gname
i
Gname
i
L
Gname
i
i
Gname
i
b
Gname
i
0X
F
Files
New
Gname
Files
Set
W
F
Files
Write
W
LibFileId
InitContext
C
mh
L
first
WHILE
mh
NIL
DO
StoreElems
W
C
mh
first
Files
WriteInt
W
mh
h
10000H
mh
w
Files
WriteString
W
mh
name
mh
mh
next
END
Files
WriteByte
W
Files
Register
F
ELSE
Texts
WriteString
TW
Fname
Texts
WriteString
TW
not
found
Texts
WriteLn
TW
Texts
Append
Oberon
Log
TW
buf
END
END
StoreLib
PROCEDURE
RemoveLibraries
BEGIN
FirstLib
NIL
END
RemoveLibraries
PROCEDURE
ThisMac
L
Library
Mname
ARRAY
OF
CHAR
MacHead
VAR
mh
MacHead
BEGIN
mh
L
first
WHILE
mh
NIL
mh
name
Mname
DO
mh
mh
next
END
RETURN
mh
END
ThisMac
PROCEDURE
DrawMac
mh
MacHead
VAR
M
Msg
VAR
elem
Object
BEGIN
elem
mh
first
WHILE
elem
NIL
DO
elem
do
draw
elem
M
elem
elem
next
END
END
DrawMac
Procedures
for
designing
macros
PROCEDURE
OpenMac
mh
MacHead
G
Graph
x
y
INTEGER
VAR
obj
Object
BEGIN
obj
mh
first
WHILE
obj
NIL
DO
obj
do
new
obj
do
copy
obj
new
INC
new
x
x
INC
new
y
y
new
selected
TRUE
Add
G
new
obj
obj
next
END
new
NIL
END
OpenMac
PROCEDURE
MakeMac
G
Graph
VAR
head
MacHead
VAR
x0
y0
x1
y1
INTEGER
obj
last
Object
mh
MacHead
BEGIN
obj
G
first
last
NIL
x0
x1
y0
y1
WHILE
obj
NIL
DO
IF
obj
selected
THEN
obj
do
new
obj
do
copy
obj
new
new
next
last
new
selected
FALSE
last
new
IF
obj
x
x0
THEN
x0
obj
x
END
IF
obj
x
obj
w
x1
THEN
x1
obj
x
obj
w
END
IF
obj
y
y0
THEN
y0
obj
y
END
IF
obj
y
obj
h
y1
THEN
y1
obj
y
obj
h
END
END
obj
obj
next
END
obj
last
WHILE
obj
NIL
DO
obj
x
obj
x
x0
obj
y
obj
y
y0
obj
obj
next
END
NEW
mh
mh
w
x1
x0
mh
h
y1
y0
mh
first
last
mh
ext
NIL
new
NIL
head
mh
END
MakeMac
PROCEDURE
InsertMac
mh
MacHead
L
Library
VAR
new
BOOLEAN
VAR
mh1
MacHead
BEGIN
mh
lib
L
mh1
L
first
WHILE
mh1
NIL
mh1
name
mh
name
DO
mh1
mh1
next
END
IF
mh1
NIL
THEN
new
TRUE
mh
next
L
first
L
first
mh
ELSE
new
FALSE
mh1
w
mh
w
mh1
h
mh
h
mh1
first
mh
first
END
END
InsertMac
Line
Methods
PROCEDURE
NewLine
VAR
line
Line
BEGIN
NEW
line
new
line
line
do
LineMethod
END
NewLine
PROCEDURE
CopyLine
src
dst
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
END
CopyLine
PROCEDURE
ChangeLine
obj
Object
VAR
M
Msg
BEGIN
CASE
M
OF
WidMsg
IF
obj
w
obj
h
THEN
IF
obj
w
THEN
obj
w
M
w
END
ELSIF
obj
h
THEN
obj
h
M
w
END
ColorMsg
obj
col
M
col
END
END
ChangeLine
PROCEDURE
LineSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
w
obj
y
y
y
obj
y
obj
h
END
LineSelectable
PROCEDURE
ReadLine
obj
Object
VAR
R
Files
Rider
VAR
C
Context
BEGIN
END
ReadLine
PROCEDURE
WriteLine
obj
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Context
BEGIN
WriteObj
W
cno
obj
END
WriteLine
PROCEDURE
PrintLine
obj
Object
x
y
INTEGER
VAR
w
h
INTEGER
BEGIN
w
obj
w
h
obj
h
IF
w
h
THEN
h
h
ELSE
w
w
END
Printer
ReplConst
obj
x
x
obj
y
y
w
h
END
PrintLine
Caption
Methods
PROCEDURE
NewCaption
VAR
cap
Caption
BEGIN
NEW
cap
new
cap
cap
do
CapMethod
END
NewCaption
PROCEDURE
CopyCaption
src
dst
Object
VAR
ch
CHAR
R
Texts
Reader
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Caption
pos
T
len
dst
Caption
len
src
Caption
len
Texts
Write
TW
0DX
Texts
OpenReader
R
T
src
Caption
pos
Texts
Read
R
ch
TW
fnt
R
fnt
WHILE
ch
0DX
DO
Texts
Write
TW
ch
Texts
Read
R
ch
END
Texts
Append
T
TW
buf
END
CopyCaption
PROCEDURE
ChangeCaption
obj
Object
VAR
M
Msg
VAR
dx
x1
dy
y1
w
w1
h1
len
INTEGER
pos
LONGINT
ch
CHAR
patadr
INTEGER
fnt
Fonts
Font
R
Texts
Reader
BEGIN
CASE
M
OF
FontMsg
fnt
M
FontMsg
fnt
w
len
pos
obj
Caption
pos
Texts
OpenReader
R
T
pos
Texts
Read
R
ch
dy
R
fnt
minY
WHILE
ch
0DX
DO
Fonts
GetPat
fnt
ch
dx
x1
y1
w1
h1
patadr
INC
w
dx
INC
len
Texts
Read
R
ch
END
INC
obj
y
fnt
minY
dy
obj
w
w
obj
h
fnt
height
Texts
ChangeLooks
T
pos
pos
len
fnt
ColorMsg
obj
col
M
ColorMsg
col
END
END
ChangeCaption
PROCEDURE
CaptionSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
w
obj
y
y
y
obj
y
obj
h
END
CaptionSelectable
PROCEDURE
ReadCaption
obj
Object
VAR
R
Files
Rider
VAR
C
Context
VAR
ch
CHAR
fno
BYTE
len
INTEGER
BEGIN
obj
Caption
pos
T
len
Texts
Write
TW
0DX
Files
ReadByte
R
fno
TW
fnt
C
font
fno
len
Files
Read
R
ch
WHILE
ch
0DX
DO
Texts
Write
TW
ch
INC
len
Files
Read
R
ch
END
obj
Caption
len
len
Texts
Append
T
TW
buf
END
ReadCaption
PROCEDURE
WriteCaption
obj
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Context
VAR
ch
CHAR
fno
BYTE
TR
Texts
Reader
BEGIN
IF
obj
Caption
len
THEN
Texts
OpenReader
TR
T
obj
Caption
pos
Texts
Read
TR
ch
fno
FontNo
W
C
TR
fnt
WriteObj
W
cno
obj
Files
WriteByte
W
fno
WHILE
ch
0DX
DO
Files
Write
W
ch
Texts
Read
TR
ch
END
Files
Write
W
0X
END
END
WriteCaption
PROCEDURE
PrintCaption
obj
Object
x
y
INTEGER
VAR
fnt
Fonts
Font
i
INTEGER
ch
CHAR
R
Texts
Reader
s
ARRAY
OF
CHAR
BEGIN
IF
obj
Caption
len
THEN
Texts
OpenReader
R
T
obj
Caption
pos
Texts
Read
R
ch
fnt
R
fnt
DEC
y
fnt
minY
i
WHILE
ch
DO
s
i
ch
INC
i
Texts
Read
R
ch
END
s
i
0X
IF
i
THEN
Printer
String
obj
x
x
obj
y
y
s
fnt
name
END
END
END
PrintCaption
Macro
Methods
PROCEDURE
NewMacro
VAR
mac
Macro
BEGIN
NEW
mac
new
mac
mac
do
MacMethod
END
NewMacro
PROCEDURE
CopyMacro
src
dst
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Macro
mac
src
Macro
mac
END
CopyMacro
PROCEDURE
ChangeMacro
obj
Object
VAR
M
Msg
BEGIN
CASE
M
OF
ColorMsg
obj
col
M
col
END
END
ChangeMacro
PROCEDURE
MacroSelectable
obj
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
y
y
y
obj
y
END
MacroSelectable
PROCEDURE
ReadMacro
obj
Object
VAR
R
Files
Rider
VAR
C
Context
VAR
lno
BYTE
name
ARRAY
OF
CHAR
BEGIN
Files
ReadByte
R
lno
Files
ReadString
R
name
obj
Macro
mac
ThisMac
C
lib
lno
name
END
ReadMacro
PROCEDURE
WriteMacro
obj
Object
cno
INTEGER
VAR
W1
Files
Rider
VAR
C
Context
VAR
lno
INTEGER
BEGIN
lno
WHILE
lno
C
noflibs
obj
Macro
mac
lib
C
lib
lno
DO
INC
lno
END
IF
lno
C
noflibs
THEN
Files
WriteByte
W1
Files
WriteByte
W1
Files
WriteByte
W1
lno
Files
WriteString
W1
obj
Macro
mac
lib
name
C
lib
lno
obj
Macro
mac
lib
INC
C
noflibs
END
WriteObj
W1
cno
obj
Files
WriteByte
W1
lno
Files
WriteString
W1
obj
Macro
mac
name
END
WriteMacro
PROCEDURE
PrintMacro
obj
Object
x
y
INTEGER
VAR
elem
Object
mh
MacHead
BEGIN
mh
obj
Macro
mac
IF
mh
NIL
THEN
elem
mh
first
WHILE
elem
NIL
DO
elem
do
print
elem
obj
x
x
obj
y
y
elem
elem
next
END
END
END
PrintMacro
PROCEDURE
Notify
T
Texts
Text
op
INTEGER
beg
end
LONGINT
BEGIN
END
Notify
PROCEDURE
InstallDrawMethods
drawLine
drawCaption
drawMacro
PROCEDURE
obj
Object
VAR
msg
Msg
BEGIN
LineMethod
draw
drawLine
CapMethod
draw
drawCaption
MacMethod
draw
drawMacro
END
InstallDrawMethods
BEGIN
Texts
OpenWriter
W
Texts
OpenWriter
TW
Texts
OpenWriter
XW
width
GetLib0
GetLib
NEW
T
Texts
Open
T
T
notify
Notify
NEW
LineMethod
LineMethod
new
NewLine
LineMethod
copy
CopyLine
LineMethod
selectable
LineSelectable
LineMethod
change
ChangeLine
LineMethod
read
ReadLine
LineMethod
write
WriteLine
LineMethod
print
PrintLine
NEW
CapMethod
CapMethod
new
NewCaption
CapMethod
copy
CopyCaption
CapMethod
selectable
CaptionSelectable
CapMethod
change
ChangeCaption
CapMethod
read
ReadCaption
CapMethod
write
WriteCaption
CapMethod
print
PrintCaption
NEW
MacMethod
MacMethod
new
NewMacro
MacMethod
copy
CopyMacro
MacMethod
selectable
MacroSelectable
MacMethod
change
ChangeMacro
MacMethod
read
ReadMacro
MacMethod
write
WriteMacro
MacMethod
print
PrintMacro
END
Graphics
MODULE
GraphTool
NW
IMPORT
Files
Texts
Oberon
CONST
Context
Line
Caption
Macro
Rectangles
VAR
W
Texts
Writer
PROCEDURE
DecGraph
VAR
ch
CHAR
class
col
fno
cat
inx
libno
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0F8X
THEN
Files
ReadByte
R
class
WHILE
R
eof
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Files
Read
R
ch
Texts
WriteInt
W
col
Texts
Write
W
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Macro
THEN
Files
ReadByte
R
libno
Files
ReadString
R
name
Texts
WriteInt
W
libno
Texts
Write
W
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
file
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecGraph
PROCEDURE
DecGraph1
VAR
ch
CHAR
class
col
fno
len
lw
vers
cat
inx
libno
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0FAX
THEN
Files
ReadByte
R
class
WHILE
R
eof
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Texts
WriteInt
W
col
Texts
Write
W
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Macro
THEN
Files
ReadByte
R
libno
Files
ReadString
R
name
Texts
WriteInt
W
libno
Texts
Write
W
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
len
Texts
WriteInt
W
len
Files
ReadByte
R
lw
Texts
WriteInt
W
lw
Files
ReadByte
R
vers
Texts
WriteInt
W
vers
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
file
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecGraph1
PROCEDURE
DecLibrary1
VAR
ch
CHAR
class
col
fno
cat
inx
libno
len
lnw
vers
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
library1
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
Read
R
ch
IF
ch
0FBX
THEN
Files
ReadByte
R
class
WHILE
class
R
eof
DO
WHILE
class
DO
Texts
WriteInt
W
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
END
ELSE
Files
ReadInt
R
xy
Texts
WriteInt
W
xy
10000H
DIV
10000H
Texts
WriteInt
W
xy
DIV
10000H
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
10000H
DIV
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadByte
R
col
Texts
WriteInt
W
col
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Texts
Write
W
Files
ReadByte
R
fno
Texts
WriteInt
W
fno
Texts
Write
W
Files
ReadString
R
name
Texts
WriteString
W
name
ELSIF
class
Rectangles
THEN
Texts
Write
W
Files
ReadByte
R
len
Texts
WriteInt
W
len
Files
ReadByte
R
lnw
Texts
WriteInt
W
lnw
Files
ReadByte
R
vers
Texts
WriteInt
W
vers
ELSE
Texts
WriteString
W
other
class
Texts
WriteInt
W
class
END
END
Texts
WriteLn
W
Files
ReadByte
R
class
END
end
macro
Texts
WriteString
W
Files
ReadInt
R
wh
Texts
WriteInt
W
wh
MOD
10000H
Texts
WriteInt
W
wh
DIV
10000H
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
library
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecLibrary1
PROCEDURE
ConvertFontname
VAR
x
ARRAY
OF
CHAR
BEGIN
Syntax
Oberon
IF
x
S
x
y
x
n
x
t
x
a
x
x
THEN
x
O
x
b
x
e
x
r
x
o
x
n
END
END
ConvertFontname
PROCEDURE
ConvertLibrary
VAR
ch
CHAR
class
col
fno
cat
inx
libno
len
lnw
vers
BYTE
xy
wh
INTEGER
name
ARRAY
OF
CHAR
F
G
Files
File
R
Q
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
convert
library
Texts
WriteString
W
S
s
F
Files
Old
S
s
IF
F
NIL
THEN
Texts
Scan
S
G
Files
New
S
s
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Files
Set
R
F
Files
Set
Q
G
Files
Read
R
ch
IF
ch
0FDX
THEN
Files
Write
Q
0FBX
Files
ReadByte
R
class
WHILE
class
R
eof
DO
WHILE
class
DO
Files
WriteByte
Q
class
IF
class
Context
THEN
Files
ReadByte
R
cat
Files
ReadByte
R
inx
Texts
WriteInt
W
cat
Texts
WriteInt
W
inx
Files
WriteByte
Q
cat
Files
WriteByte
Q
inx
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
IF
cat
THEN
font
ConvertFontname
name
END
Files
WriteString
Q
name
IF
cat
THEN
class
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
Files
WriteString
Q
name
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
ELSE
Files
ReadInt
R
xy
Files
WriteInt
Q
xy
Files
ReadInt
R
wh
Files
WriteInt
Q
wh
Files
ReadByte
R
col
Files
Read
R
ch
Files
WriteByte
Q
IF
class
Line
THEN
ELSIF
class
Caption
THEN
Files
ReadByte
R
fno
Files
WriteByte
Q
fno
Files
ReadString
R
name
Files
WriteString
Q
name
ELSIF
class
Rectangles
THEN
Files
ReadByte
R
len
Files
WriteByte
Q
len
Files
ReadByte
R
len
Files
ReadByte
R
lnw
Files
WriteByte
Q
lnw
Files
ReadByte
R
vers
Files
WriteByte
Q
vers
ELSE
Texts
WriteString
W
alien
class
Texts
WriteInt
W
class
END
END
Files
ReadByte
R
class
END
Files
WriteByte
Q
end
macro
Files
ReadInt
R
wh
Files
WriteInt
Q
wh
Files
ReadString
R
name
Files
WriteString
Q
name
Texts
WriteString
W
name
Texts
WriteInt
W
wh
MOD
10000H
Texts
WriteInt
W
wh
DIV
10000H
Texts
WriteLn
W
Files
ReadByte
R
class
END
ELSE
Texts
WriteString
W
not
a
graphics
library
END
Files
Register
G
Texts
WriteString
W
done
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
ConvertLibrary
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
GraphTool
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
GraphTool
MODULE
Input
NW
Ceres
PDR
NW
Ceres
IMPORT
SYSTEM
CONST
msAdr
kbdAdr
VAR
kbdCode
BYTE
last
keyboard
code
read
Recd
Up
Shift
Ctrl
Ext
BOOLEAN
KTabAdr
INTEGER
keyboard
code
translation
table
MW
MH
MX
MY
INTEGER
mouse
limits
and
coords
MK
SET
mouse
keys
FIFO
implemented
in
hardware
because
every
read
must
be
handled
including
tracking
the
state
of
the
Shift
and
Ctrl
keys
PROCEDURE
Peek
BEGIN
IF
SYSTEM
BIT
msAdr
THEN
SYSTEM
GET
kbdAdr
kbdCode
IF
kbdCode
0F0H
THEN
Up
TRUE
ELSIF
kbdCode
0E0H
THEN
Ext
TRUE
ELSE
IF
kbdCode
12H
OR
kbdCode
59H
THEN
shift
Shift
Up
ELSIF
kbdCode
14H
THEN
ctrl
Ctrl
Up
ELSIF
Up
THEN
Recd
TRUE
real
key
going
down
END
Up
FALSE
Ext
FALSE
END
END
END
Peek
PROCEDURE
Available
INTEGER
BEGIN
Peek
RETURN
ORD
Recd
END
Available
PROCEDURE
Read
VAR
ch
CHAR
BEGIN
WHILE
Recd
DO
Peek
END
IF
Shift
OR
Ctrl
THEN
INC
kbdCode
80H
END
ctrl
implies
shift
ch
kbdTab
kbdCode
SYSTEM
GET
KTabAdr
kbdCode
ch
IF
Ctrl
THEN
ch
CHR
ORD
ch
MOD
20H
END
Recd
FALSE
END
Read
PROCEDURE
Mouse
VAR
keys
SET
VAR
x
y
INTEGER
VAR
w
INTEGER
BEGIN
SYSTEM
GET
msAdr
w
keys
SYSTEM
VAL
SET
w
DIV
1000000H
MOD
x
w
MOD
400H
y
w
DIV
1000H
MOD
400H
IF
y
MH
THEN
y
MH
END
END
Mouse
PROCEDURE
SetMouseLimits
w
h
INTEGER
BEGIN
MW
w
MH
h
END
SetMouseLimits
PROCEDURE
Init
BEGIN
Up
FALSE
Shift
FALSE
Ctrl
FALSE
Recd
FALSE
KTabAdr
SYSTEM
ADR
1A
7A
6E
6D
6A
2C
6B
6F
2E
2F
6C
3B
2D
5B
3D
0D
5D
5C
7F
1B
7E
5A
4E
5E
4D
4A
2A
3C
4B
4F
3E
3F
4C
3A
5F
7B
2B
0D
7D
7C
7F
1B
END
Init
BEGIN
Init
END
Input
MODULE
Kernel
NW
PR
IMPORT
SYSTEM
CONST
SectorLength
timer
spiData
spiCtrl
CARD0
SPIFAST
FSoffset
80000H
256MB
in
byte
blocks
mapsize
10000H
1K
sectors
64MB
TYPE
Sector
ARRAY
SectorLength
OF
BYTE
VAR
allocated
NofSectors
INTEGER
heapOrg
heapLim
INTEGER
stackOrg
stackSize
MemLim
INTEGER
clock
INTEGER
list0
list1
list2
list3
INTEGER
lists
of
free
blocks
of
size
n
bytes
data
INTEGER
SPI
data
in
sectorMap
ARRAY
mapsize
DIV
OF
SET
New
heap
allocation
PROCEDURE
GetBlock
VAR
p
LONGINT
len
LONGINT
len
is
multiple
of
VAR
q0
q1
q2
size
LONGINT
done
BOOLEAN
BEGIN
q0
q1
list0
done
FALSE
WHILE
done
q1
DO
SYSTEM
GET
q1
size
SYSTEM
GET
q1
q2
IF
size
len
THEN
no
fit
q0
q1
q1
q2
ELSIF
size
len
THEN
extract
p
done
TRUE
p
q1
IF
q0
THEN
SYSTEM
PUT
q0
q2
ELSE
list0
q2
END
ELSE
reduce
size
done
TRUE
p
q1
q1
q1
len
SYSTEM
PUT
q1
size
len
SYSTEM
PUT
q1
SYSTEM
PUT
q1
q2
IF
q0
THEN
SYSTEM
PUT
q0
q1
ELSE
list0
q1
END
END
END
IF
done
THEN
p
END
END
GetBlock
PROCEDURE
GetBlock128
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list1
THEN
p
list1
SYSTEM
GET
list1
list1
ELSE
GetBlock
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list1
list1
q
p
q
END
END
GetBlock128
PROCEDURE
GetBlock64
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list2
THEN
p
list2
SYSTEM
GET
list2
list2
ELSE
GetBlock128
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list2
list2
q
p
q
END
END
GetBlock64
PROCEDURE
GetBlock32
VAR
p
LONGINT
VAR
q
LONGINT
BEGIN
IF
list3
THEN
p
list3
SYSTEM
GET
list3
list3
ELSE
GetBlock64
q
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list3
list3
q
p
q
END
END
GetBlock32
PROCEDURE
New
VAR
ptr
LONGINT
tag
LONGINT
called
by
NEW
via
MT
ptr
and
tag
are
pointers
VAR
p
size
lim
LONGINT
BEGIN
SYSTEM
GET
tag
size
IF
size
THEN
GetBlock32
p
ELSIF
size
THEN
GetBlock64
p
ELSIF
size
THEN
GetBlock128
p
ELSE
GetBlock
p
size
DIV
END
IF
p
THEN
ptr
ELSE
ptr
p
SYSTEM
PUT
p
tag
lim
p
size
INC
p
INC
allocated
size
WHILE
p
lim
DO
SYSTEM
PUT
p
INC
p
END
END
END
New
Garbage
collector
PROCEDURE
Mark
pref
LONGINT
VAR
pvadr
offadr
offset
tag
p
q
r
LONGINT
BEGIN
SYSTEM
GET
pref
pvadr
pointers
heapOrg
considered
NIL
WHILE
pvadr
DO
SYSTEM
GET
pvadr
p
SYSTEM
GET
p
offadr
IF
p
heapOrg
offadr
THEN
q
p
mark
elements
in
data
structure
with
root
p
REPEAT
SYSTEM
GET
p
offadr
IF
offadr
THEN
SYSTEM
GET
p
tag
offadr
tag
ELSE
INC
offadr
END
SYSTEM
PUT
p
offadr
SYSTEM
GET
offadr
offset
IF
offset
THEN
down
SYSTEM
GET
p
offset
r
SYSTEM
GET
r
offadr
IF
r
heapOrg
offadr
THEN
SYSTEM
PUT
p
offset
q
q
p
p
r
END
ELSE
up
SYSTEM
GET
q
offadr
SYSTEM
GET
offadr
offset
IF
p
q
THEN
SYSTEM
GET
q
offset
r
SYSTEM
PUT
q
offset
p
p
q
q
r
END
END
UNTIL
p
q
offset
END
INC
pref
SYSTEM
GET
pref
pvadr
END
END
Mark
PROCEDURE
Scan
VAR
p
q
mark
tag
size
LONGINT
BEGIN
p
heapOrg
REPEAT
SYSTEM
GET
p
mark
q
p
WHILE
mark
DO
SYSTEM
GET
p
tag
SYSTEM
GET
tag
size
INC
p
size
SYSTEM
GET
p
mark
END
size
p
q
DEC
allocated
size
size
of
free
block
IF
size
THEN
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list3
list3
q
INC
q
DEC
size
END
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list2
list2
q
INC
q
DEC
size
END
IF
size
MOD
THEN
SYSTEM
PUT
q
SYSTEM
PUT
q
SYSTEM
PUT
q
list1
list1
q
INC
q
DEC
size
END
IF
size
THEN
SYSTEM
PUT
q
size
SYSTEM
PUT
q
SYSTEM
PUT
q
list0
list0
q
INC
q
size
END
END
IF
mark
THEN
SYSTEM
GET
p
tag
SYSTEM
GET
tag
size
SYSTEM
PUT
p
INC
p
size
ELSE
free
SYSTEM
GET
p
size
INC
p
size
END
UNTIL
p
heapLim
END
Scan
Disk
storage
management
PROCEDURE
SPIIdle
n
INTEGER
send
n
FFs
slowly
with
no
card
selected
BEGIN
SYSTEM
PUT
spiCtrl
WHILE
n
DO
DEC
n
SYSTEM
PUT
spiData
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
END
END
SPIIdle
PROCEDURE
SPI
n
INTEGER
send
rcv
byte
slowly
with
card
selected
BEGIN
SYSTEM
PUT
spiCtrl
CARD0
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
END
SPI
PROCEDURE
SPICmd
n
arg
INTEGER
VAR
i
crc
INTEGER
BEGIN
send
cmd
REPEAT
SPIIdle
UNTIL
data
flush
while
unselected
REPEAT
SPI
UNTIL
data
flush
while
selected
IF
n
THEN
crc
ELSIF
n
THEN
crc
ELSE
crc
END
SPI
n
MOD
send
command
FOR
i
TO
BY
DO
SPI
ROR
arg
i
END
send
arg
SPI
crc
i
REPEAT
SPI
DEC
i
UNTIL
data
80H
OR
i
END
SPICmd
PROCEDURE
SDShift
VAR
n
INTEGER
VAR
data
INTEGER
BEGIN
SPICmd
CMD58
get
card
capacity
bit
SYSTEM
GET
spiData
data
SPI
IF
data
OR
SYSTEM
BIT
spiData
THEN
n
n
END
non
SDHC
card
SPI
SPI
SPIIdle
flush
response
END
SDShift
PROCEDURE
ReadSD
src
dst
INTEGER
VAR
i
INTEGER
BEGIN
SDShift
src
SPICmd
src
ASSERT
data
CMD17
read
one
block
i
wait
for
start
data
marker
REPEAT
SPI
INC
i
UNTIL
data
SYSTEM
PUT
spiCtrl
SPIFAST
CARD0
FOR
i
TO
BY
DO
SYSTEM
PUT
spiData
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
SYSTEM
GET
spiData
data
SYSTEM
PUT
dst
data
INC
dst
END
SPI
SPI
SPIIdle
may
be
a
checksum
deselect
card
END
ReadSD
PROCEDURE
WriteSD
dst
src
INTEGER
VAR
i
n
INTEGER
x
BYTE
BEGIN
SDShift
dst
SPICmd
dst
ASSERT
data
CMD24
write
one
block
SPI
write
start
data
marker
SYSTEM
PUT
spiCtrl
SPIFAST
CARD0
FOR
i
TO
BY
DO
SYSTEM
GET
src
n
INC
src
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
END
SPI
SPI
dummy
checksum
i
REPEAT
SPI
INC
i
UNTIL
data
MOD
OR
i
ASSERT
data
MOD
SPIIdle
deselect
card
END
WriteSD
PROCEDURE
InitSecMap
VAR
i
INTEGER
BEGIN
NofSectors
sectorMap
sectorMap
FOR
i
TO
mapsize
DIV
DO
sectorMap
i
END
END
InitSecMap
PROCEDURE
MarkSector
sec
INTEGER
BEGIN
sec
sec
DIV
ASSERT
SYSTEM
H
INCL
sectorMap
sec
DIV
sec
MOD
INC
NofSectors
END
MarkSector
PROCEDURE
FreeSector
sec
INTEGER
BEGIN
sec
sec
DIV
ASSERT
SYSTEM
H
EXCL
sectorMap
sec
DIV
sec
MOD
DEC
NofSectors
END
FreeSector
PROCEDURE
AllocSector
hint
INTEGER
VAR
sec
INTEGER
VAR
s
INTEGER
BEGIN
find
free
sector
starting
after
hint
hint
hint
DIV
ASSERT
SYSTEM
H
s
hint
REPEAT
INC
s
IF
s
mapsize
THEN
s
END
UNTIL
s
MOD
IN
sectorMap
s
DIV
INCL
sectorMap
s
DIV
s
MOD
INC
NofSectors
sec
s
END
AllocSector
PROCEDURE
GetSector
src
INTEGER
VAR
dst
Sector
BEGIN
src
src
DIV
ASSERT
SYSTEM
H
src
src
FSoffset
ReadSD
src
SYSTEM
ADR
dst
ReadSD
src
SYSTEM
ADR
dst
END
GetSector
PROCEDURE
PutSector
dst
INTEGER
VAR
src
Sector
BEGIN
dst
dst
DIV
ASSERT
SYSTEM
H
dst
dst
FSoffset
WriteSD
dst
SYSTEM
ADR
src
WriteSD
dst
SYSTEM
ADR
src
END
PutSector
Miscellaneous
procedures
PROCEDURE
Time
INTEGER
VAR
t
INTEGER
BEGIN
SYSTEM
GET
timer
t
RETURN
t
END
Time
PROCEDURE
Clock
INTEGER
BEGIN
RETURN
clock
END
Clock
PROCEDURE
SetClock
dt
INTEGER
BEGIN
clock
dt
END
SetClock
PROCEDURE
Install
Padr
at
INTEGER
BEGIN
SYSTEM
PUT
at
0E7000000H
Padr
at
DIV
END
Install
PROCEDURE
Trap
VAR
a
INTEGER
b
INTEGER
VAR
u
v
w
INTEGER
BEGIN
u
SYSTEM
REG
SYSTEM
GET
u
v
w
v
DIV
10H
MOD
10H
trap
number
IF
w
THEN
New
a
b
ELSE
stop
LED
w
REPEAT
UNTIL
FALSE
END
END
Trap
PROCEDURE
Init
BEGIN
Install
SYSTEM
ADR
Trap
20H
install
temporary
trap
SYSTEM
GET
MemLim
SYSTEM
GET
heapOrg
stackOrg
heapOrg
stackSize
8000H
heapLim
MemLim
list1
list2
list3
list0
heapOrg
SYSTEM
PUT
list0
heapLim
heapOrg
SYSTEM
PUT
list0
SYSTEM
PUT
list0
allocated
clock
InitSecMap
END
Init
END
Kernel
MODULE
MenuViewers
JG
NW
IMPORT
Input
Display
Viewers
Oberon
CONST
extend
reduce
FrameColor
Display
white
TYPE
Viewer
POINTER
TO
ViewerDesc
ViewerDesc
RECORD
Viewers
ViewerDesc
menuH
INTEGER
END
ModifyMsg
RECORD
Display
FrameMsg
id
INTEGER
dY
Y
H
INTEGER
END
PROCEDURE
Copy
V
Viewer
VAR
V1
Viewer
VAR
Menu
Main
Display
Frame
M
Oberon
CopyMsg
BEGIN
Menu
V
dsc
Main
V
dsc
next
NEW
V1
V1
V
V1
state
M
F
NIL
Menu
handle
Menu
M
V1
dsc
M
F
M
F
NIL
Main
handle
Main
M
V1
dsc
next
M
F
END
Copy
PROCEDURE
Draw
V
Viewers
Viewer
BEGIN
Display
ReplConst
FrameColor
V
X
V
Y
V
H
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
V
Y
V
H
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
W
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
H
V
W
Display
replace
END
Draw
PROCEDURE
Extend
V
Viewer
newY
INTEGER
VAR
dH
INTEGER
BEGIN
dH
V
Y
newY
IF
dH
THEN
Display
ReplConst
Display
black
V
X
newY
V
W
dH
Display
replace
Display
ReplConst
FrameColor
V
X
newY
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
newY
dH
Display
replace
Display
ReplConst
FrameColor
V
X
newY
V
W
Display
replace
END
END
Extend
PROCEDURE
Reduce
V
Viewer
newY
INTEGER
BEGIN
Display
ReplConst
FrameColor
V
X
newY
V
W
Display
replace
END
Reduce
PROCEDURE
Grow
V
Viewer
oldH
INTEGER
VAR
dH
INTEGER
BEGIN
dH
V
H
oldH
IF
dH
THEN
Display
ReplConst
FrameColor
V
X
V
Y
oldH
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
W
V
Y
oldH
dH
Display
replace
Display
ReplConst
FrameColor
V
X
V
Y
V
H
V
W
Display
replace
END
END
Grow
PROCEDURE
Shrink
V
Viewer
newH
INTEGER
BEGIN
Display
ReplConst
FrameColor
V
X
V
Y
newH
V
W
Display
replace
END
Shrink
PROCEDURE
Adjust
F
Display
Frame
id
dY
Y
H
INTEGER
VAR
M
ModifyMsg
BEGIN
M
id
id
M
dY
dY
M
Y
Y
M
H
H
F
handle
F
M
F
Y
Y
F
H
H
END
Adjust
PROCEDURE
Restore
V
Viewer
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
Draw
V
Menu
X
V
X
Menu
Y
V
Y
V
H
Menu
W
V
W
Menu
H
Main
X
V
X
Main
Y
V
Y
V
H
V
menuH
Main
W
V
W
Main
H
IF
V
H
V
menuH
THEN
Adjust
Menu
extend
V
Y
V
H
V
menuH
V
menuH
Adjust
Main
extend
V
Y
V
H
V
menuH
ELSE
Adjust
Menu
extend
V
Y
V
H
END
END
Restore
PROCEDURE
Modify
V
Viewer
Y
H
INTEGER
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
IF
Y
V
Y
THEN
extend
Oberon
RemoveMarks
V
X
Y
V
W
V
Y
Y
Extend
V
Y
IF
H
V
menuH
THEN
Adjust
Menu
extend
Y
H
V
menuH
V
menuH
Adjust
Main
extend
Y
H
V
menuH
ELSE
Adjust
Menu
extend
Y
H
END
ELSIF
Y
V
Y
THEN
reduce
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
IF
H
V
menuH
THEN
Adjust
Main
reduce
Y
H
V
menuH
Adjust
Menu
reduce
Y
H
V
menuH
V
menuH
ELSE
Adjust
Main
reduce
Y
H
V
menuH
Adjust
Menu
reduce
Y
H
END
Reduce
V
Y
END
END
Modify
PROCEDURE
Change
V
Viewer
X
Y
INTEGER
Keys
SET
VAR
Menu
Main
Display
Frame
V1
Viewers
Viewer
keysum
SET
Y0
dY
H
INTEGER
BEGIN
Keys
Menu
V
dsc
Main
V
dsc
next
Oberon
DrawMouseArrow
X
Y
Display
ReplConst
Display
white
V
X
V
Y
V
H
V
dsc
H
V
W
V
dsc
H
Display
invert
Y0
Y
keysum
Keys
Input
Mouse
Keys
X
Y
WHILE
Keys
DO
keysum
keysum
Keys
Oberon
DrawMouseArrow
X
Y
Input
Mouse
Keys
X
Y
END
Display
ReplConst
Display
white
V
X
V
Y
V
H
V
dsc
H
V
W
V
dsc
H
Display
invert
IF
IN
keysum
THEN
IF
IN
keysum
THEN
V1
Viewers
This
X
Y
IF
V1
IS
Viewer
Y
V1
Y
V1
H
V1
Viewer
menuH
THEN
Y
V1
Y
V1
H
END
IF
Y
V1
Y
V
menuH
THEN
Y
V1
Y
V
menuH
END
Viewers
Close
V
Viewers
Open
V
X
Y
Restore
V
ELSE
IF
Y
Y0
THEN
extend
dY
Y
Y0
V1
Viewers
Next
V
IF
V1
state
THEN
CASE
V1
OF
Viewer
IF
V1
H
V1
menuH
THEN
dY
ELSIF
V1
H
V1
menuH
dY
THEN
dY
V1
H
V1
menuH
END
Viewers
Viewer
IF
V1
H
dY
THEN
dY
V1
H
END
END
ELSIF
V1
H
dY
THEN
dY
V1
H
END
Viewers
Change
V
V
Y
V
H
dY
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
Grow
V
V
H
dY
IF
V
H
V
menuH
THEN
Adjust
Menu
extend
dY
V
Y
V
H
V
menuH
V
menuH
Adjust
Main
extend
dY
V
Y
V
H
V
menuH
ELSE
V
H
Adjust
Menu
extend
dY
V
Y
V
H
Adjust
Main
extend
dY
V
Y
V
H
V
menuH
END
ELSIF
Y
Y0
THEN
reduce
dY
Y0
Y
IF
V
H
V
menuH
THEN
IF
V
H
V
menuH
dY
THEN
dY
V
H
V
menuH
END
Oberon
RemoveMarks
V
X
V
Y
V
W
V
H
H
V
H
dY
Adjust
Main
reduce
dY
V
Y
H
V
menuH
Adjust
Menu
reduce
dY
V
Y
H
V
menuH
V
menuH
Shrink
V
H
Viewers
Change
V
V
Y
H
END
END
END
END
END
Change
PROCEDURE
Suspend
V
Viewer
VAR
Menu
Main
Display
Frame
BEGIN
Menu
V
dsc
Main
V
dsc
next
Adjust
Main
reduce
V
Y
V
H
V
menuH
Adjust
Menu
reduce
V
Y
V
H
END
Suspend
PROCEDURE
Handle
V
Display
Frame
VAR
M
Display
FrameMsg
VAR
X
Y
INTEGER
Menu
Main
Display
Frame
V1
Viewer
BEGIN
Menu
V
dsc
Main
V
dsc
next
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
X
M
X
Y
M
Y
IF
Y
V
Y
THEN
Oberon
DrawMouseArrow
X
Y
ELSIF
Y
V
Y
V
H
V
Viewer
menuH
THEN
Main
handle
Main
M
ELSIF
Y
V
Y
V
H
V
Viewer
menuH
THEN
Menu
handle
Menu
M
ELSIF
Y
V
Y
V
H
THEN
IF
IN
M
keys
THEN
Change
V
Viewer
X
Y
M
keys
ELSE
Menu
handle
Menu
M
END
ELSE
Oberon
DrawMouseArrow
X
Y
END
ELSE
Menu
handle
Menu
M
Main
handle
Main
M
END
Oberon
ControlMsg
IF
M
id
Oberon
mark
THEN
X
M
X
Y
M
Y
Oberon
DrawMouseArrow
X
Y
Oberon
DrawPointer
X
Y
ELSE
Menu
handle
Menu
M
Main
handle
Main
M
END
Oberon
CopyMsg
Copy
V
Viewer
V1
M
F
V1
Viewers
ViewerMsg
IF
M
id
Viewers
restore
THEN
Restore
V
Viewer
ELSIF
M
id
Viewers
modify
THEN
Modify
V
Viewer
M
Y
M
H
ELSIF
M
id
Viewers
suspend
THEN
Suspend
V
Viewer
END
Display
FrameMsg
Menu
handle
Menu
M
Main
handle
Main
M
END
END
Handle
PROCEDURE
New
Menu
Main
Display
Frame
menuH
X
Y
INTEGER
Viewer
VAR
V
Viewer
BEGIN
NEW
V
V
handle
Handle
V
dsc
Menu
V
dsc
next
Main
V
menuH
menuH
Viewers
Open
V
X
Y
Restore
V
RETURN
V
END
New
END
MenuViewers
MODULE
Modules
Link
and
load
on
RISC
NW
IMPORT
SYSTEM
Files
CONST
versionkey
1X
MT
DescSize
TYPE
Module
POINTER
TO
ModDesc
Command
PROCEDURE
ModuleName
ARRAY
OF
CHAR
ModDesc
RECORD
name
ModuleName
next
Module
key
num
size
refcnt
INTEGER
data
code
imp
cmd
ent
ptr
unused
INTEGER
addresses
END
VAR
root
M
Module
MTOrg
AllocPtr
res
INTEGER
importing
imported
ModuleName
limit
INTEGER
PROCEDURE
ThisFile
name
ARRAY
OF
CHAR
Files
File
VAR
i
INTEGER
filename
ModuleName
BEGIN
i
WHILE
name
i
0X
DO
filename
i
name
i
INC
i
END
filename
i
filename
i
r
filename
i
s
filename
i
c
filename
i
0X
RETURN
Files
Old
filename
END
ThisFile
PROCEDURE
error
n
INTEGER
name
ARRAY
OF
CHAR
BEGIN
res
n
importing
name
END
error
PROCEDURE
Check
s
ARRAY
OF
CHAR
VAR
i
INTEGER
ch
CHAR
BEGIN
ch
s
res
i
IF
ch
A
ch
Z
OR
ch
a
ch
z
THEN
REPEAT
ch
s
i
INC
i
UNTIL
ch
ch
OR
ch
A
ch
Z
OR
ch
a
ch
z
OR
ch
OR
i
IF
i
ch
0X
THEN
res
END
END
END
Check
PROCEDURE
Load
name
ARRAY
OF
CHAR
VAR
newmod
Module
search
module
in
list
if
not
found
load
module
res
already
present
or
loaded
res
file
not
available
res
key
conflict
res
bad
file
version
res
corrupted
file
res
no
space
VAR
mod
impmod
Module
i
n
key
impkey
mno
nofimps
size
INTEGER
p
u
v
w
INTEGER
addresses
ch
CHAR
body
Command
fixorgP
fixorgD
fixorgT
INTEGER
disp
adr
inst
pno
vno
dest
offset
INTEGER
name1
impname
ModuleName
F
Files
File
R
Files
Rider
import
ARRAY
OF
Module
BEGIN
mod
root
res
nofimps
WHILE
mod
NIL
name
mod
name
DO
mod
mod
next
END
IF
mod
NIL
THEN
load
Check
name
IF
res
THEN
F
ThisFile
name
ELSE
F
NIL
END
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadString
R
name1
Files
ReadInt
R
key
Files
Read
R
ch
Files
ReadInt
R
size
importing
name1
IF
ch
versionkey
THEN
Files
ReadString
R
impname
imports
WHILE
impname
0X
res
DO
Files
ReadInt
R
impkey
Load
impname
impmod
import
nofimps
impmod
importing
name1
IF
res
THEN
IF
impmod
key
impkey
THEN
INC
impmod
refcnt
INC
nofimps
ELSE
error
name1
imported
impname
END
END
Files
ReadString
R
impname
END
ELSE
error
name1
END
ELSE
error
name
END
IF
res
THEN
search
for
a
hole
in
the
list
allocate
and
link
INC
size
DescSize
mod
root
WHILE
mod
NIL
mod
name
0X
mod
size
size
DO
mod
mod
next
END
IF
mod
NIL
THEN
no
large
enough
hole
was
found
IF
AllocPtr
size
limit
THEN
allocate
p
AllocPtr
mod
SYSTEM
VAL
Module
p
AllocPtr
p
size
100H
DIV
20H
20H
mod
size
AllocPtr
p
mod
num
root
num
mod
next
root
root
mod
ELSE
error
name1
END
ELSE
fill
hole
p
SYSTEM
VAL
INTEGER
mod
END
END
IF
res
THEN
read
file
INC
p
DescSize
allocate
descriptor
mod
name
name
mod
key
key
mod
refcnt
mod
data
p
data
SYSTEM
PUT
mod
num
MTOrg
p
module
table
entry
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
type
descriptors
Files
ReadInt
R
n
WHILE
n
DO
SYSTEM
PUT
p
INC
p
DEC
n
END
variable
space
Files
ReadInt
R
n
WHILE
n
DO
Files
Read
R
ch
SYSTEM
PUT
p
ch
INC
p
DEC
n
END
strings
mod
code
p
program
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
program
code
mod
imp
p
copy
imports
i
WHILE
i
nofimps
DO
SYSTEM
PUT
p
import
i
INC
p
INC
i
END
mod
cmd
p
commands
Files
Read
R
ch
WHILE
ch
0X
DO
REPEAT
SYSTEM
PUT
p
ch
INC
p
Files
Read
R
ch
UNTIL
ch
0X
REPEAT
SYSTEM
PUT
p
0X
INC
p
UNTIL
p
MOD
Files
ReadInt
R
n
SYSTEM
PUT
p
n
INC
p
Files
Read
R
ch
END
REPEAT
SYSTEM
PUT
p
0X
INC
p
UNTIL
p
MOD
mod
ent
p
entries
Files
ReadInt
R
n
WHILE
n
DO
Files
ReadInt
R
w
SYSTEM
PUT
p
w
INC
p
DEC
n
END
mod
ptr
p
pointer
references
Files
ReadInt
R
w
WHILE
w
DO
SYSTEM
PUT
p
mod
data
w
INC
p
Files
ReadInt
R
w
END
SYSTEM
PUT
p
INC
p
Files
ReadInt
R
fixorgP
Files
ReadInt
R
fixorgD
Files
ReadInt
R
fixorgT
Files
ReadInt
R
w
body
SYSTEM
VAL
Command
mod
code
w
Files
Read
R
ch
IF
ch
O
THEN
corrupted
file
mod
NIL
error
name
END
END
IF
res
THEN
fixup
of
BL
adr
mod
code
fixorgP
WHILE
adr
mod
code
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
100000H
MOD
10H
pno
inst
DIV
1000H
MOD
100H
disp
inst
MOD
1000H
SYSTEM
GET
mod
imp
mno
impmod
SYSTEM
GET
impmod
ent
pno
dest
dest
dest
impmod
code
offset
dest
adr
DIV
SYSTEM
PUT
adr
offset
MOD
1000000H
0F7000000H
adr
adr
disp
END
fixup
of
LDR
STR
ADD
adr
mod
code
fixorgD
WHILE
adr
mod
code
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
100000H
MOD
10H
disp
inst
MOD
1000H
IF
mno
THEN
global
SYSTEM
PUT
adr
inst
DIV
1000000H
10H
MT
100000H
mod
num
ELSE
import
SYSTEM
GET
mod
imp
mno
impmod
v
impmod
num
SYSTEM
PUT
adr
inst
DIV
1000000H
10H
MT
100000H
v
SYSTEM
GET
adr
inst
vno
inst
MOD
100H
SYSTEM
GET
impmod
ent
vno
offset
IF
ODD
inst
DIV
100H
THEN
offset
offset
impmod
code
impmod
data
END
SYSTEM
PUT
adr
inst
DIV
10000H
10000H
offset
END
adr
adr
disp
END
fixup
of
type
descriptors
adr
mod
data
fixorgT
WHILE
adr
mod
data
DO
SYSTEM
GET
adr
inst
mno
inst
DIV
1000000H
MOD
10H
vno
inst
DIV
1000H
MOD
1000H
disp
inst
MOD
1000H
IF
mno
THEN
global
inst
mod
data
vno
ELSE
import
SYSTEM
GET
mod
imp
mno
impmod
SYSTEM
GET
impmod
ent
vno
offset
inst
impmod
data
offset
END
SYSTEM
PUT
adr
inst
adr
adr
disp
END
body
initialize
module
ELSIF
res
THEN
importing
name
WHILE
nofimps
DO
DEC
nofimps
DEC
import
nofimps
refcnt
END
END
END
newmod
mod
END
Load
PROCEDURE
ThisCommand
mod
Module
name
ARRAY
OF
CHAR
Command
VAR
k
adr
w
INTEGER
ch
CHAR
s
ARRAY
OF
CHAR
BEGIN
res
w
IF
mod
NIL
THEN
adr
mod
cmd
SYSTEM
GET
adr
ch
WHILE
ch
0X
res
DO
k
read
command
name
REPEAT
s
k
ch
INC
k
INC
adr
SYSTEM
GET
adr
ch
UNTIL
ch
0X
s
k
0X
REPEAT
INC
adr
UNTIL
adr
MOD
SYSTEM
GET
adr
k
INC
adr
IF
s
name
THEN
res
w
mod
code
k
ELSE
SYSTEM
GET
adr
ch
END
END
END
RETURN
SYSTEM
VAL
Command
w
END
ThisCommand
PROCEDURE
Free
name
ARRAY
OF
CHAR
VAR
mod
imp
Module
p
q
INTEGER
BEGIN
mod
root
res
WHILE
mod
NIL
mod
name
name
DO
mod
mod
next
END
IF
mod
NIL
THEN
IF
mod
refcnt
THEN
mod
name
0X
p
mod
imp
q
mod
cmd
WHILE
p
q
DO
SYSTEM
GET
p
imp
DEC
imp
refcnt
INC
p
END
ELSE
res
END
END
END
Free
PROCEDURE
Init
BEGIN
Files
Init
MTOrg
SYSTEM
REG
MT
SYSTEM
GET
AllocPtr
SYSTEM
GET
root
SYSTEM
GET
limit
DEC
limit
8000H
END
Init
BEGIN
Init
Load
Oberon
M
LED
res
REPEAT
UNTIL
FALSE
only
if
load
fails
END
Modules
MODULE
Net
NW
PR
IMPORT
SYSTEM
SCC
Files
Viewers
Texts
TextFrames
MenuViewers
Oberon
CONST
PakSize
T0
T1
timeouts
T0
T1
timeouts
ACK
10H
NAK
25H
NPR
26H
acknowledgements
NRQ
34H
NRS
35H
name
request
response
SND
41H
REC
42H
MSG
44H
TRQ
46H
TIM
47H
time
requests
VAR
W
Texts
Writer
Server
Oberon
Task
head0
head1
SCC
Header
partner
ARRAY
OF
CHAR
dmy
ARRAY
OF
BYTE
protected
BOOLEAN
write
protection
PROCEDURE
SetPartner
name
ARRAY
OF
CHAR
BEGIN
head0
dadr
head1
sadr
partner
name
END
SetPartner
PROCEDURE
Send
t
BYTE
L
INTEGER
data
ARRAY
OF
BYTE
BEGIN
head0
typ
t
head0
len
L
SCC
SendPacket
head0
data
END
Send
PROCEDURE
ReceiveHead
timeout
LONGINT
VAR
time
LONGINT
BEGIN
time
Oberon
Time
timeout
REPEAT
SCC
ReceiveHead
head1
IF
head1
valid
head1
sadr
head0
dadr
THEN
SCC
Skip
head1
len
head1
valid
FALSE
END
IF
head1
valid
Oberon
Time
time
THEN
head1
typ
0FFH
END
UNTIL
head1
valid
OR
head1
typ
0FFH
END
ReceiveHead
PROCEDURE
FindPartner
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
time
LONGINT
k
INTEGER
Id
ARRAY
OF
CHAR
IdB
ARRAY
OF
BYTE
BEGIN
SCC
Skip
SCC
Available
res
k
WHILE
k
name
k
0X
DO
Id
k
name
k
IdB
k
ORD
Id
k
INC
k
END
Id
k
0X
IdB
k
also
terminate
IdB
IF
Id
partner
THEN
head0
dadr
0FFH
Send
NRQ
k
IdB
time
Oberon
Time
T1
REPEAT
SCC
ReceiveHead
head1
IF
head1
valid
THEN
IF
head1
typ
NRS
THEN
SetPartner
Id
ELSE
SCC
Skip
head1
len
head1
valid
FALSE
END
ELSIF
Oberon
Time
time
THEN
res
partner
0X
END
UNTIL
head1
valid
OR
res
END
END
FindPartner
PROCEDURE
AppendS
s
ARRAY
OF
CHAR
VAR
d
ARRAY
OF
BYTE
VAR
k
INTEGER
VAR
i
INTEGER
ch
CHAR
BEGIN
i
REPEAT
ch
s
i
d
k
ORD
ch
INC
i
INC
k
UNTIL
ch
0X
END
AppendS
PROCEDURE
AppendW
s
LONGINT
VAR
d
ARRAY
OF
BYTE
n
INTEGER
VAR
k
INTEGER
VAR
i
INTEGER
BEGIN
i
REPEAT
d
k
s
MOD
100H
s
s
DIV
100H
INC
i
INC
k
UNTIL
i
n
END
AppendW
PROCEDURE
PickS
VAR
s
ARRAY
OF
CHAR
VAR
i
INTEGER
x
BYTE
BEGIN
i
REPEAT
SCC
Receive
x
s
i
CHR
x
INC
i
UNTIL
x
END
PickS
PROCEDURE
PickQ
VAR
w
LONGINT
VAR
x0
x1
x2
x3
BYTE
BEGIN
SCC
Receive
x0
SCC
Receive
x1
SCC
Receive
x2
SCC
Receive
x3
w
x0
100H
x1
100H
x2
100H
x3
END
PickQ
PROCEDURE
SendData
F
Files
File
VAR
k
seqno
INTEGER
x
BYTE
len
LONGINT
R
Files
Rider
buf
ARRAY
PakSize
OF
BYTE
BEGIN
Files
Set
R
F
len
seqno
REPEAT
k
REPEAT
Files
ReadByte
R
x
IF
R
eof
THEN
buf
k
x
INC
k
END
UNTIL
R
eof
OR
k
PakSize
REPEAT
Send
seqno
k
buf
ReceiveHead
T1
UNTIL
head1
typ
seqno
ACK
seqno
seqno
MOD
len
len
k
IF
head1
typ
seqno
ACK
THEN
Texts
WriteString
W
failed
k
END
UNTIL
k
PakSize
Texts
WriteInt
W
len
END
SendData
PROCEDURE
ReceiveData
F
Files
File
VAR
done
BOOLEAN
VAR
k
retry
seqno
INTEGER
x
BYTE
len
LONGINT
R
Files
Rider
BEGIN
Files
Set
R
F
seqno
len
retry
k
PakSize
REPEAT
IF
head1
typ
seqno
THEN
seqno
seqno
MOD
len
len
head1
len
retry
Send
seqno
ACK
dmy
k
WHILE
k
head1
len
DO
SCC
Receive
x
Files
WriteByte
R
x
INC
k
END
IF
k
PakSize
THEN
done
TRUE
END
ELSE
DEC
retry
IF
retry
THEN
Texts
WriteString
W
failed
done
FALSE
k
END
Send
seqno
ACK
dmy
END
ReceiveHead
T0
UNTIL
k
PakSize
Texts
WriteInt
W
len
END
ReceiveData
PROCEDURE
reply
msg
INTEGER
BEGIN
IF
msg
THEN
Texts
WriteString
W
no
link
ELSIF
msg
THEN
Texts
WriteString
W
no
permission
ELSIF
msg
THEN
Texts
WriteString
W
not
done
ELSIF
msg
THEN
Texts
WriteString
W
not
found
ELSIF
msg
THEN
Texts
WriteString
W
no
response
ELSIF
msg
THEN
Texts
WriteString
W
time
set
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
reply
PROCEDURE
Serve
VAR
i
INTEGER
done
BOOLEAN
x
BYTE
F
Files
File
pw
clock
newclock
LONGINT
Id
ARRAY
OF
CHAR
IdB
ARRAY
OF
BYTE
FileName
ARRAY
OF
CHAR
BEGIN
SCC
ReceiveHead
head1
IF
head1
valid
THEN
IF
head1
typ
SND
THEN
PickS
Id
PickQ
pw
PickS
FileName
Texts
WriteString
W
Id
Texts
Write
W
Texts
WriteString
W
FileName
F
Files
Old
FileName
IF
F
NIL
THEN
Texts
WriteString
W
sending
SetPartner
Id
Texts
Append
Oberon
Log
W
buf
SendData
F
ELSE
Send
NAK
dmy
Texts
Write
W
END
reply
ELSIF
head1
typ
REC
THEN
PickS
Id
PickQ
pw
PickS
FileName
IF
protected
THEN
Texts
WriteString
W
Id
Texts
Write
W
Texts
WriteString
W
FileName
F
Files
New
FileName
IF
F
NIL
THEN
Texts
WriteString
W
receiving
SetPartner
Id
Texts
Append
Oberon
Log
W
buf
Send
ACK
dmy
ReceiveHead
T0
ReceiveData
F
done
IF
done
THEN
Files
Register
F
END
ELSE
Send
NAK
dmy
Texts
Write
W
END
reply
ELSE
Send
NPR
dmy
END
ELSIF
head1
typ
MSG
THEN
i
WHILE
i
head1
len
DO
SCC
Receive
x
Texts
Write
W
CHR
x
INC
i
END
Send
ACK
dmy
reply
ELSIF
head1
typ
TRQ
THEN
i
AppendW
Oberon
Clock
IdB
i
Send
TIM
IdB
ELSIF
head1
typ
TIM
THEN
PickQ
newclock
PickS
Id
PickQ
pw
clock
Oberon
Clock
IF
protected
Id
0X
ABS
pw
clock
THEN
Oberon
SetClock
newclock
Texts
WriteString
W
Id
Texts
WriteString
W
changed
System
Date
Texts
WriteClock
W
newclock
reply
END
ELSIF
head1
typ
NRQ
THEN
i
REPEAT
SCC
Receive
x
Id
i
CHR
x
INC
i
IF
i
THEN
Id
0X
x
END
UNTIL
x
WHILE
i
head1
len
DO
SCC
Receive
x
INC
i
END
IF
Id
Oberon
User
THEN
SetPartner
Id
Send
NRS
dmy
END
ELSE
SCC
Skip
head1
len
END
END
END
Serve
PROCEDURE
GetPar1
VAR
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
END
GetPar1
PROCEDURE
GetPar
VAR
S
Texts
Scanner
VAR
end
LONGINT
VAR
T
Texts
Text
beg
tm
LONGINT
BEGIN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
tm
IF
tm
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
ELSE
end
Oberon
Par
text
len
END
END
GetPar
PROCEDURE
SendFiles
VAR
k
INTEGER
end
LONGINT
S
Texts
Scanner
F
Files
File
buf
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
k
IF
k
THEN
GetPar
S
end
WHILE
Texts
Pos
S
end
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
k
AppendS
Oberon
User
buf
k
AppendW
Oberon
Password
buf
k
AppendS
S
s
buf
k
IF
S
nextCh
THEN
prefix
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
THEN
buf
k
ORD
AppendS
S
s
buf
k
Texts
Write
W
Texts
WriteString
W
S
s
END
END
F
Files
Old
S
s
IF
F
NIL
THEN
Send
REC
k
buf
ReceiveHead
T0
IF
head1
typ
ACK
THEN
Texts
WriteString
W
sending
Texts
Append
Oberon
Log
W
buf
SendData
F
reply
ELSIF
head1
typ
NPR
THEN
reply
end
ELSIF
head1
typ
NAK
THEN
reply
end
ELSE
reply
end
END
ELSE
reply
END
Texts
Scan
S
END
ELSE
reply
END
END
END
SendFiles
PROCEDURE
ReceiveFiles
VAR
k
INTEGER
done
BOOLEAN
end
LONGINT
S
Texts
Scanner
F
Files
File
buf
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
k
IF
k
THEN
GetPar
S
end
WHILE
Texts
Pos
S
end
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
k
AppendS
Oberon
User
buf
k
AppendW
Oberon
Password
buf
k
AppendS
S
s
buf
k
IF
S
nextCh
THEN
prefix
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
THEN
buf
k
ORD
AppendS
S
s
buf
k
Texts
Write
W
Texts
WriteString
W
S
s
END
END
Send
SND
k
buf
Texts
WriteString
W
receiving
Texts
Append
Oberon
Log
W
buf
ReceiveHead
T1
IF
head1
typ
THEN
F
Files
New
S
s
IF
F
NIL
THEN
ReceiveData
F
done
IF
done
THEN
Files
Register
F
reply
ELSE
end
END
ELSE
reply
Send
NAK
dmy
END
ELSIF
head1
typ
NAK
THEN
reply
ELSIF
head1
typ
NPR
THEN
reply
end
ELSE
reply
end
END
Texts
Scan
S
END
ELSE
reply
END
END
END
ReceiveFiles
PROCEDURE
SendMsg
VAR
i
INTEGER
ch
CHAR
S
Texts
Scanner
msg
ARRAY
OF
BYTE
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
i
IF
i
THEN
Texts
Read
S
ch
WHILE
ch
i
DO
msg
i
ORD
ch
INC
i
Texts
Read
S
ch
END
Send
MSG
i
msg
ReceiveHead
T0
IF
head1
typ
ACK
THEN
reply
END
ELSE
reply
END
END
END
SendMsg
PROCEDURE
GetTime
VAR
dt
res
INTEGER
S
Texts
Scanner
BEGIN
GetPar1
S
IF
S
class
Texts
Name
THEN
FindPartner
S
s
res
IF
res
THEN
Send
TRQ
dmy
ReceiveHead
T1
IF
head1
typ
TIM
THEN
PickQ
dt
Oberon
SetClock
dt
reply
END
ELSE
reply
END
END
END
GetTime
PROCEDURE
StartServer
BEGIN
protected
TRUE
partner
0X
SCC
Start
TRUE
Oberon
Remove
Server
Oberon
Install
Server
Texts
WriteString
W
Server
started
as
Texts
WriteString
W
Oberon
User
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
StartServer
PROCEDURE
Unprotect
BEGIN
protected
FALSE
END
Unprotect
PROCEDURE
WProtect
BEGIN
protected
TRUE
END
WProtect
PROCEDURE
Reset
BEGIN
SCC
Start
TRUE
END
Reset
PROCEDURE
StopServer
BEGIN
Oberon
Remove
Server
Texts
WriteString
W
Server
stopped
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
StopServer
PROCEDURE
SCCStatus
BEGIN
Texts
WriteString
W
SCC
Available
Texts
WriteInt
W
SCC
Available
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
SCCStatus
BEGIN
Texts
OpenWriter
W
Server
Oberon
NewTask
Serve
END
Net
MODULE
Oberon
JG
NW
IMPORT
SYSTEM
Kernel
Files
Modules
Input
Display
Viewers
Fonts
Texts
CONST
message
ids
consume
track
defocus
neutralize
mark
off
idle
active
task
states
BasicCycle
ESC
1BX
SETSTAR
1AX
TYPE
Painter
PROCEDURE
x
y
INTEGER
Marker
RECORD
Fade
Draw
Painter
END
Cursor
RECORD
marker
Marker
on
BOOLEAN
X
Y
INTEGER
END
InputMsg
RECORD
Display
FrameMsg
id
INTEGER
keys
SET
X
Y
INTEGER
ch
CHAR
fnt
Fonts
Font
col
voff
INTEGER
END
SelectionMsg
RECORD
Display
FrameMsg
time
LONGINT
text
Texts
Text
beg
end
LONGINT
END
ControlMsg
RECORD
Display
FrameMsg
id
X
Y
INTEGER
END
CopyMsg
RECORD
Display
FrameMsg
F
Display
Frame
END
Task
POINTER
TO
TaskDesc
Handler
PROCEDURE
TaskDesc
RECORD
state
nextTime
period
INTEGER
next
Task
handle
Handler
END
VAR
User
ARRAY
OF
CHAR
Password
LONGINT
Arrow
Star
Marker
Mouse
Pointer
Cursor
FocusViewer
Viewers
Viewer
Log
Texts
Text
Par
RECORD
vwr
Viewers
Viewer
frame
Display
Frame
text
Texts
Text
pos
LONGINT
END
CurFnt
Fonts
Font
CurCol
CurOff
INTEGER
NofTasks
INTEGER
CurTask
Task
DW
DH
CL
INTEGER
ActCnt
INTEGER
action
count
for
GC
Mod
Modules
Module
user
identification
PROCEDURE
Code
VAR
s
ARRAY
OF
CHAR
LONGINT
VAR
i
INTEGER
a
b
c
LONGINT
BEGIN
a
b
i
WHILE
s
i
0X
DO
c
b
b
a
a
c
MOD
ORD
s
i
INC
i
END
IF
b
THEN
b
b
END
RETURN
b
a
END
Code
PROCEDURE
SetUser
VAR
user
password
ARRAY
OF
CHAR
BEGIN
User
user
Password
Code
password
END
SetUser
PROCEDURE
Clock
LONGINT
BEGIN
RETURN
Kernel
Clock
END
Clock
PROCEDURE
SetClock
d
LONGINT
BEGIN
Kernel
SetClock
d
END
SetClock
PROCEDURE
Time
LONGINT
BEGIN
RETURN
Kernel
Time
END
Time
cursor
handling
PROCEDURE
FlipArrow
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
arrow
X
Y
Display
invert
END
FlipArrow
PROCEDURE
FlipStar
X
Y
INTEGER
BEGIN
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
star
X
Y
Display
invert
END
FlipStar
PROCEDURE
OpenCursor
VAR
c
Cursor
BEGIN
c
on
FALSE
c
X
c
Y
END
OpenCursor
PROCEDURE
FadeCursor
VAR
c
Cursor
BEGIN
IF
c
on
THEN
c
marker
Fade
c
X
c
Y
c
on
FALSE
END
END
FadeCursor
PROCEDURE
DrawCursor
VAR
c
Cursor
m
Marker
x
y
INTEGER
BEGIN
IF
c
on
x
c
X
OR
y
c
Y
OR
m
Draw
c
marker
Draw
THEN
c
marker
Fade
c
X
c
Y
c
on
FALSE
END
IF
c
on
THEN
m
Draw
x
y
c
marker
m
c
X
x
c
Y
y
c
on
TRUE
END
END
DrawCursor
PROCEDURE
DrawMouse
m
Marker
x
y
INTEGER
BEGIN
DrawCursor
Mouse
m
x
y
END
DrawMouse
PROCEDURE
DrawMouseArrow
x
y
INTEGER
BEGIN
DrawCursor
Mouse
Arrow
x
y
END
DrawMouseArrow
PROCEDURE
FadeMouse
BEGIN
FadeCursor
Mouse
END
FadeMouse
PROCEDURE
DrawPointer
x
y
INTEGER
BEGIN
DrawCursor
Pointer
Star
x
y
END
DrawPointer
display
management
PROCEDURE
RemoveMarks
X
Y
W
H
INTEGER
BEGIN
IF
Mouse
X
X
Mouse
X
X
W
Mouse
Y
Y
Mouse
Y
Y
H
THEN
FadeCursor
Mouse
END
IF
Pointer
X
X
Pointer
X
X
W
Pointer
Y
Y
Pointer
Y
Y
H
THEN
FadeCursor
Pointer
END
END
RemoveMarks
PROCEDURE
HandleFiller
V
Display
Frame
VAR
M
Display
FrameMsg
BEGIN
CASE
M
OF
InputMsg
IF
M
id
track
THEN
DrawCursor
Mouse
Arrow
M
X
M
Y
END
ControlMsg
IF
M
id
mark
THEN
DrawCursor
Pointer
Star
M
X
M
Y
END
Viewers
ViewerMsg
IF
M
id
Viewers
restore
V
W
V
H
THEN
RemoveMarks
V
X
V
Y
V
W
V
H
Display
ReplConst
Display
black
V
X
V
Y
V
W
V
H
Display
replace
ELSIF
M
id
Viewers
modify
M
Y
V
Y
THEN
RemoveMarks
V
X
M
Y
V
W
V
Y
M
Y
Display
ReplConst
Display
black
V
X
M
Y
V
W
V
Y
M
Y
Display
replace
END
END
END
HandleFiller
PROCEDURE
OpenDisplay
UW
SW
H
INTEGER
VAR
Filler
Viewers
Viewer
BEGIN
Input
SetMouseLimits
Viewers
curW
UW
SW
H
Display
ReplConst
Display
black
Viewers
curW
UW
SW
H
Display
replace
NEW
Filler
Filler
handle
HandleFiller
Viewers
InitTrack
UW
H
Filler
init
user
track
NEW
Filler
Filler
handle
HandleFiller
Viewers
InitTrack
SW
H
Filler
init
system
track
END
OpenDisplay
PROCEDURE
DisplayWidth
X
INTEGER
INTEGER
BEGIN
RETURN
DW
END
DisplayWidth
PROCEDURE
DisplayHeight
X
INTEGER
INTEGER
BEGIN
RETURN
DH
END
DisplayHeight
PROCEDURE
OpenTrack
X
W
INTEGER
VAR
Filler
Viewers
Viewer
BEGIN
NEW
Filler
Filler
handle
HandleFiller
Viewers
OpenTrack
X
W
Filler
END
OpenTrack
PROCEDURE
UserTrack
X
INTEGER
INTEGER
BEGIN
RETURN
X
DIV
DW
DW
END
UserTrack
PROCEDURE
SystemTrack
X
INTEGER
INTEGER
BEGIN
RETURN
X
DIV
DW
DW
DW
DIV
END
SystemTrack
PROCEDURE
UY
X
INTEGER
INTEGER
VAR
h
INTEGER
fil
bot
alt
max
Display
Frame
BEGIN
Viewers
Locate
X
fil
bot
alt
max
IF
fil
H
DH
DIV
THEN
h
DH
ELSE
h
max
Y
max
H
DIV
END
RETURN
h
END
UY
PROCEDURE
AllocateUserViewer
DX
INTEGER
VAR
X
Y
INTEGER
BEGIN
IF
Pointer
on
THEN
X
Pointer
X
Y
Pointer
Y
ELSE
X
DX
DIV
DW
DW
Y
UY
X
END
END
AllocateUserViewer
PROCEDURE
SY
X
INTEGER
INTEGER
VAR
H0
H1
H2
H3
y
INTEGER
fil
bot
alt
max
Display
Frame
BEGIN
H3
DH
DH
DIV
H2
H3
H3
DIV
H1
DH
DIV
H0
DH
DIV
Viewers
Locate
X
DH
fil
bot
alt
max
IF
fil
H
DH
DIV
THEN
y
DH
ELSIF
max
H
DH
H0
THEN
y
max
Y
H3
ELSIF
max
H
H3
H0
THEN
y
max
Y
H2
ELSIF
max
H
H2
H0
THEN
y
max
Y
H1
ELSIF
max
bot
THEN
y
max
Y
max
H
DIV
ELSIF
bot
H
H1
THEN
y
bot
H
DIV
ELSE
y
alt
Y
alt
H
DIV
END
RETURN
y
END
SY
PROCEDURE
AllocateSystemViewer
DX
INTEGER
VAR
X
Y
INTEGER
BEGIN
IF
Pointer
on
THEN
X
Pointer
X
Y
Pointer
Y
ELSE
X
DX
DIV
DW
DW
DW
DIV
Y
SY
X
END
END
AllocateSystemViewer
PROCEDURE
MarkedViewer
Viewers
Viewer
BEGIN
RETURN
Viewers
This
Pointer
X
Pointer
Y
END
MarkedViewer
PROCEDURE
PassFocus
V
Viewers
Viewer
VAR
M
ControlMsg
BEGIN
M
id
defocus
FocusViewer
handle
FocusViewer
M
FocusViewer
V
END
PassFocus
PROCEDURE
OpenLog
T
Texts
Text
BEGIN
Log
T
END
OpenLog
command
interpretation
PROCEDURE
SetPar
F
Display
Frame
T
Texts
Text
pos
LONGINT
BEGIN
Par
vwr
Viewers
This
F
X
F
Y
Par
frame
F
Par
text
T
Par
pos
pos
END
SetPar
PROCEDURE
Call
name
ARRAY
OF
CHAR
VAR
res
INTEGER
VAR
mod
Modules
Module
P
Modules
Command
i
j
INTEGER
ch
CHAR
Mname
Cname
ARRAY
OF
CHAR
BEGIN
i
ch
name
WHILE
ch
ch
0X
DO
Mname
i
ch
INC
i
ch
name
i
END
IF
ch
THEN
Mname
i
0X
INC
i
Modules
Load
Mname
mod
res
Modules
res
IF
Modules
res
THEN
j
ch
name
i
INC
i
WHILE
ch
0X
DO
Cname
j
ch
INC
j
ch
name
i
INC
i
END
Cname
j
0X
P
Modules
ThisCommand
mod
Cname
res
Modules
res
IF
Modules
res
THEN
P
END
END
ELSE
res
END
END
Call
PROCEDURE
GetSelection
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
VAR
M
SelectionMsg
BEGIN
M
time
Viewers
Broadcast
M
time
M
time
IF
time
THEN
text
M
text
beg
M
beg
end
M
end
END
END
GetSelection
PROCEDURE
GC
VAR
mod
Modules
Module
BEGIN
IF
ActCnt
OR
Kernel
allocated
Kernel
heapLim
Kernel
heapOrg
10000H
THEN
mod
Modules
root
LED
21H
WHILE
mod
NIL
DO
IF
mod
name
0X
THEN
Kernel
Mark
mod
ptr
END
mod
mod
next
END
LED
23H
Files
RestoreList
LED
27H
Kernel
Scan
LED
20H
ActCnt
BasicCycle
END
END
GC
PROCEDURE
NewTask
h
Handler
period
INTEGER
Task
VAR
t
Task
BEGIN
NEW
t
t
state
off
t
next
t
t
handle
h
t
period
period
RETURN
t
END
NewTask
PROCEDURE
Install
T
Task
BEGIN
IF
T
state
off
THEN
T
next
CurTask
next
CurTask
next
T
T
state
idle
T
nextTime
INC
NofTasks
END
END
Install
PROCEDURE
Remove
T
Task
VAR
t
Task
BEGIN
IF
T
state
off
THEN
t
T
WHILE
t
next
T
DO
t
t
next
END
t
next
T
next
T
state
off
T
next
NIL
CurTask
t
DEC
NofTasks
END
END
Remove
PROCEDURE
Collect
count
INTEGER
BEGIN
ActCnt
count
END
Collect
PROCEDURE
SetFont
fnt
Fonts
Font
BEGIN
CurFnt
fnt
END
SetFont
PROCEDURE
SetColor
col
INTEGER
BEGIN
CurCol
col
END
SetColor
PROCEDURE
SetOffset
voff
INTEGER
BEGIN
CurOff
voff
END
SetOffset
PROCEDURE
Loop
VAR
V
Viewers
Viewer
M
InputMsg
N
ControlMsg
prevX
prevY
X
Y
t
INTEGER
keys
SET
ch
CHAR
BEGIN
REPEAT
Input
Mouse
keys
X
Y
IF
Input
Available
THEN
Input
Read
ch
IF
ch
ESC
THEN
N
id
neutralize
Viewers
Broadcast
N
FadeCursor
Pointer
LED
ELSIF
ch
SETSTAR
THEN
N
id
mark
N
X
X
N
Y
Y
V
Viewers
This
X
Y
V
handle
V
N
ELSE
M
id
consume
M
ch
ch
M
fnt
CurFnt
M
col
CurCol
M
voff
CurOff
FocusViewer
handle
FocusViewer
M
DEC
ActCnt
END
ELSIF
keys
THEN
M
id
track
M
X
X
M
Y
Y
M
keys
keys
REPEAT
V
Viewers
This
M
X
M
Y
V
handle
V
M
Input
Mouse
M
keys
M
X
M
Y
UNTIL
M
keys
DEC
ActCnt
ELSE
IF
X
prevX
OR
Y
prevY
OR
Mouse
on
THEN
M
id
track
M
X
X
IF
Y
Display
Height
THEN
Y
Display
Height
END
M
Y
Y
M
keys
keys
V
Viewers
This
X
Y
V
handle
V
M
prevX
X
prevY
Y
END
CurTask
CurTask
next
t
Kernel
Time
IF
t
CurTask
nextTime
THEN
CurTask
nextTime
t
CurTask
period
CurTask
state
active
CurTask
handle
CurTask
state
idle
END
END
UNTIL
FALSE
END
Loop
PROCEDURE
Reset
BEGIN
IF
CurTask
state
active
THEN
Remove
CurTask
END
SYSTEM
LDREG
Kernel
stackOrg
reset
stack
pointer
Loop
END
Reset
BEGIN
User
0X
Arrow
Fade
FlipArrow
Arrow
Draw
FlipArrow
Star
Fade
FlipStar
Star
Draw
FlipStar
OpenCursor
Mouse
OpenCursor
Pointer
DW
Display
Width
DH
Display
Height
CL
DW
OpenDisplay
DW
DIV
DW
DIV
DH
FocusViewer
Viewers
This
CurFnt
Fonts
Default
CurCol
Display
white
CurOff
ActCnt
CurTask
NewTask
GC
Install
CurTask
Modules
Load
System
Mod
Mod
NIL
Loop
END
Oberon
MODULE
ORB
NW
in
Oberon
IMPORT
Files
ORS
Definition
of
data
types
Object
and
Type
which
together
form
the
data
structure
called
symbol
table
Contains
procedures
for
creation
of
Objects
and
for
search
NewObj
this
thisimport
thisfield
and
OpenScope
CloseScope
Handling
of
import
and
export
i
e
reading
and
writing
of
symbol
files
is
done
by
procedures
Import
and
Export
This
module
contains
the
list
of
standard
identifiers
with
which
the
symbol
table
universe
and
that
of
the
pseudo
module
SYSTEM
are
initialized
CONST
versionkey
maxTypTab
class
values
Head
Const
Var
Par
Fld
Typ
SProc
SFunc
Mod
form
values
Byte
Bool
Char
Int
Real
Set
Pointer
NilTyp
NoTyp
Proc
String
Array
Record
TYPE
Object
POINTER
TO
ObjDesc
Module
POINTER
TO
ModDesc
Type
POINTER
TO
TypeDesc
ObjDesc
RECORD
class
exno
BYTE
expo
rdo
BOOLEAN
exported
read
only
lev
INTEGER
next
dsc
Object
type
Type
name
ORS
Ident
val
LONGINT
END
ModDesc
RECORD
ObjDesc
orgname
ORS
Ident
END
TypeDesc
RECORD
form
ref
mno
INTEGER
ref
is
only
used
for
import
export
nofpar
INTEGER
for
procedures
extension
level
for
records
len
LONGINT
for
arrays
len
open
array
for
records
adr
of
descriptor
dsc
typobj
Object
base
Type
for
arrays
records
pointers
size
LONGINT
in
bytes
always
multiple
of
except
for
Byte
Bool
and
Char
END
Object
classes
and
the
meaning
of
val
class
val
Var
address
Par
address
Const
value
Fld
offset
Typ
type
descriptor
TD
address
SProc
inline
code
number
SFunc
inline
code
number
Mod
key
Type
forms
and
the
meaning
of
dsc
and
base
form
dsc
base
Pointer
type
of
dereferenced
object
Proc
params
result
type
Array
type
of
elements
Record
fields
extension
VAR
topScope
universe
system
Object
byteType
boolType
charType
Type
intType
realType
setType
nilType
noType
strType
Type
nofmod
Ref
INTEGER
typtab
ARRAY
maxTypTab
OF
Type
PROCEDURE
NewObj
VAR
obj
Object
id
ORS
Ident
class
INTEGER
insert
new
Object
with
name
id
VAR
new
x
Object
BEGIN
x
topScope
WHILE
x
next
NIL
x
next
name
id
DO
x
x
next
END
IF
x
next
NIL
THEN
NEW
new
new
name
id
new
class
class
new
next
NIL
new
rdo
FALSE
new
dsc
NIL
x
next
new
obj
new
ELSE
obj
x
next
ORS
Mark
mult
def
END
END
NewObj
PROCEDURE
thisObj
Object
VAR
s
x
Object
BEGIN
s
topScope
REPEAT
x
s
next
WHILE
x
NIL
x
name
ORS
id
DO
x
x
next
END
s
s
dsc
UNTIL
x
NIL
OR
s
NIL
RETURN
x
END
thisObj
PROCEDURE
thisimport
mod
Object
Object
VAR
obj
Object
BEGIN
IF
mod
rdo
THEN
IF
mod
name
0X
THEN
obj
mod
dsc
WHILE
obj
NIL
obj
name
ORS
id
DO
obj
obj
next
END
ELSE
obj
NIL
END
ELSE
obj
NIL
END
RETURN
obj
END
thisimport
PROCEDURE
thisfield
rec
Type
Object
VAR
fld
Object
BEGIN
fld
rec
dsc
WHILE
fld
NIL
fld
name
ORS
id
DO
fld
fld
next
END
RETURN
fld
END
thisfield
PROCEDURE
OpenScope
VAR
s
Object
BEGIN
NEW
s
s
class
Head
s
dsc
topScope
s
next
NIL
topScope
s
END
OpenScope
PROCEDURE
CloseScope
BEGIN
topScope
topScope
dsc
END
CloseScope
Import
PROCEDURE
MakeFileName
VAR
FName
ORS
Ident
name
ext
ARRAY
OF
CHAR
VAR
i
j
INTEGER
BEGIN
i
j
assume
name
suffix
less
than
characters
WHILE
i
ORS
IdLen
name
i
0X
DO
FName
i
name
i
INC
i
END
REPEAT
FName
i
ext
j
INC
i
INC
j
UNTIL
ext
j
0X
FName
i
0X
END
MakeFileName
PROCEDURE
ThisModule
name
orgname
ORS
Ident
non
BOOLEAN
key
LONGINT
Object
VAR
mod
Module
obj
obj1
Object
BEGIN
obj1
topScope
obj
obj1
next
search
for
module
WHILE
obj
NIL
obj
name
name
DO
obj1
obj
obj
obj1
next
END
IF
obj
NIL
THEN
insert
new
module
NEW
mod
mod
class
Mod
mod
rdo
FALSE
mod
name
name
mod
orgname
orgname
mod
val
key
mod
lev
nofmod
INC
nofmod
mod
type
noType
mod
dsc
NIL
mod
next
NIL
obj1
next
mod
obj
mod
ELSE
module
already
present
IF
non
THEN
ORS
Mark
invalid
import
order
END
END
RETURN
obj
END
ThisModule
PROCEDURE
Read
VAR
R
Files
Rider
VAR
x
INTEGER
VAR
b
BYTE
BEGIN
Files
ReadByte
R
b
IF
b
80H
THEN
x
b
ELSE
x
b
100H
END
END
Read
PROCEDURE
InType
VAR
R
Files
Rider
thismod
Object
VAR
T
Type
VAR
key
LONGINT
ref
class
form
np
readonly
INTEGER
fld
par
obj
mod
Object
t
Type
name
modname
ORS
Ident
BEGIN
Read
R
ref
IF
ref
THEN
T
typtab
ref
already
read
ELSE
NEW
t
T
t
typtab
ref
t
t
mno
thismod
lev
Read
R
form
t
form
form
IF
form
Pointer
THEN
InType
R
thismod
t
base
t
size
ELSIF
form
Array
THEN
InType
R
thismod
t
base
Files
ReadNum
R
t
len
Files
ReadNum
R
t
size
ELSIF
form
Record
THEN
InType
R
thismod
t
base
IF
t
base
form
NoTyp
THEN
t
base
NIL
obj
NIL
ELSE
obj
t
base
dsc
END
Files
ReadNum
R
t
len
TD
adr
exno
Files
ReadNum
R
t
nofpar
ext
level
Files
ReadNum
R
t
size
Read
R
class
WHILE
class
DO
fields
NEW
fld
fld
class
class
Files
ReadString
R
fld
name
IF
fld
name
0X
THEN
fld
expo
TRUE
InType
R
thismod
fld
type
ELSE
fld
expo
FALSE
fld
type
nilType
END
Files
ReadNum
R
fld
val
fld
next
obj
obj
fld
Read
R
class
END
t
dsc
obj
ELSIF
form
Proc
THEN
InType
R
thismod
t
base
obj
NIL
np
Read
R
class
WHILE
class
DO
parameters
NEW
par
par
class
class
Read
R
readonly
par
rdo
readonly
InType
R
thismod
par
type
par
next
obj
obj
par
INC
np
Read
R
class
END
t
dsc
obj
t
nofpar
np
t
size
END
Files
ReadString
R
modname
IF
modname
0X
THEN
re
import
Files
ReadInt
R
key
Files
ReadString
R
name
mod
ThisModule
modname
modname
FALSE
key
obj
mod
dsc
search
type
WHILE
obj
NIL
obj
name
name
DO
obj
obj
next
END
IF
obj
NIL
THEN
T
obj
type
type
object
found
in
object
list
of
mod
ELSE
insert
new
type
object
in
object
list
of
mod
NEW
obj
obj
name
name
obj
class
Typ
obj
next
mod
dsc
mod
dsc
obj
obj
type
t
t
mno
mod
lev
t
typobj
obj
T
t
END
typtab
ref
T
END
END
END
InType
PROCEDURE
Import
VAR
modid
modid1
ORS
Ident
VAR
key
LONGINT
class
k
INTEGER
obj
Object
t
Type
thismod
Object
modname
fname
ORS
Ident
F
Files
File
R
Files
Rider
BEGIN
IF
modid1
SYSTEM
THEN
thismod
ThisModule
modid
modid1
TRUE
key
DEC
nofmod
thismod
lev
thismod
dsc
system
thismod
rdo
TRUE
ELSE
MakeFileName
fname
modid1
smb
F
Files
Old
fname
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadInt
R
key
Files
ReadInt
R
key
Files
ReadString
R
modname
thismod
ThisModule
modid
modid1
TRUE
key
thismod
rdo
TRUE
Read
R
class
version
key
IF
class
versionkey
THEN
ORS
Mark
wrong
version
END
Read
R
class
WHILE
class
DO
NEW
obj
obj
class
class
Files
ReadString
R
obj
name
InType
R
thismod
obj
type
obj
lev
thismod
lev
IF
class
Typ
THEN
t
obj
type
t
typobj
obj
Read
R
k
fixup
bases
of
previously
declared
pointer
types
WHILE
k
DO
typtab
k
base
t
Read
R
k
END
ELSE
IF
class
Const
THEN
IF
obj
type
form
Real
THEN
Files
ReadInt
R
obj
val
ELSE
Files
ReadNum
R
obj
val
END
ELSIF
class
Var
THEN
Files
ReadNum
R
obj
val
obj
rdo
TRUE
END
END
obj
next
thismod
dsc
thismod
dsc
obj
Read
R
class
END
ELSE
ORS
Mark
import
not
available
END
END
END
Import
Export
PROCEDURE
Write
VAR
R
Files
Rider
x
INTEGER
BEGIN
Files
WriteByte
R
x
END
Write
PROCEDURE
OutType
VAR
R
Files
Rider
t
Type
VAR
obj
mod
fld
Object
PROCEDURE
OutPar
VAR
R
Files
Rider
par
Object
n
INTEGER
VAR
cl
INTEGER
BEGIN
IF
n
THEN
OutPar
R
par
next
n
cl
par
class
Write
R
cl
IF
par
rdo
THEN
Write
R
ELSE
Write
R
END
OutType
R
par
type
END
END
OutPar
PROCEDURE
FindHiddenPointers
VAR
R
Files
Rider
typ
Type
offset
LONGINT
VAR
fld
Object
i
n
LONGINT
BEGIN
IF
typ
form
Pointer
OR
typ
form
NilTyp
THEN
Write
R
Fld
Write
R
Files
WriteNum
R
offset
ELSIF
typ
form
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindHiddenPointers
R
fld
type
fld
val
offset
fld
fld
next
END
ELSIF
typ
form
Array
THEN
i
n
typ
len
WHILE
i
n
DO
FindHiddenPointers
R
typ
base
typ
base
size
i
offset
INC
i
END
END
END
FindHiddenPointers
BEGIN
IF
t
ref
THEN
type
was
already
output
Write
R
t
ref
ELSE
obj
t
typobj
IF
obj
NIL
THEN
Write
R
Ref
t
ref
Ref
INC
Ref
ELSE
anonymous
Write
R
END
Write
R
t
form
IF
t
form
Pointer
THEN
OutType
R
t
base
ELSIF
t
form
Array
THEN
OutType
R
t
base
Files
WriteNum
R
t
len
Files
WriteNum
R
t
size
ELSIF
t
form
Record
THEN
IF
t
base
NIL
THEN
OutType
R
t
base
ELSE
OutType
R
noType
END
IF
obj
NIL
THEN
Files
WriteNum
R
obj
exno
ELSE
Write
R
END
Files
WriteNum
R
t
nofpar
Files
WriteNum
R
t
size
fld
t
dsc
WHILE
fld
NIL
DO
fields
IF
fld
expo
THEN
Write
R
Fld
Files
WriteString
R
fld
name
OutType
R
fld
type
Files
WriteNum
R
fld
val
offset
ELSE
FindHiddenPointers
R
fld
type
fld
val
END
fld
fld
next
END
Write
R
ELSIF
t
form
Proc
THEN
OutType
R
t
base
OutPar
R
t
dsc
t
nofpar
Write
R
END
IF
t
mno
obj
NIL
THEN
re
export
output
name
mod
topScope
next
WHILE
mod
NIL
mod
lev
t
mno
DO
mod
mod
next
END
IF
mod
NIL
THEN
Files
WriteString
R
mod
Module
orgname
Files
WriteInt
R
mod
val
Files
WriteString
R
obj
name
ELSE
ORS
Mark
re
export
not
found
Write
R
END
ELSE
Write
R
END
END
END
OutType
PROCEDURE
Export
VAR
modid
ORS
Ident
VAR
newSF
BOOLEAN
VAR
key
LONGINT
VAR
x
sum
oldkey
LONGINT
obj
obj0
Object
filename
ORS
Ident
F
F1
Files
File
R
R1
Files
Rider
BEGIN
Ref
Record
MakeFileName
filename
modid
smb
F
Files
New
filename
Files
Set
R
F
Files
WriteInt
R
placeholder
Files
WriteInt
R
placeholder
for
key
to
be
inserted
at
the
end
Files
WriteString
R
modid
Write
R
versionkey
obj
topScope
next
WHILE
obj
NIL
DO
IF
obj
expo
THEN
Write
R
obj
class
Files
WriteString
R
obj
name
OutType
R
obj
type
IF
obj
class
Typ
THEN
IF
obj
type
form
Record
THEN
obj0
topScope
next
check
whether
this
is
base
of
previously
declared
pointer
types
WHILE
obj0
obj
DO
IF
obj0
type
form
Pointer
obj0
type
base
obj
type
obj0
type
ref
THEN
Write
R
obj0
type
ref
END
obj0
obj0
next
END
END
Write
R
ELSIF
obj
class
Const
THEN
IF
obj
type
form
Proc
THEN
Files
WriteNum
R
obj
exno
ELSIF
obj
type
form
Real
THEN
Files
WriteInt
R
obj
val
ELSE
Files
WriteNum
R
obj
val
END
ELSIF
obj
class
Var
THEN
Files
WriteNum
R
obj
exno
END
END
obj
obj
next
END
REPEAT
Write
R
UNTIL
Files
Length
F
MOD
FOR
Ref
Record
TO
maxTypTab
DO
typtab
Ref
NIL
END
Files
Set
R
F
sum
Files
ReadInt
R
x
compute
key
checksum
WHILE
R
eof
DO
sum
sum
x
Files
ReadInt
R
x
END
F1
Files
Old
filename
sum
is
new
key
IF
F1
NIL
THEN
Files
Set
R1
F1
Files
ReadInt
R1
oldkey
ELSE
oldkey
sum
END
IF
sum
oldkey
THEN
IF
newSF
OR
F1
NIL
THEN
key
sum
newSF
TRUE
Files
Set
R
F
Files
WriteInt
R
sum
Files
Register
F
insert
checksum
ELSE
ORS
Mark
new
symbol
file
inhibited
END
ELSE
newSF
FALSE
key
sum
END
END
Export
PROCEDURE
Init
BEGIN
topScope
universe
nofmod
END
Init
PROCEDURE
type
ref
form
INTEGER
size
LONGINT
Type
VAR
tp
Type
BEGIN
NEW
tp
tp
form
form
tp
size
size
tp
ref
ref
tp
base
NIL
typtab
ref
tp
RETURN
tp
END
type
PROCEDURE
enter
name
ARRAY
OF
CHAR
cl
INTEGER
type
Type
n
LONGINT
VAR
obj
Object
BEGIN
NEW
obj
obj
name
name
obj
class
cl
obj
type
type
obj
val
n
obj
dsc
NIL
IF
cl
Typ
THEN
type
typobj
obj
END
obj
next
system
system
obj
END
enter
BEGIN
byteType
type
Byte
Int
boolType
type
Bool
Bool
charType
type
Char
Char
intType
type
Int
Int
realType
type
Real
Real
setType
type
Set
Set
nilType
type
NilTyp
NilTyp
noType
type
NoTyp
NoTyp
strType
type
String
String
initialize
universe
with
data
types
and
in
line
procedures
LONGINT
is
synonym
to
INTEGER
LONGREAL
to
REAL
LED
ADC
SBC
LDPSR
LDREG
REG
COND
are
not
in
language
definition
system
NIL
n
procno
nofpar
enter
UML
SFunc
intType
functions
enter
SBC
SFunc
intType
enter
ADC
SFunc
intType
enter
ROR
SFunc
intType
enter
ASR
SFunc
intType
enter
LSL
SFunc
intType
enter
LEN
SFunc
intType
enter
CHR
SFunc
charType
enter
ORD
SFunc
intType
enter
FLT
SFunc
realType
enter
FLOOR
SFunc
intType
enter
ODD
SFunc
boolType
enter
ABS
SFunc
intType
enter
LED
SProc
noType
procedures
enter
UNPK
SProc
noType
enter
PACK
SProc
noType
enter
NEW
SProc
noType
enter
ASSERT
SProc
noType
enter
EXCL
SProc
noType
enter
INCL
SProc
noType
enter
DEC
SProc
noType
enter
INC
SProc
noType
enter
SET
Typ
setType
types
enter
BOOLEAN
Typ
boolType
enter
BYTE
Typ
byteType
enter
CHAR
Typ
charType
enter
LONGREAL
Typ
realType
enter
REAL
Typ
realType
enter
LONGINT
Typ
intType
enter
INTEGER
Typ
intType
topScope
NIL
OpenScope
topScope
next
system
universe
topScope
system
NIL
initialize
unsafe
pseudo
module
SYSTEM
enter
H
SFunc
intType
functions
enter
COND
SFunc
boolType
enter
SIZE
SFunc
intType
enter
ADR
SFunc
intType
enter
VAL
SFunc
intType
enter
REG
SFunc
intType
enter
BIT
SFunc
boolType
enter
LDREG
SProc
noType
procedures
enter
LDPSR
SProc
noType
enter
COPY
SProc
noType
enter
PUT
SProc
noType
enter
GET
SProc
noType
END
ORB
MODULE
ORG
N
Wirth
Oberon
compiler
code
generator
for
RISC
IMPORT
SYSTEM
Files
ORS
ORB
Code
generator
for
Oberon
compiler
for
RISC
processor
Procedural
interface
to
Parser
OSAP
result
in
array
code
Procedure
Close
writes
code
files
CONST
WordSize
StkOrg0
VarOrg0
for
RISC
only
MT
SP
LNK
dedicated
registers
maxCode
maxStrx
maxTD
C24
1000000H
Reg
RegI
Cond
internal
item
modes
frequently
used
opcodes
U
2000H
V
1000H
Mov
Lsl
Asr
Ror
And
Ann
Ior
Xor
Add
Sub
Cmp
Mul
Div
Fad
Fsb
Fml
Fdv
Ldr
Str
BR
BLR
BC
BL
MI
PL
EQ
NE
LT
GE
LE
GT
TYPE
Item
RECORD
mode
INTEGER
type
ORB
Type
a
b
r
LONGINT
rdo
BOOLEAN
read
only
END
Item
forms
and
meaning
of
fields
mode
r
a
b
Const
value
proc
adr
immediate
value
Var
base
off
direct
adr
Par
off0
off1
indirect
adr
Reg
regno
RegI
regno
off
Cond
cond
Fchain
Tchain
VAR
pc
varsize
LONGINT
program
counter
data
index
tdx
strx
LONGINT
entry
LONGINT
main
entry
point
RH
LONGINT
available
registers
R
R
H
frame
LONGINT
frame
offset
changed
in
SaveRegs
and
RestoreRegs
fixorgP
fixorgD
fixorgT
LONGINT
origins
of
lists
of
locations
to
be
fixed
up
by
loader
check
BOOLEAN
emit
run
time
checks
version
INTEGER
RISC
RISC
relmap
ARRAY
OF
INTEGER
condition
codes
for
relations
code
ARRAY
maxCode
OF
LONGINT
data
ARRAY
maxTD
OF
LONGINT
type
descriptors
str
ARRAY
maxStrx
OF
CHAR
instruction
assemblers
according
to
formats
PROCEDURE
Put0
op
a
b
c
LONGINT
BEGIN
emit
format
instruction
code
pc
a
10H
b
10H
op
10000H
c
INC
pc
END
Put0
PROCEDURE
Put1
op
a
b
im
LONGINT
BEGIN
emit
format
instruction
10000H
im
10000H
IF
im
THEN
INC
op
V
END
code
pc
a
40H
10H
b
10H
op
10000H
im
MOD
10000H
INC
pc
END
Put1
PROCEDURE
Put1a
op
a
b
im
LONGINT
BEGIN
same
as
Put1
but
with
range
test
10000H
im
10000H
IF
im
10000H
im
0FFFFH
THEN
Put1
op
a
b
im
ELSE
Put1
Mov
U
RH
im
DIV
10000H
IF
im
MOD
10000H
THEN
Put1
Ior
RH
RH
im
MOD
10000H
END
Put0
op
a
b
RH
END
END
Put1a
PROCEDURE
Put2
op
a
b
off
LONGINT
BEGIN
emit
load
store
instruction
code
pc
op
10H
a
10H
b
100000H
off
MOD
100000H
INC
pc
END
Put2
PROCEDURE
Put3
op
cond
off
LONGINT
BEGIN
emit
branch
instruction
code
pc
op
10H
cond
1000000H
off
MOD
1000000H
INC
pc
END
Put3
PROCEDURE
incR
BEGIN
IF
RH
MT
THEN
INC
RH
ELSE
ORS
Mark
register
stack
overflow
END
END
incR
PROCEDURE
CheckRegs
BEGIN
IF
RH
THEN
ORS
Mark
Reg
Stack
RH
END
IF
pc
maxCode
THEN
ORS
Mark
program
too
long
END
IF
frame
THEN
ORS
Mark
frame
error
frame
END
END
CheckRegs
PROCEDURE
SetCC
VAR
x
Item
n
LONGINT
BEGIN
x
mode
Cond
x
a
x
b
x
r
n
END
SetCC
PROCEDURE
Trap
cond
num
LONGINT
BEGIN
Put3
BLR
cond
ORS
Pos
100H
num
10H
MT
END
Trap
handling
of
forward
reference
fixups
of
branch
addresses
and
constant
tables
PROCEDURE
negated
cond
LONGINT
LONGINT
BEGIN
IF
cond
THEN
cond
cond
ELSE
cond
cond
END
RETURN
cond
END
negated
PROCEDURE
fix
at
with
LONGINT
BEGIN
code
at
code
at
DIV
C24
C24
with
MOD
C24
END
fix
PROCEDURE
FixOne
at
LONGINT
BEGIN
fix
at
pc
at
END
FixOne
PROCEDURE
FixLink
L
LONGINT
VAR
L1
LONGINT
BEGIN
WHILE
L
DO
L1
code
L
MOD
40000H
fix
L
pc
L
L
L1
END
END
FixLink
PROCEDURE
FixLinkWith
L0
dst
LONGINT
VAR
L1
LONGINT
BEGIN
WHILE
L0
DO
L1
code
L0
MOD
C24
code
L0
code
L0
DIV
C24
C24
dst
L0
MOD
C24
L0
L1
END
END
FixLinkWith
PROCEDURE
merged
L0
L1
LONGINT
LONGINT
VAR
L2
L3
LONGINT
BEGIN
IF
L0
THEN
L3
L0
REPEAT
L2
L3
L3
code
L2
MOD
40000H
UNTIL
L3
code
L2
code
L2
L1
L1
L0
END
RETURN
L1
END
merged
loading
of
operands
and
addresses
into
registers
PROCEDURE
GetSB
base
LONGINT
BEGIN
IF
version
THEN
Put1
Mov
RH
VarOrg0
ELSE
Put2
Ldr
RH
base
pc
fixorgD
fixorgD
pc
END
END
GetSB
PROCEDURE
NilCheck
BEGIN
IF
check
THEN
Trap
EQ
END
END
NilCheck
PROCEDURE
load
VAR
x
Item
VAR
op
LONGINT
BEGIN
IF
x
type
size
THEN
op
Ldr
ELSE
op
Ldr
END
IF
x
mode
Reg
THEN
IF
x
mode
ORB
Const
THEN
IF
x
type
form
ORB
Proc
THEN
IF
x
r
THEN
ORS
Mark
not
allowed
ELSIF
x
r
THEN
Put3
BL
Put1a
Sub
RH
LNK
pc
x
a
ELSE
GetSB
x
r
Put1
Add
RH
RH
x
a
100H
mark
as
progbase
relative
END
ELSIF
x
a
0FFFFH
x
a
10000H
THEN
Put1
Mov
RH
x
a
ELSE
Put1
Mov
U
RH
x
a
DIV
10000H
MOD
10000H
IF
x
a
MOD
10000H
THEN
Put1
Ior
RH
RH
x
a
MOD
10000H
END
END
x
r
RH
incR
ELSIF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
op
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put2
op
RH
RH
x
a
END
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
op
RH
RH
x
b
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
Put2
op
x
r
x
r
x
a
ELSIF
x
mode
Cond
THEN
Put3
BC
negated
x
r
FixLink
x
b
Put1
Mov
RH
Put3
BC
FixLink
x
a
Put1
Mov
RH
x
r
RH
incR
END
x
mode
Reg
END
END
load
PROCEDURE
loadAdr
VAR
x
Item
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put1a
Add
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put1a
Add
RH
RH
x
a
END
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
IF
x
b
THEN
Put1a
Add
RH
RH
x
b
END
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
IF
x
a
THEN
Put1a
Add
x
r
x
r
x
a
END
ELSE
ORS
Mark
address
error
END
x
mode
Reg
END
loadAdr
PROCEDURE
loadCond
VAR
x
Item
BEGIN
IF
x
type
form
ORB
Bool
THEN
IF
x
mode
ORB
Const
THEN
x
r
x
a
ELSE
load
x
IF
code
pc
DIV
40000000H
THEN
Put1
Cmp
x
r
x
r
END
x
r
NE
DEC
RH
END
x
mode
Cond
x
a
x
b
ELSE
ORS
Mark
not
Boolean
END
END
loadCond
PROCEDURE
loadTypTagAdr
T
ORB
Type
VAR
x
Item
BEGIN
x
mode
ORB
Var
x
a
T
len
x
r
T
mno
loadAdr
x
END
loadTypTagAdr
PROCEDURE
loadStringAdr
VAR
x
Item
BEGIN
GetSB
Put1a
Add
RH
RH
varsize
x
a
x
mode
Reg
x
r
RH
incR
END
loadStringAdr
Items
Conversion
from
constants
or
from
Objects
on
the
Heap
to
Items
on
the
Stack
PROCEDURE
MakeConstItem
VAR
x
Item
typ
ORB
Type
val
LONGINT
BEGIN
x
mode
ORB
Const
x
type
typ
x
a
val
END
MakeConstItem
PROCEDURE
MakeRealItem
VAR
x
Item
val
REAL
BEGIN
x
mode
ORB
Const
x
type
ORB
realType
x
a
SYSTEM
VAL
LONGINT
val
END
MakeRealItem
PROCEDURE
MakeStringItem
VAR
x
Item
len
LONGINT
copies
string
from
ORS
buffer
to
ORG
string
array
VAR
i
LONGINT
BEGIN
x
mode
ORB
Const
x
type
ORB
strType
x
a
strx
x
b
len
i
IF
strx
len
maxStrx
THEN
WHILE
len
DO
str
strx
ORS
str
i
INC
strx
INC
i
DEC
len
END
WHILE
strx
MOD
DO
str
strx
0X
INC
strx
END
ELSE
ORS
Mark
too
many
strings
END
END
MakeStringItem
PROCEDURE
MakeItem
VAR
x
Item
y
ORB
Object
curlev
LONGINT
BEGIN
x
mode
y
class
x
type
y
type
x
a
y
val
x
rdo
y
rdo
IF
y
class
ORB
Par
THEN
x
b
ELSIF
y
class
ORB
Const
y
type
form
ORB
String
THEN
x
b
y
lev
len
ELSE
x
r
y
lev
END
IF
y
lev
y
lev
curlev
y
class
ORB
Const
THEN
ORS
Mark
not
accessible
END
END
MakeItem
Code
generation
for
Selectors
Variables
Constants
PROCEDURE
Field
VAR
x
Item
y
ORB
Object
x
x
y
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
x
a
x
a
y
val
ELSE
loadAdr
x
x
mode
RegI
x
a
y
val
END
ELSIF
x
mode
RegI
THEN
x
a
x
a
y
val
ELSIF
x
mode
ORB
Par
THEN
x
b
x
b
y
val
END
END
Field
PROCEDURE
Index
VAR
x
y
Item
x
x
y
VAR
s
lim
LONGINT
BEGIN
s
x
type
base
size
lim
x
type
len
IF
y
mode
ORB
Const
lim
THEN
IF
y
a
OR
y
a
lim
THEN
ORS
Mark
bad
index
END
IF
x
mode
IN
ORB
Var
RegI
THEN
x
a
y
a
s
x
a
ELSIF
x
mode
ORB
Par
THEN
x
b
y
a
s
x
b
END
ELSE
load
y
IF
check
THEN
check
array
bounds
IF
lim
THEN
Put1a
Cmp
RH
y
r
lim
ELSE
open
array
IF
x
mode
IN
ORB
Var
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put0
Cmp
RH
y
r
RH
ELSE
ORS
Mark
error
in
Index
END
END
Trap
BCC
END
IF
s
THEN
Put1
Lsl
y
r
y
r
ELSIF
s
THEN
Put1a
Mul
y
r
y
r
s
END
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
Put0
Add
y
r
SP
y
r
INC
x
a
frame
ELSE
GetSB
x
r
IF
x
r
THEN
Put0
Add
y
r
RH
y
r
ELSE
Put1a
Add
RH
RH
x
a
Put0
Add
y
r
RH
y
r
x
a
END
END
x
r
y
r
x
mode
RegI
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put0
Add
y
r
RH
y
r
x
mode
RegI
x
r
y
r
x
a
x
b
ELSIF
x
mode
RegI
THEN
Put0
Add
x
r
x
r
y
r
DEC
RH
END
END
END
Index
PROCEDURE
DeRef
VAR
x
Item
BEGIN
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
Ldr
RH
SP
x
a
frame
ELSE
GetSB
x
r
Put2
Ldr
RH
RH
x
a
END
NilCheck
x
r
RH
incR
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
Ldr
RH
RH
x
b
NilCheck
x
r
RH
incR
ELSIF
x
mode
RegI
THEN
Put2
Ldr
x
r
x
r
x
a
NilCheck
ELSIF
x
mode
Reg
THEN
ORS
Mark
bad
mode
in
DeRef
END
x
mode
RegI
x
a
x
b
END
DeRef
PROCEDURE
Q
T
ORB
Type
VAR
dcw
LONGINT
BEGIN
one
entry
of
type
descriptor
extension
table
IF
T
base
NIL
THEN
Q
T
base
dcw
data
dcw
T
mno
1000H
T
len
1000H
dcw
fixorgT
fixorgT
dcw
INC
dcw
END
END
Q
PROCEDURE
FindPtrFlds
typ
ORB
Type
off
LONGINT
VAR
dcw
LONGINT
VAR
fld
ORB
Object
i
s
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
data
dcw
off
INC
dcw
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindPtrFlds
fld
type
fld
val
off
dcw
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
s
typ
base
size
FOR
i
TO
typ
len
DO
FindPtrFlds
typ
base
i
s
off
dcw
END
END
END
FindPtrFlds
PROCEDURE
BuildTD
T
ORB
Type
VAR
dc
LONGINT
VAR
dcw
k
s
LONGINT
dcw
word
address
BEGIN
dcw
dc
DIV
s
T
size
convert
size
for
heap
allocation
IF
s
THEN
s
ELSIF
s
THEN
s
ELSIF
s
THEN
s
ELSE
s
s
DIV
END
T
len
dc
data
dcw
s
INC
dcw
len
used
as
address
k
T
nofpar
extension
level
IF
k
THEN
ORS
Mark
ext
level
too
large
ELSE
Q
T
dcw
WHILE
k
DO
data
dcw
INC
dcw
INC
k
END
END
FindPtrFlds
T
dcw
data
dcw
INC
dcw
tdx
dcw
dc
dcw
IF
tdx
maxTD
THEN
ORS
Mark
too
many
record
types
tdx
END
END
BuildTD
PROCEDURE
TypeTest
VAR
x
Item
T
ORB
Type
varpar
isguard
BOOLEAN
VAR
pc0
LONGINT
BEGIN
fetch
tag
into
RH
IF
varpar
THEN
Put2
Ldr
RH
SP
x
a
frame
ELSE
load
x
pc0
pc
Put3
BC
EQ
NIL
belongs
to
every
pointer
type
Put2
Ldr
RH
x
r
END
Put2
Ldr
RH
RH
T
nofpar
incR
loadTypTagAdr
T
tag
of
T
Put0
Cmp
RH
RH
RH
DEC
RH
IF
varpar
THEN
fix
pc0
pc
pc0
END
IF
isguard
THEN
IF
check
THEN
Trap
NE
END
ELSE
SetCC
x
EQ
IF
varpar
THEN
DEC
RH
END
END
END
TypeTest
Code
generation
for
Boolean
operators
PROCEDURE
Not
VAR
x
Item
x
x
VAR
t
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
x
r
negated
x
r
t
x
a
x
a
x
b
x
b
t
END
Not
PROCEDURE
And1
VAR
x
Item
x
x
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
x
a
x
a
pc
FixLink
x
b
x
b
END
And1
PROCEDURE
And2
VAR
x
y
Item
BEGIN
IF
y
mode
Cond
THEN
loadCond
y
END
x
a
merged
y
a
x
a
x
b
y
b
x
r
y
r
END
And2
PROCEDURE
Or1
VAR
x
Item
x
x
OR
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
x
r
x
b
x
b
pc
FixLink
x
a
x
a
END
Or1
PROCEDURE
Or2
VAR
x
y
Item
BEGIN
IF
y
mode
Cond
THEN
loadCond
y
END
x
a
y
a
x
b
merged
y
b
x
b
x
r
y
r
END
Or2
Code
generation
for
arithmetic
operators
PROCEDURE
Neg
VAR
x
Item
x
x
BEGIN
IF
x
type
form
ORB
Int
THEN
IF
x
mode
ORB
Const
THEN
x
a
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Sub
x
r
RH
x
r
END
ELSIF
x
type
form
ORB
Real
THEN
IF
x
mode
ORB
Const
THEN
x
a
x
a
7FFFFFFFH
ELSE
load
x
Put1
Mov
RH
Put0
Fsb
x
r
RH
x
r
END
ELSE
form
Set
IF
x
mode
ORB
Const
THEN
x
a
x
a
ELSE
load
x
Put1
Xor
x
r
x
r
END
END
END
Neg
PROCEDURE
AddOp
op
LONGINT
VAR
x
y
Item
x
x
y
BEGIN
IF
op
ORS
plus
THEN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
y
a
THEN
Put1a
Add
x
r
x
r
y
a
END
ELSE
load
x
load
y
Put0
Add
RH
x
r
y
r
DEC
RH
x
r
RH
END
ELSE
op
ORS
minus
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
y
a
THEN
Put1a
Sub
x
r
x
r
y
a
END
ELSE
load
x
load
y
Put0
Sub
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
END
AddOp
PROCEDURE
log2
m
LONGINT
VAR
e
LONGINT
LONGINT
BEGIN
e
WHILE
ODD
m
DO
m
m
DIV
INC
e
END
RETURN
m
END
log2
PROCEDURE
MulOp
VAR
x
y
Item
x
x
y
VAR
e
LONGINT
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
x
a
x
a
y
a
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
Put1
Lsl
x
r
x
r
e
ELSIF
y
mode
ORB
Const
THEN
load
x
Put1a
Mul
x
r
x
r
y
a
ELSIF
x
mode
ORB
Const
x
a
log2
x
a
e
THEN
load
y
Put1
Lsl
y
r
y
r
e
x
mode
Reg
x
r
y
r
ELSIF
x
mode
ORB
Const
THEN
load
y
Put1a
Mul
y
r
y
r
x
a
x
mode
Reg
x
r
y
r
ELSE
load
x
load
y
Put0
Mul
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
MulOp
PROCEDURE
DivOp
op
LONGINT
VAR
x
y
Item
x
x
op
y
VAR
e
LONGINT
BEGIN
IF
op
ORS
div
THEN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
y
a
THEN
x
a
x
a
DIV
y
a
ELSE
ORS
Mark
bad
divisor
END
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
Put1
Asr
x
r
x
r
e
ELSIF
y
mode
ORB
Const
THEN
IF
y
a
THEN
load
x
Put1a
Div
x
r
x
r
y
a
ELSE
ORS
Mark
bad
divisor
END
ELSE
load
y
IF
check
THEN
Trap
LE
END
load
x
Put0
Div
RH
x
r
y
r
DEC
RH
x
r
RH
END
ELSE
op
ORS
mod
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
y
a
THEN
x
a
x
a
MOD
y
a
ELSE
ORS
Mark
bad
modulus
END
ELSIF
y
mode
ORB
Const
y
a
log2
y
a
e
THEN
load
x
IF
e
THEN
Put1
And
x
r
x
r
y
a
ELSE
Put1
Lsl
x
r
x
r
e
Put1
Ror
x
r
x
r
e
END
ELSIF
y
mode
ORB
Const
THEN
IF
y
a
THEN
load
x
Put1a
Div
x
r
x
r
y
a
Put0
Mov
U
x
r
ELSE
ORS
Mark
bad
modulus
END
ELSE
load
y
IF
check
THEN
Trap
LE
END
load
x
Put0
Div
RH
x
r
y
r
Put0
Mov
U
RH
DEC
RH
x
r
RH
END
END
END
DivOp
Code
generation
for
REAL
operators
PROCEDURE
RealOp
op
INTEGER
VAR
x
y
Item
x
x
op
y
BEGIN
load
x
load
y
IF
op
ORS
plus
THEN
Put0
Fad
RH
x
r
y
r
ELSIF
op
ORS
minus
THEN
Put0
Fsb
RH
x
r
y
r
ELSIF
op
ORS
times
THEN
Put0
Fml
RH
x
r
y
r
ELSIF
op
ORS
rdiv
THEN
Put0
Fdv
RH
x
r
y
r
END
DEC
RH
x
r
RH
END
RealOp
Code
generation
for
set
operators
PROCEDURE
Singleton
VAR
x
Item
x
x
BEGIN
IF
x
mode
ORB
Const
THEN
x
a
LSL
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Lsl
x
r
RH
x
r
END
END
Singleton
PROCEDURE
Set
VAR
x
y
Item
x
x
y
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
IF
x
a
y
a
THEN
x
a
LSL
y
a
LSL
x
a
ELSE
x
a
END
ELSE
IF
x
mode
ORB
Const
x
a
THEN
x
a
LSL
x
a
ELSE
load
x
Put1
Mov
RH
Put0
Lsl
x
r
RH
x
r
END
IF
y
mode
ORB
Const
y
a
THEN
Put1
Mov
RH
LSL
y
a
y
mode
Reg
y
r
RH
incR
ELSE
load
y
Put1
Mov
RH
Put0
Lsl
y
r
RH
y
r
END
IF
x
mode
ORB
Const
THEN
IF
x
a
THEN
Put1
Xor
y
r
y
r
Put1a
And
RH
y
r
x
a
END
x
mode
Reg
x
r
RH
ELSE
DEC
RH
Put0
Ann
RH
x
r
y
r
END
END
END
Set
PROCEDURE
In
VAR
x
y
Item
x
x
IN
y
BEGIN
load
y
IF
x
mode
ORB
Const
THEN
Put1
Ror
y
r
y
r
x
a
MOD
20H
DEC
RH
ELSE
load
x
Put1
Add
x
r
x
r
Put0
Ror
y
r
y
r
x
r
DEC
RH
END
SetCC
x
MI
END
In
PROCEDURE
SetOp
op
LONGINT
VAR
x
y
Item
x
x
op
y
VAR
xset
yset
SET
x
type
form
Set
BEGIN
IF
x
mode
ORB
Const
y
mode
ORB
Const
THEN
xset
SYSTEM
VAL
SET
x
a
yset
SYSTEM
VAL
SET
y
a
IF
op
ORS
plus
THEN
xset
xset
yset
ELSIF
op
ORS
minus
THEN
xset
xset
yset
ELSIF
op
ORS
times
THEN
xset
xset
yset
ELSIF
op
ORS
rdiv
THEN
xset
xset
yset
END
x
a
SYSTEM
VAL
LONGINT
xset
ELSIF
y
mode
ORB
Const
THEN
load
x
IF
op
ORS
plus
THEN
Put1a
Ior
x
r
x
r
y
a
ELSIF
op
ORS
minus
THEN
Put1a
Ann
x
r
x
r
y
a
ELSIF
op
ORS
times
THEN
Put1a
And
x
r
x
r
y
a
ELSIF
op
ORS
rdiv
THEN
Put1a
Xor
x
r
x
r
y
a
END
ELSE
load
x
load
y
IF
op
ORS
plus
THEN
Put0
Ior
RH
x
r
y
r
ELSIF
op
ORS
minus
THEN
Put0
Ann
RH
x
r
y
r
ELSIF
op
ORS
times
THEN
Put0
And
RH
x
r
y
r
ELSIF
op
ORS
rdiv
THEN
Put0
Xor
RH
x
r
y
r
END
DEC
RH
x
r
RH
END
END
SetOp
Code
generation
for
relations
PROCEDURE
IntRelation
op
INTEGER
VAR
x
y
Item
x
x
y
BEGIN
IF
y
mode
ORB
Const
y
type
form
ORB
Proc
THEN
load
x
IF
y
a
OR
op
IN
ORS
eql
ORS
neq
OR
code
pc
DIV
40000000H
THEN
Put1a
Cmp
x
r
x
r
y
a
END
DEC
RH
ELSE
IF
x
mode
Cond
OR
y
mode
Cond
THEN
ORS
Mark
not
implemented
END
load
x
load
y
Put0
Cmp
x
r
x
r
y
r
DEC
RH
END
SetCC
x
relmap
op
ORS
eql
END
IntRelation
PROCEDURE
RealRelation
op
INTEGER
VAR
x
y
Item
x
x
y
BEGIN
load
x
IF
y
mode
ORB
Const
y
a
THEN
DEC
RH
ELSE
load
y
Put0
Fsb
x
r
x
r
y
r
DEC
RH
END
SetCC
x
relmap
op
ORS
eql
END
RealRelation
PROCEDURE
StringRelation
op
INTEGER
VAR
x
y
Item
x
x
y
x
y
are
char
arrays
or
strings
BEGIN
IF
x
type
form
ORB
String
THEN
loadStringAdr
x
ELSE
loadAdr
x
END
IF
y
type
form
ORB
String
THEN
loadStringAdr
y
ELSE
loadAdr
y
END
Put2
Ldr
RH
x
r
Put1
Add
x
r
x
r
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put0
Cmp
RH
RH
RH
Put3
BC
NE
Put1
Cmp
RH
RH
Put3
BC
NE
DEC
RH
SetCC
x
relmap
op
ORS
eql
END
StringRelation
Code
generation
of
Assignments
PROCEDURE
StrToChar
VAR
x
Item
BEGIN
x
type
ORB
charType
DEC
strx
x
a
ORD
str
x
a
END
StrToChar
PROCEDURE
Store
VAR
x
y
Item
x
y
VAR
op
LONGINT
BEGIN
load
y
IF
x
type
size
THEN
op
Str
ELSE
op
Str
END
IF
x
mode
ORB
Var
THEN
IF
x
r
THEN
local
Put2
op
y
r
SP
x
a
frame
ELSE
GetSB
x
r
Put2
op
y
r
RH
x
a
END
ELSIF
x
mode
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
Put2
op
y
r
RH
x
b
ELSIF
x
mode
RegI
THEN
Put2
op
y
r
x
r
x
a
DEC
RH
ELSE
ORS
Mark
bad
mode
in
Store
END
DEC
RH
END
Store
PROCEDURE
StoreStruct
VAR
x
y
Item
x
y
frame
VAR
s
pc0
LONGINT
BEGIN
IF
y
type
size
THEN
loadAdr
x
loadAdr
y
IF
x
type
form
ORB
Array
x
type
len
THEN
IF
y
type
len
THEN
IF
x
type
size
y
type
size
THEN
Put1a
Mov
RH
y
type
size
DIV
ELSE
ORS
Mark
different
length
size
not
implemented
END
ELSE
y
open
array
Put2
Ldr
RH
SP
y
a
s
y
type
base
size
element
size
pc0
pc
Put3
BC
EQ
IF
s
THEN
Put1
Add
RH
RH
Put1
Asr
RH
RH
ELSIF
s
THEN
Put1a
Mul
RH
RH
s
DIV
END
IF
check
THEN
Put1a
Mov
RH
x
type
size
DIV
Put0
Cmp
RH
RH
RH
Trap
GT
END
fix
pc0
pc
pc0
END
ELSIF
x
type
form
ORB
Record
THEN
Put1a
Mov
RH
x
type
size
DIV
ELSE
ORS
Mark
inadmissible
assignment
END
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put2
Str
RH
x
r
Put1
Add
x
r
x
r
Put1
Sub
RH
RH
Put3
BC
NE
END
RH
END
StoreStruct
PROCEDURE
CopyString
VAR
x
y
Item
x
y
VAR
len
LONGINT
BEGIN
loadAdr
x
len
x
type
len
IF
len
THEN
IF
len
y
b
THEN
ORS
Mark
string
too
long
END
ELSIF
check
THEN
Put2
Ldr
RH
SP
x
a
open
array
len
frame
Put1
Cmp
RH
RH
y
b
Trap
LT
END
loadStringAdr
y
Put2
Ldr
RH
y
r
Put1
Add
y
r
y
r
Put2
Str
RH
x
r
Put1
Add
x
r
x
r
Put1
Asr
RH
RH
Put3
BC
NE
RH
END
CopyString
Code
generation
for
parameters
PROCEDURE
OpenArrayParam
VAR
x
Item
BEGIN
loadAdr
x
IF
x
type
len
THEN
Put1a
Mov
RH
x
type
len
ELSE
Put2
Ldr
RH
SP
x
a
frame
END
incR
END
OpenArrayParam
PROCEDURE
VarParam
VAR
x
Item
ftype
ORB
Type
VAR
xmd
INTEGER
BEGIN
xmd
x
mode
loadAdr
x
IF
ftype
form
ORB
Array
ftype
len
THEN
open
array
IF
x
type
len
THEN
Put1a
Mov
RH
x
type
len
ELSE
Put2
Ldr
RH
SP
x
a
frame
END
incR
ELSIF
ftype
form
ORB
Record
THEN
IF
xmd
ORB
Par
THEN
Put2
Ldr
RH
SP
x
a
frame
incR
ELSE
loadTypTagAdr
x
type
END
END
END
VarParam
PROCEDURE
ValueParam
VAR
x
Item
BEGIN
load
x
END
ValueParam
PROCEDURE
StringParam
VAR
x
Item
BEGIN
loadStringAdr
x
Put1
Mov
RH
x
b
incR
len
END
StringParam
For
Statements
PROCEDURE
For0
VAR
x
y
Item
BEGIN
load
y
END
For0
PROCEDURE
For1
VAR
x
y
z
w
Item
VAR
L
LONGINT
BEGIN
IF
z
mode
ORB
Const
THEN
Put1a
Cmp
RH
y
r
z
a
ELSE
load
z
Put0
Cmp
RH
y
r
z
r
DEC
RH
END
L
pc
IF
w
a
THEN
Put3
BC
GT
ELSIF
w
a
THEN
Put3
BC
LT
ELSE
ORS
Mark
zero
increment
Put3
BC
MI
END
Store
x
y
END
For1
PROCEDURE
For2
VAR
x
y
w
Item
BEGIN
load
x
DEC
RH
Put1a
Add
x
r
x
r
w
a
END
For2
Branches
procedure
calls
procedure
prolog
and
epilog
PROCEDURE
Here
LONGINT
BEGIN
RETURN
pc
END
Here
PROCEDURE
FJump
VAR
L
LONGINT
BEGIN
Put3
BC
L
L
pc
END
FJump
PROCEDURE
CFJump
VAR
x
Item
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
x
a
FixLink
x
b
x
a
pc
END
CFJump
PROCEDURE
BJump
L
LONGINT
BEGIN
Put3
BC
L
pc
END
BJump
PROCEDURE
CBJump
VAR
x
Item
L
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
Put3
BC
negated
x
r
L
pc
FixLink
x
b
FixLinkWith
x
a
L
END
CBJump
PROCEDURE
Fixup
VAR
x
Item
BEGIN
FixLink
x
a
END
Fixup
PROCEDURE
SaveRegs
r
LONGINT
R
r
VAR
r0
LONGINT
BEGIN
r
r0
Put1
Sub
SP
SP
r
INC
frame
r
REPEAT
Put2
Str
r0
SP
r
r0
INC
r0
UNTIL
r0
r
END
SaveRegs
PROCEDURE
RestoreRegs
r
LONGINT
R
r
VAR
r0
LONGINT
BEGIN
r
r0
r
REPEAT
DEC
r0
Put2
Ldr
r0
SP
r
r0
UNTIL
r0
Put1
Add
SP
SP
r
DEC
frame
r
END
RestoreRegs
PROCEDURE
PrepCall
VAR
x
Item
VAR
r
LONGINT
BEGIN
x
type
form
ORB
Proc
IF
x
mode
ORB
Par
THEN
load
x
END
r
RH
IF
RH
THEN
SaveRegs
RH
RH
END
END
PrepCall
PROCEDURE
Call
VAR
x
Item
r
LONGINT
BEGIN
x
type
form
ORB
Proc
IF
x
mode
ORB
Const
THEN
IF
x
r
THEN
Put3
BL
x
a
DIV
pc
ELSE
imported
IF
pc
fixorgP
1000H
THEN
Put3
BL
x
r
100H
x
a
1000H
pc
fixorgP
fixorgP
pc
ELSE
ORS
Mark
fixup
impossible
END
END
ELSE
IF
x
mode
ORB
Par
THEN
load
x
DEC
RH
ELSE
Put2
Ldr
RH
SP
Put1
Add
SP
SP
DEC
r
DEC
frame
END
IF
check
THEN
Trap
EQ
END
Put3
BLR
RH
END
IF
x
type
base
form
ORB
NoTyp
THEN
procedure
RH
ELSE
function
IF
r
THEN
Put0
Mov
r
RestoreRegs
r
END
x
mode
Reg
x
r
r
RH
r
END
END
Call
PROCEDURE
Enter
parblksize
locblksize
LONGINT
int
BOOLEAN
VAR
a
r
LONGINT
BEGIN
frame
IF
int
THEN
procedure
prolog
IF
locblksize
10000H
THEN
ORS
Mark
too
many
locals
END
a
r
Put1
Sub
SP
SP
locblksize
Put2
Str
LNK
SP
WHILE
a
parblksize
DO
Put2
Str
r
SP
a
INC
r
INC
a
END
ELSE
interrupt
procedure
Put1
Sub
SP
SP
locblksize
Put2
Str
SP
Put2
Str
SP
Put2
Str
SP
R0
R1
R2
saved
on
stack
END
END
Enter
PROCEDURE
Return
form
INTEGER
VAR
x
Item
size
LONGINT
int
BOOLEAN
BEGIN
IF
form
ORB
NoTyp
THEN
load
x
END
IF
int
THEN
procedure
epilog
Put2
Ldr
LNK
SP
Put1
Add
SP
SP
size
Put3
BR
LNK
ELSE
interrupt
return
restore
R2
R1
R0
Put2
Ldr
SP
Put2
Ldr
SP
Put2
Ldr
SP
Put1
Add
SP
SP
size
Put3
BR
10H
RTI
END
RH
END
Return
In
line
code
procedures
PROCEDURE
Increment
upordown
LONGINT
VAR
x
y
Item
VAR
op
zr
v
LONGINT
BEGIN
frame
IF
upordown
THEN
op
Add
ELSE
op
Sub
END
IF
x
type
ORB
byteType
THEN
v
ELSE
v
END
IF
y
type
form
ORB
NoTyp
THEN
y
mode
ORB
Const
y
a
END
IF
x
mode
ORB
Var
x
r
THEN
zr
RH
Put2
Ldr
v
zr
SP
x
a
incR
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
y
a
ELSE
load
y
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
v
zr
SP
x
a
DEC
RH
ELSE
loadAdr
x
zr
RH
Put2
Ldr
v
RH
x
r
incR
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
y
a
ELSE
load
y
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
v
zr
x
r
DEC
RH
END
END
Increment
PROCEDURE
Include
inorex
LONGINT
VAR
x
y
Item
VAR
op
zr
LONGINT
BEGIN
loadAdr
x
zr
RH
Put2
Ldr
RH
x
r
incR
IF
inorex
THEN
op
Ior
ELSE
op
Ann
END
IF
y
mode
ORB
Const
THEN
Put1a
op
zr
zr
LSL
y
a
ELSE
load
y
Put1
Mov
RH
Put0
Lsl
y
r
RH
y
r
Put0
op
zr
zr
y
r
DEC
RH
END
Put2
Str
zr
x
r
DEC
RH
END
Include
PROCEDURE
Assert
VAR
x
Item
VAR
cond
LONGINT
BEGIN
IF
x
mode
Cond
THEN
loadCond
x
END
IF
x
a
THEN
cond
negated
x
r
ELSE
Put3
BC
x
r
x
b
FixLink
x
a
x
b
pc
cond
END
Trap
cond
FixLink
x
b
END
Assert
PROCEDURE
New
VAR
x
Item
BEGIN
loadAdr
x
loadTypTagAdr
x
type
base
Trap
RH
END
New
PROCEDURE
Pack
VAR
x
y
Item
VAR
z
Item
BEGIN
z
x
load
x
load
y
Put1
Lsl
y
r
y
r
Put0
Add
x
r
x
r
y
r
DEC
RH
Store
z
x
END
Pack
PROCEDURE
Unpk
VAR
x
y
Item
VAR
z
e0
Item
BEGIN
z
x
load
x
e0
mode
Reg
e0
r
RH
e0
type
ORB
intType
Put1
Asr
RH
x
r
Put1
Sub
RH
RH
Store
y
e0
incR
Put1
Lsl
RH
RH
Put0
Sub
x
r
x
r
RH
Store
z
x
END
Unpk
PROCEDURE
Led
VAR
x
Item
BEGIN
load
x
Put1
Mov
RH
Put2
Str
x
r
RH
DEC
RH
END
Led
PROCEDURE
Get
VAR
x
y
Item
BEGIN
load
x
x
type
y
type
x
mode
RegI
x
a
Store
y
x
END
Get
PROCEDURE
Put
VAR
x
y
Item
BEGIN
load
x
x
type
y
type
x
mode
RegI
x
a
Store
x
y
END
Put
PROCEDURE
Copy
VAR
x
y
z
Item
BEGIN
load
x
load
y
IF
z
mode
ORB
Const
THEN
IF
z
a
THEN
load
z
ELSE
ORS
Mark
bad
count
END
ELSE
load
z
IF
check
THEN
Trap
LT
END
Put3
BC
EQ
END
Put2
Ldr
RH
x
r
Put1
Add
x
r
x
r
Put2
Str
RH
y
r
Put1
Add
y
r
y
r
Put1
Sub
z
r
z
r
Put3
BC
NE
DEC
RH
END
Copy
PROCEDURE
LDPSR
VAR
x
Item
BEGIN
x
mode
Const
Put3
x
a
20H
END
LDPSR
PROCEDURE
LDREG
VAR
x
y
Item
BEGIN
IF
y
mode
ORB
Const
THEN
Put1a
Mov
x
a
y
a
ELSE
load
y
Put0
Mov
x
a
y
r
DEC
RH
END
END
LDREG
In
line
code
functions
PROCEDURE
Abs
VAR
x
Item
BEGIN
IF
x
mode
ORB
Const
THEN
x
a
ABS
x
a
ELSE
load
x
IF
x
type
form
ORB
Real
THEN
Put1
Lsl
x
r
x
r
Put1
Ror
x
r
x
r
ELSE
Put1
Cmp
x
r
x
r
Put3
BC
GE
Put1
Mov
RH
Put0
Sub
x
r
RH
x
r
END
END
END
Abs
PROCEDURE
Odd
VAR
x
Item
BEGIN
load
x
Put1
And
x
r
x
r
SetCC
x
NE
DEC
RH
END
Odd
PROCEDURE
Floor
VAR
x
Item
BEGIN
load
x
Put1
Mov
U
RH
4B00H
Put0
Fad
V
x
r
x
r
RH
END
Floor
PROCEDURE
Float
VAR
x
Item
BEGIN
load
x
Put1
Mov
U
RH
4B00H
Put0
Fad
U
x
r
x
r
RH
END
Float
PROCEDURE
Ord
VAR
x
Item
BEGIN
IF
x
mode
IN
ORB
Var
ORB
Par
RegI
Cond
THEN
load
x
END
END
Ord
PROCEDURE
Len
VAR
x
Item
BEGIN
IF
x
type
len
THEN
IF
x
mode
RegI
THEN
DEC
RH
END
x
mode
ORB
Const
x
a
x
type
len
ELSE
open
array
Put2
Ldr
RH
SP
x
a
frame
x
mode
Reg
x
r
RH
incR
END
END
Len
PROCEDURE
Shift
fct
LONGINT
VAR
x
y
Item
VAR
op
LONGINT
BEGIN
load
x
IF
fct
THEN
op
Lsl
ELSIF
fct
THEN
op
Asr
ELSE
op
Ror
END
IF
y
mode
ORB
Const
THEN
Put1
op
x
r
x
r
y
a
MOD
20H
ELSE
load
y
Put0
op
RH
x
r
y
r
DEC
RH
x
r
RH
END
END
Shift
PROCEDURE
ADC
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Add
2000H
x
r
x
r
y
r
DEC
RH
END
ADC
PROCEDURE
SBC
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Sub
2000H
x
r
x
r
y
r
DEC
RH
END
SBC
PROCEDURE
UML
VAR
x
y
Item
BEGIN
load
x
load
y
Put0
Mul
2000H
x
r
x
r
y
r
DEC
RH
END
UML
PROCEDURE
Bit
VAR
x
y
Item
BEGIN
load
x
Put2
Ldr
x
r
x
r
IF
y
mode
ORB
Const
THEN
Put1
Ror
x
r
x
r
y
a
DEC
RH
ELSE
load
y
Put1
Add
y
r
y
r
Put0
Ror
x
r
x
r
y
r
DEC
RH
END
SetCC
x
MI
END
Bit
PROCEDURE
Register
VAR
x
Item
BEGIN
x
mode
Const
Put0
Mov
RH
x
a
MOD
10H
x
mode
Reg
x
r
RH
incR
END
Register
PROCEDURE
H
VAR
x
Item
BEGIN
x
mode
Const
Put0
Mov
U
x
a
MOD
V
RH
x
mode
Reg
x
r
RH
incR
END
H
PROCEDURE
Adr
VAR
x
Item
BEGIN
IF
x
mode
IN
ORB
Var
ORB
Par
RegI
THEN
loadAdr
x
ELSIF
x
mode
ORB
Const
x
type
form
ORB
Proc
THEN
load
x
ELSIF
x
mode
ORB
Const
x
type
form
ORB
String
THEN
loadStringAdr
x
ELSE
ORS
Mark
not
addressable
END
END
Adr
PROCEDURE
Condition
VAR
x
Item
BEGIN
x
mode
Const
SetCC
x
x
a
END
Condition
PROCEDURE
Open
v
INTEGER
BEGIN
pc
tdx
strx
RH
fixorgP
fixorgD
fixorgT
check
v
version
v
IF
v
THEN
pc
REPEAT
code
pc
INC
pc
UNTIL
pc
END
END
Open
PROCEDURE
SetDataSize
dc
LONGINT
BEGIN
varsize
dc
END
SetDataSize
PROCEDURE
Header
BEGIN
entry
pc
IF
version
THEN
code
0E7000000H
pc
Put1a
Mov
SP
StkOrg0
RISC
ELSE
Put1
Sub
SP
SP
Put2
Str
LNK
SP
END
END
Header
PROCEDURE
NofPtrs
typ
ORB
Type
LONGINT
VAR
fld
ORB
Object
n
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
n
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
n
WHILE
fld
NIL
DO
n
NofPtrs
fld
type
n
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
n
NofPtrs
typ
base
typ
len
ELSE
n
END
RETURN
n
END
NofPtrs
PROCEDURE
FindPtrs
VAR
R
Files
Rider
typ
ORB
Type
adr
LONGINT
VAR
fld
ORB
Object
i
s
LONGINT
BEGIN
IF
typ
form
ORB
Pointer
OR
typ
form
ORB
NilTyp
THEN
Files
WriteInt
R
adr
ELSIF
typ
form
ORB
Record
THEN
fld
typ
dsc
WHILE
fld
NIL
DO
FindPtrs
R
fld
type
fld
val
adr
fld
fld
next
END
ELSIF
typ
form
ORB
Array
THEN
s
typ
base
size
FOR
i
TO
typ
len
DO
FindPtrs
R
typ
base
i
s
adr
END
END
END
FindPtrs
PROCEDURE
Close
VAR
modid
ORS
Ident
key
nofent
LONGINT
VAR
obj
ORB
Object
i
comsize
nofimps
nofptrs
size
LONGINT
name
ORS
Ident
F
Files
File
R
Files
Rider
BEGIN
exit
code
IF
version
THEN
Put1
Mov
Put3
BR
RISC
ELSE
Put2
Ldr
LNK
SP
Put1
Add
SP
SP
Put3
BR
LNK
END
obj
ORB
topScope
next
nofimps
comsize
nofptrs
WHILE
obj
NIL
DO
IF
obj
class
ORB
Mod
obj
dsc
ORB
system
THEN
INC
nofimps
count
imports
ELSIF
obj
exno
obj
class
ORB
Const
obj
type
form
ORB
Proc
obj
type
nofpar
obj
type
base
ORB
noType
THEN
i
count
commands
WHILE
obj
name
i
0X
DO
INC
i
END
i
i
DIV
INC
comsize
i
ELSIF
obj
class
ORB
Var
THEN
INC
nofptrs
NofPtrs
obj
type
count
pointers
END
obj
obj
next
END
size
varsize
strx
comsize
pc
nofimps
nofent
nofptrs
varsize
includes
type
descriptors
ORB
MakeFileName
name
modid
rsc
write
code
file
F
Files
New
name
Files
Set
R
F
Files
WriteString
R
modid
Files
WriteInt
R
key
Files
Write
R
CHR
version
Files
WriteInt
R
size
obj
ORB
topScope
next
WHILE
obj
NIL
obj
class
ORB
Mod
DO
imports
IF
obj
dsc
ORB
system
THEN
Files
WriteString
R
obj
ORB
Module
orgname
Files
WriteInt
R
obj
val
END
obj
obj
next
END
Files
Write
R
0X
Files
WriteInt
R
tdx
i
WHILE
i
tdx
DO
Files
WriteInt
R
data
i
INC
i
END
type
descriptors
Files
WriteInt
R
varsize
tdx
data
Files
WriteInt
R
strx
FOR
i
TO
strx
DO
Files
Write
R
str
i
END
strings
Files
WriteInt
R
pc
code
len
FOR
i
TO
pc
DO
Files
WriteInt
R
code
i
END
program
obj
ORB
topScope
next
WHILE
obj
NIL
DO
commands
IF
obj
exno
obj
class
ORB
Const
obj
type
form
ORB
Proc
obj
type
nofpar
obj
type
base
ORB
noType
THEN
Files
WriteString
R
obj
name
Files
WriteInt
R
obj
val
END
obj
obj
next
END
Files
Write
R
0X
Files
WriteInt
R
nofent
Files
WriteInt
R
entry
obj
ORB
topScope
next
WHILE
obj
NIL
DO
entries
IF
obj
exno
THEN
IF
obj
class
ORB
Const
obj
type
form
ORB
Proc
OR
obj
class
ORB
Var
THEN
Files
WriteInt
R
obj
val
ELSIF
obj
class
ORB
Typ
THEN
IF
obj
type
form
ORB
Record
THEN
Files
WriteInt
R
obj
type
len
MOD
10000H
ELSIF
obj
type
form
ORB
Pointer
obj
type
base
typobj
NIL
OR
obj
type
base
typobj
exno
THEN
Files
WriteInt
R
obj
type
base
len
MOD
10000H
END
END
END
obj
obj
next
END
obj
ORB
topScope
next
WHILE
obj
NIL
DO
pointer
variables
IF
obj
class
ORB
Var
THEN
FindPtrs
R
obj
type
obj
val
END
obj
obj
next
END
Files
WriteInt
R
Files
WriteInt
R
fixorgP
Files
WriteInt
R
fixorgD
Files
WriteInt
R
fixorgT
Files
WriteInt
R
entry
Files
Write
R
O
Files
Register
F
END
Close
BEGIN
relmap
relmap
relmap
relmap
relmap
relmap
END
ORG
MODULE
ORP
N
Wirth
Oberon
compiler
for
RISC
in
Oberon
IMPORT
Texts
Oberon
ORS
ORB
ORG
Author
Niklaus
Wirth
Parser
of
Oberon
RISC
compiler
Uses
Scanner
ORS
to
obtain
symbols
tokens
ORB
for
definition
of
data
structures
and
for
handling
import
and
export
and
ORG
to
produce
binary
code
ORP
performs
type
checking
and
data
allocation
Parser
is
target
independent
except
for
part
of
the
handling
of
allocations
TYPE
PtrBase
POINTER
TO
PtrBaseDesc
PtrBaseDesc
RECORD
list
of
names
of
pointer
base
types
name
ORS
Ident
type
ORB
Type
next
PtrBase
END
VAR
sym
INTEGER
last
symbol
read
dc
LONGINT
data
counter
level
exno
version
INTEGER
newSF
BOOLEAN
option
flag
expression
PROCEDURE
VAR
x
ORG
Item
to
avoid
forward
reference
Type
PROCEDURE
VAR
type
ORB
Type
FormalType
PROCEDURE
VAR
typ
ORB
Type
dim
INTEGER
modid
ORS
Ident
pbsList
PtrBase
list
of
names
of
pointer
base
types
dummy
ORB
Object
W
Texts
Writer
PROCEDURE
Check
s
INTEGER
msg
ARRAY
OF
CHAR
BEGIN
IF
sym
s
THEN
ORS
Get
sym
ELSE
ORS
Mark
msg
END
END
Check
PROCEDURE
qualident
VAR
obj
ORB
Object
BEGIN
obj
ORB
thisObj
ORS
Get
sym
IF
obj
NIL
THEN
ORS
Mark
undef
obj
dummy
END
IF
sym
ORS
period
obj
class
ORB
Mod
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
obj
ORB
thisimport
obj
ORS
Get
sym
IF
obj
NIL
THEN
ORS
Mark
undef
obj
dummy
END
ELSE
ORS
Mark
identifier
expected
obj
dummy
END
END
END
qualident
PROCEDURE
CheckBool
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Bool
THEN
ORS
Mark
not
Boolean
x
type
ORB
boolType
END
END
CheckBool
PROCEDURE
CheckInt
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Int
THEN
ORS
Mark
not
Integer
x
type
ORB
intType
END
END
CheckInt
PROCEDURE
CheckReal
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Real
THEN
ORS
Mark
not
Real
x
type
ORB
realType
END
END
CheckReal
PROCEDURE
CheckSet
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Set
THEN
ORS
Mark
not
Set
x
type
ORB
setType
END
END
CheckSet
PROCEDURE
CheckSetVal
VAR
x
ORG
Item
BEGIN
IF
x
type
form
ORB
Int
THEN
ORS
Mark
not
Int
x
type
ORB
setType
ELSIF
x
mode
ORB
Const
THEN
IF
x
a
OR
x
a
THEN
ORS
Mark
invalid
set
END
END
END
CheckSetVal
PROCEDURE
CheckConst
VAR
x
ORG
Item
BEGIN
IF
x
mode
ORB
Const
THEN
ORS
Mark
not
a
constant
x
mode
ORB
Const
END
END
CheckConst
PROCEDURE
CheckReadOnly
VAR
x
ORG
Item
BEGIN
IF
x
rdo
THEN
ORS
Mark
read
only
END
END
CheckReadOnly
PROCEDURE
CheckExport
VAR
expo
BOOLEAN
BEGIN
IF
sym
ORS
times
THEN
expo
TRUE
ORS
Get
sym
IF
level
THEN
ORS
Mark
remove
asterisk
END
ELSE
expo
FALSE
END
END
CheckExport
PROCEDURE
IsExtension
t0
t1
ORB
Type
BOOLEAN
BEGIN
t1
is
an
extension
of
t0
RETURN
t0
t1
OR
t1
NIL
IsExtension
t0
t1
base
END
IsExtension
expressions
PROCEDURE
TypeTest
VAR
x
ORG
Item
T
ORB
Type
guard
BOOLEAN
VAR
xt
ORB
Type
BEGIN
xt
x
type
IF
T
form
xt
form
T
form
ORB
Pointer
OR
T
form
ORB
Record
x
mode
ORB
Par
THEN
WHILE
xt
T
xt
NIL
DO
xt
xt
base
END
IF
xt
T
THEN
xt
x
type
IF
xt
form
ORB
Pointer
THEN
IF
IsExtension
xt
base
T
base
THEN
ORG
TypeTest
x
T
base
FALSE
guard
x
type
T
ELSE
ORS
Mark
not
an
extension
END
ELSIF
xt
form
ORB
Record
x
mode
ORB
Par
THEN
IF
IsExtension
xt
T
THEN
ORG
TypeTest
x
T
TRUE
guard
x
type
T
ELSE
ORS
Mark
not
an
extension
END
ELSE
ORS
Mark
incompatible
types
END
ELSIF
guard
THEN
ORG
MakeConstItem
x
ORB
boolType
END
ELSE
ORS
Mark
type
mismatch
END
IF
guard
THEN
x
type
ORB
boolType
END
END
TypeTest
PROCEDURE
selector
VAR
x
ORG
Item
VAR
y
ORG
Item
obj
ORB
Object
BEGIN
WHILE
sym
ORS
lbrak
OR
sym
ORS
period
OR
sym
ORS
arrow
OR
sym
ORS
lparen
x
type
form
IN
ORB
Record
ORB
Pointer
DO
IF
sym
ORS
lbrak
THEN
REPEAT
ORS
Get
sym
expression
y
IF
x
type
form
ORB
Array
THEN
CheckInt
y
ORG
Index
x
y
x
type
x
type
base
ELSE
ORS
Mark
not
an
array
END
UNTIL
sym
ORS
comma
Check
ORS
rbrak
no
ELSIF
sym
ORS
period
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
IF
x
type
form
ORB
Pointer
THEN
ORG
DeRef
x
x
type
x
type
base
END
IF
x
type
form
ORB
Record
THEN
obj
ORB
thisfield
x
type
ORS
Get
sym
IF
obj
NIL
THEN
ORG
Field
x
obj
x
type
obj
type
ELSE
ORS
Mark
undef
END
ELSE
ORS
Mark
not
a
record
END
ELSE
ORS
Mark
ident
END
ELSIF
sym
ORS
arrow
THEN
ORS
Get
sym
IF
x
type
form
ORB
Pointer
THEN
ORG
DeRef
x
x
type
x
type
base
ELSE
ORS
Mark
not
a
pointer
END
ELSIF
sym
ORS
lparen
x
type
form
IN
ORB
Record
ORB
Pointer
THEN
type
guard
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
TypeTest
x
obj
type
TRUE
ELSE
ORS
Mark
guard
type
expected
END
ELSE
ORS
Mark
not
an
identifier
END
Check
ORS
rparen
missing
END
END
END
selector
PROCEDURE
EqualSignatures
t0
t1
ORB
Type
BOOLEAN
VAR
p0
p1
ORB
Object
com
BOOLEAN
BEGIN
com
TRUE
IF
t0
base
t1
base
t0
nofpar
t1
nofpar
THEN
p0
t0
dsc
p1
t1
dsc
WHILE
p0
NIL
DO
IF
p0
class
p1
class
p0
rdo
p1
rdo
p0
type
p1
type
OR
p0
type
form
ORB
Array
p1
type
form
ORB
Array
p0
type
len
p1
type
len
p0
type
base
p1
type
base
OR
p0
type
form
ORB
Proc
p1
type
form
ORB
Proc
EqualSignatures
p0
type
p1
type
THEN
p0
p0
next
p1
p1
next
ELSE
p0
NIL
com
FALSE
END
END
ELSE
com
FALSE
END
RETURN
com
END
EqualSignatures
PROCEDURE
CompTypes
t0
t1
ORB
Type
varpar
BOOLEAN
BOOLEAN
BEGIN
check
for
assignment
compatibility
RETURN
t0
t1
openarray
assignment
disallowed
in
ORG
OR
t0
form
ORB
Array
t1
form
ORB
Array
t0
base
t1
base
t0
len
t1
len
OR
t0
form
ORB
Record
t1
form
ORB
Record
IsExtension
t0
t1
OR
varpar
t0
form
ORB
Pointer
t1
form
ORB
Pointer
IsExtension
t0
base
t1
base
OR
t0
form
ORB
Proc
t1
form
ORB
Proc
EqualSignatures
t0
t1
OR
t0
form
IN
ORB
Pointer
ORB
Proc
t1
form
ORB
NilTyp
END
CompTypes
PROCEDURE
Parameter
par
ORB
Object
VAR
x
ORG
Item
varpar
BOOLEAN
BEGIN
expression
x
IF
par
NIL
THEN
varpar
par
class
ORB
Par
IF
CompTypes
par
type
x
type
varpar
THEN
IF
varpar
THEN
ORG
ValueParam
x
ELSE
par
class
Par
IF
par
rdo
THEN
CheckReadOnly
x
END
ORG
VarParam
x
par
type
END
ELSIF
x
type
form
ORB
Array
par
type
form
ORB
Array
x
type
base
par
type
base
par
type
len
THEN
IF
par
rdo
THEN
CheckReadOnly
x
END
ORG
OpenArrayParam
x
ELSIF
x
type
form
ORB
String
varpar
par
rdo
par
type
form
ORB
Array
par
type
base
form
ORB
Char
par
type
len
THEN
ORG
StringParam
x
ELSIF
varpar
par
type
form
ORB
Int
x
type
form
ORB
Int
THEN
ORG
ValueParam
x
BYTE
ELSIF
x
type
form
ORB
String
x
b
par
class
ORB
Var
par
type
form
ORB
Char
THEN
ORG
StrToChar
x
ORG
ValueParam
x
ELSIF
par
type
form
ORB
Array
par
type
base
ORB
byteType
par
type
len
par
type
size
x
type
size
THEN
ORG
VarParam
x
par
type
ELSE
ORS
Mark
incompatible
parameters
END
END
END
Parameter
PROCEDURE
ParamList
VAR
x
ORG
Item
VAR
n
INTEGER
par
ORB
Object
BEGIN
par
x
type
dsc
n
IF
sym
ORS
rparen
THEN
Parameter
par
n
WHILE
sym
ORS
comma
DO
Check
sym
comma
IF
par
NIL
THEN
par
par
next
END
INC
n
Parameter
par
END
Check
ORS
rparen
missing
ELSE
ORS
Get
sym
END
IF
n
x
type
nofpar
THEN
ORS
Mark
too
few
params
ELSIF
n
x
type
nofpar
THEN
ORS
Mark
too
many
params
END
END
ParamList
PROCEDURE
StandFunc
VAR
x
ORG
Item
fct
LONGINT
restyp
ORB
Type
VAR
y
ORG
Item
n
npar
LONGINT
BEGIN
Check
ORS
lparen
no
npar
fct
MOD
fct
fct
DIV
expression
x
n
WHILE
sym
ORS
comma
DO
ORS
Get
sym
expression
y
INC
n
END
Check
ORS
rparen
no
IF
n
npar
THEN
IF
fct
THEN
ABS
IF
x
type
form
IN
ORB
Int
ORB
Real
THEN
ORG
Abs
x
restyp
x
type
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
ODD
CheckInt
x
ORG
Odd
x
ELSIF
fct
THEN
FLOOR
CheckReal
x
ORG
Floor
x
ELSIF
fct
THEN
FLT
CheckInt
x
ORG
Float
x
ELSIF
fct
THEN
ORD
IF
x
type
form
ORB
Proc
THEN
ORG
Ord
x
ELSIF
x
type
form
ORB
String
x
b
THEN
ORG
StrToChar
x
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
CHR
CheckInt
x
ORG
Ord
x
ELSIF
fct
THEN
LEN
IF
x
type
form
ORB
Array
THEN
ORG
Len
x
ELSE
ORS
Mark
not
an
array
END
ELSIF
fct
IN
THEN
LSL
ASR
ROR
CheckInt
y
IF
x
type
form
IN
ORB
Int
ORB
Set
THEN
ORG
Shift
fct
x
y
restyp
x
type
ELSE
ORS
Mark
bad
type
END
ELSIF
fct
THEN
ADC
ORG
ADC
x
y
ELSIF
fct
THEN
SBC
ORG
SBC
x
y
ELSIF
fct
THEN
UML
ORG
UML
x
y
ELSIF
fct
THEN
BIT
CheckInt
x
CheckInt
y
ORG
Bit
x
y
ELSIF
fct
THEN
REG
CheckConst
x
CheckInt
x
ORG
Register
x
ELSIF
fct
THEN
VAL
IF
x
mode
ORB
Typ
x
type
size
y
type
size
THEN
restyp
x
type
x
y
ELSE
ORS
Mark
casting
not
allowed
END
ELSIF
fct
THEN
ADR
ORG
Adr
x
ELSIF
fct
THEN
SIZE
IF
x
mode
ORB
Typ
THEN
ORG
MakeConstItem
x
ORB
intType
x
type
size
ELSE
ORS
Mark
must
be
a
type
END
ELSIF
fct
THEN
COND
CheckConst
x
CheckInt
x
ORG
Condition
x
ELSIF
fct
THEN
H
CheckConst
x
CheckInt
x
ORG
H
x
END
x
type
restyp
ELSE
ORS
Mark
wrong
nof
params
END
END
StandFunc
PROCEDURE
element
VAR
x
ORG
Item
VAR
y
ORG
Item
BEGIN
expression
x
CheckSetVal
x
IF
sym
ORS
upto
THEN
ORS
Get
sym
expression
y
CheckSetVal
y
ORG
Set
x
y
ELSE
ORG
Singleton
x
END
x
type
ORB
setType
END
element
PROCEDURE
set
VAR
x
ORG
Item
VAR
y
ORG
Item
BEGIN
IF
sym
ORS
if
THEN
IF
sym
ORS
rbrace
THEN
ORS
Mark
missing
END
ORG
MakeConstItem
x
ORB
setType
empty
set
ELSE
element
x
WHILE
sym
ORS
rparen
OR
sym
ORS
rbrace
DO
IF
sym
ORS
comma
THEN
ORS
Get
sym
ELSIF
sym
ORS
rbrace
THEN
ORS
Mark
missing
comma
END
element
y
ORG
SetOp
ORS
plus
x
y
END
END
END
set
PROCEDURE
factor
VAR
x
ORG
Item
VAR
obj
ORB
Object
rx
LONGINT
BEGIN
sync
IF
sym
ORS
char
OR
sym
ORS
ident
THEN
ORS
Mark
expression
expected
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
char
sym
ORS
for
OR
sym
ORS
then
END
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
SFunc
THEN
StandFunc
x
obj
val
obj
type
ELSE
ORG
MakeItem
x
obj
level
selector
x
IF
sym
ORS
lparen
THEN
ORS
Get
sym
IF
x
type
form
ORB
Proc
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ParamList
x
ORG
Call
x
rx
x
type
x
type
base
ELSE
ORS
Mark
not
a
function
ParamList
x
END
END
END
ELSIF
sym
ORS
int
THEN
ORG
MakeConstItem
x
ORB
intType
ORS
ival
ORS
Get
sym
ELSIF
sym
ORS
real
THEN
ORG
MakeRealItem
x
ORS
rval
ORS
Get
sym
ELSIF
sym
ORS
char
THEN
ORG
MakeConstItem
x
ORB
charType
ORS
ival
ORS
Get
sym
ELSIF
sym
ORS
nil
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
nilType
ELSIF
sym
ORS
string
THEN
ORG
MakeStringItem
x
ORS
slen
ORS
Get
sym
ELSIF
sym
ORS
lparen
THEN
ORS
Get
sym
expression
x
Check
ORS
rparen
no
ELSIF
sym
ORS
lbrace
THEN
ORS
Get
sym
set
x
Check
ORS
rbrace
no
ELSIF
sym
ORS
not
THEN
ORS
Get
sym
factor
x
CheckBool
x
ORG
Not
x
ELSIF
sym
ORS
false
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
boolType
ELSIF
sym
ORS
true
THEN
ORS
Get
sym
ORG
MakeConstItem
x
ORB
boolType
ELSE
ORS
Mark
not
a
factor
ORG
MakeConstItem
x
ORB
intType
END
END
factor
PROCEDURE
term
VAR
x
ORG
Item
VAR
y
ORG
Item
op
f
INTEGER
BEGIN
factor
x
f
x
type
form
WHILE
sym
ORS
times
sym
ORS
and
DO
op
sym
ORS
Get
sym
IF
op
ORS
times
THEN
IF
f
ORB
Int
THEN
factor
y
CheckInt
y
ORG
MulOp
x
y
ELSIF
f
ORB
Real
THEN
factor
y
CheckReal
y
ORG
RealOp
op
x
y
ELSIF
f
ORB
Set
THEN
factor
y
CheckSet
y
ORG
SetOp
op
x
y
ELSE
ORS
Mark
bad
type
END
ELSIF
op
ORS
div
OR
op
ORS
mod
THEN
CheckInt
x
factor
y
CheckInt
y
ORG
DivOp
op
x
y
ELSIF
op
ORS
rdiv
THEN
IF
f
ORB
Real
THEN
factor
y
CheckReal
y
ORG
RealOp
op
x
y
ELSIF
f
ORB
Set
THEN
factor
y
CheckSet
y
ORG
SetOp
op
x
y
ELSE
ORS
Mark
bad
type
END
ELSE
op
and
CheckBool
x
ORG
And1
x
factor
y
CheckBool
y
ORG
And2
x
y
END
END
END
term
PROCEDURE
SimpleExpression
VAR
x
ORG
Item
VAR
y
ORG
Item
op
INTEGER
BEGIN
IF
sym
ORS
minus
THEN
ORS
Get
sym
term
x
IF
x
type
form
IN
ORB
Int
ORB
Real
ORB
Set
THEN
ORG
Neg
x
ELSE
CheckInt
x
END
ELSIF
sym
ORS
plus
THEN
ORS
Get
sym
term
x
ELSE
term
x
END
WHILE
sym
ORS
plus
sym
ORS
or
DO
op
sym
ORS
Get
sym
IF
op
ORS
or
THEN
ORG
Or1
x
CheckBool
x
term
y
CheckBool
y
ORG
Or2
x
y
ELSIF
x
type
form
ORB
Int
THEN
term
y
CheckInt
y
ORG
AddOp
op
x
y
ELSIF
x
type
form
ORB
Real
THEN
term
y
CheckReal
y
ORG
RealOp
op
x
y
ELSE
CheckSet
x
term
y
CheckSet
y
ORG
SetOp
op
x
y
END
END
END
SimpleExpression
PROCEDURE
expression0
VAR
x
ORG
Item
VAR
y
ORG
Item
obj
ORB
Object
rel
xf
yf
INTEGER
BEGIN
SimpleExpression
x
IF
sym
ORS
eql
sym
ORS
geq
THEN
rel
sym
ORS
Get
sym
SimpleExpression
y
xf
x
type
form
yf
y
type
form
IF
x
type
y
type
THEN
IF
xf
IN
ORB
Char
ORB
Int
THEN
ORG
IntRelation
rel
x
y
ELSIF
xf
ORB
Real
THEN
ORG
RealRelation
rel
x
y
ELSIF
xf
IN
ORB
Set
ORB
Pointer
ORB
Proc
ORB
NilTyp
ORB
Bool
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Array
x
type
base
form
ORB
Char
OR
xf
ORB
String
THEN
ORG
StringRelation
rel
x
y
ELSE
ORS
Mark
illegal
comparison
END
ELSIF
xf
IN
ORB
Pointer
ORB
Proc
yf
ORB
NilTyp
OR
yf
IN
ORB
Pointer
ORB
Proc
xf
ORB
NilTyp
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Pointer
yf
ORB
Pointer
IsExtension
x
type
base
y
type
base
OR
IsExtension
y
type
base
x
type
base
OR
xf
ORB
Proc
yf
ORB
Proc
EqualSignatures
x
type
y
type
THEN
IF
rel
ORS
neq
THEN
ORG
IntRelation
rel
x
y
ELSE
ORS
Mark
only
or
END
ELSIF
xf
ORB
Array
x
type
base
form
ORB
Char
yf
ORB
String
OR
yf
ORB
Array
y
type
base
form
ORB
Char
OR
yf
ORB
Array
y
type
base
form
ORB
Char
xf
ORB
String
THEN
ORG
StringRelation
rel
x
y
ELSIF
xf
ORB
Char
yf
ORB
String
y
b
THEN
ORG
StrToChar
y
ORG
IntRelation
rel
x
y
ELSIF
yf
ORB
Char
xf
ORB
String
x
b
THEN
ORG
StrToChar
x
ORG
IntRelation
rel
x
y
ELSIF
xf
ORB
Int
yf
ORB
Int
THEN
ORG
IntRelation
rel
x
y
BYTE
ELSE
ORS
Mark
illegal
comparison
END
x
type
ORB
boolType
ELSIF
sym
ORS
in
THEN
ORS
Get
sym
CheckInt
x
SimpleExpression
y
CheckSet
y
ORG
In
x
y
x
type
ORB
boolType
ELSIF
sym
ORS
is
THEN
ORS
Get
sym
qualident
obj
TypeTest
x
obj
type
FALSE
x
type
ORB
boolType
END
END
expression0
statements
PROCEDURE
StandProc
pno
LONGINT
VAR
nap
npar
LONGINT
nof
actual
formal
parameters
x
y
z
ORG
Item
BEGIN
Check
ORS
lparen
no
npar
pno
MOD
pno
pno
DIV
expression
x
nap
IF
sym
ORS
comma
THEN
ORS
Get
sym
expression
y
nap
z
type
ORB
noType
WHILE
sym
ORS
comma
DO
ORS
Get
sym
expression
z
INC
nap
END
ELSE
y
type
ORB
noType
END
Check
ORS
rparen
no
IF
npar
nap
OR
pno
IN
THEN
IF
pno
IN
THEN
INC
DEC
CheckInt
x
CheckReadOnly
x
IF
y
type
ORB
noType
THEN
CheckInt
y
END
ORG
Increment
pno
x
y
ELSIF
pno
IN
THEN
INCL
EXCL
CheckSet
x
CheckReadOnly
x
CheckInt
y
ORG
Include
pno
x
y
ELSIF
pno
THEN
CheckBool
x
ORG
Assert
x
ELSIF
pno
THEN
NEW
CheckReadOnly
x
IF
x
type
form
ORB
Pointer
x
type
base
form
ORB
Record
THEN
ORG
New
x
ELSE
ORS
Mark
not
a
pointer
to
record
END
ELSIF
pno
THEN
CheckReal
x
CheckInt
y
CheckReadOnly
x
ORG
Pack
x
y
ELSIF
pno
THEN
CheckReal
x
CheckInt
y
CheckReadOnly
x
ORG
Unpk
x
y
ELSIF
pno
THEN
IF
x
type
form
ORB
Set
THEN
ORG
Led
x
ELSE
ORS
Mark
bad
type
END
ELSIF
pno
THEN
CheckInt
x
ORG
Get
x
y
ELSIF
pno
THEN
CheckInt
x
ORG
Put
x
y
ELSIF
pno
THEN
CheckInt
x
CheckInt
y
CheckInt
z
ORG
Copy
x
y
z
ELSIF
pno
THEN
CheckConst
x
CheckInt
x
ORG
LDPSR
x
ELSIF
pno
THEN
CheckInt
x
ORG
LDREG
x
y
END
ELSE
ORS
Mark
wrong
nof
parameters
END
END
StandProc
PROCEDURE
StatSequence
VAR
obj
ORB
Object
orgtype
ORB
Type
original
type
of
case
var
x
y
z
w
ORG
Item
L0
L1
rx
LONGINT
PROCEDURE
TypeCase
obj
ORB
Object
VAR
x
ORG
Item
VAR
typobj
ORB
Object
BEGIN
IF
sym
ORS
ident
THEN
qualident
typobj
ORG
MakeItem
x
obj
level
IF
typobj
class
ORB
Typ
THEN
ORS
Mark
not
a
type
END
TypeTest
x
typobj
type
FALSE
obj
type
typobj
type
ORG
CFJump
x
Check
ORS
colon
expected
StatSequence
ELSE
ORG
CFJump
x
ORS
Mark
type
id
expected
END
END
TypeCase
PROCEDURE
SkipCase
BEGIN
WHILE
sym
ORS
colon
DO
ORS
Get
sym
END
ORS
Get
sym
StatSequence
END
SkipCase
BEGIN
StatSequence
REPEAT
sync
obj
NIL
IF
sym
ORS
ident
sym
ORS
for
OR
sym
ORS
semicolon
THEN
ORS
Mark
statement
expected
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
ident
END
IF
sym
ORS
ident
THEN
qualident
obj
ORG
MakeItem
x
obj
level
IF
x
mode
ORB
SProc
THEN
StandProc
obj
val
ELSE
selector
x
IF
sym
ORS
becomes
THEN
assignment
ORS
Get
sym
CheckReadOnly
x
expression
y
IF
CompTypes
x
type
y
type
FALSE
THEN
IF
x
type
form
ORB
Pointer
OR
x
type
form
ORB
Proc
THEN
ORG
Store
x
y
ELSE
ORG
StoreStruct
x
y
END
ELSIF
x
type
form
ORB
Array
y
type
form
ORB
Array
x
type
base
y
type
base
y
type
len
THEN
ORG
StoreStruct
x
y
ELSIF
x
type
form
ORB
Array
x
type
base
form
ORB
Char
y
type
form
ORB
String
THEN
ORG
CopyString
x
y
ELSIF
x
type
form
ORB
Int
y
type
form
ORB
Int
THEN
ORG
Store
x
y
BYTE
ELSIF
x
type
form
ORB
Char
y
type
form
ORB
String
y
b
THEN
ORG
StrToChar
y
ORG
Store
x
y
ELSE
ORS
Mark
illegal
assignment
END
ELSIF
sym
ORS
eql
THEN
ORS
Mark
should
be
ORS
Get
sym
expression
y
ELSIF
sym
ORS
lparen
THEN
procedure
call
ORS
Get
sym
IF
x
type
form
ORB
Proc
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ParamList
x
ORG
Call
x
rx
ELSE
ORS
Mark
not
a
procedure
ParamList
x
END
ELSIF
x
type
form
ORB
Proc
THEN
procedure
call
without
parameters
IF
x
type
nofpar
THEN
ORS
Mark
missing
parameters
END
IF
x
type
base
form
ORB
NoTyp
THEN
ORG
PrepCall
x
rx
ORG
Call
x
rx
ELSE
ORS
Mark
not
a
procedure
END
ELSIF
x
mode
ORB
Typ
THEN
ORS
Mark
illegal
assignment
ELSE
ORS
Mark
not
a
procedure
END
END
ELSIF
sym
ORS
if
THEN
ORS
Get
sym
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
then
no
THEN
StatSequence
L0
WHILE
sym
ORS
elsif
DO
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
then
no
THEN
StatSequence
END
IF
sym
ORS
else
THEN
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
StatSequence
ELSE
ORG
Fixup
x
END
ORG
FixLink
L0
Check
ORS
end
no
END
ELSIF
sym
ORS
while
THEN
ORS
Get
sym
L0
ORG
Here
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
do
no
DO
StatSequence
ORG
BJump
L0
WHILE
sym
ORS
elsif
DO
ORS
Get
sym
ORG
Fixup
x
expression
x
CheckBool
x
ORG
CFJump
x
Check
ORS
do
no
DO
StatSequence
ORG
BJump
L0
END
ORG
Fixup
x
Check
ORS
end
no
END
ELSIF
sym
ORS
repeat
THEN
ORS
Get
sym
L0
ORG
Here
StatSequence
IF
sym
ORS
until
THEN
ORS
Get
sym
expression
x
CheckBool
x
ORG
CBJump
x
L0
ELSE
ORS
Mark
missing
UNTIL
END
ELSIF
sym
ORS
for
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
ORG
MakeItem
x
obj
level
CheckInt
x
CheckReadOnly
x
IF
sym
ORS
becomes
THEN
ORS
Get
sym
expression
y
CheckInt
y
ORG
For0
x
y
L0
ORG
Here
Check
ORS
to
no
TO
expression
z
CheckInt
z
obj
rdo
TRUE
IF
sym
ORS
by
THEN
ORS
Get
sym
expression
w
CheckConst
w
CheckInt
w
ELSE
ORG
MakeConstItem
w
ORB
intType
END
Check
ORS
do
no
DO
ORG
For1
x
y
z
w
L1
StatSequence
Check
ORS
end
no
END
ORG
For2
x
y
w
ORG
BJump
L0
ORG
FixLink
L1
obj
rdo
FALSE
ELSE
ORS
Mark
expected
END
ELSE
ORS
Mark
identifier
expected
END
ELSIF
sym
ORS
case
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
orgtype
obj
type
IF
orgtype
form
ORB
Pointer
OR
orgtype
form
ORB
Record
obj
class
ORB
Par
THEN
Check
ORS
of
OF
expected
TypeCase
obj
x
L0
WHILE
sym
ORS
bar
DO
ORS
Get
sym
ORG
FJump
L0
ORG
Fixup
x
obj
type
orgtype
TypeCase
obj
x
END
ORG
Fixup
x
ORG
FixLink
L0
obj
type
orgtype
ELSE
ORS
Mark
numeric
case
not
implemented
Check
ORS
of
OF
expected
SkipCase
WHILE
sym
ORS
bar
DO
SkipCase
END
END
ELSE
ORS
Mark
ident
expected
END
Check
ORS
end
no
END
END
ORG
CheckRegs
IF
sym
ORS
semicolon
THEN
ORS
Get
sym
ELSIF
sym
ORS
semicolon
THEN
ORS
Mark
missing
semicolon
END
UNTIL
sym
ORS
semicolon
END
StatSequence
Types
and
declarations
PROCEDURE
IdentList
class
INTEGER
VAR
first
ORB
Object
VAR
obj
ORB
Object
BEGIN
IF
sym
ORS
ident
THEN
ORB
NewObj
first
ORS
id
class
ORS
Get
sym
CheckExport
first
expo
WHILE
sym
ORS
comma
DO
ORS
Get
sym
IF
sym
ORS
ident
THEN
ORB
NewObj
obj
ORS
id
class
ORS
Get
sym
CheckExport
obj
expo
ELSE
ORS
Mark
ident
END
END
IF
sym
ORS
colon
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
ELSE
first
NIL
END
END
IdentList
PROCEDURE
ArrayType
VAR
type
ORB
Type
VAR
x
ORG
Item
typ
ORB
Type
len
LONGINT
BEGIN
NEW
typ
typ
form
ORB
NoTyp
expression
x
IF
x
mode
ORB
Const
x
type
form
ORB
Int
x
a
THEN
len
x
a
ELSE
len
ORS
Mark
not
a
valid
length
END
IF
sym
ORS
of
THEN
ORS
Get
sym
Type
typ
base
IF
typ
base
form
ORB
Array
typ
base
len
THEN
ORS
Mark
dyn
array
not
allowed
END
ELSIF
sym
ORS
comma
THEN
ORS
Get
sym
ArrayType
typ
base
ELSE
ORS
Mark
missing
OF
typ
base
ORB
intType
END
typ
size
len
typ
base
size
DIV
typ
form
ORB
Array
typ
len
len
type
typ
END
ArrayType
PROCEDURE
RecordType
VAR
type
ORB
Type
VAR
obj
obj0
new
bot
base
ORB
Object
typ
tp
ORB
Type
offset
off
n
LONGINT
BEGIN
NEW
typ
typ
form
ORB
NoTyp
typ
base
NIL
typ
mno
level
typ
nofpar
offset
bot
NIL
IF
sym
ORS
lparen
THEN
ORS
Get
sym
record
extension
IF
level
THEN
ORS
Mark
extension
of
local
types
not
implemented
END
IF
sym
ORS
ident
THEN
qualident
base
IF
base
class
ORB
Typ
THEN
IF
base
type
form
ORB
Record
THEN
typ
base
base
type
ELSE
typ
base
ORB
intType
ORS
Mark
invalid
extension
END
typ
nofpar
typ
base
nofpar
nofpar
here
abused
for
extension
level
bot
typ
base
dsc
offset
typ
base
size
ELSE
ORS
Mark
type
expected
END
ELSE
ORS
Mark
ident
expected
END
Check
ORS
rparen
no
END
WHILE
sym
ORS
ident
DO
fields
n
obj
bot
WHILE
sym
ORS
ident
DO
obj0
obj
WHILE
obj0
NIL
obj0
name
ORS
id
DO
obj0
obj0
next
END
IF
obj0
NIL
THEN
ORS
Mark
mult
def
END
NEW
new
ORS
CopyId
new
name
new
class
ORB
Fld
new
next
obj
obj
new
INC
n
ORS
Get
sym
CheckExport
new
expo
IF
sym
ORS
comma
sym
ORS
colon
THEN
ORS
Mark
comma
expected
ELSIF
sym
ORS
comma
THEN
ORS
Get
sym
END
END
Check
ORS
colon
colon
expected
Type
tp
IF
tp
form
ORB
Array
tp
len
THEN
ORS
Mark
dyn
array
not
allowed
END
IF
tp
size
THEN
offset
offset
DIV
END
offset
offset
n
tp
size
off
offset
obj0
obj
WHILE
obj0
bot
DO
obj0
type
tp
obj0
lev
off
off
tp
size
obj0
val
off
obj0
obj0
next
END
bot
obj
IF
sym
ORS
semicolon
THEN
ORS
Get
sym
ELSIF
sym
ORS
end
THEN
ORS
Mark
or
END
END
END
typ
form
ORB
Record
typ
dsc
bot
typ
size
offset
DIV
type
typ
END
RecordType
PROCEDURE
FPSection
VAR
adr
LONGINT
VAR
nofpar
INTEGER
VAR
obj
first
ORB
Object
tp
ORB
Type
parsize
LONGINT
cl
INTEGER
rdo
BOOLEAN
BEGIN
IF
sym
ORS
var
THEN
ORS
Get
sym
cl
ORB
Par
ELSE
cl
ORB
Var
END
IdentList
cl
first
FormalType
tp
rdo
FALSE
IF
cl
ORB
Var
tp
form
ORB
Array
THEN
cl
ORB
Par
rdo
TRUE
END
IF
tp
form
ORB
Array
tp
len
OR
tp
form
ORB
Record
THEN
parsize
ORG
WordSize
open
array
or
record
needs
second
word
for
length
or
type
tag
ELSE
parsize
ORG
WordSize
END
obj
first
WHILE
obj
NIL
DO
INC
nofpar
obj
class
cl
obj
type
tp
obj
rdo
rdo
obj
lev
level
obj
val
adr
adr
adr
parsize
obj
obj
next
END
IF
adr
THEN
ORS
Mark
too
many
parameters
END
END
FPSection
PROCEDURE
ProcedureType
ptype
ORB
Type
VAR
parblksize
LONGINT
VAR
obj
ORB
Object
size
LONGINT
nofpar
INTEGER
BEGIN
ptype
base
ORB
noType
size
parblksize
nofpar
ptype
dsc
NIL
IF
sym
ORS
lparen
THEN
ORS
Get
sym
IF
sym
ORS
rparen
THEN
ORS
Get
sym
ELSE
FPSection
size
nofpar
WHILE
sym
ORS
semicolon
DO
ORS
Get
sym
FPSection
size
nofpar
END
Check
ORS
rparen
no
END
IF
sym
ORS
colon
THEN
function
ORS
Get
sym
IF
sym
ORS
ident
THEN
qualident
obj
ptype
base
obj
type
IF
obj
class
ORB
Typ
obj
type
form
IN
ORB
Byte
ORB
Pointer
ORB
Proc
THEN
ORS
Mark
illegal
function
type
END
ELSE
ORS
Mark
type
identifier
expected
END
END
END
ptype
nofpar
nofpar
parblksize
size
END
ProcedureType
PROCEDURE
FormalType0
VAR
typ
ORB
Type
dim
INTEGER
VAR
obj
ORB
Object
dmy
LONGINT
BEGIN
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
typ
obj
type
ELSE
ORS
Mark
not
a
type
typ
ORB
intType
END
ELSIF
sym
ORS
array
THEN
ORS
Get
sym
Check
ORS
of
OF
IF
dim
THEN
ORS
Mark
multi
dimensional
open
arrays
not
implemented
END
NEW
typ
typ
form
ORB
Array
typ
len
typ
size
ORG
WordSize
FormalType
typ
base
dim
ELSIF
sym
ORS
procedure
THEN
ORS
Get
sym
ORB
OpenScope
NEW
typ
typ
form
ORB
Proc
typ
size
ORG
WordSize
dmy
ProcedureType
typ
dmy
typ
dsc
ORB
topScope
next
ORB
CloseScope
ELSE
ORS
Mark
identifier
expected
typ
ORB
noType
END
END
FormalType0
PROCEDURE
CheckRecLevel
lev
INTEGER
BEGIN
IF
lev
THEN
ORS
Mark
ptr
base
must
be
global
END
END
CheckRecLevel
PROCEDURE
Type0
VAR
type
ORB
Type
VAR
dmy
LONGINT
obj
ORB
Object
ptbase
PtrBase
BEGIN
type
ORB
intType
sync
IF
sym
ORS
ident
sym
ORS
array
THEN
ORS
Mark
not
a
type
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
ident
OR
sym
ORS
array
END
IF
sym
ORS
ident
THEN
qualident
obj
IF
obj
class
ORB
Typ
THEN
IF
obj
type
NIL
obj
type
form
ORB
NoTyp
THEN
type
obj
type
END
ELSE
ORS
Mark
not
a
type
or
undefined
END
ELSIF
sym
ORS
array
THEN
ORS
Get
sym
ArrayType
type
ELSIF
sym
ORS
record
THEN
ORS
Get
sym
RecordType
type
Check
ORS
end
no
END
ELSIF
sym
ORS
pointer
THEN
ORS
Get
sym
Check
ORS
to
no
TO
NEW
type
type
form
ORB
Pointer
type
size
ORG
WordSize
type
base
ORB
intType
IF
sym
ORS
ident
THEN
obj
ORB
thisObj
IF
obj
NIL
THEN
IF
obj
class
ORB
Typ
obj
type
form
IN
ORB
Record
ORB
NoTyp
THEN
CheckRecLevel
obj
lev
type
base
obj
type
ELSIF
obj
class
ORB
Mod
THEN
ORS
Mark
external
base
type
not
implemented
ELSE
ORS
Mark
no
valid
base
type
END
ELSE
CheckRecLevel
level
enter
into
list
of
forward
references
to
be
fixed
in
Declarations
NEW
ptbase
ORS
CopyId
ptbase
name
ptbase
type
type
ptbase
next
pbsList
pbsList
ptbase
END
ORS
Get
sym
ELSE
Type
type
base
IF
type
base
form
ORB
Record
OR
type
base
typobj
NIL
THEN
ORS
Mark
must
point
to
named
record
END
CheckRecLevel
level
END
ELSIF
sym
ORS
procedure
THEN
ORS
Get
sym
ORB
OpenScope
NEW
type
type
form
ORB
Proc
type
size
ORG
WordSize
dmy
ProcedureType
type
dmy
type
dsc
ORB
topScope
next
ORB
CloseScope
ELSE
ORS
Mark
illegal
type
END
END
Type0
PROCEDURE
Declarations
VAR
varsize
LONGINT
VAR
obj
first
ORB
Object
x
ORG
Item
tp
ORB
Type
ptbase
PtrBase
expo
BOOLEAN
id
ORS
Ident
BEGIN
sync
pbsList
NIL
IF
sym
ORS
const
sym
ORS
end
sym
ORS
return
THEN
ORS
Mark
declaration
REPEAT
ORS
Get
sym
UNTIL
sym
ORS
const
OR
sym
ORS
end
OR
sym
ORS
return
END
IF
sym
ORS
const
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
id
ORS
Get
sym
CheckExport
expo
IF
sym
ORS
eql
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
expression
x
IF
x
type
form
ORB
String
x
b
THEN
ORG
StrToChar
x
END
ORB
NewObj
obj
id
ORB
Const
obj
expo
expo
IF
x
mode
ORB
Const
THEN
obj
val
x
a
obj
lev
x
b
obj
type
x
type
ELSE
ORS
Mark
expression
not
constant
obj
type
ORB
intType
END
Check
ORS
semicolon
missing
END
END
IF
sym
ORS
type
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
id
ORS
Get
sym
CheckExport
expo
IF
sym
ORS
eql
THEN
ORS
Get
sym
ELSE
ORS
Mark
END
Type
tp
ORB
NewObj
obj
id
ORB
Typ
obj
type
tp
obj
expo
expo
obj
lev
level
IF
tp
typobj
NIL
THEN
tp
typobj
obj
END
IF
expo
obj
type
form
ORB
Record
THEN
obj
exno
exno
INC
exno
ELSE
obj
exno
END
IF
tp
form
ORB
Record
THEN
ptbase
pbsList
check
whether
this
is
base
of
a
pointer
type
search
and
fixup
WHILE
ptbase
NIL
DO
IF
obj
name
ptbase
name
THEN
ptbase
type
base
obj
type
END
ptbase
ptbase
next
END
IF
level
THEN
ORG
BuildTD
tp
dc
END
type
descriptor
len
used
as
its
address
END
Check
ORS
semicolon
missing
END
END
IF
sym
ORS
var
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
IdentList
ORB
Var
first
Type
tp
obj
first
WHILE
obj
NIL
DO
obj
type
tp
obj
lev
level
IF
tp
size
THEN
varsize
varsize
DIV
align
END
obj
val
varsize
varsize
varsize
obj
type
size
IF
obj
expo
THEN
obj
exno
exno
INC
exno
END
obj
obj
next
END
Check
ORS
semicolon
missing
END
END
varsize
varsize
DIV
ptbase
pbsList
WHILE
ptbase
NIL
DO
IF
ptbase
type
base
form
ORB
Int
THEN
ORS
Mark
undefined
pointer
base
of
END
ptbase
ptbase
next
END
IF
sym
ORS
const
sym
ORS
var
THEN
ORS
Mark
declaration
in
bad
order
END
END
Declarations
PROCEDURE
ProcedureDecl
VAR
proc
ORB
Object
type
ORB
Type
procid
ORS
Ident
x
ORG
Item
locblksize
parblksize
L
LONGINT
int
BOOLEAN
BEGIN
ProcedureDecl
int
FALSE
ORS
Get
sym
IF
sym
ORS
times
THEN
ORS
Get
sym
int
TRUE
END
IF
sym
ORS
ident
THEN
ORS
CopyId
procid
ORS
Get
sym
ORB
NewObj
proc
ORS
id
ORB
Const
IF
int
THEN
parblksize
ELSE
parblksize
END
NEW
type
type
form
ORB
Proc
type
size
ORG
WordSize
proc
type
type
proc
val
proc
lev
level
CheckExport
proc
expo
IF
proc
expo
THEN
proc
exno
exno
INC
exno
END
ORB
OpenScope
INC
level
type
base
ORB
noType
ProcedureType
type
parblksize
formal
parameter
list
Check
ORS
semicolon
no
locblksize
parblksize
Declarations
locblksize
proc
val
ORG
Here
proc
type
dsc
ORB
topScope
next
IF
sym
ORS
procedure
THEN
L
ORG
FJump
L
REPEAT
ProcedureDecl
Check
ORS
semicolon
no
UNTIL
sym
ORS
procedure
ORG
FixOne
L
proc
val
ORG
Here
proc
type
dsc
ORB
topScope
next
END
ORG
Enter
parblksize
locblksize
int
IF
sym
ORS
begin
THEN
ORS
Get
sym
StatSequence
END
IF
sym
ORS
return
THEN
ORS
Get
sym
expression
x
IF
type
base
ORB
noType
THEN
ORS
Mark
this
is
not
a
function
ELSIF
CompTypes
type
base
x
type
FALSE
THEN
ORS
Mark
wrong
result
type
END
ELSIF
type
base
form
ORB
NoTyp
THEN
ORS
Mark
function
without
result
type
base
ORB
noType
END
ORG
Return
type
base
form
x
locblksize
int
ORB
CloseScope
DEC
level
Check
ORS
end
no
END
IF
sym
ORS
ident
THEN
IF
ORS
id
procid
THEN
ORS
Mark
no
match
END
ORS
Get
sym
ELSE
ORS
Mark
no
proc
id
END
END
END
ProcedureDecl
PROCEDURE
Module
VAR
key
LONGINT
impid
impid1
ORS
Ident
BEGIN
Texts
WriteString
W
compiling
ORS
Get
sym
IF
sym
ORS
module
THEN
ORS
Get
sym
IF
sym
ORS
times
THEN
version
Texts
Write
W
ORS
Get
sym
ELSE
version
END
ORB
Init
ORB
OpenScope
IF
sym
ORS
ident
THEN
ORS
CopyId
modid
ORS
Get
sym
Texts
WriteString
W
modid
Texts
Append
Oberon
Log
W
buf
ELSE
ORS
Mark
identifier
expected
END
Check
ORS
semicolon
no
level
dc
exno
key
IF
sym
ORS
import
THEN
ORS
Get
sym
WHILE
sym
ORS
ident
DO
ORS
CopyId
impid
ORS
Get
sym
IF
sym
ORS
becomes
THEN
ORS
Get
sym
IF
sym
ORS
ident
THEN
ORS
CopyId
impid1
ORS
Get
sym
ELSE
ORS
Mark
id
expected
END
ELSE
impid1
impid
END
ORB
Import
impid
impid1
IF
sym
ORS
comma
THEN
ORS
Get
sym
ELSIF
sym
ORS
ident
THEN
ORS
Mark
comma
missing
END
END
Check
ORS
semicolon
no
END
ORG
Open
version
Declarations
dc
ORG
SetDataSize
dc
DIV
WHILE
sym
ORS
procedure
DO
ProcedureDecl
Check
ORS
semicolon
no
END
ORG
Header
IF
sym
ORS
begin
THEN
ORS
Get
sym
StatSequence
END
Check
ORS
end
no
END
IF
sym
ORS
ident
THEN
IF
ORS
id
modid
THEN
ORS
Mark
no
match
END
ORS
Get
sym
ELSE
ORS
Mark
identifier
missing
END
IF
sym
ORS
period
THEN
ORS
Mark
period
missing
END
IF
ORS
errcnt
version
THEN
ORB
Export
modid
newSF
key
IF
newSF
THEN
Texts
WriteString
W
new
symbol
file
END
END
IF
ORS
errcnt
THEN
ORG
Close
modid
key
exno
Texts
WriteInt
W
ORG
pc
Texts
WriteInt
W
dc
Texts
WriteHex
W
key
ELSE
Texts
WriteLn
W
Texts
WriteString
W
compilation
FAILED
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
ORB
CloseScope
pbsList
NIL
ELSE
ORS
Mark
must
start
with
MODULE
END
END
Module
PROCEDURE
Option
VAR
S
Texts
Scanner
BEGIN
newSF
FALSE
IF
S
nextCh
THEN
Texts
Scan
S
Texts
Scan
S
IF
S
class
Texts
Name
S
s
s
THEN
newSF
TRUE
END
END
END
Option
PROCEDURE
Compile
VAR
beg
end
time
LONGINT
T
Texts
Text
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
THEN
IF
S
c
THEN
Option
S
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
ORS
Init
T
beg
Module
END
ELSIF
S
c
THEN
Option
S
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
S
s
NEW
T
Texts
Open
T
S
s
IF
T
len
THEN
ORS
Init
T
Module
END
END
END
END
ELSE
WHILE
S
class
Texts
Name
DO
NEW
T
Texts
Open
T
S
s
IF
T
len
THEN
Option
S
ORS
Init
T
Module
ELSE
Texts
WriteString
W
S
s
Texts
WriteString
W
not
found
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
IF
T
len
ORS
errcnt
THEN
Texts
Scan
S
ELSE
S
class
END
END
END
Oberon
Collect
END
Compile
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
OR
Compiler
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
NEW
dummy
dummy
class
ORB
Var
dummy
type
ORB
intType
expression
expression0
Type
Type0
FormalType
FormalType0
END
ORP
MODULE
ORS
NW
Scanner
in
Oberon
IMPORT
SYSTEM
Texts
Oberon
Oberon
Scanner
does
lexical
analysis
Input
is
Oberon
Text
output
is
sequence
of
symbols
i
e
identifiers
numbers
strings
and
special
symbols
Recognises
all
Oberon
keywords
and
skips
comments
The
keywords
are
recorded
in
a
table
Get
sym
delivers
next
symbol
from
input
text
with
Reader
R
Mark
msg
records
error
and
delivers
error
message
with
Writer
W
If
Get
delivers
ident
then
the
identifier
a
string
is
in
variable
id
if
int
or
char
in
ival
if
real
in
rval
and
if
string
in
str
and
slen
CONST
IdLen
NKW
nof
keywords
maxExp
stringBufSize
lexical
symbols
null
times
rdiv
div
mod
and
plus
minus
or
eql
neq
lss
leq
gtr
geq
in
is
arrow
period
char
int
real
false
true
nil
string
not
lparen
lbrak
lbrace
ident
if
while
repeat
case
for
comma
colon
becomes
upto
rparen
rbrak
rbrace
then
of
do
to
by
semicolon
end
bar
else
elsif
until
return
array
record
pointer
const
type
var
procedure
begin
import
module
eot
TYPE
Ident
ARRAY
IdLen
OF
CHAR
VAR
ival
slen
LONGINT
results
of
Get
rval
REAL
id
Ident
for
identifiers
str
ARRAY
stringBufSize
OF
CHAR
errcnt
INTEGER
ch
CHAR
last
character
read
errpos
LONGINT
R
Texts
Reader
W
Texts
Writer
k
INTEGER
KWX
ARRAY
OF
INTEGER
keyTab
ARRAY
NKW
OF
RECORD
sym
INTEGER
id
ARRAY
OF
CHAR
END
PROCEDURE
CopyId
VAR
ident
Ident
BEGIN
ident
id
END
CopyId
PROCEDURE
Pos
LONGINT
BEGIN
RETURN
Texts
Pos
R
END
Pos
PROCEDURE
Mark
msg
ARRAY
OF
CHAR
VAR
p
LONGINT
BEGIN
p
Pos
IF
p
errpos
errcnt
THEN
Texts
WriteLn
W
Texts
WriteString
W
pos
Texts
WriteInt
W
p
Texts
Write
W
Texts
WriteString
W
msg
Texts
Append
Oberon
Log
W
buf
END
INC
errcnt
errpos
p
END
Mark
PROCEDURE
Identifier
VAR
sym
INTEGER
VAR
i
k
INTEGER
BEGIN
i
REPEAT
IF
i
IdLen
THEN
id
i
ch
INC
i
END
Texts
Read
R
ch
UNTIL
ch
OR
ch
ch
A
OR
ch
Z
ch
a
OR
ch
z
id
i
0X
IF
i
THEN
k
KWX
i
search
for
keyword
WHILE
id
keyTab
k
id
k
KWX
i
DO
INC
k
END
IF
k
KWX
i
THEN
sym
keyTab
k
sym
ELSE
sym
ident
END
ELSE
sym
ident
END
END
Identifier
PROCEDURE
String
VAR
i
INTEGER
BEGIN
i
Texts
Read
R
ch
WHILE
R
eot
ch
22X
DO
IF
ch
THEN
IF
i
stringBufSize
THEN
str
i
ch
INC
i
ELSE
Mark
string
too
long
END
END
Texts
Read
R
ch
END
str
i
0X
INC
i
Texts
Read
R
ch
slen
i
END
String
PROCEDURE
HexString
VAR
i
m
n
INTEGER
BEGIN
i
Texts
Read
R
ch
WHILE
R
eot
ch
DO
WHILE
R
eot
ch
DO
Texts
Read
R
ch
END
skip
IF
ch
ch
THEN
m
ORD
ch
30H
ELSIF
A
ch
ch
F
THEN
m
ORD
ch
37H
ELSE
m
Mark
hexdig
expected
END
Texts
Read
R
ch
IF
ch
ch
THEN
n
ORD
ch
30H
ELSIF
A
ch
ch
F
THEN
n
ORD
ch
37H
ELSE
n
Mark
hexdig
expected
END
IF
i
stringBufSize
THEN
str
i
CHR
m
10H
n
INC
i
ELSE
Mark
string
too
long
END
Texts
Read
R
ch
END
Texts
Read
R
ch
slen
i
no
0X
appended
END
HexString
PROCEDURE
Ten
e
LONGINT
REAL
VAR
x
t
REAL
BEGIN
x
t
WHILE
e
DO
IF
ODD
e
THEN
x
t
x
END
t
t
t
e
e
DIV
END
RETURN
x
END
Ten
PROCEDURE
Number
VAR
sym
INTEGER
CONST
max
VAR
i
k
e
n
s
h
LONGINT
x
REAL
d
ARRAY
OF
INTEGER
negE
BOOLEAN
BEGIN
ival
i
n
k
REPEAT
IF
n
THEN
d
n
ORD
ch
30H
INC
n
ELSE
Mark
too
many
digits
n
END
Texts
Read
R
ch
UNTIL
ch
OR
ch
ch
A
OR
ch
F
IF
ch
H
OR
ch
R
OR
ch
X
THEN
hex
REPEAT
h
d
i
IF
h
THEN
h
h
END
k
k
10H
h
INC
i
no
overflow
check
UNTIL
i
n
IF
ch
X
THEN
sym
char
IF
k
100H
THEN
ival
k
ELSE
Mark
illegal
value
ival
END
ELSIF
ch
R
THEN
sym
real
rval
SYSTEM
VAL
REAL
k
ELSE
sym
int
ival
k
END
Texts
Read
R
ch
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
double
dot
ch
7FX
decimal
integer
REPEAT
IF
d
i
THEN
IF
k
max
d
i
DIV
THEN
k
k
d
i
ELSE
Mark
too
large
k
END
ELSE
Mark
bad
integer
END
INC
i
UNTIL
i
n
sym
int
ival
k
ELSE
real
number
x
e
REPEAT
integer
part
x
x
FLT
d
i
INC
i
UNTIL
i
n
WHILE
ch
ch
DO
fraction
x
x
FLT
ORD
ch
30H
DEC
e
Texts
Read
R
ch
END
IF
ch
E
OR
ch
D
THEN
scale
factor
Texts
Read
R
ch
s
IF
ch
THEN
negE
TRUE
Texts
Read
R
ch
ELSE
negE
FALSE
IF
ch
THEN
Texts
Read
R
ch
END
END
IF
ch
ch
THEN
REPEAT
s
s
ORD
ch
30H
Texts
Read
R
ch
UNTIL
ch
OR
ch
IF
negE
THEN
e
e
s
ELSE
e
e
s
END
ELSE
Mark
digit
END
END
IF
e
THEN
IF
e
maxExp
THEN
x
x
Ten
e
ELSE
x
END
ELSIF
e
THEN
IF
e
maxExp
THEN
x
Ten
e
x
ELSE
x
Mark
too
large
END
END
sym
real
rval
x
END
ELSE
decimal
integer
REPEAT
IF
d
i
THEN
IF
k
max
d
i
DIV
THEN
k
k
d
i
ELSE
Mark
too
large
k
END
ELSE
Mark
bad
integer
END
INC
i
UNTIL
i
n
sym
int
ival
k
END
END
Number
PROCEDURE
comment
BEGIN
Texts
Read
R
ch
REPEAT
WHILE
R
eot
ch
DO
IF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
comment
END
ELSE
Texts
Read
R
ch
END
END
WHILE
ch
DO
Texts
Read
R
ch
END
UNTIL
ch
OR
R
eot
IF
R
eot
THEN
Texts
Read
R
ch
ELSE
Mark
unterminated
comment
END
END
comment
PROCEDURE
Get
VAR
sym
INTEGER
BEGIN
REPEAT
WHILE
R
eot
ch
DO
Texts
Read
R
ch
END
IF
R
eot
THEN
sym
eot
ELSIF
ch
A
THEN
IF
ch
THEN
IF
ch
22X
THEN
String
sym
string
ELSIF
ch
THEN
Texts
Read
R
ch
sym
neq
ELSIF
ch
THEN
HexString
sym
string
ELSIF
ch
THEN
Texts
Read
R
ch
sym
and
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
sym
null
comment
ELSE
sym
lparen
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
rparen
ELSIF
ch
THEN
Texts
Read
R
ch
sym
times
ELSIF
ch
THEN
Texts
Read
R
ch
sym
plus
ELSIF
ch
THEN
Texts
Read
R
ch
sym
comma
ELSIF
ch
THEN
Texts
Read
R
ch
sym
minus
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
upto
ELSE
sym
period
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
rdiv
ELSE
Texts
Read
R
ch
sym
null
END
ELSIF
ch
THEN
Number
sym
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
becomes
ELSE
sym
colon
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
semicolon
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
leq
ELSE
sym
lss
END
ELSIF
ch
THEN
Texts
Read
R
ch
sym
eql
ELSIF
ch
THEN
Texts
Read
R
ch
IF
ch
THEN
Texts
Read
R
ch
sym
geq
ELSE
sym
gtr
END
ELSE
Texts
Read
R
ch
sym
null
END
ELSIF
ch
THEN
Identifier
sym
ELSIF
ch
a
THEN
IF
ch
THEN
sym
lbrak
ELSIF
ch
THEN
sym
rbrak
ELSIF
ch
THEN
sym
arrow
ELSE
sym
null
END
Texts
Read
R
ch
ELSIF
ch
THEN
Identifier
sym
ELSE
IF
ch
THEN
sym
lbrace
ELSIF
ch
THEN
sym
rbrace
ELSIF
ch
THEN
sym
bar
ELSIF
ch
THEN
sym
not
ELSIF
ch
7FX
THEN
sym
upto
ELSE
sym
null
END
Texts
Read
R
ch
END
UNTIL
sym
null
END
Get
PROCEDURE
Init
T
Texts
Text
pos
LONGINT
BEGIN
errpos
pos
errcnt
Texts
OpenReader
R
T
pos
Texts
Read
R
ch
END
Init
PROCEDURE
EnterKW
sym
INTEGER
name
ARRAY
OF
CHAR
BEGIN
keyTab
k
id
name
keyTab
k
sym
sym
INC
k
END
EnterKW
BEGIN
Texts
OpenWriter
W
k
KWX
KWX
EnterKW
if
IF
EnterKW
do
DO
EnterKW
of
OF
EnterKW
or
OR
EnterKW
to
TO
EnterKW
in
IN
EnterKW
is
IS
EnterKW
by
BY
KWX
k
EnterKW
end
END
EnterKW
nil
NIL
EnterKW
var
VAR
EnterKW
div
DIV
EnterKW
mod
MOD
EnterKW
for
FOR
KWX
k
EnterKW
else
ELSE
EnterKW
then
THEN
EnterKW
true
TRUE
EnterKW
type
TYPE
EnterKW
case
CASE
KWX
k
EnterKW
elsif
ELSIF
EnterKW
false
FALSE
EnterKW
array
ARRAY
EnterKW
begin
BEGIN
EnterKW
const
CONST
EnterKW
until
UNTIL
EnterKW
while
WHILE
KWX
k
EnterKW
record
RECORD
EnterKW
repeat
REPEAT
EnterKW
return
RETURN
EnterKW
import
IMPORT
EnterKW
module
MODULE
KWX
k
EnterKW
pointer
POINTER
KWX
k
KWX
k
EnterKW
procedure
PROCEDURE
KWX
k
END
ORS
MODULE
ORTool
NW
IMPORT
SYSTEM
Files
Texts
Oberon
ORB
VAR
W
Texts
Writer
Form
INTEGER
result
of
ReadType
mnemo0
mnemo1
ARRAY
OF
CHAR
mnemonics
PROCEDURE
Read
VAR
R
Files
Rider
VAR
n
INTEGER
VAR
b
BYTE
BEGIN
Files
ReadByte
R
b
IF
b
80H
THEN
n
b
ELSE
n
b
100H
END
END
Read
PROCEDURE
ReadType
VAR
R
Files
Rider
VAR
key
len
lev
size
off
INTEGER
ref
mno
class
form
readonly
INTEGER
name
modname
ARRAY
OF
CHAR
BEGIN
Read
R
ref
Texts
Write
W
Texts
Write
W
IF
ref
THEN
Texts
Write
W
Texts
WriteInt
W
ref
ELSE
Texts
WriteInt
W
ref
Read
R
form
Texts
WriteString
W
form
Texts
WriteInt
W
form
IF
form
ORB
Pointer
THEN
ReadType
R
ELSIF
form
ORB
Array
THEN
ReadType
R
Files
ReadNum
R
len
Files
ReadNum
R
size
Texts
WriteString
W
len
Texts
WriteInt
W
len
Texts
WriteString
W
size
Texts
WriteInt
W
size
ELSIF
form
ORB
Record
THEN
ReadType
R
base
type
Files
ReadNum
R
off
Texts
WriteString
W
exno
Texts
WriteInt
W
off
Files
ReadNum
R
off
Texts
WriteString
W
extlev
Texts
WriteInt
W
off
Files
ReadNum
R
size
Texts
WriteString
W
size
Texts
WriteInt
W
size
Texts
Write
W
Texts
Write
W
Read
R
class
WHILE
class
DO
fields
Files
ReadString
R
name
IF
name
0X
THEN
Texts
Write
W
Texts
WriteString
W
name
ReadType
R
ELSE
Texts
WriteString
W
END
Files
ReadNum
R
off
Texts
WriteInt
W
off
Read
R
class
END
Texts
Write
W
ELSIF
form
ORB
Proc
THEN
ReadType
R
Texts
Write
W
Read
R
class
WHILE
class
DO
Texts
WriteString
W
class
Texts
WriteInt
W
class
Read
R
readonly
IF
readonly
THEN
Texts
Write
W
END
ReadType
R
Read
R
class
END
Texts
Write
W
END
Files
ReadString
R
modname
IF
modname
0X
THEN
Files
ReadInt
R
key
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
modname
Texts
Write
W
Texts
WriteString
W
name
Texts
WriteHex
W
key
END
END
Form
form
Texts
Write
W
END
ReadType
PROCEDURE
DecSym
decode
symbol
file
VAR
class
typno
k
INTEGER
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
OR
decode
Texts
WriteString
W
S
s
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadInt
R
k
Files
ReadInt
R
k
Files
ReadString
R
name
Texts
WriteString
W
name
Texts
WriteHex
W
k
Read
R
class
Texts
WriteInt
W
class
sym
file
version
IF
class
ORB
versionkey
THEN
Texts
WriteLn
W
Read
R
class
WHILE
class
DO
Texts
WriteInt
W
class
Files
ReadString
R
name
Texts
Write
W
Texts
WriteString
W
name
ReadType
R
IF
class
ORB
Typ
THEN
Texts
Write
W
Read
R
class
WHILE
class
DO
pointer
base
fixup
Texts
WriteString
W
Texts
WriteInt
W
class
Read
R
class
END
Texts
Write
W
ELSIF
class
ORB
Const
OR
class
ORB
Var
THEN
Files
ReadNum
R
k
Texts
WriteInt
W
k
Reals
Strings
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Read
R
class
END
ELSE
Texts
WriteString
W
bad
symfile
version
END
ELSE
Texts
WriteString
W
not
found
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
DecSym
PROCEDURE
WriteReg
r
LONGINT
BEGIN
Texts
Write
W
IF
r
THEN
Texts
WriteString
W
R
Texts
WriteInt
W
r
MOD
10H
ELSIF
r
THEN
Texts
WriteString
W
MT
ELSIF
r
THEN
Texts
WriteString
W
SB
ELSIF
r
THEN
Texts
WriteString
W
SP
ELSE
Texts
WriteString
W
LNK
END
END
WriteReg
PROCEDURE
opcode
w
LONGINT
VAR
k
op
u
a
b
c
LONGINT
BEGIN
k
w
DIV
40000000H
MOD
a
w
DIV
1000000H
MOD
10H
b
w
DIV
100000H
MOD
10H
op
w
DIV
10000H
MOD
10H
u
w
DIV
20000000H
MOD
IF
k
THEN
Texts
WriteString
W
mnemo0
op
IF
u
THEN
Texts
Write
W
END
WriteReg
a
WriteReg
b
WriteReg
w
MOD
10H
ELSIF
k
THEN
Texts
WriteString
W
mnemo0
op
IF
u
THEN
Texts
Write
W
END
WriteReg
a
WriteReg
b
w
w
MOD
10000H
IF
w
8000H
THEN
w
w
10000H
END
Texts
WriteInt
W
w
ELSIF
k
THEN
LDR
STR
IF
u
THEN
Texts
WriteString
W
STR
ELSE
Texts
WriteString
W
LDR
END
WriteReg
a
WriteReg
b
w
w
MOD
100000H
IF
w
80000H
THEN
w
w
100000H
END
Texts
WriteInt
W
w
ELSIF
k
THEN
Branch
instr
Texts
Write
W
B
IF
ODD
w
DIV
10000000H
THEN
Texts
Write
W
L
END
Texts
WriteString
W
mnemo1
a
IF
u
THEN
WriteReg
w
MOD
10H
ELSE
w
w
MOD
100000H
IF
w
80000H
THEN
w
w
100000H
END
Texts
WriteInt
W
w
END
END
END
opcode
PROCEDURE
Sync
VAR
R
Files
Rider
VAR
ch
CHAR
BEGIN
Files
Read
R
ch
Texts
WriteString
W
Sync
Texts
Write
W
ch
Texts
WriteLn
W
END
Sync
PROCEDURE
Write
VAR
R
Files
Rider
x
INTEGER
BEGIN
Files
WriteByte
R
x
x
END
Write
PROCEDURE
DecObj
decode
object
file
VAR
class
i
n
key
size
fix
adr
data
len
INTEGER
ch
CHAR
name
ARRAY
OF
CHAR
F
Files
File
R
Files
Rider
S
Texts
Scanner
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
decode
Texts
WriteString
W
S
s
F
Files
Old
S
s
IF
F
NIL
THEN
Files
Set
R
F
Files
ReadString
R
name
Texts
WriteLn
W
Texts
WriteString
W
name
Files
ReadInt
R
key
Texts
WriteHex
W
key
Read
R
class
Texts
WriteInt
W
class
version
Files
ReadInt
R
size
Texts
WriteInt
W
size
Texts
WriteLn
W
Texts
WriteString
W
imports
Texts
WriteLn
W
Files
ReadString
R
name
WHILE
name
0X
DO
Texts
Write
W
9X
Texts
WriteString
W
name
Files
ReadInt
R
key
Texts
WriteHex
W
key
Texts
WriteLn
W
Files
ReadString
R
name
END
Sync
R
Texts
WriteString
W
type
descriptors
Texts
WriteLn
W
Files
ReadInt
R
n
n
n
DIV
i
WHILE
i
n
DO
Files
ReadInt
R
data
Texts
WriteHex
W
data
INC
i
END
Texts
WriteLn
W
Texts
WriteString
W
data
Files
ReadInt
R
data
Texts
WriteInt
W
data
Texts
WriteLn
W
Texts
WriteString
W
strings
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
Read
R
ch
Texts
Write
W
ch
INC
i
END
Texts
WriteLn
W
Texts
WriteString
W
code
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
ReadInt
R
data
Texts
WriteInt
W
i
Texts
Write
W
9X
Texts
WriteHex
W
data
Texts
Write
W
9X
opcode
data
Texts
WriteLn
W
INC
i
END
Sync
R
Texts
WriteString
W
commands
Texts
WriteLn
W
Files
ReadString
R
name
WHILE
name
0X
DO
Texts
Write
W
9X
Texts
WriteString
W
name
Files
ReadInt
R
adr
Texts
WriteInt
W
adr
Texts
WriteLn
W
Files
ReadString
R
name
END
Sync
R
Texts
WriteString
W
entries
Texts
WriteLn
W
Files
ReadInt
R
n
i
WHILE
i
n
DO
Files
ReadInt
R
adr
Texts
WriteInt
W
adr
INC
i
END
Texts
WriteLn
W
Sync
R
Texts
WriteString
W
pointer
refs
Texts
WriteLn
W
Files
ReadInt
R
adr
WHILE
adr
DO
Texts
WriteInt
W
adr
Files
ReadInt
R
adr
END
Texts
WriteLn
W
Sync
R
Files
ReadInt
R
data
Texts
WriteString
W
fixP
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
fixD
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
fixT
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
ReadInt
R
data
Texts
WriteString
W
entry
Texts
WriteInt
W
data
Texts
WriteLn
W
Files
Read
R
ch
IF
ch
O
THEN
Texts
WriteString
W
format
eror
Texts
WriteLn
W
END
Sync
R
ELSE
Texts
WriteString
W
not
found
Texts
WriteLn
W
END
Texts
Append
Oberon
Log
W
buf
END
END
DecObj
BEGIN
Texts
OpenWriter
W
Texts
WriteString
W
ORTool
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
mnemo0
MOV
mnemo0
LSL
mnemo0
ASR
mnemo0
ROR
mnemo0
AND
mnemo0
ANN
mnemo0
IOR
mnemo0
XOR
mnemo0
ADD
mnemo0
SUB
mnemo0
MUL
mnemo0
DIV
mnemo0
FAD
mnemo0
FSB
mnemo0
FML
mnemo0
FDV
mnemo1
MI
mnemo1
PL
mnemo1
EQ
mnemo1
NE
mnemo1
LS
mnemo1
HI
mnemo1
LT
mnemo1
GE
mnemo1
LE
mnemo1
GT
mnemo1
NO
END
ORTool
MODULE
Rectangles
NW
IMPORT
SYSTEM
Display
Files
Input
Texts
Oberon
Graphics
GraphicFrames
TYPE
Rectangle
POINTER
TO
RectDesc
RectDesc
RECORD
Graphics
ObjectDesc
lw
vers
INTEGER
END
VAR
method
Graphics
Method
tack
grey
INTEGER
PROCEDURE
New
VAR
r
Rectangle
BEGIN
NEW
r
r
do
method
Graphics
New
r
END
New
PROCEDURE
Copy
src
dst
Graphics
Object
BEGIN
dst
x
src
x
dst
y
src
y
dst
w
src
w
dst
h
src
h
dst
col
src
col
dst
Rectangle
lw
src
Rectangle
lw
dst
Rectangle
vers
src
Rectangle
vers
END
Copy
PROCEDURE
mark
f
GraphicFrames
Frame
col
x
y
INTEGER
BEGIN
GraphicFrames
ReplConst
f
col
x
y
END
mark
PROCEDURE
Draw
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x
y
w
h
lw
col
INTEGER
f
GraphicFrames
Frame
PROCEDURE
draw
f
GraphicFrames
Frame
col
x
y
w
h
lw
INTEGER
BEGIN
GraphicFrames
ReplConst
f
col
x
y
w
lw
Display
replace
GraphicFrames
ReplConst
f
col
x
w
lw
y
lw
h
Display
replace
GraphicFrames
ReplConst
f
col
x
y
h
lw
w
lw
Display
replace
GraphicFrames
ReplConst
f
col
x
y
lw
h
Display
replace
END
draw
BEGIN
CASE
M
OF
GraphicFrames
DrawMsg
x
obj
x
M
x
y
obj
y
M
y
w
obj
w
h
obj
h
f
M
f
lw
obj
Rectangle
lw
IF
x
f
X1
x
w
f
X
y
f
Y1
y
h
f
Y
THEN
IF
M
col
Display
black
THEN
col
obj
col
ELSE
col
M
col
END
IF
M
mode
THEN
draw
f
col
x
y
w
h
lw
IF
obj
selected
THEN
mark
f
Display
white
x
y
END
ELSIF
M
mode
THEN
mark
f
Display
white
x
y
normal
selected
ELSIF
M
mode
THEN
mark
f
Display
black
x
y
selected
normal
ELSIF
M
mode
THEN
draw
f
Display
black
x
y
w
h
lw
mark
f
Display
black
x
y
erase
END
END
END
END
Draw
PROCEDURE
Selectable
obj
Graphics
Object
x
y
INTEGER
BOOLEAN
BEGIN
RETURN
obj
x
x
x
obj
x
obj
y
y
y
obj
y
END
Selectable
PROCEDURE
Change
obj
Graphics
Object
VAR
M
Graphics
Msg
VAR
x0
y0
x1
y1
dx
dy
INTEGER
k
SET
BEGIN
CASE
M
OF
Graphics
WidMsg
obj
Rectangle
lw
M
w
Graphics
ColorMsg
obj
col
M
col
END
END
Change
PROCEDURE
Read
obj
Graphics
Object
VAR
R
Files
Rider
VAR
C
Graphics
Context
VAR
b
BYTE
len
INTEGER
BEGIN
Files
ReadByte
R
b
len
Files
ReadByte
R
b
obj
Rectangle
lw
b
Files
ReadByte
R
b
obj
Rectangle
vers
b
END
Read
PROCEDURE
Write
obj
Graphics
Object
cno
INTEGER
VAR
W
Files
Rider
VAR
C
Graphics
Context
BEGIN
Graphics
WriteObj
W
cno
obj
Files
WriteByte
W
Files
WriteByte
W
obj
Rectangle
lw
Files
WriteByte
W
obj
Rectangle
vers
END
Write
PROCEDURE
Print
obj
Graphics
Object
x
y
INTEGER
VAR
w
h
lw
s
INTEGER
BEGIN
INC
x
obj
x
INC
y
obj
y
w
obj
w
h
obj
h
lw
obj
Rectangle
lw
s
obj
Rectangle
vers
Printer
ReplConst
x
y
w
lw
Printer
ReplConst
x
w
lw
y
lw
h
Printer
ReplConst
x
y
h
lw
w
lw
Printer
ReplConst
x
y
lw
h
IF
s
THEN
Printer
ReplPattern
x
y
w
h
s
END
END
Print
PROCEDURE
Make
command
VAR
x0
x1
y0
y1
INTEGER
R
Rectangle
G
GraphicFrames
Frame
BEGIN
G
GraphicFrames
Focus
IF
G
NIL
G
mark
next
NIL
THEN
GraphicFrames
Deselect
G
x0
G
mark
x
y0
G
mark
y
x1
G
mark
next
x
y1
G
mark
next
y
NEW
R
R
col
Oberon
CurCol
R
w
ABS
x1
x0
R
h
ABS
y1
y0
IF
x1
x0
THEN
x0
x1
END
IF
y1
y0
THEN
y0
y1
END
R
x
x0
G
x
R
y
y0
G
y
R
lw
Graphics
width
R
vers
R
do
method
Graphics
Add
G
graph
R
GraphicFrames
Defocus
G
GraphicFrames
DrawObj
G
R
END
END
Make
BEGIN
NEW
method
method
module
Rectangles
method
allocator
New
method
new
New
method
copy
Copy
method
draw
Draw
method
selectable
Selectable
method
change
Change
method
read
Read
method
write
Write
method
print
Print
tack
SYSTEM
ADR
grey
SYSTEM
ADR
END
Rectangles
MODULE
SCC
NW
Ceres
nRF24L01
version
PR
IMPORT
SYSTEM
Kernel
CONST
swi
spiData
spiCtrl
netSelect
spiFast
netEnable
HdrSize
MaxPayload
SubPacket
Wait
SendTries
MaxPacket
HdrSize
MaxPayload
SubPacket
DIV
SubPacket
SubPacket
TYPE
Header
RECORD
valid
BOOLEAN
dadr
sadr
typ
BYTE
len
INTEGER
of
data
following
header
END
VAR
filter
BOOLEAN
Adr
BYTE
rcvd
INTEGER
rx
RECORD
hd
Header
dat
ARRAY
MaxPacket
HdrSize
OF
BYTE
END
PROCEDURE
SPICtrl
s
SET
BEGIN
SYSTEM
PUT
spiCtrl
s
IF
netEnable
IN
s
THEN
LED
55H
ELSE
LED
END
END
SPICtrl
PROCEDURE
SPI
n
INTEGER
BEGIN
send
rcv
into
shift
reg
one
byte
or
word
at
current
speed
SYSTEM
PUT
spiData
n
REPEAT
UNTIL
SYSTEM
BIT
spiCtrl
wait
until
done
END
SPI
PROCEDURE
StartCmd
cmd
INTEGER
BEGIN
SPICtrl
netSelect
SPI
cmd
END
StartCmd
PROCEDURE
WriteReg1
reg
dat
INTEGER
disables
radio
BEGIN
StartCmd
reg
20H
SPI
dat
SPICtrl
W
REGISTER
END
WriteReg1
PROCEDURE
SubRcv
dst
INTEGER
VAR
i
dat
INTEGER
BEGIN
StartCmd
061H
R
RX
PAYLOAD
disables
radio
SPICtrl
netSelect
spiFast
FOR
i
TO
SubPacket
BY
DO
SPI
SYSTEM
GET
spiData
dat
SYSTEM
PUT
dst
i
dat
END
SPICtrl
WriteReg1
40H
done
STATUS
clear
RX
DR
SPICtrl
netEnable
enable
radio
END
SubRcv
PROCEDURE
SubSnd
src
INTEGER
VAR
timeout
BOOLEAN
VAR
i
dat
res
t1
try
INTEGER
x
status
BYTE
BEGIN
already
in
xmit
mode
StartCmd
0A0H
W
TX
PAYLOAD
SPICtrl
netSelect
spiFast
FOR
i
TO
SubPacket
BY
DO
SYSTEM
GET
src
i
dat
SPI
dat
END
SPICtrl
end
W
TX
PAYLOAD
command
try
SPICtrl
netEnable
netSelect
start
xmit
pulse
start
NOP
cmd
REPEAT
t1
Kernel
Time
Wait
REPEAT
wait
for
sent
or
retransmits
exceeded
SPI
0FFH
SYSTEM
GET
spiData
status
NOP
res
status
DIV
10H
MOD
SPICtrl
SPICtrl
netSelect
end
restart
NOP
cmd
end
10us
pulse
on
enable
UNTIL
res
IF
res
THEN
WriteReg1
20H
TX
DS
sent
ack
received
reset
it
ELSIF
res
THEN
WriteReg1
10H
INC
try
MAX
RT
retransmits
exceeded
reset
it
IF
try
SendTries
THEN
res
ELSE
REPEAT
UNTIL
Kernel
Time
t1
SPICtrl
netEnable
netSelect
start
xmit
pulse
start
NOP
cmd
again
END
END
UNTIL
res
timeout
res
END
SubSnd
PROCEDURE
Flush
BEGIN
StartCmd
0E1H
SPICtrl
StartCmd
0E2H
SPICtrl
FLUSH
TX
FLUSH
RX
END
Flush
PROCEDURE
ResetRcv
BEGIN
SYSTEM
PUT
SYSTEM
ADR
rx
rx
hd
len
rcvd
END
ResetRcv
PROCEDURE
Listen
b
BOOLEAN
BEGIN
WriteReg1
07EH
ORD
b
CONFIG
mask
ints
EN
CRC
byte
PWR
UP
PRX
PTX
WriteReg1
70H
STATUS
clear
ints
IF
b
THEN
SPICtrl
netEnable
END
turn
radio
on
END
Listen
PROCEDURE
Start
filt
BOOLEAN
VAR
n
INTEGER
BEGIN
filter
filt
Adr
SYSTEM
GET
swi
n
n
n
DIV
MOD
10H
WriteReg1
n
RF
CH
channel
WriteReg1
07H
RF
SETUP
1Mb
for
better
range
0dBm
WriteReg1
11H
SubPacket
RX
PW
P0
pipe
payload
width
Flush
Listen
TRUE
ResetRcv
END
Start
PROCEDURE
SendPacket
VAR
head
Header
dat
ARRAY
OF
BYTE
VAR
len
i
off
INTEGER
timeout
BOOLEAN
payload
ARRAY
SubPacket
OF
BYTE
BEGIN
let
any
receive
ack
finish
before
turning
radio
off
i
Kernel
Time
Wait
REPEAT
SPICtrl
netEnable
netSelect
SPI
0FFH
SPICtrl
netEnable
NOP
UNTIL
Kernel
Time
i
IF
Adr
THEN
Adr
i
MOD
100H
END
Listen
FALSE
head
sadr
Adr
head
valid
TRUE
SYSTEM
COPY
SYSTEM
ADR
head
SYSTEM
ADR
payload
HdrSize
DIV
i
HdrSize
off
len
head
len
WHILE
len
i
SubPacket
DO
payload
i
dat
off
INC
i
INC
off
DEC
len
END
WHILE
i
SubPacket
DO
payload
i
INC
i
END
SubSnd
SYSTEM
ADR
payload
timeout
WHILE
timeout
len
DO
i
send
the
rest
WHILE
len
i
SubPacket
DO
payload
i
dat
off
INC
i
INC
off
DEC
len
END
WHILE
i
SubPacket
DO
payload
i
INC
i
END
SubSnd
SYSTEM
ADR
payload
timeout
END
Listen
TRUE
END
SendPacket
PROCEDURE
Available
INTEGER
BEGIN
packet
already
rcvd
RETURN
rx
hd
len
rcvd
END
Available
PROCEDURE
Receive
VAR
x
BYTE
BEGIN
packet
already
rcvd
IF
rcvd
rx
hd
len
THEN
x
rx
dat
rcvd
INC
rcvd
ELSE
x
END
END
Receive
PROCEDURE
Rcvd
time
INTEGER
BOOLEAN
VAR
status
fifoStatus
BYTE
rcvd
BOOLEAN
BEGIN
time
time
Kernel
Time
REPEAT
SPICtrl
netEnable
netSelect
SPI
17H
R
REGISTER
FIFO
STATUS
SYSTEM
GET
spiData
status
SPI
SYSTEM
GET
spiData
fifoStatus
SPICtrl
netEnable
rcvd
ODD
status
DIV
40H
OR
ODD
fifoStatus
RX
DR
data
ready
or
RX
FIFO
not
empty
UNTIL
rcvd
OR
Kernel
Time
time
RETURN
rcvd
END
Rcvd
PROCEDURE
ReceiveHead
VAR
head
Header
actually
recv
whole
packet
VAR
adr
n
INTEGER
BEGIN
head
valid
FALSE
IF
Rcvd
THEN
ResetRcv
adr
SYSTEM
ADR
rx
SubRcv
adr
n
rx
hd
len
HdrSize
DIV
SubPacket
IF
rx
hd
len
MaxPayload
rx
hd
dadr
0FFH
OR
filter
OR
Adr
OR
rx
hd
dadr
Adr
THEN
WHILE
n
Rcvd
Wait
DO
INC
adr
SubPacket
SubRcv
adr
DEC
n
END
rx
hd
valid
n
ELSE
WHILE
Rcvd
Wait
DO
SubRcv
adr
END
ResetRcv
discard
packet
END
head
rx
hd
END
END
ReceiveHead
PROCEDURE
Skip
m
INTEGER
VAR
dmy
BYTE
BEGIN
WHILE
m
DO
Receive
dmy
DEC
m
END
END
Skip
PROCEDURE
Stop
BEGIN
SPICtrl
Flush
ResetRcv
END
Stop
BEGIN
Start
TRUE
END
SCC
MODULE
System
JG
NW
NW
IMPORT
SYSTEM
Kernel
FileDir
Files
Modules
Input
Display
Viewers
Fonts
Texts
Oberon
MenuViewers
TextFrames
CONST
StandardMenu
System
Close
System
Copy
System
Grow
Edit
Search
Edit
Store
LogMenu
Edit
Locate
Edit
Search
System
Copy
System
Grow
System
Clear
VAR
W
Texts
Writer
pat
ARRAY
OF
CHAR
PROCEDURE
GetArg
VAR
S
Texts
Scanner
VAR
T
Texts
Text
beg
end
time
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
END
END
END
GetArg
PROCEDURE
EndLine
BEGIN
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
EndLine
Toolbox
for
system
control
PROCEDURE
SetUser
VAR
i
INTEGER
ch
CHAR
user
ARRAY
OF
CHAR
password
ARRAY
OF
CHAR
BEGIN
i
Input
Read
ch
WHILE
ch
i
DO
user
i
ch
INC
i
Input
Read
ch
END
user
i
0X
i
Input
Read
ch
WHILE
ch
i
DO
password
i
ch
INC
i
Input
Read
ch
END
password
i
0X
Oberon
SetUser
user
password
END
SetUser
PROCEDURE
SetFont
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Oberon
SetFont
Fonts
This
S
s
END
END
SetFont
PROCEDURE
SetColor
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
Oberon
SetColor
S
i
END
END
SetColor
PROCEDURE
SetOffset
VAR
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Int
THEN
Oberon
SetOffset
S
i
END
END
SetOffset
PROCEDURE
Date
VAR
S
Texts
Scanner
dt
hr
min
sec
yr
mo
day
LONGINT
BEGIN
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Int
THEN
set
clock
day
S
i
Texts
Scan
S
mo
S
i
Texts
Scan
S
yr
S
i
Texts
Scan
S
hr
S
i
Texts
Scan
S
min
S
i
Texts
Scan
S
sec
S
i
dt
yr
mo
day
hr
min
sec
Kernel
SetClock
dt
ELSE
read
clock
Texts
WriteString
W
System
Clock
dt
Oberon
Clock
Texts
WriteClock
W
dt
EndLine
END
END
Date
PROCEDURE
Collect
BEGIN
Oberon
Collect
END
Collect
Toolbox
for
standard
display
PROCEDURE
Open
open
viewer
in
system
track
VAR
X
Y
INTEGER
V
Viewers
Viewer
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
Open
PROCEDURE
Clear
clear
Log
VAR
T
Texts
Text
F
Display
Frame
buf
Texts
Buffer
BEGIN
F
Oberon
Par
frame
IF
F
NIL
F
next
IS
TextFrames
Frame
F
Oberon
Par
vwr
dsc
THEN
NEW
buf
Texts
OpenBuf
buf
T
F
next
TextFrames
Frame
text
Texts
Delete
T
T
len
buf
END
END
Clear
PROCEDURE
Close
VAR
V
Viewers
Viewer
BEGIN
IF
Oberon
Par
frame
Oberon
Par
vwr
dsc
THEN
V
Oberon
Par
vwr
ELSE
V
Oberon
MarkedViewer
END
Viewers
Close
V
END
Close
PROCEDURE
CloseTrack
VAR
V
Viewers
Viewer
BEGIN
V
Oberon
MarkedViewer
Viewers
CloseTrack
V
X
END
CloseTrack
PROCEDURE
Recall
VAR
V
Viewers
Viewer
M
Viewers
ViewerMsg
BEGIN
Viewers
Recall
V
IF
V
NIL
V
state
THEN
Viewers
Open
V
V
X
V
Y
V
H
M
id
Viewers
restore
V
handle
V
M
END
END
Recall
PROCEDURE
Copy
VAR
V
V1
Viewers
Viewer
M
Oberon
CopyMsg
N
Viewers
ViewerMsg
BEGIN
V
Oberon
Par
vwr
V
handle
V
M
V1
M
F
Viewers
Viewer
Viewers
Open
V1
V
X
V
Y
V
H
DIV
N
id
Viewers
restore
V1
handle
V1
N
END
Copy
PROCEDURE
Grow
VAR
V
V1
Viewers
Viewer
M
Oberon
CopyMsg
N
Viewers
ViewerMsg
DW
DH
INTEGER
BEGIN
V
Oberon
Par
vwr
DW
Oberon
DisplayWidth
V
X
DH
Oberon
DisplayHeight
V
X
IF
V
H
DH
Viewers
minH
THEN
Oberon
OpenTrack
V
X
V
W
ELSIF
V
W
DW
THEN
Oberon
OpenTrack
Oberon
UserTrack
V
X
DW
END
IF
V
H
DH
Viewers
minH
OR
V
W
DW
THEN
V
handle
V
M
V1
M
F
Viewers
Viewer
Viewers
Open
V1
V
X
DH
N
id
Viewers
restore
V1
handle
V1
N
END
END
Grow
Toolbox
for
module
management
PROCEDURE
Free1
VAR
S
Texts
Scanner
BEGIN
Texts
WriteString
W
S
s
Texts
WriteString
W
unloading
Modules
Free
S
s
IF
Modules
res
THEN
Texts
WriteString
W
failed
END
EndLine
END
Free1
PROCEDURE
Free
VAR
T
Texts
Text
beg
end
time
LONGINT
S
Texts
Scanner
BEGIN
Texts
WriteString
W
System
Free
EndLine
Texts
OpenScanner
S
Oberon
Par
text
Oberon
Par
pos
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenScanner
S
T
beg
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Free1
S
END
END
ELSE
WHILE
S
class
Texts
Name
DO
Free1
S
Texts
Scan
S
END
END
Oberon
Collect
END
Free
PROCEDURE
FreeFonts
BEGIN
Texts
WriteString
W
System
FreeFonts
Fonts
Free
EndLine
END
FreeFonts
Toolbox
of
file
system
PROCEDURE
List
name
FileDir
FileName
adr
LONGINT
VAR
cont
BOOLEAN
VAR
i0
i
j0
j
INTEGER
hp
FileDir
FileHeader
BEGIN
i
WHILE
pat
i
pat
i
name
i
DO
INC
i
END
IF
pat
i
0X
name
i
0X
THEN
i0
i
j0
i
ELSIF
pat
i
THEN
i0
i
j0
i
WHILE
name
i0
0X
DO
i
i0
j
j0
WHILE
name
i
0X
name
i
pat
j
DO
INC
i
INC
j
END
IF
pat
j
0X
THEN
IF
name
i
0X
THEN
match
j0
j
ELSE
INC
i0
END
ELSIF
pat
j
THEN
i0
i
j0
j
ELSE
INC
i0
END
END
END
IF
name
i0
0X
pat
j0
0X
THEN
found
Texts
WriteString
W
name
IF
pat
j0
THEN
option
Kernel
GetSector
adr
hp
Texts
Write
W
9X
Texts
WriteClock
W
hp
date
Texts
WriteInt
W
hp
aleng
FileDir
SectorSize
hp
bleng
FileDir
HeaderSize
length
Texts
WriteHex
W
adr
END
Texts
WriteLn
W
END
END
List
PROCEDURE
Directory
VAR
X
Y
i
INTEGER
ch
CHAR
R
Texts
Reader
T
t
Texts
Text
V
Viewers
Viewer
beg
end
time
LONGINT
pre
ARRAY
OF
CHAR
BEGIN
Texts
OpenReader
R
Oberon
Par
text
Oberon
Par
pos
Texts
Read
R
ch
WHILE
ch
DO
Texts
Read
R
ch
END
IF
ch
OR
ch
0DX
THEN
Oberon
GetSelection
T
beg
end
time
IF
time
THEN
Texts
OpenReader
R
T
beg
Texts
Read
R
ch
WHILE
ch
DO
Texts
Read
R
ch
END
END
END
i
WHILE
ch
DO
pat
i
ch
INC
i
Texts
Read
R
ch
END
pat
i
0X
IF
ch
THEN
pat
i
END
directory
option
i
WHILE
pat
i
DO
pre
i
pat
i
INC
i
END
pre
i
0X
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
t
TextFrames
Text
V
MenuViewers
New
TextFrames
NewMenu
System
Directory
StandardMenu
TextFrames
NewText
t
TextFrames
menuH
X
Y
FileDir
Enumerate
pre
List
Texts
Append
t
W
buf
END
Directory
PROCEDURE
CopyFiles
VAR
f
g
Files
File
Rf
Rg
Files
Rider
ch
CHAR
name
ARRAY
OF
CHAR
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
CopyFiles
EndLine
WHILE
S
class
Texts
Name
DO
name
S
s
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteString
W
copying
Texts
Append
Oberon
Log
W
buf
f
Files
Old
name
IF
f
NIL
THEN
g
Files
New
S
s
Files
Set
Rf
f
Files
Set
Rg
g
Files
Read
Rf
ch
WHILE
Rf
eof
DO
Files
Write
Rg
ch
Files
Read
Rf
ch
END
Files
Register
g
ELSE
Texts
WriteString
W
failed
END
EndLine
END
END
END
Texts
Scan
S
END
END
CopyFiles
PROCEDURE
RenameFiles
VAR
res
INTEGER
name
ARRAY
OF
CHAR
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
RenameFiles
EndLine
WHILE
S
class
Texts
Name
DO
name
S
s
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Char
S
c
THEN
Texts
Scan
S
IF
S
class
Texts
Name
THEN
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
S
s
Texts
WriteString
W
renaming
Files
Rename
name
S
s
res
IF
res
THEN
Texts
WriteString
W
failed
END
EndLine
END
END
END
Texts
Scan
S
END
END
RenameFiles
PROCEDURE
DeleteFiles
VAR
res
INTEGER
S
Texts
Scanner
BEGIN
GetArg
S
Texts
WriteString
W
System
DeleteFiles
EndLine
WHILE
S
class
Texts
Name
DO
Texts
WriteString
W
S
s
Texts
WriteString
W
deleting
Files
Delete
S
s
res
IF
res
THEN
Texts
WriteString
W
failed
END
EndLine
Texts
Scan
S
END
END
DeleteFiles
Toolbox
for
system
inspection
PROCEDURE
Watch
BEGIN
Texts
WriteString
W
System
Watch
Texts
WriteLn
W
Texts
WriteString
W
Modules
space
bytes
Texts
WriteInt
W
Modules
AllocPtr
Texts
WriteInt
W
Modules
AllocPtr
DIV
Kernel
heapOrg
Texts
Write
W
EndLine
Texts
WriteString
W
Heap
speace
Texts
WriteInt
W
Kernel
allocated
Texts
WriteInt
W
Kernel
allocated
DIV
Kernel
heapLim
Kernel
heapOrg
Texts
Write
W
EndLine
Texts
WriteString
W
Disk
sectors
Texts
WriteInt
W
Kernel
NofSectors
Texts
WriteInt
W
Kernel
NofSectors
DIV
10000H
Texts
Write
W
EndLine
Texts
WriteString
W
Tasks
Texts
WriteInt
W
Oberon
NofTasks
EndLine
END
Watch
PROCEDURE
ShowModules
VAR
T
Texts
Text
V
Viewers
Viewer
M
Modules
Module
X
Y
INTEGER
BEGIN
T
TextFrames
Text
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
V
MenuViewers
New
TextFrames
NewMenu
System
ShowModules
StandardMenu
TextFrames
NewText
T
TextFrames
menuH
X
Y
M
Modules
root
WHILE
M
NIL
DO
IF
M
name
0X
THEN
Texts
WriteString
W
M
name
Texts
Write
W
9X
Texts
WriteHex
W
ORD
M
Texts
WriteHex
W
M
code
Texts
WriteInt
W
M
refcnt
ELSE
Texts
WriteString
W
END
Texts
WriteLn
W
M
M
next
END
Texts
Append
T
W
buf
END
ShowModules
PROCEDURE
ShowCommands
VAR
M
Modules
Module
comadr
LONGINT
ch
CHAR
T
Texts
Text
S
Texts
Scanner
V
Viewers
Viewer
X
Y
INTEGER
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
Modules
Load
S
s
M
IF
M
NIL
THEN
Oberon
AllocateSystemViewer
Oberon
Par
vwr
X
X
Y
T
TextFrames
Text
V
MenuViewers
New
TextFrames
NewMenu
System
Commands
StandardMenu
TextFrames
NewText
T
TextFrames
menuH
X
Y
comadr
M
cmd
SYSTEM
GET
comadr
ch
INC
comadr
WHILE
ch
0X
DO
Texts
WriteString
W
S
s
Texts
Write
W
REPEAT
Texts
Write
W
ch
SYSTEM
GET
comadr
ch
INC
comadr
UNTIL
ch
0X
WHILE
comadr
MOD
DO
INC
comadr
END
Texts
WriteLn
W
INC
comadr
SYSTEM
GET
comadr
ch
INC
comadr
END
Texts
Append
T
W
buf
END
END
END
ShowCommands
PROCEDURE
ShowFonts
VAR
fnt
Fonts
Font
BEGIN
Texts
WriteString
W
System
ShowFonts
Texts
WriteLn
W
fnt
Fonts
root
WHILE
fnt
NIL
DO
Texts
Write
W
9X
Texts
WriteString
W
fnt
name
Texts
WriteLn
W
fnt
fnt
next
END
Texts
Append
Oberon
Log
W
buf
END
ShowFonts
PROCEDURE
OpenViewers
VAR
logV
toolV
Viewers
Viewer
menu
main
Display
Frame
d
LONGINT
X
Y
INTEGER
BEGIN
d
Kernel
Clock
Texts
WriteString
W
Oberon
V5
NW
EndLine
Oberon
AllocateSystemViewer
X
Y
menu
TextFrames
NewMenu
System
Log
LogMenu
main
TextFrames
NewText
Oberon
Log
logV
MenuViewers
New
menu
main
TextFrames
menuH
X
Y
Oberon
AllocateSystemViewer
X
Y
menu
TextFrames
NewMenu
System
Tool
StandardMenu
main
TextFrames
NewText
TextFrames
Text
System
Tool
toolV
MenuViewers
New
menu
main
TextFrames
menuH
X
Y
END
OpenViewers
PROCEDURE
ExtendDisplay
VAR
V
Viewers
Viewer
X
Y
DX
DW
DH
INTEGER
S
Texts
Scanner
BEGIN
GetArg
S
IF
S
class
Texts
Name
THEN
DX
Viewers
curW
DW
Oberon
DisplayWidth
DX
DH
Oberon
DisplayHeight
DX
Oberon
OpenDisplay
DW
DIV
DW
DIV
DH
Oberon
AllocateSystemViewer
DX
X
Y
V
MenuViewers
New
TextFrames
NewMenu
S
s
StandardMenu
TextFrames
NewText
TextFrames
Text
S
s
TextFrames
menuH
X
Y
END
END
ExtendDisplay
PROCEDURE
Trap
VAR
a
INTEGER
b
INTEGER
VAR
u
v
w
INTEGER
mod
Modules
Module
BEGIN
u
SYSTEM
REG
SYSTEM
GET
u
v
w
v
DIV
10H
MOD
10H
trap
number
IF
w
THEN
Kernel
New
a
b
ELSE
trap
Texts
WriteLn
W
Texts
WriteString
W
pos
Texts
WriteInt
W
v
DIV
100H
MOD
10000H
Texts
WriteString
W
TRAP
Texts
WriteInt
W
w
mod
Modules
root
WHILE
mod
NIL
u
mod
code
OR
u
mod
imp
DO
mod
mod
next
END
IF
mod
NIL
THEN
Texts
WriteString
W
in
Texts
WriteString
W
mod
name
END
Texts
WriteString
W
at
Texts
WriteHex
W
u
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Oberon
Reset
END
END
Trap
PROCEDURE
Abort
VAR
n
INTEGER
BEGIN
n
SYSTEM
REG
Texts
WriteString
W
ABORT
Texts
WriteHex
W
n
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
Oberon
Reset
END
Abort
BEGIN
Texts
OpenWriter
W
Oberon
OpenLog
TextFrames
Text
OpenViewers
Kernel
Install
SYSTEM
ADR
Trap
20H
Kernel
Install
SYSTEM
ADR
Abort
END
System
MODULE
TextFrames
JG
NW
IMPORT
Modules
Input
Display
Viewers
Fonts
Texts
Oberon
MenuViewers
CONST
replace
insert
delete
unmark
message
id
BS
8X
TAB
9X
CR
0DX
DEL
7FX
TYPE
Line
POINTER
TO
LineDesc
LineDesc
RECORD
len
LONGINT
wid
INTEGER
eot
BOOLEAN
next
Line
END
Location
RECORD
org
pos
LONGINT
dx
x
y
INTEGER
lin
Line
END
Frame
POINTER
TO
FrameDesc
FrameDesc
RECORD
Display
FrameDesc
text
Texts
Text
org
LONGINT
col
INTEGER
lsp
INTEGER
left
right
top
bot
INTEGER
markH
INTEGER
time
LONGINT
hasCar
hasSel
hasMark
BOOLEAN
carloc
Location
selbeg
selend
Location
trailer
Line
END
UpdateMsg
RECORD
Display
FrameMsg
id
INTEGER
text
Texts
Text
beg
end
LONGINT
END
CopyOverMsg
RECORD
Display
FrameMsg
text
Texts
Text
beg
end
LONGINT
END
VAR
TBuf
DelBuf
Texts
Buffer
menuH
barW
left
right
top
bot
lsp
INTEGER
standard
sizes
asr
dsr
selH
markW
eolW
INTEGER
nextCh
CHAR
ScrollMarker
Oberon
Marker
W
KW
Texts
Writer
keyboard
writer
PROCEDURE
Min
i
j
INTEGER
INTEGER
BEGIN
IF
i
j
THEN
j
i
END
RETURN
j
END
Min
display
support
PROCEDURE
ReplConst
col
INTEGER
F
Frame
X
Y
W
H
INTEGER
mode
INTEGER
BEGIN
IF
X
W
F
X
F
W
THEN
Display
ReplConst
col
X
Y
W
H
mode
ELSIF
X
F
X
F
W
THEN
Display
ReplConst
col
X
Y
F
X
F
W
X
H
mode
END
END
ReplConst
PROCEDURE
FlipSM
X
Y
INTEGER
VAR
DW
DH
CL
INTEGER
BEGIN
DW
Display
Width
DH
Display
Height
CL
DW
IF
X
CL
THEN
IF
X
THEN
X
ELSIF
X
DW
THEN
X
DW
END
ELSE
IF
X
CL
THEN
X
CL
ELSIF
X
CL
DW
THEN
X
CL
DW
END
END
IF
Y
THEN
Y
ELSIF
Y
DH
THEN
Y
DH
END
Display
CopyPattern
Display
white
Display
updown
X
Y
Display
invert
END
FlipSM
PROCEDURE
UpdateMark
F
Frame
in
scroll
bar
VAR
oldH
INTEGER
BEGIN
oldH
F
markH
F
markH
F
org
F
H
DIV
F
text
len
IF
F
hasMark
F
left
barW
F
markH
oldH
THEN
Display
ReplConst
Display
white
F
X
F
Y
F
H
oldH
markW
Display
invert
Display
ReplConst
Display
white
F
X
F
Y
F
H
F
markH
markW
Display
invert
END
END
UpdateMark
PROCEDURE
SetChangeMark
F
Frame
on
BOOLEAN
in
corner
BEGIN
IF
F
H
menuH
THEN
IF
on
THEN
Display
CopyPattern
Display
white
Display
block
F
X
F
W
F
Y
F
H
Display
paint
ELSE
Display
ReplConst
F
col
F
X
F
W
F
Y
F
H
Display
replace
END
END
END
SetChangeMark
PROCEDURE
Width
VAR
R
Texts
Reader
len
LONGINT
INTEGER
VAR
patadr
pos
LONGINT
ox
dx
x
y
w
h
INTEGER
BEGIN
pos
ox
WHILE
pos
len
DO
Fonts
GetPat
R
fnt
nextCh
dx
x
y
w
h
patadr
ox
ox
dx
INC
pos
Texts
Read
R
nextCh
END
RETURN
ox
END
Width
PROCEDURE
DisplayLine
F
Frame
L
Line
VAR
R
Texts
Reader
X
Y
INTEGER
len
LONGINT
VAR
patadr
NX
dx
x
y
w
h
INTEGER
BEGIN
NX
F
X
F
W
WHILE
nextCh
CR
R
fnt
NIL
DO
Fonts
GetPat
R
fnt
nextCh
dx
x
y
w
h
patadr
IF
X
x
w
NX
h
THEN
Display
CopyPattern
R
col
patadr
X
x
Y
y
Display
invert
END
X
X
dx
INC
len
Texts
Read
R
nextCh
END
L
len
len
L
wid
X
eolW
F
X
F
left
L
eot
R
fnt
NIL
Texts
Read
R
nextCh
END
DisplayLine
PROCEDURE
Validate
T
Texts
Text
VAR
pos
LONGINT
VAR
R
Texts
Reader
BEGIN
IF
pos
T
len
THEN
pos
T
len
ELSIF
pos
THEN
DEC
pos
Texts
OpenReader
R
T
pos
REPEAT
Texts
Read
R
nextCh
INC
pos
UNTIL
R
eot
OR
nextCh
CR
ELSE
pos
END
END
Validate
PROCEDURE
Mark
F
Frame
on
BOOLEAN
BEGIN
IF
F
H
F
left
barW
F
hasMark
on
OR
F
hasMark
on
THEN
Display
ReplConst
Display
white
F
X
F
Y
F
H
F
markH
markW
Display
invert
END
F
hasMark
on
END
Mark
PROCEDURE
Restore
F
Frame
VAR
R
Texts
Reader
L
l
Line
curY
botY
INTEGER
BEGIN
Display
ReplConst
F
col
F
X
F
Y
F
W
F
H
Display
replace
IF
F
left
barW
THEN
Display
ReplConst
Display
white
F
X
barW
F
Y
F
H
Display
invert
END
Validate
F
text
F
org
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
F
org
Texts
Read
R
nextCh
L
F
trailer
curY
F
Y
F
H
F
top
asr
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
F
markH
F
org
F
H
DIV
F
text
len
END
Restore
PROCEDURE
Suspend
F
Frame
BEGIN
F
trailer
next
F
trailer
END
Suspend
PROCEDURE
Extend
F
Frame
newY
INTEGER
VAR
R
Texts
Reader
L
l
Line
org
LONGINT
curY
botY
INTEGER
BEGIN
Display
ReplConst
F
col
F
X
newY
F
W
F
Y
newY
Display
replace
IF
F
left
barW
THEN
Display
ReplConst
Display
white
F
X
barW
newY
F
Y
newY
Display
invert
END
botY
F
Y
F
bot
dsr
F
H
F
H
F
Y
newY
F
Y
newY
IF
F
trailer
next
F
trailer
THEN
Validate
F
text
F
org
END
L
F
trailer
org
F
org
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
org
org
L
len
curY
curY
lsp
END
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
F
markH
F
org
F
H
DIV
F
text
len
END
Extend
PROCEDURE
Reduce
F
Frame
newY
INTEGER
VAR
L
Line
curY
botY
INTEGER
BEGIN
F
H
F
H
F
Y
newY
F
Y
newY
botY
F
Y
F
bot
dsr
L
F
trailer
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
curY
curY
lsp
END
L
next
F
trailer
IF
curY
asr
F
Y
THEN
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
asr
F
Y
Display
replace
END
F
markH
F
org
F
H
DIV
F
text
len
Mark
F
TRUE
END
Reduce
PROCEDURE
Show
F
Frame
pos
LONGINT
VAR
R
Texts
Reader
L
L0
Line
org
LONGINT
curY
botY
Y0
INTEGER
BEGIN
IF
F
trailer
next
F
trailer
THEN
Validate
F
text
pos
IF
pos
F
org
THEN
Mark
F
FALSE
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
F
H
Display
replace
botY
F
Y
F
Y
F
Y
F
H
F
H
F
org
pos
F
trailer
next
F
trailer
Extend
F
botY
Mark
F
TRUE
ELSIF
pos
F
org
THEN
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
next
F
trailer
org
pos
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
org
pos
THEN
F
org
org
F
trailer
next
L
Y0
curY
WHILE
L
next
F
trailer
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
Display
CopyBlock
F
X
F
left
curY
dsr
F
W
F
left
Y0
asr
curY
dsr
F
X
F
left
curY
dsr
F
Y
F
H
F
top
asr
Y0
curY
curY
F
Y
F
H
F
top
asr
Y0
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
dsr
F
Y
Display
replace
botY
F
Y
F
bot
dsr
org
org
L
len
curY
curY
lsp
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
L0
DisplayLine
F
L0
R
F
X
F
left
curY
L
next
L0
L
L0
curY
curY
lsp
END
L
next
F
trailer
UpdateMark
F
ELSE
Mark
F
FALSE
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
F
H
Display
replace
botY
F
Y
F
Y
F
Y
F
H
F
H
F
org
pos
F
trailer
next
F
trailer
Extend
F
botY
Mark
F
TRUE
END
END
END
SetChangeMark
F
F
text
changed
END
Show
PROCEDURE
LocateLine
F
Frame
y
INTEGER
VAR
loc
Location
VAR
L
Line
org
LONGINT
cury
INTEGER
BEGIN
org
F
org
L
F
trailer
next
cury
F
H
F
top
asr
WHILE
L
next
F
trailer
cury
y
dsr
DO
org
org
L
len
L
L
next
cury
cury
lsp
END
loc
org
org
loc
lin
L
loc
y
cury
END
LocateLine
PROCEDURE
LocateString
F
Frame
x
y
INTEGER
VAR
loc
Location
VAR
R
Texts
Reader
patadr
bpos
pos
lim
LONGINT
bx
ex
ox
dx
u
v
w
h
INTEGER
BEGIN
LocateLine
F
y
loc
lim
loc
org
loc
lin
len
bpos
loc
org
bx
F
left
pos
loc
org
ox
F
left
Texts
OpenReader
R
F
text
loc
org
Texts
Read
R
nextCh
REPEAT
WHILE
pos
lim
nextCh
DO
scan
string
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
END
ex
ox
WHILE
pos
lim
nextCh
DO
scan
gap
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
END
IF
pos
lim
ox
x
THEN
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
bpos
pos
bx
ox
INC
pos
ox
ox
dx
Texts
Read
R
nextCh
ELSE
pos
lim
END
UNTIL
pos
lim
loc
pos
bpos
loc
dx
ex
bx
loc
x
bx
END
LocateString
PROCEDURE
LocateChar
F
Frame
x
y
INTEGER
VAR
loc
Location
VAR
R
Texts
Reader
patadr
pos
lim
LONGINT
ox
dx
u
v
w
h
INTEGER
BEGIN
LocateLine
F
y
loc
lim
loc
org
loc
lin
len
pos
loc
org
ox
F
left
dx
eolW
Texts
OpenReader
R
F
text
loc
org
WHILE
pos
lim
DO
Texts
Read
R
nextCh
Fonts
GetPat
R
fnt
nextCh
dx
u
v
w
h
patadr
IF
ox
dx
x
THEN
INC
pos
ox
ox
dx
IF
pos
lim
THEN
dx
eolW
END
ELSE
lim
pos
END
END
loc
pos
pos
loc
dx
dx
loc
x
ox
END
LocateChar
PROCEDURE
LocatePos
F
Frame
pos
LONGINT
VAR
loc
Location
VAR
T
Texts
Text
R
Texts
Reader
L
Line
org
LONGINT
cury
INTEGER
BEGIN
T
F
text
org
F
org
L
F
trailer
next
cury
F
H
F
top
asr
IF
pos
org
THEN
pos
org
END
WHILE
L
next
F
trailer
pos
org
L
len
DO
org
org
L
len
L
L
next
cury
cury
lsp
END
IF
pos
org
L
len
THEN
pos
org
L
len
END
Texts
OpenReader
R
T
org
Texts
Read
R
nextCh
loc
org
org
loc
pos
pos
loc
lin
L
loc
x
F
left
Width
R
pos
org
loc
y
cury
END
LocatePos
PROCEDURE
Pos
F
Frame
X
Y
INTEGER
LONGINT
VAR
loc
Location
BEGIN
LocateChar
F
X
F
X
Y
F
Y
loc
RETURN
loc
pos
END
Pos
PROCEDURE
FlipCaret
F
Frame
BEGIN
IF
F
carloc
x
F
W
F
carloc
y
F
carloc
x
F
W
THEN
Display
CopyPattern
Display
white
Display
hook
F
X
F
carloc
x
F
Y
F
carloc
y
Display
invert
END
END
FlipCaret
PROCEDURE
SetCaret
F
Frame
pos
LONGINT
BEGIN
LocatePos
F
pos
F
carloc
FlipCaret
F
F
hasCar
TRUE
END
SetCaret
PROCEDURE
TrackCaret
F
Frame
X
Y
INTEGER
VAR
keysum
SET
VAR
loc
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateChar
F
X
F
X
Y
F
Y
F
carloc
FlipCaret
F
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateChar
F
X
F
X
Y
F
Y
loc
IF
loc
pos
F
carloc
pos
THEN
FlipCaret
F
F
carloc
loc
FlipCaret
F
END
UNTIL
keys
F
hasCar
TRUE
END
END
TrackCaret
PROCEDURE
RemoveCaret
F
Frame
BEGIN
IF
F
hasCar
THEN
FlipCaret
F
F
hasCar
FALSE
END
END
RemoveCaret
PROCEDURE
FlipSelection
F
Frame
VAR
beg
end
Location
VAR
L
Line
Y
INTEGER
BEGIN
L
beg
lin
Y
F
Y
beg
y
IF
L
end
lin
THEN
ReplConst
Display
white
F
F
X
beg
x
Y
end
x
beg
x
selH
Display
invert
ELSE
ReplConst
Display
white
F
F
X
beg
x
Y
F
left
L
wid
beg
x
selH
Display
invert
L
L
next
Y
Y
lsp
WHILE
L
end
lin
DO
ReplConst
Display
white
F
F
X
F
left
Y
L
wid
selH
Display
invert
L
L
next
Y
Y
lsp
END
ReplConst
Display
white
F
F
X
F
left
Y
end
x
F
left
selH
Display
invert
END
END
FlipSelection
PROCEDURE
SetSelection
F
Frame
beg
end
LONGINT
BEGIN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
END
LocatePos
F
beg
F
selbeg
LocatePos
F
end
F
selend
IF
F
selbeg
pos
F
selend
pos
THEN
FlipSelection
F
F
selbeg
F
selend
F
time
Oberon
Time
F
hasSel
TRUE
END
END
SetSelection
PROCEDURE
TrackSelection
F
Frame
X
Y
INTEGER
VAR
keysum
SET
VAR
loc
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
END
LocateChar
F
X
F
X
Y
F
Y
loc
IF
F
hasSel
loc
pos
F
selbeg
pos
F
selend
pos
F
selbeg
pos
THEN
LocateChar
F
F
left
Y
F
Y
F
selbeg
ELSE
F
selbeg
loc
END
INC
loc
pos
loc
x
loc
x
loc
dx
F
selend
loc
FlipSelection
F
F
selbeg
F
selend
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateChar
F
X
F
X
Y
F
Y
loc
IF
loc
pos
F
selbeg
pos
THEN
loc
F
selbeg
END
INC
loc
pos
loc
x
loc
x
loc
dx
IF
loc
pos
F
selend
pos
THEN
FlipSelection
F
loc
F
selend
F
selend
loc
ELSIF
loc
pos
F
selend
pos
THEN
FlipSelection
F
F
selend
loc
F
selend
loc
END
UNTIL
keys
F
time
Oberon
Time
F
hasSel
TRUE
END
END
TrackSelection
PROCEDURE
RemoveSelection
F
Frame
BEGIN
IF
F
hasSel
THEN
FlipSelection
F
F
selbeg
F
selend
F
hasSel
FALSE
END
END
RemoveSelection
PROCEDURE
TrackLine
F
Frame
X
Y
INTEGER
VAR
org
LONGINT
VAR
keysum
SET
VAR
old
new
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateLine
F
Y
F
Y
old
ReplConst
Display
white
F
F
X
F
left
F
Y
old
y
dsr
old
lin
wid
Display
invert
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouse
ScrollMarker
X
Y
LocateLine
F
Y
F
Y
new
IF
new
org
old
org
THEN
ReplConst
Display
white
F
F
X
F
left
F
Y
old
y
dsr
old
lin
wid
Display
invert
ReplConst
Display
white
F
F
X
F
left
F
Y
new
y
dsr
new
lin
wid
Display
invert
old
new
END
UNTIL
keys
ReplConst
Display
white
F
F
X
F
left
F
Y
new
y
dsr
new
lin
wid
Display
invert
org
new
org
ELSE
org
END
END
TrackLine
PROCEDURE
TrackWord
F
Frame
X
Y
INTEGER
VAR
pos
LONGINT
VAR
keysum
SET
VAR
old
new
Location
keys
SET
BEGIN
IF
F
trailer
next
F
trailer
THEN
LocateString
F
X
F
X
Y
F
Y
old
ReplConst
Display
white
F
F
X
old
x
F
Y
old
y
dsr
old
dx
Display
invert
keysum
REPEAT
Input
Mouse
keys
X
Y
keysum
keysum
keys
Oberon
DrawMouseArrow
X
Y
LocateString
F
X
F
X
Y
F
Y
new
IF
new
pos
old
pos
THEN
ReplConst
Display
white
F
F
X
old
x
F
Y
old
y
dsr
old
dx
Display
invert
ReplConst
Display
white
F
F
X
new
x
F
Y
new
y
dsr
new
dx
Display
invert
old
new
END
UNTIL
keys
ReplConst
Display
white
F
F
X
new
x
F
Y
new
y
dsr
new
dx
Display
invert
pos
new
pos
ELSE
pos
END
END
TrackWord
PROCEDURE
Replace
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
Line
org
len
LONGINT
curY
wid
INTEGER
BEGIN
IF
end
F
org
THEN
IF
beg
F
org
THEN
beg
F
org
END
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
len
beg
org
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
curY
dsr
L
wid
wid
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
wid
curY
len
org
org
L
len
L
L
next
curY
curY
lsp
WHILE
L
F
trailer
org
end
DO
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
curY
org
org
L
len
L
L
next
curY
curY
lsp
END
END
END
UpdateMark
F
END
Replace
PROCEDURE
Insert
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
L0
l
Line
org
len
LONGINT
curY
botY
Y0
Y1
Y2
dY
wid
INTEGER
BEGIN
IF
beg
F
org
THEN
F
org
F
org
end
beg
ELSE
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
botY
F
Y
F
bot
dsr
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
len
beg
org
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
curY
dsr
L
wid
wid
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
wid
curY
len
org
org
L
len
curY
curY
lsp
Y0
curY
L0
L
next
WHILE
org
end
curY
botY
DO
NEW
l
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
org
org
L
len
curY
curY
lsp
END
IF
L0
L
next
THEN
Y1
curY
L
next
L0
WHILE
L
next
F
trailer
curY
botY
DO
L
L
next
curY
curY
lsp
END
L
next
F
trailer
dY
Y0
Y1
IF
Y1
curY
dY
THEN
Display
CopyBlock
F
X
F
left
curY
dY
lsp
dsr
F
W
F
left
Y1
curY
dY
F
X
F
left
curY
lsp
dsr
Y2
Y1
dY
ELSE
Y2
curY
END
curY
Y1
L
L0
WHILE
curY
Y2
DO
Display
ReplConst
F
col
F
X
F
left
curY
dsr
F
W
F
left
lsp
Display
replace
DisplayLine
F
L
R
F
X
F
left
curY
L
L
next
curY
curY
lsp
END
END
END
END
UpdateMark
F
END
Insert
PROCEDURE
Delete
F
Frame
beg
end
LONGINT
VAR
R
Texts
Reader
L
L0
l
Line
org
org0
len
LONGINT
curY
botY
Y0
Y1
wid
INTEGER
BEGIN
IF
end
F
org
THEN
F
org
F
org
end
beg
ELSE
IF
beg
F
org
THEN
F
trailer
next
len
F
trailer
next
len
F
org
beg
F
org
beg
END
org
F
org
L
F
trailer
next
curY
F
Y
F
H
F
top
asr
WHILE
L
F
trailer
org
L
len
beg
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
IF
L
F
trailer
THEN
botY
F
Y
F
bot
dsr
org0
org
L0
L
Y0
curY
WHILE
L
F
trailer
org
end
DO
org
org
L
len
L
L
next
curY
curY
lsp
END
Y1
curY
Texts
OpenReader
R
F
text
org0
Texts
Read
R
nextCh
len
beg
org0
wid
Width
R
len
ReplConst
F
col
F
F
X
F
left
wid
Y0
dsr
L0
wid
wid
lsp
Display
replace
DisplayLine
F
L0
R
F
X
F
left
wid
Y0
len
Y0
Y0
lsp
IF
L
L0
next
THEN
L0
next
L
L
L0
org
org0
L0
len
WHILE
L
next
F
trailer
DO
L
L
next
org
org
L
len
curY
curY
lsp
END
Display
CopyBlock
F
X
F
left
curY
lsp
dsr
F
W
F
left
Y1
curY
F
X
F
left
curY
lsp
dsr
Y0
Y1
curY
curY
Y0
Y1
Display
ReplConst
F
col
F
X
F
left
F
Y
F
W
F
left
curY
lsp
F
Y
dsr
Display
replace
Texts
OpenReader
R
F
text
org
Texts
Read
R
nextCh
WHILE
L
eot
curY
botY
DO
NEW
l
DisplayLine
F
l
R
F
X
F
left
curY
L
next
l
L
l
curY
curY
lsp
END
L
next
F
trailer
END
END
END
UpdateMark
F
END
Delete
PROCEDURE
Recall
VAR
B
Texts
Buffer
BEGIN
B
TBuf
NEW
TBuf
Texts
OpenBuf
TBuf
END
Recall
message
handling
PROCEDURE
RemoveMarks
F
Frame
BEGIN
RemoveCaret
F
RemoveSelection
F
END
RemoveMarks
PROCEDURE
NotifyDisplay
T
Texts
Text
op
INTEGER
beg
end
LONGINT
VAR
M
UpdateMsg
BEGIN
M
id
op
M
text
T
M
beg
beg
M
end
end
Viewers
Broadcast
M
END
NotifyDisplay
PROCEDURE
Call
F
Frame
pos
LONGINT
new
BOOLEAN
VAR
S
Texts
Scanner
res
INTEGER
BEGIN
Texts
OpenScanner
S
F
text
pos
Texts
Scan
S
IF
S
class
Texts
Name
S
line
THEN
Oberon
SetPar
F
F
text
pos
S
len
Oberon
Call
S
s
res
IF
res
THEN
Texts
WriteString
W
Call
error
Texts
WriteString
W
Modules
importing
IF
res
THEN
Texts
WriteString
W
module
not
found
ELSIF
res
THEN
Texts
WriteString
W
bad
version
ELSIF
res
THEN
Texts
WriteString
W
imports
Texts
WriteString
W
Modules
imported
Texts
WriteString
W
with
bad
key
ELSIF
res
THEN
Texts
WriteString
W
corrupted
obj
file
ELSIF
res
THEN
Texts
WriteString
W
command
not
found
ELSIF
res
THEN
Texts
WriteString
W
insufficient
space
END
Texts
WriteLn
W
Texts
Append
Oberon
Log
W
buf
END
END
END
Call
PROCEDURE
Write
F
Frame
ch
CHAR
fnt
Fonts
Font
col
voff
INTEGER
VAR
buf
Texts
Buffer
BEGIN
F
hasCar
IF
ch
BS
THEN
backspace
IF
F
carloc
pos
F
org
THEN
Texts
Delete
F
text
F
carloc
pos
F
carloc
pos
DelBuf
SetCaret
F
F
carloc
pos
END
ELSIF
ch
3X
THEN
ctrl
c
copy
IF
F
hasSel
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Save
F
text
F
selbeg
pos
F
selend
pos
TBuf
END
ELSIF
ch
16X
THEN
ctrl
v
paste
NEW
buf
Texts
OpenBuf
buf
Texts
Copy
TBuf
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
TBuf
len
ELSIF
ch
18X
THEN
ctrl
x
cut
IF
F
hasSel
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Delete
F
text
F
selbeg
pos
F
selend
pos
TBuf
END
ELSIF
20X
ch
ch
DEL
OR
ch
CR
OR
ch
TAB
THEN
KW
fnt
fnt
KW
col
col
KW
voff
voff
Texts
Write
KW
ch
Texts
Insert
F
text
F
carloc
pos
KW
buf
SetCaret
F
F
carloc
pos
END
END
Write
PROCEDURE
Defocus
F
Frame
BEGIN
RemoveCaret
F
END
Defocus
PROCEDURE
Neutralize
F
Frame
BEGIN
RemoveMarks
F
END
Neutralize
PROCEDURE
Modify
F
Frame
id
dY
Y
H
INTEGER
BEGIN
Mark
F
FALSE
RemoveMarks
F
SetChangeMark
F
FALSE
IF
id
MenuViewers
extend
THEN
IF
dY
THEN
Display
CopyBlock
F
X
F
Y
F
W
F
H
F
X
F
Y
dY
F
Y
F
Y
dY
END
Extend
F
Y
ELSIF
id
MenuViewers
reduce
THEN
Reduce
F
Y
dY
IF
dY
THEN
Display
CopyBlock
F
X
F
Y
F
W
F
H
F
X
Y
F
Y
Y
END
END
IF
F
H
THEN
Mark
F
TRUE
SetChangeMark
F
F
text
changed
END
END
Modify
PROCEDURE
Open
F
Frame
H
Display
Handler
T
Texts
Text
org
LONGINT
col
left
right
top
bot
lsp
INTEGER
VAR
L
Line
BEGIN
NEW
L
L
len
L
wid
L
eot
FALSE
L
next
L
F
handle
H
F
text
T
F
org
org
F
trailer
L
F
left
left
F
right
right
F
top
top
F
bot
bot
F
lsp
lsp
F
col
col
F
hasMark
FALSE
F
hasCar
FALSE
F
hasSel
FALSE
END
Open
PROCEDURE
Copy
F
Frame
VAR
F1
Frame
BEGIN
NEW
F1
Open
F1
F
handle
F
text
F
org
F
col
F
left
F
right
F
top
F
bot
F
lsp
END
Copy
PROCEDURE
CopyOver
F
Frame
text
Texts
Text
beg
end
LONGINT
VAR
buf
Texts
Buffer
BEGIN
IF
F
hasCar
THEN
NEW
buf
Texts
OpenBuf
buf
Texts
Save
text
beg
end
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
end
beg
END
END
CopyOver
PROCEDURE
GetSelection
F
Frame
VAR
text
Texts
Text
VAR
beg
end
time
LONGINT
BEGIN
IF
F
hasSel
THEN
IF
F
text
text
THEN
IF
F
selbeg
pos
beg
THEN
beg
F
selbeg
pos
END
leftmost
IF
F
time
time
THEN
end
F
selend
pos
time
F
time
END
last
selected
ELSIF
F
time
time
THEN
text
F
text
beg
F
selbeg
pos
end
F
selend
pos
time
F
time
END
END
END
GetSelection
PROCEDURE
Update
F
Frame
VAR
M
UpdateMsg
BEGIN
F
text
M
text
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
IF
M
id
replace
THEN
Replace
F
M
beg
M
end
ELSIF
M
id
insert
THEN
Insert
F
M
beg
M
end
ELSIF
M
id
delete
THEN
Delete
F
M
beg
M
end
END
SetChangeMark
F
F
text
changed
END
Update
PROCEDURE
Edit
F
Frame
X
Y
INTEGER
Keys
SET
VAR
M
CopyOverMsg
text
Texts
Text
buf
Texts
Buffer
v
Viewers
Viewer
beg
end
time
pos
LONGINT
keysum
SET
fnt
Fonts
Font
col
voff
INTEGER
BEGIN
IF
X
F
X
Min
F
left
barW
THEN
scroll
bar
Oberon
DrawMouse
ScrollMarker
X
Y
keysum
Keys
IF
Keys
THEN
ML
scroll
up
TrackLine
F
X
Y
pos
keysum
IF
pos
keysum
THEN
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
pos
END
ELSIF
Keys
THEN
MM
keysum
Keys
REPEAT
Input
Mouse
Keys
X
Y
keysum
keysum
Keys
Oberon
DrawMouse
ScrollMarker
X
Y
UNTIL
Keys
IF
keysum
THEN
IF
IN
keysum
THEN
pos
ELSIF
IN
keysum
THEN
pos
F
text
len
ELSE
pos
F
Y
F
H
Y
F
text
len
DIV
F
H
END
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
pos
END
ELSIF
Keys
THEN
MR
scroll
down
TrackLine
F
X
Y
pos
keysum
IF
keysum
THEN
SetChangeMark
F
FALSE
RemoveMarks
F
Oberon
RemoveMarks
F
X
F
Y
F
W
F
H
Show
F
F
org
pos
END
END
ELSE
text
area
Oberon
DrawMouseArrow
X
Y
IF
IN
Keys
THEN
MR
select
TrackSelection
F
X
Y
keysum
IF
F
hasSel
THEN
IF
keysum
THEN
MR
ML
delete
text
Oberon
GetSelection
text
beg
end
time
Texts
Delete
text
beg
end
TBuf
Oberon
PassFocus
Viewers
This
F
X
F
Y
SetCaret
F
beg
ELSIF
keysum
THEN
MR
MM
copy
to
caret
Oberon
GetSelection
text
beg
end
time
M
text
text
M
beg
beg
M
end
end
Oberon
FocusViewer
handle
Oberon
FocusViewer
M
END
END
ELSIF
IN
Keys
THEN
MM
call
TrackWord
F
X
Y
pos
keysum
IF
pos
IN
keysum
THEN
Call
F
pos
IN
keysum
END
ELSIF
IN
Keys
THEN
ML
set
caret
Oberon
PassFocus
Viewers
This
F
X
F
Y
TrackCaret
F
X
Y
keysum
IF
keysum
THEN
ML
MM
copy
from
selection
to
caret
Oberon
GetSelection
text
beg
end
time
IF
time
THEN
NEW
TBuf
Texts
OpenBuf
TBuf
Texts
Save
text
beg
end
TBuf
Texts
Insert
F
text
F
carloc
pos
TBuf
SetSelection
F
F
carloc
pos
F
carloc
pos
end
beg
SetCaret
F
F
carloc
pos
end
beg
ELSIF
TBuf
NIL
THEN
NEW
buf
Texts
OpenBuf
buf
Texts
Copy
TBuf
buf
Texts
Insert
F
text
F
carloc
pos
buf
SetCaret
F
F
carloc
pos
buf
len
END
ELSIF
keysum
THEN
ML
MR
copy
looks
Oberon
GetSelection
text
beg
end
time
IF
time
THEN
Texts
Attributes
F
text
F
carloc
pos
fnt
col
voff
IF
fnt
NIL
THEN
Texts
ChangeLooks
text
beg
end
fnt
col
voff
END
END
END
END
END
END
Edit
PROCEDURE
Handle
F
Display
Frame
VAR
M
Display
FrameMsg
VAR
F1
Frame
buf
Texts
Buffer
BEGIN
CASE
F
OF
Frame
CASE
M
OF
Oberon
InputMsg
IF
M
id
Oberon
track
THEN
Edit
F
M
X
M
Y
M
keys
ELSIF
M
id
Oberon
consume
THEN
IF
F
hasCar
THEN
Write
F
M
ch
M
fnt
M
col
M
voff
END
END
Oberon
ControlMsg
IF
M
id
Oberon
defocus
THEN
Defocus
F
ELSIF
M
id
Oberon
neutralize
THEN
Neutralize
F
END
Oberon
SelectionMsg
GetSelection
F
M
text
M
beg
M
end
M
time
Oberon
CopyMsg
Copy
F
F1
M
F
F1
MenuViewers
ModifyMsg
Modify
F
M
id
M
dY
M
Y
M
H
CopyOverMsg
CopyOver
F
M
text
M
beg
M
end
UpdateMsg
IF
F
text
M
text
THEN
Update
F
M
END
END
END
END
Handle
creation
PROCEDURE
Menu
name
commands
ARRAY
OF
CHAR
Texts
Text
VAR
T
Texts
Text
BEGIN
NEW
T
T
notify
NotifyDisplay
Texts
Open
T
Texts
WriteString
W
name
Texts
WriteString
W
Texts
WriteString
W
commands
Texts
Append
T
W
buf
RETURN
T
END
Menu
PROCEDURE
Text
name
ARRAY
OF
CHAR
Texts
Text
VAR
T
Texts
Text
BEGIN
NEW
T
T
notify
NotifyDisplay
Texts
Open
T
name
RETURN
T
END
Text
PROCEDURE
NewMenu
name
commands
ARRAY
OF
CHAR
Frame
VAR
F
Frame
T
Texts
Text
BEGIN
NEW
F
T
Menu
name
commands
Open
F
Handle
T
Display
white
left
DIV
lsp
RETURN
F
END
NewMenu
PROCEDURE
NewText
text
Texts
Text
pos
LONGINT
Frame
VAR
F
Frame
BEGIN
NEW
F
Open
F
Handle
text
pos
Display
black
left
right
top
bot
lsp
RETURN
F
END
NewText
BEGIN
NEW
TBuf
NEW
DelBuf
Texts
OpenBuf
TBuf
Texts
OpenBuf
DelBuf
lsp
Fonts
Default
height
menuH
lsp
barW
menuH
left
barW
lsp
DIV
right
lsp
DIV
top
lsp
DIV
bot
lsp
DIV
asr
Fonts
Default
maxY
dsr
Fonts
Default
minY
selH
lsp
markW
lsp
DIV
eolW
lsp
DIV
ScrollMarker
Fade
FlipSM
ScrollMarker
Draw
FlipSM
Texts
OpenWriter
W
Texts
OpenWriter
KW
END
TextFrames
MODULE
Texts
JG
NW
IMPORT
Files
Fonts
CONST
scanner
symbol
classes
Inval
invalid
symbol
Name
name
s
length
len
String
literal
string
s
length
len
Int
integer
i
decimal
or
hexadecimal
Real
real
number
x
Char
special
character
c
TextBlock
TextTag
offset
run
run
len
AsciiCode
run
fnt
name
col
voff
len
TAB
9X
CR
0DX
maxD
TextTag
0F1X
replace
insert
delete
unmark
op
codes
TYPE
Piece
POINTER
TO
PieceDesc
PieceDesc
RECORD
f
Files
File
off
len
LONGINT
fnt
Fonts
Font
col
voff
INTEGER
prev
next
Piece
END
Text
POINTER
TO
TextDesc
Notifier
PROCEDURE
T
Text
op
INTEGER
beg
end
LONGINT
TextDesc
RECORD
len
LONGINT
changed
BOOLEAN
notify
Notifier
trailer
Piece
pce
Piece
cache
org
LONGINT
cache
END
Reader
RECORD
eot
BOOLEAN
fnt
Fonts
Font
col
voff
INTEGER
ref
Piece
org
LONGINT
off
LONGINT
rider
Files
Rider
END
Scanner
RECORD
Reader
nextCh
CHAR
line
class
INTEGER
i
LONGINT
x
REAL
y
LONGREAL
c
CHAR
len
INTEGER
s
ARRAY
OF
CHAR
END
Buffer
POINTER
TO
BufDesc
BufDesc
RECORD
len
LONGINT
header
last
Piece
END
Writer
RECORD
buf
Buffer
fnt
Fonts
Font
col
voff
INTEGER
rider
Files
Rider
END
VAR
TrailerFile
Files
File
Filing
PROCEDURE
Trailer
Piece
VAR
Q
Piece
BEGIN
NEW
Q
Q
f
TrailerFile
Q
off
Q
len
Q
fnt
NIL
Q
col
Q
voff
RETURN
Q
END
Trailer
PROCEDURE
Load
VAR
R
Files
Rider
T
Text
VAR
Q
q
p
Piece
off
LONGINT
N
fno
INTEGER
bt
BYTE
f
Files
File
FName
ARRAY
OF
CHAR
Dict
ARRAY
OF
Fonts
Font
BEGIN
f
Files
Base
R
N
Q
Trailer
p
Q
Files
ReadInt
R
off
Files
ReadByte
R
bt
fno
bt
WHILE
fno
DO
IF
fno
N
THEN
Files
ReadString
R
FName
Dict
N
Fonts
This
FName
INC
N
END
NEW
q
q
fnt
Dict
fno
Files
ReadByte
R
bt
q
col
bt
Files
ReadByte
R
bt
q
voff
ASR
LSL
bt
Files
ReadInt
R
q
len
Files
ReadByte
R
bt
fno
bt
q
f
f
q
off
off
off
off
q
len
p
next
q
q
prev
p
p
q
END
p
next
Q
Q
prev
p
T
trailer
Q
Files
ReadInt
R
T
len
Files
Set
R
f
Files
Pos
R
T
len
END
Load
PROCEDURE
Open
T
Text
name
ARRAY
OF
CHAR
VAR
f
Files
File
R
Files
Rider
Q
q
Piece
tag
CHAR
len
LONGINT
BEGIN
f
Files
Old
name
IF
f
NIL
THEN
Files
Set
R
f
Files
Read
R
tag
IF
tag
TextTag
THEN
Load
R
T
ELSE
Ascii
file
len
Files
Length
f
Q
Trailer
NEW
q
q
fnt
Fonts
Default
q
col
q
voff
q
f
f
q
off
q
len
len
Q
next
q
q
prev
Q
q
next
Q
Q
prev
q
T
trailer
Q
T
len
len
END
ELSE
create
new
text
Q
Trailer
Q
next
Q
Q
prev
Q
T
trailer
Q
T
len
END
T
changed
FALSE
T
org
T
pce
T
trailer
init
cache
END
Open
PROCEDURE
Store
VAR
W
Files
Rider
T
Text
VAR
p
q
Piece
R
Files
Rider
off
rlen
pos
LONGINT
N
n
INTEGER
ch
CHAR
Dict
ARRAY
OF
CHAR
BEGIN
pos
Files
Pos
W
Files
WriteInt
W
place
holder
N
p
T
trailer
next
WHILE
p
T
trailer
DO
rlen
p
len
q
p
next
WHILE
q
T
trailer
q
fnt
p
fnt
q
col
p
col
q
voff
p
voff
DO
rlen
rlen
q
len
q
q
next
END
Dict
N
p
fnt
name
n
WHILE
Dict
n
p
fnt
name
DO
INC
n
END
Files
WriteByte
W
n
IF
n
N
THEN
Files
WriteString
W
p
fnt
name
INC
N
END
Files
WriteByte
W
p
col
Files
WriteByte
W
p
voff
Files
WriteInt
W
rlen
p
q
END
Files
WriteByte
W
Files
WriteInt
W
T
len
off
Files
Pos
W
p
T
trailer
next
WHILE
p
T
trailer
DO
rlen
p
len
Files
Set
R
p
f
p
off
WHILE
rlen
DO
Files
Read
R
ch
Files
Write
W
ch
DEC
rlen
END
p
p
next
END
Files
Set
W
Files
Base
W
pos
Files
WriteInt
W
off
fixup
T
changed
FALSE
IF
T
notify
NIL
THEN
T
notify
T
unmark
END
END
Store
PROCEDURE
Close
T
Text
name
ARRAY
OF
CHAR
VAR
f
Files
File
w
Files
Rider
BEGIN
f
Files
New
name
Files
Set
w
f
Files
Write
w
TextTag
Store
w
T
Files
Register
f
END
Close
Editing
PROCEDURE
OpenBuf
B
Buffer
BEGIN
NEW
B
header
null
piece
B
last
B
header
B
len
END
OpenBuf
PROCEDURE
FindPiece
T
Text
pos
LONGINT
VAR
org
LONGINT
VAR
pce
Piece
VAR
p
Piece
porg
LONGINT
BEGIN
p
T
pce
porg
T
org
IF
pos
porg
THEN
WHILE
pos
porg
p
len
DO
INC
porg
p
len
p
p
next
END
ELSE
p
p
prev
DEC
porg
p
len
WHILE
pos
porg
DO
p
p
prev
DEC
porg
p
len
END
END
T
pce
p
T
org
porg
update
cache
pce
p
org
porg
END
FindPiece
PROCEDURE
SplitPiece
p
Piece
off
LONGINT
VAR
pr
Piece
VAR
q
Piece
BEGIN
IF
off
THEN
NEW
q
q
fnt
p
fnt
q
col
p
col
q
voff
p
voff
q
len
p
len
off
q
f
p
f
q
off
p
off
off
p
len
off
q
next
p
next
p
next
q
q
prev
p
q
next
prev
q
pr
q
ELSE
pr
p
END
END
SplitPiece
PROCEDURE
Save
T
Text
beg
end
LONGINT
B
Buffer
VAR
p
q
qb
qe
Piece
org
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
org
p
NEW
qb
qb
p
qb
len
qb
len
beg
org
qb
off
qb
off
beg
org
qe
qb
WHILE
end
org
p
len
DO
org
org
p
len
p
p
next
NEW
q
q
p
qe
next
q
q
prev
qe
qe
q
END
qe
next
NIL
qe
len
qe
len
org
p
len
end
B
last
next
qb
qb
prev
B
last
B
last
qe
B
len
B
len
end
beg
END
Save
PROCEDURE
Copy
SB
DB
Buffer
VAR
Q
q
p
Piece
BEGIN
p
SB
header
Q
DB
last
WHILE
p
SB
last
DO
p
p
next
NEW
q
q
p
Q
next
q
q
prev
Q
Q
q
END
DB
last
Q
DB
len
DB
len
SB
len
END
Copy
PROCEDURE
Insert
T
Text
pos
LONGINT
B
Buffer
VAR
pl
pr
p
qb
qe
Piece
org
end
LONGINT
BEGIN
FindPiece
T
pos
org
p
SplitPiece
p
pos
org
pr
IF
T
org
org
THEN
T
org
org
p
prev
len
T
pce
p
prev
END
pl
pr
prev
qb
B
header
next
IF
qb
NIL
qb
f
pl
f
qb
off
pl
off
pl
len
qb
fnt
pl
fnt
qb
col
pl
col
qb
voff
pl
voff
THEN
pl
len
pl
len
qb
len
qb
qb
next
END
IF
qb
NIL
THEN
qe
B
last
qb
prev
pl
pl
next
qb
qe
next
pr
pr
prev
qe
END
T
len
T
len
B
len
end
pos
B
len
B
last
B
header
B
last
next
NIL
B
len
T
changed
TRUE
T
notify
T
insert
pos
end
END
Insert
PROCEDURE
Append
T
Text
B
Buffer
BEGIN
Insert
T
T
len
B
END
Append
PROCEDURE
Delete
T
Text
beg
end
LONGINT
B
Buffer
VAR
pb
pe
pbr
per
Piece
orgb
orge
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
orgb
pb
SplitPiece
pb
beg
orgb
pbr
FindPiece
T
end
orge
pe
SplitPiece
pe
end
orge
per
IF
T
org
orgb
THEN
adjust
cache
T
org
orgb
pb
prev
len
T
pce
pb
prev
END
B
header
next
pbr
B
last
per
prev
B
last
next
NIL
B
len
end
beg
per
prev
pbr
prev
pbr
prev
next
per
T
len
T
len
B
len
T
changed
TRUE
T
notify
T
delete
beg
end
END
Delete
PROCEDURE
ChangeLooks
T
Text
beg
end
LONGINT
sel
SET
fnt
Fonts
Font
col
voff
INTEGER
VAR
pb
pe
p
Piece
org
LONGINT
BEGIN
IF
end
T
len
THEN
end
T
len
END
FindPiece
T
beg
org
p
SplitPiece
p
beg
org
pb
FindPiece
T
end
org
p
SplitPiece
p
end
org
pe
p
pb
REPEAT
IF
IN
sel
THEN
p
fnt
fnt
END
IF
IN
sel
THEN
p
col
col
END
IF
IN
sel
THEN
p
voff
voff
END
p
p
next
UNTIL
p
pe
T
changed
TRUE
T
notify
T
replace
beg
end
END
ChangeLooks
PROCEDURE
Attributes
T
Text
pos
LONGINT
VAR
fnt
Fonts
Font
VAR
col
voff
INTEGER
VAR
p
Piece
org
LONGINT
BEGIN
FindPiece
T
pos
org
p
fnt
p
fnt
col
p
col
voff
p
voff
END
Attributes
Access
Readers
PROCEDURE
OpenReader
VAR
R
Reader
T
Text
pos
LONGINT
VAR
p
Piece
org
LONGINT
BEGIN
FindPiece
T
pos
org
p
R
ref
p
R
org
org
R
off
pos
org
Files
Set
R
rider
p
f
p
off
R
off
R
eot
FALSE
END
OpenReader
PROCEDURE
Read
VAR
R
Reader
VAR
ch
CHAR
BEGIN
Files
Read
R
rider
ch
R
fnt
R
ref
fnt
R
col
R
ref
col
R
voff
R
ref
voff
INC
R
off
IF
R
off
R
ref
len
THEN
IF
R
ref
f
TrailerFile
THEN
R
eot
TRUE
END
R
org
R
org
R
off
R
off
R
ref
R
ref
next
R
org
R
org
R
off
R
off
Files
Set
R
rider
R
ref
f
R
ref
off
END
END
Read
PROCEDURE
Pos
VAR
R
Reader
LONGINT
BEGIN
RETURN
R
org
R
off
END
Pos
Access
Scanners
NW
PROCEDURE
OpenScanner
VAR
S
Scanner
T
Text
pos
LONGINT
BEGIN
OpenReader
S
T
pos
S
line
S
nextCh
END
OpenScanner
floating
point
formats
x
m
e
bit
sign
bits
e
bits
m
x
m
e
bit
sign
bits
e
bits
m
PROCEDURE
Ten
n
INTEGER
REAL
VAR
t
p
REAL
BEGIN
t
p
compute
n
WHILE
n
DO
IF
ODD
n
THEN
t
p
t
END
p
p
p
n
n
DIV
END
RETURN
t
END
Ten
PROCEDURE
Scan
VAR
S
Scanner
CONST
maxExp
maxM
VAR
ch
term
CHAR
neg
negE
hex
BOOLEAN
i
j
h
d
e
n
s
INTEGER
k
LONGINT
x
REAL
BEGIN
ch
S
nextCh
i
WHILE
S
eot
ch
DO
IF
ch
CR
THEN
INC
S
line
END
Read
S
ch
END
IF
A
ch
ch
Z
OR
a
ch
ch
z
THEN
name
REPEAT
S
s
i
ch
INC
i
Read
S
ch
UNTIL
ch
ch
OR
ch
ch
A
OR
Z
ch
ch
a
OR
z
ch
OR
i
S
s
i
0X
S
len
i
S
class
Name
ELSIF
ch
22X
THEN
string
Read
S
ch
WHILE
ch
22X
ch
i
DO
S
s
i
ch
INC
i
Read
S
ch
END
S
s
i
0X
S
len
i
Read
S
ch
S
class
String
ELSE
hex
FALSE
IF
ch
THEN
neg
TRUE
Read
S
ch
ELSE
neg
FALSE
END
IF
ch
ch
THEN
number
n
ORD
ch
30H
h
n
Read
S
ch
WHILE
ch
ch
OR
A
ch
ch
F
DO
IF
ch
THEN
d
ORD
ch
30H
ELSE
d
ORD
ch
37H
hex
TRUE
END
n
n
d
h
10H
h
d
Read
S
ch
END
IF
ch
H
THEN
hex
integer
Read
S
ch
S
i
h
S
class
Int
neg
ELSIF
ch
THEN
real
number
Read
S
ch
x
e
j
WHILE
ch
ch
DO
fraction
h
n
ORD
ch
30H
IF
h
maxM
THEN
n
h
INC
j
END
Read
S
ch
END
IF
ch
E
THEN
scale
factor
s
Read
S
ch
IF
ch
THEN
negE
TRUE
Read
S
ch
ELSE
negE
FALSE
IF
ch
THEN
Read
S
ch
END
END
WHILE
ch
ch
DO
s
s
ORD
ch
30H
Read
S
ch
END
IF
negE
THEN
DEC
e
s
ELSE
INC
e
s
END
END
x
FLT
n
DEC
e
j
IF
e
THEN
IF
e
maxExp
THEN
x
x
Ten
e
ELSE
x
END
ELSIF
e
THEN
IF
e
maxExp
THEN
x
Ten
e
x
ELSE
x
END
END
IF
neg
THEN
S
x
x
ELSE
S
x
x
END
IF
hex
THEN
S
class
ELSE
S
class
Real
END
ELSE
decimal
integer
IF
neg
THEN
S
i
n
ELSE
S
i
n
END
IF
hex
THEN
S
class
Inval
ELSE
S
class
Int
END
END
ELSE
spectal
character
S
class
Char
IF
neg
THEN
S
c
ELSE
S
c
ch
Read
S
ch
END
END
END
S
nextCh
ch
END
Scan
Access
Writers
NW
PROCEDURE
OpenWriter
VAR
W
Writer
BEGIN
NEW
W
buf
OpenBuf
W
buf
W
fnt
Fonts
Default
W
col
W
voff
Files
Set
W
rider
Files
New
END
OpenWriter
PROCEDURE
SetFont
VAR
W
Writer
fnt
Fonts
Font
BEGIN
W
fnt
fnt
END
SetFont
PROCEDURE
SetColor
VAR
W
Writer
col
INTEGER
BEGIN
W
col
col
END
SetColor
PROCEDURE
SetOffset
VAR
W
Writer
voff
INTEGER
BEGIN
W
voff
voff
END
SetOffset
PROCEDURE
Write
VAR
W
Writer
ch
CHAR
VAR
p
Piece
BEGIN
IF
W
buf
last
fnt
W
fnt
OR
W
buf
last
col
W
col
OR
W
buf
last
voff
W
voff
THEN
NEW
p
p
f
Files
Base
W
rider
p
off
Files
Pos
W
rider
p
len
p
fnt
W
fnt
p
col
W
col
p
voff
W
voff
p
next
NIL
W
buf
last
next
p
p
prev
W
buf
last
W
buf
last
p
END
Files
Write
W
rider
ch
INC
W
buf
last
len
INC
W
buf
len
END
Write
PROCEDURE
WriteLn
VAR
W
Writer
BEGIN
Write
W
CR
END
WriteLn
PROCEDURE
WriteString
VAR
W
Writer
s
ARRAY
OF
CHAR
VAR
i
INTEGER
BEGIN
i
WHILE
s
i
DO
Write
W
s
i
INC
i
END
END
WriteString
PROCEDURE
WriteInt
VAR
W
Writer
x
n
LONGINT
VAR
i
INTEGER
x0
LONGINT
a
ARRAY
OF
CHAR
BEGIN
IF
ROR
x
THEN
WriteString
W
ELSE
i
IF
x
THEN
DEC
n
x0
x
ELSE
x0
x
END
REPEAT
a
i
CHR
x0
MOD
30H
x0
x0
DIV
INC
i
UNTIL
x0
WHILE
n
i
DO
Write
W
DEC
n
END
IF
x
THEN
Write
W
END
REPEAT
DEC
i
Write
W
a
i
UNTIL
i
END
END
WriteInt
PROCEDURE
WriteHex
VAR
W
Writer
x
LONGINT
VAR
i
INTEGER
y
LONGINT
a
ARRAY
OF
CHAR
BEGIN
i
Write
W
REPEAT
y
x
MOD
10H
IF
y
THEN
a
i
CHR
y
30H
ELSE
a
i
CHR
y
37H
END
x
x
DIV
10H
INC
i
UNTIL
i
REPEAT
DEC
i
Write
W
a
i
UNTIL
i
END
WriteHex
PROCEDURE
WriteReal
VAR
W
Writer
x
REAL
n
INTEGER
VAR
e
i
m
INTEGER
d
ARRAY
OF
CHAR
BEGIN
e
ASR
ORD
x
MOD
100H
binary
exponent
IF
e
THEN
WriteString
W
WHILE
n
DO
Write
W
DEC
n
END
ELSIF
e
THEN
WriteString
W
NaN
ELSE
Write
W
WHILE
n
DO
DEC
n
Write
W
END
n
digits
to
be
written
IF
x
THEN
Write
W
x
x
ELSE
Write
W
END
e
e
DIV
decimal
exponent
IF
e
THEN
x
x
Ten
e
ELSE
x
Ten
e
x
END
m
FLOOR
x
i
IF
m
THEN
INC
e
m
m
DIV
END
REPEAT
d
i
CHR
m
MOD
30H
m
m
DIV
INC
i
UNTIL
m
DEC
i
Write
W
d
i
Write
W
IF
i
n
THEN
n
ELSE
n
n
END
WHILE
i
n
DO
DEC
i
Write
W
d
i
END
Write
W
E
INC
e
IF
e
THEN
Write
W
e
e
ELSE
Write
W
END
Write
W
CHR
e
DIV
30H
Write
W
CHR
e
MOD
30H
END
END
WriteReal
PROCEDURE
WriteRealFix
VAR
W
Writer
x
REAL
n
k
INTEGER
VAR
i
m
INTEGER
neg
BOOLEAN
d
ARRAY
OF
CHAR
BEGIN
IF
x
THEN
WriteString
W
ELSE
IF
x
THEN
x
x
neg
TRUE
ELSE
neg
FALSE
END
IF
k
THEN
k
END
x
Ten
k
x
m
FLOOR
x
i
REPEAT
d
i
CHR
m
MOD
30H
m
m
DIV
INC
i
UNTIL
m
Write
W
WHILE
n
i
DO
Write
W
DEC
n
END
IF
neg
THEN
Write
W
DEC
n
ELSE
Write
W
END
WHILE
i
k
DO
DEC
i
Write
W
d
i
END
Write
W
WHILE
k
i
DO
DEC
k
Write
W
END
WHILE
i
DO
DEC
i
Write
W
d
i
END
END
END
WriteRealFix
PROCEDURE
WritePair
VAR
W
Writer
ch
CHAR
x
LONGINT
BEGIN
Write
W
ch
Write
W
CHR
x
DIV
30H
Write
W
CHR
x
MOD
30H
END
WritePair
PROCEDURE
WriteClock
VAR
W
Writer
d
LONGINT
BEGIN
WritePair
W
d
DIV
20000H
MOD
20H
day
WritePair
W
d
DIV
400000H
MOD
10H
month
WritePair
W
d
DIV
4000000H
MOD
40H
year
WritePair
W
d
DIV
1000H
MOD
20H
hour
WritePair
W
d
DIV
40H
MOD
40H
min
WritePair
W
d
MOD
40H
sec
END
WriteClock
BEGIN
TrailerFile
Files
New
END
Texts
MODULE
Viewers
JG
NW
IMPORT
Display
CONST
restore
modify
suspend
message
ids
inf
TYPE
Viewer
POINTER
TO
ViewerDesc
ViewerDesc
RECORD
Display
FrameDesc
state
INTEGER
END
state
displayed
state
filler
state
closed
state
suspended
ViewerMsg
RECORD
Display
FrameMsg
id
INTEGER
X
Y
W
H
INTEGER
state
INTEGER
END
Track
POINTER
TO
TrackDesc
TrackDesc
RECORD
ViewerDesc
under
Display
Frame
END
VAR
curW
minH
DH
INTEGER
FillerTrack
Track
FillerViewer
backup
Viewer
last
closed
viewer
PROCEDURE
Open
V
Viewer
X
Y
INTEGER
VAR
T
u
v
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
X
inf
THEN
IF
Y
DH
THEN
Y
DH
END
T
FillerTrack
next
WHILE
X
T
X
T
W
DO
T
T
next
END
u
T
dsc
v
u
next
WHILE
Y
v
Y
v
H
DO
u
v
v
u
next
END
IF
Y
v
Y
minH
THEN
Y
v
Y
minH
END
IF
v
next
Y
Y
v
Y
v
H
minH
THEN
V
X
T
X
V
W
T
W
V
Y
v
Y
V
H
v
H
M
id
suspend
M
state
v
handle
v
M
v
Viewer
state
V
next
v
next
u
next
V
V
state
ELSE
V
X
T
X
V
W
T
W
V
Y
v
Y
V
H
Y
v
Y
M
id
modify
M
Y
Y
M
H
v
Y
v
H
Y
v
handle
v
M
v
Y
M
Y
v
H
M
H
V
next
v
u
next
V
V
state
END
END
END
Open
PROCEDURE
Change
V
Viewer
Y
INTEGER
VAR
v
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
THEN
IF
Y
DH
THEN
Y
DH
END
v
V
next
IF
v
next
Y
Y
v
Y
v
H
minH
THEN
Y
v
Y
v
H
minH
END
IF
Y
V
Y
minH
THEN
M
id
modify
M
Y
Y
M
H
v
Y
v
H
Y
v
handle
v
M
v
Y
M
Y
v
H
M
H
V
H
Y
V
Y
END
END
END
Change
PROCEDURE
RestoreTrack
S
Display
Frame
VAR
T
t
v
Display
Frame
M
ViewerMsg
BEGIN
t
S
next
WHILE
t
next
S
DO
t
t
next
END
T
S
Track
under
WHILE
T
next
NIL
DO
T
T
next
END
t
next
S
Track
under
T
next
S
next
M
id
restore
REPEAT
t
t
next
v
t
dsc
REPEAT
v
v
next
v
handle
v
M
v
Viewer
state
v
Viewer
state
UNTIL
v
t
dsc
UNTIL
t
T
END
RestoreTrack
PROCEDURE
Close
V
Viewer
VAR
T
U
Display
Frame
M
ViewerMsg
BEGIN
IF
V
state
THEN
U
V
next
T
FillerTrack
REPEAT
T
T
next
UNTIL
V
X
T
X
T
W
IF
T
Track
under
NIL
OR
U
next
V
THEN
M
id
suspend
M
state
V
handle
V
M
V
state
backup
V
M
id
modify
M
Y
V
Y
M
H
V
H
U
H
U
handle
U
M
U
Y
M
Y
U
H
M
H
WHILE
U
next
V
DO
U
U
next
END
U
next
V
next
ELSE
close
track
M
id
suspend
M
state
V
handle
V
M
V
state
backup
V
U
handle
U
M
U
Viewer
state
RestoreTrack
T
END
END
END
Close
PROCEDURE
Recall
VAR
V
Viewer
BEGIN
V
backup
END
Recall
PROCEDURE
This
X
Y
INTEGER
Viewer
VAR
T
V
Display
Frame
BEGIN
IF
X
inf
Y
DH
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
V
T
dsc
REPEAT
V
V
next
UNTIL
Y
V
Y
V
H
ELSE
V
NIL
END
RETURN
V
Viewer
END
This
PROCEDURE
Next
V
Viewer
Viewer
BEGIN
RETURN
V
next
Viewer
END
Next
PROCEDURE
Locate
X
H
INTEGER
VAR
fil
bot
alt
max
Display
Frame
VAR
T
V
Display
Frame
BEGIN
IF
X
inf
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
fil
T
dsc
bot
fil
next
IF
bot
next
fil
THEN
alt
bot
next
V
alt
next
WHILE
V
fil
alt
H
H
DO
IF
V
H
alt
H
THEN
alt
V
END
V
V
next
END
ELSE
alt
bot
END
max
T
dsc
V
max
next
WHILE
V
fil
DO
IF
V
H
max
H
THEN
max
V
END
V
V
next
END
END
END
Locate
PROCEDURE
InitTrack
W
H
INTEGER
Filler
Viewer
VAR
S
Display
Frame
T
Track
BEGIN
IF
Filler
state
THEN
Filler
X
curW
Filler
W
W
Filler
Y
Filler
H
H
Filler
state
Filler
next
Filler
NEW
T
T
X
curW
T
W
W
T
Y
T
H
H
T
dsc
Filler
T
under
NIL
FillerViewer
X
curW
W
FillerViewer
W
inf
FillerViewer
X
FillerTrack
X
FillerViewer
X
FillerTrack
W
FillerViewer
W
S
FillerTrack
WHILE
S
next
FillerTrack
DO
S
S
next
END
S
next
T
T
next
FillerTrack
curW
curW
W
END
END
InitTrack
PROCEDURE
OpenTrack
X
W
INTEGER
Filler
Viewer
VAR
newT
Track
S
T
t
v
Display
Frame
M
ViewerMsg
v0
Viewer
BEGIN
IF
X
inf
Filler
state
THEN
S
FillerTrack
T
S
next
WHILE
X
T
X
T
W
DO
S
T
T
S
next
END
WHILE
X
W
T
X
T
W
DO
T
T
next
END
M
id
suspend
t
S
REPEAT
t
t
next
v
t
dsc
REPEAT
v
v
next
M
state
v
Viewer
state
v
handle
v
M
v
Viewer
state
M
state
UNTIL
v
t
dsc
UNTIL
t
T
Filler
X
S
next
X
Filler
W
T
X
T
W
S
next
X
Filler
Y
Filler
H
DH
Filler
state
Filler
next
Filler
NEW
newT
newT
X
Filler
X
newT
W
Filler
W
newT
Y
newT
H
DH
newT
dsc
Filler
newT
under
S
next
S
next
newT
newT
next
T
next
T
next
NIL
END
END
OpenTrack
PROCEDURE
CloseTrack
X
INTEGER
VAR
T
V
Display
Frame
M
ViewerMsg
BEGIN
IF
X
inf
THEN
T
FillerTrack
REPEAT
T
T
next
UNTIL
X
T
X
T
W
IF
T
Track
under
NIL
THEN
M
id
suspend
M
state
V
T
dsc
REPEAT
V
V
next
V
handle
V
M
V
Viewer
state
UNTIL
V
T
dsc
RestoreTrack
T
END
END
END
CloseTrack
PROCEDURE
Broadcast
VAR
M
Display
FrameMsg
VAR
T
V
Display
Frame
BEGIN
T
FillerTrack
next
WHILE
T
FillerTrack
DO
V
T
dsc
REPEAT
V
V
next
V
handle
V
M
UNTIL
V
T
dsc
T
T
next
END
END
Broadcast
BEGIN
backup
NIL
curW
minH
DH
Display
Height
NEW
FillerViewer
FillerViewer
X
FillerViewer
W
inf
FillerViewer
Y
FillerViewer
H
DH
FillerViewer
next
FillerViewer
NEW
FillerTrack
FillerTrack
X
FillerTrack
W
inf
FillerTrack
Y
FillerTrack
H
DH
FillerTrack
dsc
FillerViewer
FillerTrack
next
FillerTrack
END
Viewers
